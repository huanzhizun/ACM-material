
<!-- saved from url=(0051)http://www.lydsy.com/JudgeOnline/export_ac_code.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<link rel="stylesheet" href="./BZOJ全代码_files/hoj.css" type="text/css">
</head>
<body>
<center>
<div style="width:90%; text-align:left">
<img src="./BZOJ全代码_files/logo.png">
</div>
<table width="96%"> 
	<tbody><tr align="center" class="hd" valign="top">
				<th><a href="http://www.lydsy.com/JudgeOnline/faqs.php">F.A.Qs</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/bbs.php">Web Board</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/">Home</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/problemset.php">ProblemSet</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/status.php">Status</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/ranklist.php">Ranklist</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/contest.php">Contest</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/modifypage.php"><b>ModifyUser</b></a>&nbsp;&nbsp;<a href="http://www.lydsy.com/JudgeOnline/userinfo.php?user=WJMZBMR">
				<font color="red">WJMZBMR</font></a><a href="http://www.lydsy.com/JudgeOnline/mail.php"><font color="red">(0)</font></a></th><th><a href="http://www.lydsy.com/JudgeOnline/logout.php">Logout</a></th>		<th><a href="http://www.lydsy.com/JudgeOnline/donation.php" class="highlight">捐赠本站</a></th>
	</tr>
</tbody></table>
</center>
<center>
<div class="notice">
	<div>
		<b>Notice:</b>1：欢迎添加试题到OJ上，要求难度在省选之上，相关资料请发到lydsy2012@163.com,谢谢。
2：鉴于OJ目前存在的各种乱象，即日起暂停注册，请各位用户珍惜手中ID。
	</div>
</div>
</center>

<title>Export All AC Source</title>
<h2>Problem1000</h2><pre>#include&lt;iostream&gt;
using namespace std;
int  main()
{
    int a,b;
    cin &gt;&gt; a &gt;&gt; b;
    cout &lt;&lt; a+b &lt;&lt; endl;
    return 0;
}<pre><h2>Problem1000</h2><pre>a,b=map(int,raw_input().split())
print a+b<pre><h2>Problem1001</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define tr(e,x) for(eit e=x.begin();e!=x.end();e++)
using namespace std;
const int maxn=1000,maxv=maxn*maxn*2,inf=~0U&gt;&gt;2;
int n,m,vs,vt,v;
int Node[maxn][maxn][2];
int Dist[maxv];
struct Edge
{
    int t,c;
    Edge(int _t,int _c):t(_t),c(_c){}
};
struct State
{
    int p,c;
    State(int _p,int _c):p(_p),c(_c){}
    bool operator&lt;(const State&amp;o)const
    {
        return c&gt;o.c;
    }
};
vector&lt;Edge&gt; E[maxv];
priority_queue&lt;State&gt; Q;
typedef vector&lt;Edge&gt;::iterator eit;
int Dijstra()
{
    rep(i,v)Dist[i]=inf;Q.push(State(vs,0));
    while(Q.size())
    {
        State t=Q.top();Q.pop();if(t.c&gt;Dist[t.p])continue;
        if(t.p==vt)return t.c;
        tr(e,E[t.p])
        {
            int ncost=t.c+e-&gt;c;
            if(ncost&lt;Dist[e-&gt;t])
            {
                Dist[e-&gt;t]=ncost;
                Q.push(State(e-&gt;t,ncost));
            }
        }
    }
}
void AddEdge(int s,int t,int c)
{
    E[s].pb(Edge(t,c));
    E[t].pb(Edge(s,c));
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d",&amp;n,&amp;m);v=0;
    rep(i,n-1)rep(j,m-1)rep(k,2)Node[i][j][k]=v++;
    vs=v++;vt=v++;int c;
    rep(j,m-1)scanf("%d",&amp;c),AddEdge(vs,Node[0][j][0],c);
    rep(i,n-2)rep(j,m-1)
    {
        scanf("%d",&amp;c);AddEdge(Node[i][j][1],Node[i+1][j][0],c);
    }
    rep(j,m-1)scanf("%d",&amp;c),AddEdge(Node[n-2][j][1],vt,c);
    rep(i,n-1)
    {
        scanf("%d",&amp;c);AddEdge(Node[i][0][1],vt,c);
        rep(j,m-2)
        {
            scanf("%d",&amp;c);AddEdge(Node[i][j+1][1],Node[i][j][0],c);
        }
        scanf("%d",&amp;c);AddEdge(vs,Node[i][m-2][0],c);
    }
    rep(i,n-1)
        rep(j,m-1)
        {
            scanf("%d",&amp;c);
            AddEdge(Node[i][j][0],Node[i][j][1],c);
        }
    printf("%d\n",Dijstra());
}

<pre><h2>Problem1002</h2><pre>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100+10,maxl=1000;
int n;
struct BigInt
{
    int H[maxl],l;
    BigInt(){memset(H,0,sizeof(H));l=0;}
    void Set(int x){H[0]=x;}
    int operator[](int v)const{return H[v];}
    void operator=(const BigInt&amp;o)
    {
        memcpy(H,o.H,sizeof(H));
        l=o.l;
    }
    void operator+=(const BigInt&amp;o)
    {
        int d=0;l=max(l,o.l);
        for(int i=0;i&lt;=l;i++)
        {
            d+=H[i]+o[i];
            H[i]=d%10;
            d/=10;
        }
        if(d)H[++l]=d;
    }
    void operator*=(int x)
    {
        int d=0;
        for(int i=0;i&lt;=l;i++)
        {
            d+=H[i]*x;
            H[i]=d%10;
            d/=10;
        }
        while(d)
        {
            H[++l]=d%10;
            d/=10;
        }
    }
    void Print()
    {
        for(int i=l;i&gt;=0;i--)cout&lt;&lt;H[i];
        cout&lt;&lt;endl;
    }
}Dp[maxn],ans,tmp;
int main()
{
    cin&gt;&gt;n;Dp[0].Set(1);
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=i;j++)
        {
            tmp=Dp[i-j];tmp*=j;
            Dp[i]+=tmp;
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        Dp[n-i]*=i;Dp[n-i]*=i;
        ans+=Dp[n-i];
    }
    ans.Print();
}
<pre><h2>Problem1003</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,a,b) for(int i=a;i&lt;=b;i++)
#define all(x) x.begin(),x.end()
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;2,maxT=100+1,maxn=20,maxm=1000;
int T,n,k,m;
struct Edge
{
    int t,c;
    Edge*next;
    Edge(int _t,int _c,Edge*_n):t(_t),c(_c),next(_n){}
}*E[maxn]={0};
struct Vertex
{
    int D[maxT];
    Vertex(){memset(D,0,sizeof(D));}
    void Ins(int l,int r)
    {
        For(i,l,r) D[i]=1;
    }
    void Set()
    {
        For(i,1,T) D[i]+=D[i-1];
    }
    bool ok(int l,int r)
    {
        return D[r]==D[l-1];
    }
}V[maxn];
void InsEdge(int s,int t,int c)
{
    E[s]=new Edge(t,c,E[s]);
    E[t]=new Edge(s,c,E[t]);
}
void Init()
{
    cin&gt;&gt;T&gt;&gt;n&gt;&gt;k&gt;&gt;m;int s,t,c;
    while(m--)
    {
        scanf("%d %d %d",&amp;s,&amp;t,&amp;c);
        InsEdge(s-1,t-1,c);
    }
    int p,a,l,r;cin&gt;&gt;p;
    while(p--)
    {
        scanf("%d %d %d",&amp;a,&amp;l,&amp;r);
        V[a-1].Ins(l,r);
    }
    rep(i,n)V[i].Set();
}
int Cost(int l,int r)
{
    static int dist[maxn];
    static bool inq[maxn];
    rep(i,n) dist[i]=inf,inq[i]=false;
    queue&lt;int&gt; Q;
    Q.push(0);inq[0]=true;dist[0]=0;
    while(Q.size())
    {
        int t=Q.front();Q.pop();inq[t]=false;int cost=dist[t];
        for(Edge*e=E[t];e;e=e-&gt;next)
        {
            int ncost=cost+e-&gt;c,v=e-&gt;t;
            if(!V[v].ok(l,r))continue;
            if(dist[v]&gt;ncost)
            {
                dist[v]=ncost;
                if(!inq[v]) Q.push(v),inq[v]=true;
            }
        }
    }
    return dist[n-1];
}
int dp[maxT];
void Work()
{
    dp[0]=0;
    For(i,1,T)
    {
        dp[i]=inf;
        for(int j=i-1;j&gt;=0;--j)
        {
            int c=Cost(j+1,i);
            if(c==inf)break;
            dp[i]=min(dp[i],dp[j]+c*(i-j)+k);
        }
    }
    cout&lt;&lt;dp[T]-k&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Work();
}
<pre><h2>Problem1004</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=60;
typedef long long ll;
using namespace std;
int a,b,c,m,p,n;ll ret;
int M[maxn];
void Plus(int&amp;a,int b)
{
    a+=b;if(a&gt;=p)a-=p;
}
int Cal(int A[maxn])
{
    static int B[maxn],s;
    static bool V[maxn];
    static int Dp[2][maxn][maxn][maxn];
    s=0;memset(V,0,sizeof(V));
    rep(i,n)if(!V[i])
    {
        int t=0,x=i;
        while(!V[x])V[x]=true,x=A[x],t++;
        B[s++]=t;
    }
    int now=0,next=1;
    memset(Dp,0,sizeof(Dp));Dp[next][0][0][0]=1;
    rep(o,s)
    {
        swap(now,next);memset(Dp[next],0,sizeof(Dp[next]));
        int t=B[o],tmp;
        rep(i,a+1)rep(j,b+1)rep(k,c+1)if(tmp=Dp[now][i][j][k])
        {
            Plus(Dp[next][i+t][j][k],tmp);
            Plus(Dp[next][i][j+t][k],tmp);
            Plus(Dp[next][i][j][k+t],tmp);
        }
    }
    return Dp[next][a][b][c];
}
int pow_mod(int a,int b)
{
    if(b==1)return a;
    ll tmp=pow_mod(a,b/2);tmp*=tmp;tmp%=p;
    if(b&amp;1)tmp*=a,tmp%=p;
    return tmp;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;m&gt;&gt;p;n=a+b+c;
    rep(i,m)
    {
        rep(j,n)cin&gt;&gt;M[j],M[j]--;
        ret+=Cal(M);
    }
    rep(i,n)M[i]=i;ret+=Cal(M);
    ret=ret*pow_mod(m+1,p-2);ret%=p;
    cout&lt;&lt;ret&lt;&lt;endl;
}


<pre><h2>Problem1004</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=60;
typedef long long ll;
using namespace std;
int a,b,c,m,p,n;ll ret;
int M[maxn];
void Plus(int&amp;a,int b)
{
    a+=b;if(a&gt;=p)a-=p;
}
int Cal(int A[maxn])
{
    static int B[maxn],s;
    static bool V[maxn];
    static int Dp[2][maxn][maxn];
    s=0;memset(V,0,sizeof(V));
    rep(i,n)if(!V[i])
    {
        int t=0,x=i;
        while(!V[x])V[x]=true,x=A[x],t++;
        B[s++]=t;
    }
    int now=0,next=1;
    memset(Dp,0,sizeof(Dp));Dp[next][0][0]=1;
    rep(o,s)
    {
        swap(now,next);memset(Dp[next],0,sizeof(Dp[next]));
        int t=B[o],tmp;
        rep(i,a+1)rep(j,b+1)if(tmp=Dp[now][i][j])
        {
            Plus(Dp[next][i+t][j],tmp);
            Plus(Dp[next][i][j+t],tmp);
            Plus(Dp[next][i][j],tmp);
        }
    }
    return Dp[next][a][b];
}
int pow_mod(int a,int b)
{
    if(b==1)return a;
    ll tmp=pow_mod(a,b/2);tmp*=tmp;tmp%=p;
    if(b&amp;1)tmp*=a,tmp%=p;
    return tmp;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;m&gt;&gt;p;n=a+b+c;
    rep(i,m)
    {
        rep(j,n)cin&gt;&gt;M[j],M[j]--;
        ret+=Cal(M);
    }
    rep(i,n)M[i]=i;ret+=Cal(M);
    ret=ret*pow_mod(m+1,p-2);ret%=p;
    cout&lt;&lt;ret&lt;&lt;endl;
}


<pre><h2>Problem1004</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=60;
typedef long long ll;
using namespace std;
int a,b,c,m,p,n;ll ret;
int M[maxn];
void Plus(int&amp;a,int b)
{
    a+=b;if(a&gt;=p)a-=p;
}
int Cal(int A[maxn])
{
    static int B[maxn],s;
    static bool V[maxn];
    static int Dp[2][maxn][maxn];
    s=0;memset(V,0,sizeof(V));
    rep(i,n)if(!V[i])
    {
        int t=0,x=i;
        while(!V[x])V[x]=true,x=A[x],t++;
        B[s++]=t;
    }
    int now=0,next=1;
    memset(Dp,0,sizeof(Dp));Dp[next][0][0]=1;
    rep(o,s)
    {
        swap(now,next);memset(Dp[next],0,sizeof(Dp[next]));
        int t=B[o],tmp;
        rep(i,a+1)rep(j,b+1)if(tmp=Dp[now][i][j])
        {
            Plus(Dp[next][i+t][j],tmp);
            Plus(Dp[next][i][j+t],tmp);
            Plus(Dp[next][i][j],tmp);
        }
    }
    return Dp[next][a][b];
}
int pow_mod(int a,int b)
{
    if(b==1)return a;
    ll tmp=pow_mod(a,b/2);tmp*=tmp;tmp%=p;
    if(b&amp;1)tmp*=a,tmp%=p;
    return tmp;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;m&gt;&gt;p;n=a+b+c;
    rep(i,m)
    {
        rep(j,n)scanf("%d",M+j),M[j]--;
        ret+=Cal(M);
    }
    rep(i,n)M[i]=i;ret+=Cal(M);
    ret=ret*pow_mod(m+1,p-2);ret%=p;
    cout&lt;&lt;ret&lt;&lt;endl;
}


<pre><h2>Problem1005</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=1000;
int n;
vector&lt;int&gt; Prime;
typedef vector&lt;int&gt;::iterator it;
int D[maxn],S=0,noLimit=0;
bool isPrime(int x)
{
    if(x==2) return true;
    if(x/2==0) return false;
    for(int i=3;i*i&lt;=x;i+=2)
        if(x%i==0) return false;
    return true;
}
void getPrime()
{
    for(int i=2;i&lt;=n;i++)
        if(isPrime(i)) Prime.pb(i);
}
void init()
{
    cin&gt;&gt;n;
    rep(i,n)
    {
        cin&gt;&gt;D[i];
        if(D[i]&gt;0)
            S+=D[i]-1;
        else
            noLimit++;
    }
}
struct BigInt
{
	int H[400];
	BigInt(){memset(H,0,sizeof(H));}
	void mul(int x)
	{
	    rep(i,Prime.size())
            while(x%Prime[i]==0) x/=Prime[i],H[i]++;
	}
	void div(int x)
	{
	    rep(i,Prime.size())
            while(x%Prime[i]==0) x/=Prime[i],H[i]--;
	}
};
ostream&amp; operator&lt;&lt;(ostream&amp;out,const BigInt&amp;x)
{
    static int Hp[100000],last;
    memset(Hp,0,sizeof(Hp));Hp[last=0]=1;
    rep(i,Prime.size())
    {
        rep(j,x.H[i])
        {
            int o=Prime[i],d=0;
            rep(k,last+1)
            {
                d+=Hp[k]*o;
                Hp[k]=d%10;
                d/=10;
            }
            while(d) Hp[++last]=d%10,d/=10;
        }
    }
    for(int i=last;i&gt;=0;--i)out&lt;&lt;Hp[i];
    return out;
}
void work()
{
    if(S&gt;n-2){cout&lt;&lt;0&lt;&lt;endl;return;}
    if(noLimit==0&amp;&amp;S&lt;n-2){cout&lt;&lt;0&lt;&lt;endl;return;}
    getPrime();
    BigInt ans;
    for(int i=1;i&lt;=n-2;i++)
        ans.mul(i);
    rep(i,n)
    {
        if(D[i]&gt;0)
            for(int j=1;j&lt;=D[i]-1;j++)
                ans.div(j);
    }
    for(int i=1;i&lt;=n-2-S;i++)
        ans.div(i);
    rep(i,n-2-S) ans.mul(noLimit);
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    init();
    work();
}
<pre><h2>Problem1006</h2><pre>#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
const int maxn=10000+10;
using namespace std;
typedef vector&lt;int&gt;::iterator it;
int n,m,cnt[maxn]={},c[maxn]={},hash[maxn]={};
bool v[maxn]={};
vector&lt;int&gt; E[maxn],ord;
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d",&amp;n,&amp;m);int s,t;
    while(m--)scanf("%d%d",&amp;s,&amp;t),--s,--t,E[s].pb(t),E[t].pb(s);
    rep(i,n)
    {
        int max=-1,t;
        rep(j,n)if(!v[j]&amp;&amp;cnt[j]&gt;max)max=cnt[j],t=j;
        v[t]=true;tr(e,E[t])cnt[*e]++;
        ord.pb(t);
    }
    c[ord[0]]=1;
    for(int id=1;id&lt;=n-1;id++)
    {
        int t=ord[id];
        tr(e,E[t])hash[c[*e]]=id;
        rep(i,n)if(hash[i+1]!=id){c[t]=i+1;break;}
    }
    int ans=0;rep(i,n)ans&gt;?=c[i];
    printf("%d\n",ans);
}


<pre><h2>Problem1007</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
#include&lt;utility&gt;
#include&lt;stack&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=50000;
struct Line
{
    int k,b,no;
    bool operator&lt;(const Line&amp;o) const
    {return k&lt;o.k||k==o.k&amp;&amp;b&gt;o.b;}
    bool operator==(const Line&amp;o) const
    {return k==o.k;}
}L[maxn],S[maxn];
int top=0,n,ans[maxn],cnt=0;
double Cal(Line a,Line b)
{
    return double(b.b-a.b)/(a.k-b.k);
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;rep(i,n) scanf("%d %d",&amp;L[i].k,&amp;L[i].b),L[i].no=i;
    sort(L,L+n);n=unique(L,L+n)-L;
    rep(i,n)
    {
        while(top&gt;1&amp;&amp;Cal(S[top-1],S[top-2])&gt;=Cal(S[top-1],L[i]))--top;
        S[top++]=L[i];
    }
    rep(i,top) ans[cnt++]=S[i].no;
    sort(ans,ans+cnt);
    rep(i,cnt-1)printf("%d ",ans[i]+1);printf("%d\n",ans[cnt-1]+1);
}
<pre><h2>Problem1007</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=50000;
struct Line
{
    int k,b,no;
    bool operator&lt;(const Line&amp;o) const
    {return k&lt;o.k||k==o.k&amp;&amp;b&gt;o.b;}
    bool operator==(const Line&amp;o) const
    {return k==o.k;}
}L[maxn],S[maxn];
int top=0,n,ans[maxn],cnt=0;
double Cal(Line a,Line b)
{
    return double(b.b-a.b)/(a.k-b.k);
}
int main()
{
    scanf("%d",&amp;n);rep(i,n) scanf("%d %d",&amp;L[i].k,&amp;L[i].b),L[i].no=i;
    sort(L,L+n);n=unique(L,L+n)-L;
    rep(i,n)
    {
        while(top&gt;1&amp;&amp;Cal(S[top-1],S[top-2])&gt;=Cal(S[top-1],L[i]))--top;
        S[top++]=L[i];
    }
    rep(i,top) ans[cnt++]=S[i].no;
    sort(ans,ans+cnt);
    rep(i,cnt-1)printf("%d ",ans[i]+1);printf("%d\n",ans[cnt-1]+1);
}
<pre><h2>Problem1008</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int inf=~0U&gt;&gt;1;
typedef long long ll;
const int mod=100003;
ll m,n;
inline void mul(ll&amp;a,int b)
{
    a*=b;a%=mod;
}
int power(ll x,int base)
{
    if(x==0) return 1;
    ll tmp=power(x/2,base);
    mul(tmp,tmp);
    if(x&amp;1) mul(tmp,base);
    return tmp;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;m&gt;&gt;n;
    int all=power(n,m);
    ll sub=power(n-1,m-1);
    mul(sub,m);
    int ans=all-sub;if(ans&lt;0) ans+=mod;
    cout&lt;&lt;ans&lt;&lt;endl;
}
<pre><h2>Problem1008</h2><pre>#include&lt;iostream&gt;
using namespace std;
typedef long long ll;
const int mod=100003;
ll m,n;
inline void mul(ll&amp;a,int b){a*=b;a%=mod;}
int power(ll x,int base)
{
    if(x==0) return 1;
    ll tmp=power(x/2,base);
    mul(tmp,tmp);
    if(x&amp;1) mul(tmp,base);
    return tmp;
}
int main()
{
    cin&gt;&gt;m&gt;&gt;n;
    int all=power(n,m);
    ll sub=power(n-1,m-1);
    mul(sub,m);
    int ans=all-sub;if(ans&lt;0) ans+=mod;
    cout&lt;&lt;ans&lt;&lt;endl;
}
<pre><h2>Problem1009</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxm=20;
int n,m,mod,A[maxm],next[maxm+1];
struct Mat
{
    int M[maxm][maxm];
    Mat(){memset(M,0,sizeof(M));}
    void operator=(const Mat&amp;o)
    {memcpy(M,o.M,sizeof(M));}
    int&amp; operator()(int i,int j){return M[i][j];}
    Mat operator*(Mat&amp;o)
    {
        Mat T;
        rep(i,m)rep(j,m)rep(k,m)T(i,j)+=M[i][k]*o(k,j),T(i,j)%=mod;
        return T;
    }
}orig;
Mat Power(int n)
{
    if(n==1) return orig;
    Mat tmp=Power(n/2);
    tmp=tmp*tmp;
    if(n&amp;1) tmp=tmp*orig;
    return tmp;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod;char x;
    rep(i,m) cin&gt;&gt;x,A[i+1]=x-'0';
    next[1]=0;int t=0;
    for(int i=2;i&lt;=m;i++)
    {
        while(t&gt;0&amp;&amp;A[t+1]!=A[i]) t=next[t];
        if(A[t+1]==A[i])++t;
        next[i]=t;
    }
    for(int i=0;i&lt;m;++i)
    {
        rep(j,10)
        {
            int t=i;
            while(t&gt;0&amp;&amp;A[t+1]!=j)t=next[t];
            if(A[t+1]==j)++t;
            orig(t,i)++;
        }
    }
    Mat ans=Power(n);int Ans=0;
    rep(i,m) Ans+=ans(i,0),Ans%=mod;
    cout&lt;&lt;Ans&lt;&lt;endl;
}
<pre><h2>Problem1010</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;deque&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1;
const int maxn=50000+1;
typedef long long ll;
struct node
{
    int l,r,ch;
    node(){}
    node(int _l,int _r,int _ch):l(_l),r(_r),ch(_ch){}
};
ll Sum[maxn]={0},Dp[maxn];
int top=0;
int L,n;
ll Cost(int l,int r)
{
    ll x=Sum[r]-Sum[l-1]+r-l;
    x-=L;
    return x*x;
}
ll Get(int i,int j)
{
    if(j&gt;=i)return inf;
    return Dp[j]+Cost(j+1,i);
}
int binary(node t,int i)
{
    int l=t.l,r=t.r;
    #define check(m) (Get(m,t.ch)&lt;Get(m,i))
    if(check(r)) return r;
    while(l+1&lt;r)
    {
        int m=(l+r)/2;
        if(check(m)) l=m;
        else r=m;
    }
    return l;
    #undef check
}
void Init()
{
    scanf("%d %d",&amp;n,&amp;L);
    rep(i,n)scanf("%lld",Sum+i+1);
    for(int i=1;i&lt;=n;i++) Sum[i]+=Sum[i-1];
}
void Work()
{
    Dp[0]=0;deque&lt;node&gt; D;
    D.pb(node(1,n,0));
    for(int i=1;i&lt;=n;i++)
    {
        Dp[i]=Get(i,D.front().ch);
        if(D.front().l&lt;D.front().r)
            D.front().l++;
        else
            D.pop_front();
        node t;int e;
        while(D.size())
        {
            t=D.back();
            if(Get(t.l,i)&lt;=Get(t.l,t.ch))
            {
                D.pop_back();
            }
            else
            {
                e=binary(t,i);
                D.back().r=e;
                break;
            }
        }
        if(D.size()==0)
            D.pb(node(i+1,n,i));
        else if(e&lt;n) D.pb(node(e+1,n,i));
    }
    cout&lt;&lt;Dp[n]&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Work();
}
<pre><h2>Problem1012</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int maxn=200000;
int stack[maxn],top=0;
int F[maxn],A[maxn];
int find(int x){if(F[x]==x) return x; return F[x]=find(F[x]);}
void Union(int x,int y){F[y]=x;}
int main()
{
    //freopen("in","r",stdin);
    int last=0,m,d,x,n=0;char c;
    scanf("%d %d\n",&amp;m,&amp;d);
    while(m--)
    {
        scanf("%c %d\n",&amp;c,&amp;x);
        if(c=='Q')
            x=(n-x),printf("%d\n",last=A[find(x)]);
        else
        {
            F[n]=n;A[n]=(last+x)%d;
            while(top&amp;&amp;A[stack[top-1]]&lt;=A[n])
                Union(n,stack[top-1]),top--;
            stack[top++]=n++;
        }
    }
}
<pre><h2>Problem1013</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=10;
using namespace std;
double L[maxn+1][maxn];
double A[maxn][maxn+1];
int n;
inline double sqr(double x)
{
    return x*x;
}
void Init()
{
    cin&gt;&gt;n;
    rep(i,n+1)
        rep(j,n)cin&gt;&gt;L[i][j];
    rep(i,n)
    {
        double*Line=A[i];
        double*a=L[i],*b=L[i+1];
        Line[n]=0;
        rep(j,n)Line[n]+=sqr(a[j])-sqr(b[j]),Line[j]=2*(a[j]-b[j]);
    }
}
void Solve()
{
    rep(i,n)
    {
        double t=A[i][i];
        rep(j,n+1)A[i][j]/=t;
        rep(j,n)if(j!=i)
        {
            double r=A[j][i];
            rep(k,n+1)A[j][k]-=r*A[i][k];
        }
    }
    rep(i,n)printf("%0.3lf ",A[i][n]);
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


<pre><h2>Problem1013</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=10;
using namespace std;
double L[maxn+1][maxn];
double A[maxn][maxn+1];
int n;
int main()
{
    cin&gt;&gt;n;
    rep(i,n+1)
        rep(j,n)cin&gt;&gt;L[i][j];
    rep(i,n)
    {
        double*Line=A[i];
        double*a=L[i],*b=L[i+1];
        Line[n]=0;
        rep(j,n)Line[n]+=a[j]*a[j]-b[j]*b[j],Line[j]=2*(a[j]-b[j]);
    }
    rep(i,n)
    {
        double t=A[i][i];
        rep(j,n+1)A[i][j]/=t;
        rep(j,n)if(j!=i)
        {
            double r=A[j][i];
            rep(k,n+1)A[j][k]-=r*A[i][k];
        }
    }
    rep(i,n)printf("%0.3lf ",A[i][n]);
}


<pre><h2>Problem1014</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cctype&gt;
#include&lt;cassert&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=100000+100,seed=13331;
typedef unsigned long long ull;
char C[maxn];
int n,m;
ull P[maxn];
struct Node
{
    int x,size;
    ull key;
    Node*ch[2],*p;
    Node():size(0){memset(ch,0,sizeof(ch));key=0;}
    bool d(){return this==p-&gt;ch[1];}
    void sc(Node*c,bool _d)
    {
        ch[_d]=c;c-&gt;p=this;
    }
}TNull,*Null=&amp;TNull;
struct SplayTree
{
    Node Data[maxn];
    Node*root,*Now;
    Node* New_Node(int x=0)
    {
        Now-&gt;size=1;rep(i,2)Now-&gt;ch[i]=Null;
        Now-&gt;x=x;Now-&gt;key=x;
        return Now++;
    }
    SplayTree()
    {
        Now=Data;
    }
    void Update(Node*t)
    {
        ull ret=t-&gt;ch[0]-&gt;key;ret*=seed;
        ret+=t-&gt;x;ret*=P[t-&gt;ch[1]-&gt;size];ret+=t-&gt;ch[1]-&gt;key;
        t-&gt;key=ret;
        t-&gt;size=t-&gt;ch[0]-&gt;size+t-&gt;ch[1]-&gt;size+1;
    }
    void rot(Node*t)
    {
        Node*p=t-&gt;p;bool d=t-&gt;d();
        p-&gt;sc(t-&gt;ch[!d],d);
        p-&gt;p-&gt;sc(t,p-&gt;d());
        t-&gt;sc(p,!d);
        Update(p);
        if(p==root)root=t;
    }
    void Splay(Node*x,Node*f)
    {
        while(x-&gt;p!=f)
        {
            if(x-&gt;p-&gt;p==f)rot(x);
            else x-&gt;d()==x-&gt;p-&gt;d()?(rot(x-&gt;p),rot(x)):(rot(x),rot(x));
        }
        Update(x);
    }
    Node*Select(Node*x,int k)
    {
        assert(x!=Null);
        assert(x-&gt;ch[0]!=0);
        int r=x-&gt;ch[0]-&gt;size;
        if(r==k)return x;
        if(k&lt;r)return Select(x-&gt;ch[0],k);
        return Select(x-&gt;ch[1],k-r-1);
    }
    Node*&amp;get(int l,int r)
    {
        Node*x=Select(root,l);
        Splay(x,Null);
        Node*y=Select(root,r);
        Splay(y,x);
        return y-&gt;ch[0];
    }
    void Insert(int p,int x)
    {
        get(p-1,p);Node*t=New_Node(x);
        root-&gt;ch[1]-&gt;sc(t,0);
        Splay(t,Null);
    }
    void Replace(int p,int x)
    {
        Node*t=get(p-1,p+1);t-&gt;x=x;t-&gt;key=x;
        Splay(t,Null);
    }
    ull Hash(int l,int r)
    {
        return get(l-1,r+1)-&gt;key;
    }
    int Ask(int a,int b)
    {
        int ret=0;int n=root-&gt;size-1;
        for(int i=1&lt;&lt;18;i;i&gt;&gt;=1)
            if(a+i&lt;=n&amp;&amp;b+i&lt;=n&amp;&amp;Hash(a,a+i-1)==Hash(b,b+i-1))
            {
                ret+=i;a+=i;b+=i;
            }
        return ret;
    }
    Node*build(int l,int r)
    {
        if(l&gt;r)return Null;
        int m=l+r&gt;&gt;1;
        Node*t=New_Node(C[m]),*L=build(l,m-1),*R=build(m+1,r);
        if(L!=Null)t-&gt;sc(L,0);
        if(R!=Null)t-&gt;sc(R,1);
        Update(t);
        return t;
    }
    void Build()
    {
        root=build(0,n+1);root-&gt;p=Null;
    }
    void Debug(Node*t)
    {
        if(t==Null)return;
        Debug(t-&gt;ch[0]);
        cout&lt;&lt;t-&gt;x&lt;&lt;" "&lt;&lt;t-&gt;size&lt;&lt;endl;
        Debug(t-&gt;ch[1]);
    }
}T;
int main()
{
    //freopen("in","r",stdin);
    P[0]=1;
    rep(i,maxn-1)P[i+1]=P[i]*seed;
    scanf("%s",C+1);C[0]=0;
    n=strlen(C+1);C[n+1]=0;
    T.Build();
    char c,d;int a,b;
    scanf("%d",&amp;m);
    rep(i,m)
    {
        scanf(" ");scanf("%c",&amp;c);
        switch(c)
        {
            case 'Q':scanf("%d %d",&amp;a,&amp;b);printf("%d\n",T.Ask(a,b));break;
            case 'I':scanf("%d %c",&amp;a,&amp;d);T.Insert(a+1,d);break;
            case 'R':scanf("%d %c",&amp;a,&amp;d);T.Replace(a,d);break;
        }
    }
}
<pre><h2>Problem1015</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#include&lt;utility&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,a,b) for(int i=a;i&lt;=b;i++)
#define tr(i,x) for(vi::iterator i=x.begin();i!=x.end();i++)
#define all(x) x.begin(),x.end()
#define pb push_back
#define divide cout&lt;&lt;"---------------"&lt;&lt;endl;
using namespace std;
const int inf=~0U&gt;&gt;1,maxm=400000,maxn=maxm;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef pair&lt;int,int&gt; ii;
ii E[maxm];
int A[maxn],Ans[maxn],S[maxn+1]={0},T[maxm];
bool inSet[maxn]={0},used[maxn]={0};
int F[maxn],n,m,cnt;
void makeset(int x)
{
    F[x]=x;cnt++;inSet[x]=true;
}
int find(int x)
{
    if(F[x]==x)return x;
    return F[x]=find(F[x]);
}
void Union(int i,int j)
{
    if(!inSet[i]||!inSet[j])return;
    i=find(i);j=find(j);
    if(i!=j) F[i]=j,cnt--;
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d %d",&amp;n,&amp;m);int s,t;cnt=0;
    rep(i,m)
    {
        scanf("%d %d",&amp;s,&amp;t);
        E[i*2]=ii(s,t);
        E[i*2+1]=ii(t,s);
        S[s]++;S[t]++;
    }
    for(int i=1;i&lt;=n;i++) S[i]+=S[i-1];
    for(int i=2*m-1;i&gt;=0;--i)
        T[--S[E[i].first]]=E[i].second;
    int k;scanf("%d",&amp;k);
    rep(i,k)scanf("%d",A+i),used[A[i]]=true;
    rep(i,n)if(!used[i])makeset(i);
    rep(i,n)if(!used[i])for(int e=S[i];e&lt;S[i+1];e++)Union(i,T[e]);
    Ans[k]=cnt;
    for(int i=k-1;i&gt;=0;--i)
    {
        int t=A[i];makeset(t);
        for(int e=S[t];e&lt;S[t+1];e++)Union(t,T[e]);
        Ans[i]=cnt;
    }
    rep(i,k+1)printf("%d\n",Ans[i]);
}
<pre><h2>Problem1016</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;map&gt;
#include &lt;utility&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,mod=31011,maxn=100,maxm=1000;
using namespace std;
typedef pair&lt;int,int&gt; ii;
struct UF
{
    int F[maxn];
    void clear(){rep(i,maxn)F[i]=i;}
    int find(int x)
    {
        if(F[x]==x)return x;
        return F[x]=find(F[x]);
    }
    bool Union(int i,int j)
    {
        i=find(i);j=find(j);
        return F[i]=j,i!=j;
    }
    UF&amp; operator=(const UF&amp;u)
    {
        memcpy(F,u.F,sizeof(F));
        return *this;
    }
};
int n,m,ans=1,get,ret;
typedef map&lt;int,vector&lt;ii&gt; &gt;::iterator mit;
map&lt;int,vector&lt;ii&gt; &gt; M;
UF All,Link;
vector&lt;ii&gt; now;
void Dfs(int p,int c)
{
    if(p==now.size())
    {
        if(c==get)ret++;
        return;
    }
    ii t=now[p];UF tmp=Link;
    if(Link.Union(t.first,t.second))Dfs(p+1,c+1);
    Link=tmp;
    Dfs(p+1,c);
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;int s,t,c;
    rep(i,m)
    {
        cin&gt;&gt;s&gt;&gt;t&gt;&gt;c;s--;t--;
        M[c].pb(ii(s,t));
    }
    All.clear();s=0;
    for(mit i=M.begin();i!=M.end();i++)
    {
        now=i-&gt;second;Link=All;get=0;ret=0;
        rep(j,now.size())get+=All.Union(now[j].first,now[j].second);
        Dfs(0,0);ans*=ret;ans%=mod;s+=get;
    }
    if(s&lt;n-1)cout&lt;&lt;0&lt;&lt;endl;
    else cout&lt;&lt;ans&lt;&lt;endl;
}


<pre><h2>Problem1016</h2><pre>#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;utility&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int mod=31011,maxn=100,maxm=1000;
using namespace std;
typedef pair&lt;int,int&gt; ii;
struct UF
{
    int F[maxn];
    void clear(){rep(i,maxn)F[i]=i;}
    int find(int x)
    {
        if(F[x]==x)return x;
        return F[x]=find(F[x]);
    }
    bool Union(int i,int j)
    {
        i=find(i);j=find(j);
        return F[i]=j,i!=j;
    }
    UF&amp; operator=(const UF&amp;u)
    {
        memcpy(F,u.F,sizeof(F));
        return *this;
    }
};
int n,m,ans=1,get,ret;
typedef map&lt;int,vector&lt;ii&gt; &gt;::iterator mit;
map&lt;int,vector&lt;ii&gt; &gt; M;
UF All,Link;
vector&lt;ii&gt; now;
void Dfs(int p,int c)
{
    if(p==now.size())
    {
        if(c==get)ret++;
        return;
    }
    ii t=now[p];UF tmp=Link;
    if(Link.Union(t.first,t.second))Dfs(p+1,c+1);
    Link=tmp;
    Dfs(p+1,c);
}
int main()
{
    cin&gt;&gt;n&gt;&gt;m;int s,t,c;
    rep(i,m)
    {
        cin&gt;&gt;s&gt;&gt;t&gt;&gt;c;s--;t--;
        M[c].pb(ii(s,t));
    }
    All.clear();s=0;
    for(mit i=M.begin();i!=M.end();i++)
    {
        now=i-&gt;second;Link=All;get=0;ret=0;
        rep(j,now.size())get+=All.Union(now[j].first,now[j].second);
        Dfs(0,0);ans*=ret;ans%=mod;s+=get;
    }
    if(s&lt;n-1)cout&lt;&lt;0&lt;&lt;endl;
    else cout&lt;&lt;ans&lt;&lt;endl;
}


<pre><h2>Problem1016</h2><pre>/**
 * Created by IntelliJ IDEA.
 * User: mac
 * Date: 11-12-12
 * Time: 下午6:16
 * To change this template use File | Settings | File Templates.
 */

import java.io.*;
import java.util.*;

public class Main {

    BufferedReader reader;
    StringTokenizer tokenizer;
    PrintWriter writer;

    void setIO(String name) throws IOException {
        reader = new BufferedReader(new FileReader(name + ".in"));
        tokenizer = null;
        writer = new PrintWriter(name + ".out");
    }

    void run() {
        try {
            reader = new BufferedReader(new InputStreamReader(System.in));
            tokenizer = null;
            writer = new PrintWriter(System.out);
//            setIO(getClass().getName());
            solve();
            reader.close();
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    String nextToken() throws IOException {
        while (tokenizer == null || !tokenizer.hasMoreTokens())
            tokenizer = new StringTokenizer(reader.readLine());
        return tokenizer.nextToken();
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    public static final int MOD = 31011;

    class Edge {
        int a, b, c;

        Edge(int a, int b, int c) {
            this.a = a;
            this.b = b;
            this.c = c;
        }
    }

    int[] father;

    int find(int x) {
        if (x == father[x])
            return x;
        return father[x] = find(father[x]);
    }

    boolean unite(int a, int b) {
        a = find(a);
        b = find(b);
        if (a == b)
            return false;
        father[a] = b;
        return true;
    }

    void solve() throws IOException {
        int nV = nextInt(), nE = nextInt();
//        System.out.println(nV + " " + nE);

        TreeMap&lt;Integer, List&lt;Edge&gt;&gt; map = new TreeMap&lt;Integer, List&lt;Edge&gt;&gt;();

        for (int i = 0; i &lt; nE; i++) {
            Edge e = new Edge(nextInt() - 1, nextInt() - 1, nextInt());
            if (!map.containsKey(e.c))
                map.put(e.c, new ArrayList&lt;Edge&gt;());
            map.get(e.c).add(e);
        }

        father = new int[nV];
        for (int i = 0; i &lt; nV; i++) {
            father[i] = i;
        }

        long sum = 0, way = 1;

        for (Map.Entry&lt;Integer, List&lt;Edge&gt;&gt; e : map.entrySet()) {

            List&lt;Edge&gt; edgeList = e.getValue();

            List&lt;Integer&gt; vs = new ArrayList&lt;Integer&gt;();
            for (Edge edge : edgeList) {
                edge.a = find(edge.a);
                edge.b = find(edge.b);
                vs.add(edge.a);
                vs.add(edge.b);
            }

            int maxEdge = 0;
            for (Edge edge : edgeList) {
                maxEdge += unite(edge.a, edge.b) ? 1 : 0;
            }

            int curWay = 0;

            for (int edgeSet = 0; edgeSet &lt; (1 &lt;&lt; edgeList.size()); edgeSet++) {
                for (Integer v : vs) {
                    father[v] = v;
                }
                int curEdge = 0;
                for (int i = 0; i &lt; edgeList.size(); i++) {
                    if ((edgeSet &gt;&gt; i &amp; 1) &gt; 0) {
                        Edge edge = edgeList.get(i);
                        if (!unite(edge.a, edge.b)) {
                            curEdge = -1;
                            break;
                        } else {
                            ++curEdge;
                        }
                    }
                }
                if (curEdge == maxEdge) {
                    ++curWay;
                }
            }


            for (Integer v : vs) {
                father[v] = v;
            }

            for (Edge edge : edgeList) {
                if (unite(edge.a, edge.b))
                    sum += edge.c;
            }

            way = way * curWay % MOD;
        }

        for (int i = 0; i &lt; nV; i++) {
            if (find(i) != find(0)) {
                writer.println(0);
                return;
            }
        }
        writer.println(way);
    }

    static public void main(String[] args) {
        new Main().run();
    }
}
<pre><h2>Problem1018</h2><pre>/*
 * [SHOI2008]堵塞的交通traffic.cpp
 *
 *  Created on: 2011-6-22
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int NROWS = 2;
const int MAX_N_COLS = 100000 + 10;
int nCols;
bool edgeHor[NROWS][MAX_N_COLS] = { };
bool edgeVer[MAX_N_COLS] = { };

const int LU = 0, LD = 1, RU = 2, RD = 3;

void floyd(int con[], int N) {
	for (int k = 0; k &lt; N; ++k) {
		for (int i = 0; i &lt; N; ++i) {
			if (con[i] &gt;&gt; k &amp; 1)
				con[i] |= con[k];
		}
	}
}

void makeUp(int con[], int N) {
	for (int i = 0; i &lt; N; ++i) {
		con[i] |= 1 &lt;&lt; i;
		for (int j = 0; j &lt; N; ++j) {
			if (con[i] &gt;&gt; j &amp; 1)
				con[j] |= 1 &lt;&lt; i;
		}
	}
}

struct Info {
	int con[4];
	bool exist;
	Info(bool _exist = true) :
		exist(_exist) {
		memset(con, 0, sizeof con);
	}
	bool ask(int a, int b) {
		return con[a] &gt;&gt; b &amp; 1;
	}
	int set(int a, int b, int v) {
		if (v)
			con[a] |= 1 &lt;&lt; b;
		else
			con[a] &amp;= ~(1 &lt;&lt; b);
	}
	void setSingle(int l, int r) {
		memset(con, 0, sizeof con);
		set(LU, RU, edgeHor[0][l]);
		set(LD, RD, edgeHor[1][l]);
		set(LU, LD, edgeVer[l]);
		set(RU, RD, edgeVer[r]);
		makeUp(con, 4);
		floyd(con, 4);
	}
	Info&amp;operator=(const Info&amp;i) {
		memcpy(con, i.con, sizeof con);
		exist = i.exist;
		return *this;
	}
};

Info operator+(const Info&amp;L, const Info&amp;R) {
	if (!L.exist || !R.exist)
		return L.exist ? L : R;
	static int con[6];
	memset(con, false, sizeof con);
	for (int i = 0; i &lt; 4; ++i) {
		con[i] |= L.con[i];
		con[i + 2] |= R.con[i] &lt;&lt; 2;
	}
	floyd(con, 6);
	Info ret;
	for (int i = 0; i &lt; 4; ++i) {
		for (int j = 0; j &lt; 4; ++j) {
			int ni = i &lt; 2 ? i : i + 2, nj = j &lt; 2 ? j : j + 2;
			if (con[ni] &gt;&gt; nj &amp; 1)
				ret.con[i] |= 1 &lt;&lt; j;
		}
	}
	return ret;
}

struct Tree {
	Info I;
	Tree*ch[2];
	int l, r;

	void update() {
		I = ch[0]-&gt;I + ch[1]-&gt;I;
	}

	Tree(int _l, int _r) :
		l(_l), r(_r) {
		if (l + 1 == r) {
			I.setSingle(l, r);
			return;
		}
		int m = l + r &gt;&gt; 1;
		ch[0] = new Tree(l, m);
		ch[1] = new Tree(m, r);
		update();
	}

	void changeHor(int at) {
		if (at &lt; l || at &gt;= r)
			return;
		if (l + 1 == r) {
			I.setSingle(l, r);
			return;
		}
		for (int c = 0; c &lt; 2; ++c) {
			ch[c]-&gt;changeHor(at);
		}
		update();
	}

	void changeVer(int at) {
		if (at &lt; l || at &gt; r)
			return;
		if (l + 1 == r) {
			I.setSingle(l, r);
			return;
		}
		for (int c = 0; c &lt; 2; ++c) {
			ch[c]-&gt;changeVer(at);
		}
		update();
	}

	Info ask(int L, int R) {
		if (R &lt;= l || r &lt;= L)
			return Info(false);
		if (L &lt;= l &amp;&amp; R &gt;= r)
			return I;
		return ch[0]-&gt;ask(L, R) + ch[1]-&gt;ask(L, R);
	}
}*root;

bool ask(int r1, int c1, int r2, int c2) {
	if (c1 &gt; c2) {
		swap(r1, r2);
		swap(c1, c2);
	}
	Info mid;
	if (c1 == c2) {
		for (int i = 0; i &lt; 2; ++i) {
			mid.set(i, i + 2, true);
		}
		for (int i = 0; i &lt; 4; i += 2) {
			mid.set(i, i + 1, edgeVer[c1]);
		}
		makeUp(mid.con, 4);
		floyd(mid.con, 4);
	} else {
		mid = root-&gt;ask(c1, c2);
	}

	if (mid.ask(r1, r2 + 2))
		return true;

	if (!mid.ask(LU, LD)) {
		if (c1 &gt; 0) {
			Info left = root-&gt;ask(0, c1);
			if (left.ask(RU, RD))
				mid.set(LU, LD, true);
		}
	}
	if (!mid.ask(RU, RD)) {
		if (c2 &lt; nCols - 1) {
			Info right = root-&gt;ask(c2, nCols - 1);
			if (right.ask(LU, LD))
				mid.set(RU, RD, true);
		}
	}

	makeUp(mid.con, 4);
	floyd(mid.con, 4);
	return mid.ask(r1, r2 + 2);
}

void set(int r1, int c1, int r2, int c2, bool toWhat) {
	if (c1 == c2) {
		edgeVer[c1] = toWhat;
		if (root)
			root-&gt;changeVer(c1);
	} else {
		int c = min(c1, c2);
		edgeHor[r1][c] = toWhat;
		if (root)
			root-&gt;changeHor(c);
	}
}

bool visited[NROWS][MAX_N_COLS];

void dfs(int r, int c) {
	if (visited[r][c])
		return;
	visited[r][c] = true;
	if (edgeVer[c])
		dfs(1 - r, c);
	if (c + 1 &lt; nCols &amp;&amp; edgeHor[r][c])
		dfs(r, c + 1);
	if (c &gt; 0 &amp;&amp; edgeHor[r][c - 1])
		dfs(r, c - 1);
}

bool bfAsk(int r1, int c1, int r2, int c2) {
	memset(visited, false, sizeof visited);
	dfs(r1, c1);
	return visited[r2][c2];
}

void solve() {
	cin &gt;&gt; nCols;
	if (nCols &gt; 1)
		root = new Tree(0, nCols - 1);
	else
		root = 0;
	char buf[100];
	for (;;) {
		scanf(" ");
		scanf("%s", buf);
		bool toWhat, isAsk = false;
		switch (buf[0]) {
			case 'O': {
				toWhat = true;
				break;
			}
			case 'C': {
				toWhat = false;
				break;
			}
			case 'A': {
				isAsk = true;
				break;
			}
			case 'E': {
				return;
				break;
			}
		}

		int r1, c1, r2, c2;
		scanf("%d%d%d%d", &amp;r1, &amp;c1, &amp;r2, &amp;c2);
		--r1, --c1, --r2, --c2;
		if (isAsk) {
			printf("%c\n", ask(r1, c1, r2, c2) ? 'Y' : 'N');
		} else {
			set(r1, c1, r2, c2, toWhat);
		}
	}
}

void runTest() {
	nCols = 1000;
	memset(edgeVer, false, sizeof edgeVer);
	memset(edgeHor, false, sizeof edgeHor);
	root = new Tree(0, nCols - 1);
	for (int it = 0; it &lt; 1000; ++it) {
		int r1, c1, r2, c2;
		int t = rand() % 3;
		switch (t) {
			case 0:
			case 1: {
				if (rand() % 2 == 0) {
					r1 = r2 = rand() % 2;
					c1 = rand() % (nCols - 1);
					c2 = c1 + 1;
				} else {
					c1 = c2 = rand() % nCols;
					r1 = 0, r2 = 1;
				}
				set(r1, c1, r2, c2, rand() % 100 &gt; 0);
				break;
			}
			case 2: {
				r1 = rand() % 2, r2 = rand() % 2;
				c1 = rand() % nCols, c2 = rand() % nCols;
				bool ret = ask(r1, c1, r2, c2);
				bool ans = bfAsk(r1, c1, r2, c2);
				if (ret != ans) {
					printf("BAD!");
				}
				break;
			}
		}
	}
}

int main() {
	//	runTest();
	solve();
}
<pre><h2>Problem1019</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long ll;
int Moves[6][2],n;
void init()
{
    cin&gt;&gt;n;
    char a;
    rep(i,6)
    {
        scanf(" ");
        rep(j,2)cin&gt;&gt;a,Moves[i][j]=a-'A';
    }
}
int Stupid_Cal(int n)
{
    vector&lt;int&gt; Stack[3];
    for(int i=n;i&gt;=1;i--)Stack[0].pb(i);
    int last=0;
    for(int num=0;;)
    {
        if(Stack[1].size()==n||Stack[2].size()==n)
            return num;
        rep(i,6)
        {
            int from=Moves[i][0],to=Moves[i][1];
                if(Stack[from].size()&amp;&amp;Stack[from].back()!=last)
                    if(Stack[to].size()==0||Stack[from].back()&lt;Stack[to].back())
                    {
                        last=Stack[from].back();
                        Stack[from].pop_back();
                        Stack[to].pb(last);
                        num++;
                        break;
                    }
        }
    }
}
void Solve()
{
    if(n&lt;=3){cout&lt;&lt;Stupid_Cal(n)&lt;&lt;endl;return;}
    int a2=Stupid_Cal(2),a3=Stupid_Cal(3);
    int a=a3/a2,b=a3-a*a2;
    ll ans=a3;
    for(int i=4;i&lt;=n;i++)
        ans=ans*a+b;
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    init();
    Solve();
}


<pre><h2>Problem1020</h2><pre>/**************************************************************
    Problem: 1020
    User: nimendongde
    Language: C++
    Result: Accepted
    Time:293 ms
    Memory:280 kb
****************************************************************/
 
/*
 * [SHOI2008]安全的航线flight.cpp
 *
 *  Created on: 2011-3-29
 *      Author: user
 */
 
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
 
const int MAX_N_LANDS = 20 + 10;
const int MAX_N_POINT_IN_LANDS = 20 + 10;
const int MAX_N_TURNS = 20 + 10;
 
const double EPS = 1e-8;
inline int sign(double a) {
    return a &lt; -EPS ? -1 : a &gt; EPS;
}
 
struct Point {
    double x, y;
    Point() {
    }
    Point(double _x, double _y) :
        x(_x), y(_y) {
    }
    Point operator+(const Point&amp;p) const {
        return Point(x + p.x, y + p.y);
    }
    Point operator-(const Point&amp;p) const {
        return Point(x - p.x, y - p.y);
    }
    Point operator*(double d) const {
        return Point(x * d, y * d);
    }
    Point operator/(double d) const {
        return Point(x / d, y / d);
    }
    double det(const Point&amp;p) const {
        return x * p.y - y * p.x;
    }
    double dot(const Point&amp;p) const {
        return x * p.x + y * p.y;
    }
    Point rot90() const {
        return Point(-y, x);
    }
    void read() {
        scanf("%lf%lf", &amp;x, &amp;y);
    }
    void write() const {
        printf("%lf %lf", x, y);
    }
    double abs() {
        return hypot(x, y);
    }
    double abs2() {
        return x * x + y * y;
    }
    Point unit() {
        return *this / abs();
    }
 
    bool operator&lt;(const Point&amp;p) const {
        int cx = sign(x - p.x);
        if (cx != 0)
            return cx == -1;
        return sign(y - p.y) == -1;
    }
    double dist(const Point&amp;p) const {
        return hypot(x - p.x, y - p.y);
    }
};
 
#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))
 
#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))
 
Point isSS(Point p1, Point p2, Point q1, Point q2) {
    double a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);
    return (p1 * a2 + p2 * a1) / (a1 + a2);
}
 
bool isIntersect(Point p1, Point p2, Point q1, Point q2) {
    return crossOp(p1,p2,q1) * crossOp(p1,p2,q2) &lt;= 0 &amp;&amp; crossOp(q1,q2,p1)
            * crossOp(q1,q2,p2) &lt;= 0;
}
 
//bool isInMiddle(double a, double m, double b) {
//  return sign(a - m) == 0 || sign(b - m) == 0 || (a &lt; m != b &lt; m);
//}
//
//bool isInMiddle(Point a, Point m, Point b) {
//  return crossOp(a,m,b) == 0 &amp;&amp; isInMiddle(a.x, m.x, b.x) &amp;&amp; isInMiddle(a.y,
//          m.y, b.y);
//}
 
Point turns[MAX_N_TURNS];
int nTurns;
 
double distLinePoint(Point p1, Point p2, Point me) {
    return fabs(cross(p1,me,p2)) / p1.dist(p2);
}
 
Point nearestSegPoint(Point p1, Point p2, Point me) {
    //p1..p2 and me
    if ((me - p1).dot(p2 - p1) &lt;= 0)
        return p1;
    if ((me - p2).dot(p1 - p2) &lt;= 0)
        return p2;
    double dist = cross(p1,me,p2) / p1.dist(p2);
    Point dir = (p2 - p1).rot90().unit() * dist;
    return me + dir;
}
 
struct Land {
    Point ps[MAX_N_POINT_IN_LANDS];
    int nPs;
 
    void makeCounterClockwise() {
        if (crossOp(ps[0],ps[1],ps[2]) &lt; 0)
            reverse(ps, ps + nPs);
    }
 
    void read() {
        scanf("%d", &amp;nPs);
        for (int i = 0; i &lt; nPs; ++i) {
            ps[i].read();
        }
 
        makeCounterClockwise();
    }
 
    vector&lt;Point&gt; getIntersect(Point q1, Point q2) const {
        vector&lt;Point&gt; is;
        for (int i = 0; i &lt; nPs; ++i) {
            Point p1 = ps[i];
            Point p2 = ps[(i + 1) % nPs];
            if (isIntersect(p1, p2, q1, q2))
                is.push_back(isSS(p1, p2, q1, q2));
        }
 
        return is;
    }
 
    bool contain(Point me) const {
        Point dst(25452.687575, 36878.654555);
 
        int cnt = 0;
        for (int i = 0; i &lt; nPs; ++i) {
            cnt += isIntersect(me, dst, ps[i], ps[(i + 1) % nPs]);
        }
 
        return cnt % 2 == 1;
    }
 
    Point getNearestPoint(Point me) const {
        double minDist = 1e100;
        Point ret;
        for (int i = 0; i &lt; nPs; ++i) {
            Point cur = nearestSegPoint(ps[i], ps[(i + 1) % nPs], me);
            double curDist = cur.dist(me);
            if (curDist &lt; minDist) {
                minDist = curDist;
                ret = cur;
            }
        }
 
        return ret;
    }
};
 
int nLands;
Land lands[MAX_N_LANDS];
 
void inputData() {
    scanf("%d%d", &amp;nLands, &amp;nTurns);
    for (int i = 0; i &lt; nTurns; ++i) {
        turns[i].read();
    }
 
    for (int i = 0; i &lt; nLands; ++i) {
        lands[i].read();
    }
}
 
struct Segment {
    Point p1, p2;
    Segment(Point _p1, Point _p2) :
        p1(_p1), p2(_p2) {
        normalize();
    }
 
    void normalize() {
        if (p2 &lt; p1)
            swap(p1, p2);
    }
 
    double length() {
        return p1.dist(p2);
    }
 
    Point mid() {
        return (p1 + p2) / 2;
    }
};
 
queue&lt;Segment&gt; segQue;
 
void processLand(const Land&amp;land) {
    int oldSize = segQue.size();
    for (int me = 0; me &lt; oldSize; ++me) {
        Segment seg = segQue.front();
        segQue.pop();
 
        vector&lt;Point&gt; is = land.getIntersect(seg.p1, seg.p2);
        is.push_back(seg.p1);
        is.push_back(seg.p2);
        sort(is.begin(), is.end());
 
        for (int i = 0; i &lt; is.size() - 1; ++i) {
            Point l = is[i];
            Point r = is[i + 1];
            Point mid = (l + r) / 2;
            if (!land.contain(mid) &amp;&amp; (r - l).abs() &gt; EPS)
                segQue.push(Segment(l, r));
        }
    }
}
 
void initSegs() {
    for (int i = 0; i &lt; nTurns - 1; ++i) {
        segQue.push(Segment(turns[i], turns[i + 1]));
    }
 
    for (int i = 0; i &lt; nLands; ++i) {
        processLand(lands[i]);
    }
}
 
double ans = 0;
 
Point getNearestPointInAllLand(Point me) {
    Point ret;
    double minDist = 1e100;
    for (int landId = 0; landId &lt; nLands; ++landId) {
        Point cur = lands[landId].getNearestPoint(me);
        double curDist = cur.dist(me);
        if (curDist &lt; minDist) {
            minDist = curDist;
            ret = cur;
        }
    }
 
    return ret;
}
 
double calcMinDist(Point me) {
    Point cur = getNearestPointInAllLand(me);
    return cur.dist(me);
}
 
bool isInsideCircle(Point c, double r, Point me) {
    return sign(c.dist(me) - r) &lt;= 0;
}
 
Point projection(Point p1, Point p2, Point me) {
    Point dir = p2 - p1;
    return p1 + dir * (dir.dot(me - p1) / dir.abs2());
}
 
vector&lt;Point&gt; isLS(Point c, double r, Point p1, Point p2) {
    double d = distLinePoint(p1, p2, c);
    if (d &gt;= r)
        return vector&lt;Point&gt; ();
    Point at = projection(p1, p2, c);
    double x = sqrt(r * r - d * d);
    Point dir = (p1 - p2).unit() * x;
    vector&lt;Point&gt; is;
    is.push_back(at + dir);
    is.push_back(at - dir);
    return is;
}
 
bool isMiddle(double a, double m, double b) {
    return sign(a - m) == 0 || sign(b - m) == 0 || (a &lt; m != b &lt; m);
}
 
bool isMiddle(Point a, Point m, Point b) {
    return isMiddle(a.x, m.x, b.x) &amp;&amp; isMiddle(a.y, m.y, b.y);
}
 
bool isUseLess(const Segment&amp; seg) {
    Point p1 = seg.p1;
    Point p2 = seg.p2;
    Point c1 = getNearestPointInAllLand(p1);
    Point c2 = getNearestPointInAllLand(p2);
 
    //check if circle (c1,ans) and (c2,ans) can cover whole segment
 
    vector&lt;Point&gt; ps;
    vector&lt;Point&gt; is = isLS(c1, ans, p1, p2);
    ps.insert(ps.end(), is.begin(), is.end());
    is = isLS(c2, ans, p1, p2);
    ps.insert(ps.end(), is.begin(), is.end());
    ps.push_back(p1);
    ps.push_back(p2);
 
    sort(ps.begin(), ps.end());
 
    for (int i = 0; i + 1 &lt; ps.size(); ++i) {
        Point l = ps[i];
        Point r = ps[i + 1];
        Point m = (l + r) / 2;
        if (!isMiddle(p1, m, p2))
            continue;
        if (!isInsideCircle(c1, ans, m) &amp;&amp; !isInsideCircle(c2, ans, m))
            return false;
    }
 
    return true;
}
 
void work() {
    initSegs();
    int iter = 0;
    while (!segQue.empty() &amp;&amp; iter++ &lt; 2000) {
        Segment cur = segQue.front();
        segQue.pop();
        if (isUseLess(cur) || cur.length() &lt; 1e-3)
            continue;
        Point mid = cur.mid();
        double ret = calcMinDist(mid);
        if (ret &gt; ans)
            ans = ret;
        segQue.push(Segment(cur.p1, mid));
        segQue.push(Segment(mid, cur.p2));
    }
 
    printf("%0.2lf\n", ans);
}
 
void solve() {
    inputData();
    work();
}
 
int main() {
    solve();
}<pre><h2>Problem1021</h2><pre>/* Sample solution for the Circle of Debt problem in NCPC'07 by Andreas Bj&amp;#246;rklund */
#include &lt;stdio.h&gt;

#define MAXM 20000

int n,lsum,ssum;
int lgsum[3],smsum[3];
int D[3];
int C[3][6];
const int E[6]={100,50,20,10,5,1};
const int Z[6]={10,5,2,1,5,1};
int V[6];

int Mx[2][2][2001][2001];

int main(void)
{
  int i,j,k,q,l,m,best;
  int R[3];
  int dir[2];
  n=1;
  while(n--)
  {
    int ab,bc,ca;
    scanf("%d %d %d",&amp;ab,&amp;bc,&amp;ca);
    D[0]=ab-ca;
    D[1]=bc-ab;
    D[2]=ca-bc;

    lsum=ssum=0;

    for (i=0;i&lt;3;i++)
    {
      lgsum[i]=smsum[i]=0;
      for (j=0;j&lt;6;j++)
      {
        scanf("%d",&amp;C[i][j]);
        lgsum[i]+=(j&lt;4)*C[i][j]*E[j];
        smsum[i]+=(j&gt;3)*C[i][j]*E[j];
      }
      lsum+=lgsum[i];
      ssum+=smsum[i];
    }

    if (lgsum[0]+smsum[0]&lt;D[0] || lgsum[1]+smsum[1]&lt;D[1] || lgsum[2]+smsum[2]&lt;D[2])
      printf("impossible\n");
    else
    {
      for (q=0;q&lt;2;q++)
        for (j=0;j&lt;(q?ssum+1:(lsum/10)+1);j++)
          for (k=0;k&lt;(q?ssum+1:(lsum/10)+1)-j;k++)
            Mx[q][0][j][k]=MAXM;
      Mx[0][0][lgsum[0]/10][lgsum[1]/10]=0;
      Mx[1][0][smsum[0]][smsum[1]]=0;
      dir[0]=dir[1]=0;

      D[0]=lgsum[0]+smsum[0]-D[0];
      D[1]=lgsum[1]+smsum[1]-D[1];

      for (i=0;i&lt;6;i++)
      {
        int q=i&gt;3;
        int which=q?9-i:i;
        int who;

        for (j=0;j&lt;(q?ssum+1:(lsum/10)+1);j++)
          for (k=0;k&lt;(q?ssum+1-j:(lsum/10)+1-j);k++)
            Mx[q][1-dir[q]][j][k]=MAXM;

          for (j=0;j&lt;(q?ssum+1:(lsum/10)+1);j++)
            for (k=0;k&lt;(q?ssum+1-j:(lsum/10)+1-j);k++)
              if (Mx[q][dir[q]][j][k]&lt;MAXM)
                for (who=0;who&lt;3;who++)
                {
                  for (l=0;l&lt;(C[who][which])+1;l++) // one of them (who) gives to the two others
                  {
                    R[0]=j;R[1]=k;
                    if (who==0) {R[0]-=l*Z[which]; R[1]+=l*Z[which]; if (q &amp;&amp; ((R[1]-D[1])%E[which-1])!=0) continue;}
                    if (who==1) {R[1]-=l*Z[which]; if (q &amp;&amp; ((R[0]-D[0]+R[1]-D[1])%E[which-1])!=0) continue;}
                    if (who==2) {R[0]+=l*Z[which]; if (q &amp;&amp; ((R[0]-D[0])%E[which-1])!=0) continue;}

                    for (m=0;m&lt;(C[who][which])+1-l ;m++)
                    {
                      if (Mx[q][1-dir[q]][R[0]][R[1]]&gt;m+l+Mx[q][dir[q]][j][k])
                        Mx[q][1-dir[q]][R[0]][R[1]]=m+l+Mx[q][dir[q]][j][k];

                      if (who==0) R[0]-=Z[which];
                      if (who==1) {R[1]-=Z[which];R[0]+=Z[which];}
                      if (who==2) R[1]+=Z[which];

                    }
                  }

                  for (l=0;l&lt;(C[(who+1) %3][which])+1;l++) // one of them (who) gets from the two others
                    {
                      R[0]=j;R[1]=k;
                      if (who==0) {R[0]+=l*Z[which]; R[1]-=l*Z[which]; if (q &amp;&amp; ((R[1]-D[1])%E[which-1])!=0) continue;}
                      if (who==1) {R[1]+=l*Z[which]; if (q &amp;&amp; ((R[0]-D[0]+R[1]-D[1])%E[which-1])!=0) continue;}
                      if (who==2) {R[0]-=l*Z[which]; if (q &amp;&amp; ((R[0]-D[0])%E[which-1])!=0) continue;}
                      for (m=0;m&lt;(C[(who+2) %3][which])+1;m++)
                      {
                        if (Mx[q][1-dir[q]][R[0]][R[1]]&gt;m+l+Mx[q][dir[q]][j][k])
                          Mx[q][1-dir[q]][R[0]][R[1]]=m+l+Mx[q][dir[q]][j][k];
                        R[who]+=Z[which];
                        R[(who+2) %3]-=Z[which];
                      }
                    }
                }
        dir[q]=1-dir[q];
      }

      best=MAXM;

      for (j=D[0]%10;j&lt;ssum+1;j+=10) // Find best by meet-in-the-middle
        for (k=D[1]%10;k&lt;ssum+1-j;k+=10)
          if (D[0]-j&gt;=0 &amp;&amp; D[1]-k&gt;=0 &amp;&amp; D[0]+D[1]-j-k&lt;lsum+1)
            if (Mx[0][dir[0]][(D[0]-j)/10][(D[1]-k)/10]+Mx[1][dir[1]][j][k]&lt;best)
              best=Mx[0][dir[0]][(D[0]-j)/10][(D[1]-k)/10]+Mx[1][dir[1]][j][k];
      if (best&lt;MAXM)
        printf("%d\n", best);
      else
        printf("impossible\n");
    }
  }
  return 0;
}
<pre><h2>Problem1022</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1;
void Win(){cout&lt;&lt;"John"&lt;&lt;endl;}
void Lose(){cout&lt;&lt;"Brother"&lt;&lt;endl;}
void Put(bool d){d?Win():Lose();}
void solve()
{
    int n,cnt=0,x,a=0;
    cin&gt;&gt;n;
    rep(i,n)cin&gt;&gt;x,a^=x,cnt+=x==1;
    if(cnt==n)Put(!(cnt&amp;1));
    else Put(a);
}
int main()
{
    //freopen("in","r",stdin);
    int t;cin&gt;&gt;t;while(t--)solve();
}
<pre><h2>Problem1023</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=50000+10;
using namespace std;
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator it;
int n;
void Ins_Edge(int s,int t)
{
    E[s].pb(t);E[t].pb(s);
}
void Clear_List()
{
    rep(i,n)E[i].clear();
}
bool Input_Data()
{
    int m,Last,now,Len;
    if(scanf("%d%d",&amp;n,&amp;m)!=2)return false;
    Clear_List();
    rep(i,m)
    {
        scanf("%d",&amp;Len);Last=-1;
        rep(j,Len)
        {
            scanf("%d",&amp;now);now--;
            if(Last&gt;=0)Ins_Edge(Last,now);
            Last=now;
        }
    }
    return true;
}
int phi[maxn],Father[maxn];
int color[maxn]={},Ans=0;
int MaxLen[maxn];
inline void RelaxAns(int Ret)
{
    if(Ret&gt;Ans)Ans=Ret;
}
inline void RelaxMax(int v,int Len)
{
    RelaxAns(MaxLen[v]+Len);
    MaxLen[v]=max(MaxLen[v],Len);
}
vector&lt;int&gt; cyc[maxn];
void Doit_Cycle(int v)
{
    vector&lt;int&gt;&amp;A=cyc[v];A.pb(v);
    static int Q[maxn*2],h,t;
    static int a[maxn];
    int L=A.size();
    int MaxL=0;
    rep(i,L)
    {
        if(i!=L-1)
            a[i]=MaxLen[A[i]],
            MaxL=max(MaxL,a[i]+min(i+1,L-1-i));
        else
            a[i]=0;
    }
    h=t=0;
    #define val(i) (a[i%L]-i)
    for(int i=0;i&lt;2*L;i++)
    {
        while(h&lt;t&amp;&amp;i-Q[h]&gt;L/2)h++;
        if(h&lt;t)RelaxAns(val(Q[h])+a[i%L]+i);
        Q[t++]=i;
        while(h+1&lt;t&amp;&amp;val(Q[t-2])&lt;=val(Q[t-1]))Q[t-2]=Q[t-1],t--;
    }
    A.clear();
    RelaxMax(v,MaxL);
}
struct State
{
    int v,st;
    it e;
    State(int _v,it _e):
        v(_v),e(_e),st(-1){}
};
/*
void Dfs(int v)
{
    static stack&lt;State&gt; S;
    S.push()
    color[v]=1;
    tr(e,E[v])
    {
        int u=*e;if(u==Father[v])continue;
        if(color[u]==0)
        {
            Father[u]=v;
            Dfs(u);
            if(phi[u]==-1)
            {
                RelaxMax(v,MaxLen[u]+1);
            }
            else if(phi[u]==v)
            {
                Doit_Cycle(v);
            }
            else
            {
                phi[v]=phi[u];
            }
        }
        else if(color[u]==1)
        {
            phi[v]=u;
        }
    }
    if(phi[v]&gt;=0)
        cyc[phi[v]].pb(v);
    color[v]=2;
}
*/
void Dfs(int v)
{
    static stack&lt;State&gt; S;
    S.push(State(v,E[v].begin()));
    while(S.size())
    {
        State&amp;now=S.top();
        int v=now.v;it&amp;e=now.e;
        if(e==E[v].end())
        {
            if(phi[v]&gt;=0)
                cyc[phi[v]].pb(v);
            color[v]=2;
            S.pop();
            continue;
        }
        if(e==E[v].begin())
        {
            color[v]=1;
        }
        int u=*e;
        if(u==Father[v])
        {
            e++;continue;
        }
        if(now.st==-1)
        {
            if(color[u]==0)
            {
                Father[u]=v;
                State next(u,E[u].begin());
                S.push(next);
                now.st=0;
                continue;
            }
            else if(color[u]==1)
            {
                phi[v]=u;
                e++;now.st=-1;
                continue;
            }
            e++;now.st=-1;continue;
        }
        if(now.st==0)
        {
            if(phi[u]==-1)
            {
                RelaxMax(v,MaxLen[u]+1);
            }
            else if(phi[u]==v)
            {
                Doit_Cycle(v);
            }
            else
            {
                phi[v]=phi[u];
            }
            e++;
            now.st=-1;
        }
    }
}
int main()
{
    //freopen("in","r",stdin);
    while(Input_Data())
    {
        memset(phi,-1,sizeof phi);
        Father[0]=-1;Dfs(0);
        cout&lt;&lt;Ans&lt;&lt;endl;
    }
}
<pre><h2>Problem1024</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
double dfs(double x,double y,int c)
{
    if(x&gt;y)swap(x,y);
    if(c==1)return y/x;double ret=inf,r=1.0/c;
    for(int i=1;i&lt;c;i++)
    {
        ret&lt;?=max(dfs(x*r*i,y,i),dfs(x-x*r*i,y,c-i));
        ret&lt;?=max(dfs(x,y*r*i,i),dfs(x,y-y*r*i,c-i));
    }
    return ret;
}
int main()
{
    //freopen("in","r",stdin);
    double x,y;int n;
    scanf("%lf %lf %d",&amp;x,&amp;y,&amp;n);
    printf("%0.6f\n",dfs(x,y,n));
}


<pre><h2>Problem1024</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
using namespace std;
double dfs(double x,double y,int c)
{
    if(x&gt;y)swap(x,y);
    if(c==1)return y/x;double ret=1e20,r=1.0/c;
    for(int i=1;i&lt;c;i++)
        ret&lt;?=max(dfs(x*r*i,y,i),dfs(x-x*r*i,y,c-i)),
        ret&lt;?=max(dfs(x,y*r*i,i),dfs(x,y-y*r*i,c-i));
    return ret;
}
int main()
{
    double x,y;int n;
    scanf("%lf %lf %d",&amp;x,&amp;y,&amp;n);
    printf("%0.6f\n",dfs(x,y,n));
}


<pre><h2>Problem1025</h2><pre>#include&lt;iostream&gt;
using namespace std;
const int maxn=1000+100;
bool IsPrime(int p)
{
    if(p==2) return true;
    if(p%2==0) return false;
    for(int x=3;x*x&lt;=p;x+=2)
        if(p%x==0) return false;
    return true;
}
int Ps[maxn],cnt=0,n;
void GetPrime()
{
    for(int x=2;x&lt;=n;x++)
        if(IsPrime(x))
            Ps[cnt++]=x;
}
typedef long long ll;
ll F[maxn][maxn];
bool s[maxn][maxn]={0};
ll dfs(int pos,int N)
{
    if(pos==cnt&amp;&amp;N&gt;=0) return 1;
    ll&amp;ans=F[pos][N];
    if(s[pos][N]) return ans;
    ans=0;s[pos][N]=true;
    for(int x=Ps[pos];x&lt;=N;x*=Ps[pos])
    {
        ans+=dfs(pos+1,N-x);
    }
    ans+=dfs(pos+1,N);
    return ans;
}
int main()
{
    cin&gt;&gt;n;GetPrime();
    cout&lt;&lt;dfs(0,n)&lt;&lt;endl;
}
<pre><h2>Problem1026</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxd=12;
using namespace std;
typedef long long ll;
ll Count[maxd][10]={},C;
int N[maxd],n;
void PreDo()
{
    rep(j,10)Count[1][j]=1;
    for(int i=2;i&lt;maxd;i++)
    {
        rep(j,10)
        {
            Count[i][j]=0;
            rep(k,10)if(abs(k-j)&gt;=2)Count[i][j]+=Count[i-1][k];
        }
    }
}
void Dfs(int p,int l)
{
    int t=N[p];
    if(p==0)
    {
        rep(j,t+1)if(abs(j-l)&gt;=2)C++;
        return;
    }
    rep(i,t)
    {
        if(abs(i-l)&gt;=2)
        {
            if(p==n-1&amp;&amp;i==0)
            {
                rep(j,p)rep(k,9)C+=Count[j+1][k+1];
            }
            else
            {
                C+=Count[p+1][i];
            }
        }
    }
    if(abs(t-l)&gt;=2)Dfs(p-1,t);
}
ll Cal(ll A)
{
    if(!A)return 0;
    for(n=0;A;A/=10,n++)N[n]=A%10;
    C=0;Dfs(n-1,20);
    return C;
}
int main()
{
    //freopen("in","r",stdin);
    PreDo();
    ll a,b;cin&gt;&gt;a&gt;&gt;b;
    cout&lt;&lt;Cal(b)-Cal(a-1)&lt;&lt;endl;
}


<pre><h2>Problem1027</h2><pre>/**************************************************************
    Problem: 1027
    User: nimendongde
    Language: C++
    Result: Accepted
    Time:123 ms
    Memory:484 kb
****************************************************************/
 
/*
 * [JSOI2007]合金.cpp
 *
 *  Created on: 2011-3-14
 *      Author: user
 */
 
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
 
const int MAX_N_MATERIAL = 500 + 10;
const int MAX_N_ORDER = 500 + 10;
 
const double EPS = 1e-8;
inline int sign(double a) {
    return a &lt; -EPS ? -1 : a &gt; EPS;
}
 
struct Point {
    double x, y;
    Point() {
    }
    Point(double _x, double _y) :
        x(_x), y(_y) {
    }
    Point operator+(const Point&amp;p) const {
        return Point(x + p.x, y + p.y);
    }
    Point operator-(const Point&amp;p) const {
        return Point(x - p.x, y - p.y);
    }
    Point operator*(double d) const {
        return Point(x * d, y * d);
    }
    Point operator/(double d) const {
        return Point(x / d, y / d);
    }
    double det(const Point&amp;p) const {
        return x * p.y - y * p.x;
    }
    double dot(const Point&amp;p) const {
        return x * p.x + y * p.y;
    }
    Point rot90() const {
        return Point(-y, x);
    }
    void read() {
        scanf("%lf%lf", &amp;x, &amp;y);
    }
    void write() const {
        printf("%lf %lf", x, y);
    }
 
    bool operator==(const Point&amp;p) {
        return sign(x - p.x) == 0 &amp;&amp; sign(y - p.y) == 0;
    }
};
 
#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))
#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))
 
Point isSS(Point p1, Point p2, Point q1, Point q2) {
    double a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);
    return (p1 * a2 + p2 * a1) / (a1 + a2);
}
 
Point materials[MAX_N_MATERIAL];
int nMaterials;
 
Point orders[MAX_N_ORDER];
int nOrders;
 
void inputData() {
    scanf("%d%d", &amp;nMaterials, &amp;nOrders);
    for (int i = 0; i &lt; nMaterials; ++i) {
        double tmp;
        materials[i].read();
        scanf("%lf", &amp;tmp);
    }
    for (int i = 0; i &lt; nOrders; ++i) {
        double tmp;
        orders[i].read();
        scanf("%lf", &amp;tmp);
    }
}
 
bool graph[MAX_N_MATERIAL][MAX_N_MATERIAL];
 
bool inMiddle(double a, double m, double b) {
    return sign(a - m) == 0 || sign(b - m) == 0 || (a &lt; m) != (b &lt; m);
}
 
bool inMiddle(const Point&amp;a, const Point&amp;m, const Point&amp;b) {
    return inMiddle(a.x, m.x, b.x) &amp;&amp; inMiddle(a.y, m.y, b.y);
}
 
void buildGraph() {
    for (int i = 0; i &lt; nMaterials; ++i) {
        for (int j = 0; j &lt; i; ++j) {
            bool ok = true;
 
            int dir = 0;
            for (int k = 0; k &lt; nOrders; ++k) {
                int ret = crossOp(materials[i],materials[j],orders[k]);
                if (!ret)
                    continue;
                if (dir != 0 &amp;&amp; ret != dir) {
                    ok = false;
                    break;
                }
                dir = ret;
            }
            if (!ok)
                continue;
 
            if (dir == 0) {
                for (int k = 0; k &lt; nOrders; ++k) {
                    if (!inMiddle(materials[i], orders[k], materials[j])) {
                        ok = false;
                    }
                }
            }
 
            if (ok) {
                if (dir &gt;= 0)
                    graph[i][j] = true;
                if (dir &lt;= 0)
                    graph[j][i] = true;
            }
        }
    }
}
 
void work() {
    for (int me = 0; me &lt; nMaterials; ++me) {
        bool ok = true;
        for (int it = 0; it &lt; nOrders; ++it) {
            if (materials[me] == orders[it])
                ;
            else {
                ok = false;
                break;
            }
        }
        if (ok) {
            puts("1");
            return;
        }
    }
 
    static int que[MAX_N_MATERIAL * MAX_N_MATERIAL * 4], qh, qt;
    int dist[MAX_N_MATERIAL];
 
    int ans = INT_MAX / 2;
    for (int start = 0; start &lt; nMaterials; ++start) {
        qh = qt = 0;
        fill(dist, dist + nMaterials, INT_MAX / 2);
        for (int v = 0; v &lt; nMaterials; ++v) {
            if (graph[start][v]) {
                dist[v] = 1;
                que[qt++] = v;
            }
        }
 
        while (qh &lt; qt) {
            int u = que[qh++];
            for (int v = 0; v &lt; nMaterials; ++v) {
                if (graph[u][v]) {
                    if (dist[v] &gt; dist[u] + 1) {
                        dist[v] = dist[u] + 1;
                        que[qt++] = v;
                    }
                }
            }
        }
 
        ans = min(ans, dist[start]);
    }
 
    if (ans == INT_MAX / 2)
        ans = -1;
 
    printf("%d\n", ans);
}
 
int main() {
    inputData();
    buildGraph();
    work();
}<pre><h2>Problem1028</h2><pre>#include &lt;cstdio&gt;
#include &lt;map&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=400;
using namespace std;
typedef unsigned long long ull;
int A[maxn]={},B[maxn]={},n,m;
bool Check()
{
    rep(cur,n)
        if(A[cur]&gt;=2)
        {
            A[cur]-=2;
            rep(i,n)B[i]=A[i];
            bool ok=true;
            for(int i=0;i&lt;n;)
            {
                B[i]%=3;
                if(!B[i])i++;
                else
                {
                    if(i+2&lt;n)
                    {
                        if(B[i+1]&lt;B[i]){ok=false;break;}
                        B[i+1]-=B[i];
                        if(B[i+2]&lt;B[i]){ok=false;break;}
                        B[i+2]-=B[i];
                        i++;
                    }
                    else
                    {
                        ok=false;
                        break;
                    }
                }
            }
            A[cur]+=2;
            if(ok)return true;
        }
    return false;
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    cin&gt;&gt;n&gt;&gt;m;int x;
    rep(i,m*3+1)
    {
        scanf("%d",&amp;x);
        A[--x]++;
    }
    int s=0;
    rep(i,n)
    {
        A[i]++;
        if(Check())
        {
            s++;
            printf("%d ",i+1);
        }
        A[i]--;
    }
    if(!s)puts("NO");
}
<pre><h2>Problem1029</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=150000;
using namespace std;
struct Repair
{
    int Dead,Time;
    bool operator&lt;(const Repair&amp;p)const
    {
        return Dead&lt;p.Dead;
    }
};
Repair R[maxn];
priority_queue&lt;int&gt; PQ;
int N;
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;N;rep(i,N)scanf("%d%d",&amp;R[i].Time,&amp;R[i].Dead);
    sort(R,R+N);int total=0,ans=0;
    rep(i,N)
    {
        if(R[i].Time+total&lt;=R[i].Dead)
            PQ.push(R[i].Time),total+=R[i].Time,ans++;
        else
        {
            if(R[i].Time&lt;PQ.top())
            {
                total-=PQ.top();PQ.pop();
                PQ.push(R[i].Time);total+=R[i].Time;
            }
        }
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


<pre><h2>Problem1030</h2><pre>/*
 * [JSOI2007]文本生成器.cpp
 *
 *  Created on: 2011-3-15
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_WORD = 60 + 1;
const int MAX_L_WORD = 100 + 1;
const int MAX_L_ARTICLE = 100 + 1;
const int MAX_N_ALPHABET = 26;

struct Trie {
	Trie*ch[MAX_N_ALPHABET];
	Trie*jump[MAX_N_ALPHABET];
	Trie*sufLink;
	bool hasWord;
	int id;
	static int numId;
	Trie() {
		id = numId++;
		memset(ch, 0, sizeof ch);
		sufLink = 0;
		hasWord = false;
	}
	Trie*getCh(char what) {
		int which = what - 'A';
		if (ch[which] != 0)
			return ch[which];
		ch[which] = new Trie;
		return ch[which];
	}
};

int Trie::numId = 0;
Trie*root;

int articleLen;
int nWords;

void inputData() {
	root = new Trie;
	cin &gt;&gt; nWords &gt;&gt; articleLen;
	for (int i = 0; i &lt; nWords; ++i) {
		string s;
		cin &gt;&gt; s;
		Trie*t = root;
		for (int j = 0; j &lt; s.length(); ++j) {
			t = t-&gt;getCh(s[j]);
		}
		t-&gt;hasWord = true;
	}
//	cout &lt;&lt; Trie::numId &lt;&lt; endl;
}

const int MAX_N_NODES = MAX_L_WORD * MAX_N_WORD + 10;
Trie*que[MAX_N_NODES];
int qh, qt;

void build() {
	qh = qt = 0;
	que[qt++] = root;
	for (; qh &lt; qt;) {
		Trie*u = que[qh++];
		for (int what = 0; what &lt; MAX_N_ALPHABET; ++what) {
			if (u-&gt;ch[what] != 0) {
				Trie*v = u-&gt;ch[what];
				Trie*p = u-&gt;sufLink;
				while (p != 0 &amp;&amp; p-&gt;ch[what] == 0)
					p = p-&gt;sufLink;
				if (p == 0)
					v-&gt;sufLink = root;
				else
					v-&gt;sufLink = p-&gt;ch[what];
				v-&gt;hasWord |= v-&gt;sufLink-&gt;hasWord;
				que[qt++] = v;
			}
		}
	}

	for (int i = 0; i &lt; qt; ++i) {
		Trie*u = que[i];
		for (int what = 0; what &lt; MAX_N_ALPHABET; ++what) {
			Trie*t = u;
			while (t != 0 &amp;&amp; t-&gt;ch[what] == 0)
				t = t-&gt;sufLink;
			if (t == 0)
				u-&gt;jump[what] = root;
			else
				u-&gt;jump[what] = t-&gt;ch[what];
		}
	}
}

const int MOD = 10007;
int memo[MAX_N_NODES][MAX_L_ARTICLE][2];//state,len,hasWord?

int rec(Trie*u, int len, bool hasWord) {
	if (len == 0) {
		return hasWord ? 1 : 0;
	}
	int&amp;ret = memo[u-&gt;id][len][hasWord];
	if (ret != -1)
		return ret;
	ret = 0;
	for (int what = 0; what &lt; MAX_N_ALPHABET; ++what) {
		Trie*v = u-&gt;jump[what];
		ret += rec(v, len - 1, hasWord | v-&gt;hasWord);
	}
	ret %= MOD;
	return ret;
}

void doDp() {
	memset(memo, -1, sizeof memo);
	printf("%d\n", rec(root, articleLen, false));
}

void solve() {
	inputData();
	build();
	doDp();
}

int main() {
	solve();
}
<pre><h2>Problem1031</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=100000*2+1;
int n,m,sa[maxn],ta[maxn],tb[maxn],*x=ta,*y=tb;
char C[maxn];
bool cmp(int i,int j,int l)
{
    return y[i]==y[j]&amp;&amp;y[i+l]==y[j+l];
}
void Sort()
{
    static int w[maxn];
    rep(i,m)w[i]=0;rep(i,n)w[x[y[i]]]++;
    rep(i,m-1)w[i+1]+=w[i];
    for(int i=n-1;i&gt;=0;i--)sa[--w[x[y[i]]]]=y[i];
}
void Da()
{
    int i,j,p;
    rep(i,n)x[i]=C[i],y[i]=i;Sort();
    for(p=1,j=1;p&lt;n;m=p,j*=2)
    {
        for(p=0,i=n-j;i&lt;n;i++)y[p++]=i;
        rep(i,n)if(sa[i]&gt;=j)y[p++]=sa[i]-j;Sort();
        for(swap(x,y),i=1,p=1,x[sa[0]]=0;i&lt;n;i++)
            x[sa[i]]=cmp(sa[i-1],sa[i],j)?p-1:p++;
    }
}
int main()
{
    //freopen("in","r",stdin);
    gets(C);n=strlen(C);
    rep(i,n)C[n+i]=C[i];n&lt;&lt;=1;C[n++]=0;m=256;
    Da();int s=n/2;
    rep(i,n)if(sa[i]&lt;s)printf("%c",C[s+sa[i]-1]);
    printf("\n");
}
<pre><h2>Problem1032</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define N 555
#define inf 1000000007
int n,a[N],ri[N],le[N],f[N][N];bool v[N][N];
int ask(int l,int r)
{
        if(l==r)return 2;
        if(l==r-1)return a[l]==a[r]?1:4;
        if(v[l][r])return f[l][r];
        v[l][r]=1;int&amp;s=f[l][r];s=inf;
        if(a[l]==a[r])
        {
                if(ri[l]&gt;=r)return s=1;
                s=min(s,ask(ri[l]+1,le[r]-1)+(ri[l]==l&amp;&amp;le[r]==r));
        }
        for(int i=l;i&lt;r;i++)s=min(s,ask(l,i)+ask(i+1,r));
        return s;
}
int main()
{
        scanf("%d",&amp;n);for(int i=0;i&lt;n;i++)scanf("%d",a+i);
        le[0]=0;for(int i=1;i&lt;n;i++)le[i]=a[i]==a[i-1]?le[i-1]:i;
        ri[n-1]=n-1;for(int i=n-2;i&gt;=0;i--)ri[i]=a[i]==a[i+1]?ri[i+1]:i;
        printf("%d\n",ask(0,n-1));
        return 0;
}<pre><h2>Problem1034</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxn=100000+10,maxs=1000;
using namespace std;
int n,A[maxn],B[maxn],C[maxn],m;
inline void Add(int l,int r,int x)
{
    if(r&lt;0||l&gt;r)return;if(l&lt;0)l=0;
    C[l]+=x;C[r+1]-=x;
}
int Solve(int A[maxn],int B[maxn])
{
    int ans=0;
    memset(C,0,sizeof C);
    rep(i,n)
    {
        int l=lower_bound(B,B+n,A[i])-B;
        int r=upper_bound(B,B+n,A[i])-B;
        Add(i-l+1,i,2);
        Add(i-r+1,i-l,1);
    }
    int ret=0;
    rep(i,n)
    {
        ret+=C[i];
        ans=max(ans,ret);
    }
    return ans;
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);
    rep(i,n)scanf("%d",A+i);
    rep(i,n)scanf("%d",B+i);
    sort(A,A+n);sort(B,B+n);
    cout&lt;&lt;Solve(A,B)&lt;&lt;" "&lt;&lt;n*2-Solve(B,A)&lt;&lt;endl;
}


<pre><h2>Problem1034</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxn=100000+10,maxs=1000;
using namespace std;
int n,A[maxn],B[maxn],C[maxn],m;
inline void Add(int l,int r,int x)
{
    if(r&lt;0||l&gt;r)return;if(l&lt;0)l=0;
    C[l]+=x;C[r+1]-=x;
}
int Solve(int A[maxn],int B[maxn])
{
    int ans=0;
    memset(C,0,sizeof C);
    int l=0,r=0;B[n]=inf;
    rep(i,n)
    {
        while(B[l]&lt;A[i])l++;
        while(B[r]&lt;=A[i])r++;
        Add(i-l+1,i,2);
        Add(i-r+1,i-l,1);
    }
    int ret=0;
    rep(i,n)
    {
        ret+=C[i];
        ans=max(ans,ret);
    }
    return ans;
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);
    rep(i,n)scanf("%d",A+i);
    rep(i,n)scanf("%d",B+i);
    sort(A,A+n);sort(B,B+n);
    cout&lt;&lt;Solve(A,B)&lt;&lt;" "&lt;&lt;n*2-Solve(B,A)&lt;&lt;endl;
}


<pre><h2>Problem1035</h2><pre>/*
 *  [ZJOI2008]Risk.cpp
 *
 *  Created on: 2011-5-21
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;cassert&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
struct Point;
struct Polygon;

struct Edge {
	Polygon*poly;
	Point*src, *dst;
	double alpha;
	Edge*rev, *prev, *next;
	Edge(Point*_src, Point*_dst);
	void write();
};

struct Point {
	vector&lt;Edge*&gt; outgo;
	int x, y;
	double alpha;
	Point(int _x, int _y) :
		x(_x), y(_y) {
	}
	Point() {
	}
	void doSort();
	void write() {
		cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")";
	}
};

void Edge::write() {
	src-&gt;write();
	cout &lt;&lt; "-&gt;";
	dst-&gt;write();
}

inline int det(Point*p1, Point*p2) {
	return p1-&gt;x * p2-&gt;y - p2-&gt;x * p1-&gt;y;
}

inline int cross(Point*p1, Point*p2, Point*p3) {
	return (p2-&gt;x - p1-&gt;x) * (p3-&gt;y - p1-&gt;y) - (p3-&gt;x - p1-&gt;x)
			* (p2-&gt;y - p1-&gt;y);
}

inline int sign(int x) {
	return x &lt; 0 ? -1 : x &gt; 0;
}

inline int crossOp(Point*p1, Point*p2, Point*p3) {
	return sign(cross(p1, p2, p3));
}

inline bool isSS(Point*p1, Point*p2, Point*q1, Point*q2) {
	return crossOp(p1, p2, q1) * crossOp(p1, p2, q2) &lt; 0 &amp;&amp; crossOp(q1, q2, p1)
			* crossOp(q1, q2, p2) &lt; 0;
}

inline int dot(Point*a, Point*b) {
	return a-&gt;x * b-&gt;x + a-&gt;y * b-&gt;y;
}

Point memo[100];
int memoTop = 0;

Point*sub(Point*a, Point*b) {
	Point*ret = memo + memoTop++;
	ret-&gt;x = a-&gt;x - b-&gt;x;
	ret-&gt;y = a-&gt;y - b-&gt;y;
	return ret;
}

bool inSP(Point*p1, Point*p2, Point*q) {
	if (crossOp(p1, p2, q) != 0)
		return false;
	memoTop = 0;
	return dot(sub(q, p1), sub(q, p2)) &lt;= 0;
}

struct Polygon;

vector&lt;Polygon*&gt; polys;

struct Polygon {
	set&lt;int&gt; ans;
	int idx;
	vector&lt;Edge*&gt; edges;
	Polygon() {
		idx = -1;
		polys.push_back(this);
	}
	bool isInside(Point*p) {
		static Point*far = new Point(23413, 32145);
		int isCount = 0;
		foreach(iter,edges) {
			Edge*e = *iter;
			isCount += isSS(e-&gt;src, e-&gt;dst, p, far);
		}
		return isCount % 2 == 1;
	}
	bool contain(Polygon*p) {
		foreach(iter,p-&gt;edges) {
			Edge*e = *iter;
			Point*q = e-&gt;src;
			bool check = false;
			foreach(iter2,edges) {
				Edge*e2 = *iter2;
				if (inSP(e2-&gt;src, e2-&gt;dst, q)) {
					check = true;
					break;
				}
			}
			if (check)
				continue;
			if (!isInside(q))
				return false;
		}
		return true;
	}
	int area;
	void calcArea() {
		area = 0;
		foreach(iter,edges) {
			Edge*e = *iter;
			area += det(e-&gt;src, e-&gt;dst);
		}
	}

	void debug() {
		cout &lt;&lt; edges.size() &lt;&lt; ":" &lt;&lt; endl;
		foreach(iter,edges) {
			(*iter)-&gt;src-&gt;write();
		}
		cout &lt;&lt; endl;
	}
};

vector&lt;Edge*&gt; edges;

Edge::Edge(Point*_src, Point*_dst) :
	src(_src), dst(_dst), poly(0) {
	alpha = atan2(dst-&gt;y - src-&gt;y, dst-&gt;x - src-&gt;x);
	edges.push_back(this);
}

bool cmpEdgePtr(Edge*a, Edge*b) {
	return a-&gt;alpha &lt; b-&gt;alpha;
}

void Point::doSort() {
	sort(outgo.begin(), outgo.end(), cmpEdgePtr);
	int n = outgo.size();
	for (int i = 0; i &lt; n; ++i) {
		int prev = i == 0 ? n - 1 : i - 1;
		int next = i + 1 == n ? 0 : i + 1;
		outgo[i]-&gt;prev = outgo[prev];
		outgo[i]-&gt;next = outgo[next];
	}
}

bool cmpPointPtr(Point*a, Point*b) {
	if (a-&gt;x != b-&gt;x)
		return a-&gt;x &lt; b-&gt;x;
	return a-&gt;y &lt; b-&gt;y;
}

struct Comparator {
	bool operator()(Point*a, Point*b) const {
		return cmpPointPtr(a, b);
	}
};

bool isEqual(Point*a, Point*b) {
	return a-&gt;x == b-&gt;x &amp;&amp; a-&gt;y == b-&gt;y;
}

map&lt;Point*, Point*, Comparator&gt; pointToId;

Point*getPoint(Point*p) {
	if (pointToId.count(p) &gt; 0) {
		delete p;
		return pointToId[p];
	}
	return pointToId[p] = p;
}

vector&lt;Point*&gt; armies;
int nNations, nEdges;

Point*readPoint() {
	int x, y;
	scanf("%d%d", &amp;x, &amp;y);
	return new Point(x, y);
}

void buildEdge(Point*p, Point*q) {
	Edge*pq = new Edge(p, q);
	Edge*qp = new Edge(q, p);
	pq-&gt;rev = qp;
	qp-&gt;rev = pq;
	p-&gt;outgo.push_back(pq);
	q-&gt;outgo.push_back(qp);
}

void readInput() {
	scanf("%d%d", &amp;nNations, &amp;nEdges);
	for (int i = 0; i &lt; nNations; ++i) {
		armies.push_back(readPoint());
	}
	for (int i = 0; i &lt; nEdges; ++i) {
		Point*p = readPoint(), *q = readPoint();
		p = getPoint(p);
		q = getPoint(q);
		buildEdge(p, q);
	}
}

bool cmpPolyPtr(Polygon*a, Polygon*b) {
	return a-&gt;area &lt; b-&gt;area;
}

void work() {
	foreach(iter,pointToId) {
		Point*p = iter-&gt;second;
		p-&gt;doSort();
	}
	foreach(iter,edges) {
		Edge*e = *iter;
		if (e-&gt;poly)
			continue;
		Polygon*poly = new Polygon;
		int cur = 0;
		//		cout &lt;&lt; "Start:" &lt;&lt; endl;
		while (e-&gt;poly == 0) {
			//			e-&gt;write();
			//			cout &lt;&lt; endl;
			e-&gt;poly = poly;
			poly-&gt;edges.push_back(e);
			e = e-&gt;rev-&gt;prev;
		}
	}

	vector&lt;Polygon*&gt; validPolys;
	foreach(iter,polys) {
		Polygon*poly = *iter;
		poly-&gt;calcArea();
		if (poly-&gt;area &gt; 0) {
			validPolys.push_back(poly);
		}
	}

	sort(validPolys.begin(), validPolys.end(), cmpPolyPtr);
	vector&lt;Polygon*&gt; byIdx(validPolys.size());
	vector&lt;bool&gt; used(armies.size(), false);
	for (int i = 0; i &lt; validPolys.size(); ++i) {
		Polygon*cur = validPolys[i];
		for (int j = 0; j &lt; armies.size(); ++j) {
			if (used[j])
				continue;
			Point*p = armies[j];
			if (cur-&gt;isInside(p)) {
				cur-&gt;idx = j;
				used[j] = true;
				break;
			}
		}
		assert(cur-&gt;idx != -1);
		byIdx[cur-&gt;idx] = cur;
	}

	for (int i = 0; i &lt; byIdx.size(); ++i) {
		Polygon*poly = byIdx[i];
		set&lt;int&gt;&amp;ans = poly-&gt;ans;
		foreach(iter,poly-&gt;edges) {
			Edge*e = *iter;
			Polygon*np = e-&gt;rev-&gt;poly;
			if (np-&gt;area &gt; 0) {
				ans.insert(np-&gt;idx);
			}
		}
		Polygon*fa = 0;
		for (int j = 0; j &lt; validPolys.size(); ++j) {
			Polygon*f = validPolys[j];
			if (f-&gt;area &gt; poly-&gt;area &amp;&amp; f-&gt;contain(poly)) {
				fa = f;
				break;
			}
		}
		if (fa != 0) {
			foreach(iter,poly-&gt;edges) {
				Edge*e = *iter;
				Polygon*np = e-&gt;rev-&gt;poly;
				if (np-&gt;area &lt; 0) {
					ans.insert(fa-&gt;idx);
					fa-&gt;ans.insert(poly-&gt;idx);
					break;
				}
			}
		}
	}

	for (int i = 0; i &lt; byIdx.size(); ++i) {
		Polygon*p = byIdx[i];
		set&lt;int&gt;&amp;ans = p-&gt;ans;
		printf("%d", ans.size());
		foreach(iter,ans) {
			printf(" %d", *iter + 1);
		}
		printf("\n");
	}
}

void solve() {
	readInput();
	work();
}

int main() {
	solve();
}
<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
vector&lt;int&gt; E[maxn];
vector&lt;int&gt; Et[maxn];
typedef vector&lt;int&gt;::iterator it;
int n,q,w[maxn],Lim,dep[maxn],Fa[maxn];
int size[maxn]={},own[maxn],Max[maxn],Sum[maxn];
void Build(int t,int f,int d)
{
    dep[t]=d;Fa[t]=f;
    if(own[t]==-1)
    {
        own[t]=t;
        size[t]++;
    }
    int tmp=own[t];
    tr(e,E[t])if(*e!=f)
    {
        if(size[tmp]&lt;Lim)
        {
            Et[t].pb(*e);
            own[*e]=tmp;
            size[tmp]++;
        }
        Build(*e,t,d+1);
    }
}
void Dfs(int t,int s,int m)
{
    s+=w[t],m=max(m,w[t]);
    Sum[t]=s;Max[t]=m;
    tr(e,Et[t])
    {
        Dfs(*e,s,m);
    }
}
void ReMark(int t)
{
    Dfs(t,0,-inf);
}
void Change(int t,int u)
{
    w[t]=u;
    ReMark(own[t]);
}
int QSum(int a,int b)
{
    int s=0;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b]||own[a]==a)
            s+=w[a],a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            s+=Sum[a],a=Fa[own[a]];
        }
    }
    return s+w[a];
}
int QMax(int a,int b)
{
    int m=-inf;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            m=max(m,w[a]),a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            m=max(m,Max[a]),a=Fa[own[a]];
        }
    }
    return max(m,w[a]);
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    scanf("%d",&amp;n);int s,t;Lim=sqrt(n)+1;
    rep(i,n-1)scanf("%d%d",&amp;s,&amp;t),--s,--t,E[s].pb(t),E[t].pb(s);
    rep(i,n)scanf("%d",w+i);
    memset(own,-1,sizeof own);
    Build(0,-1,0);
    rep(i,n)if(own[i]==i)ReMark(i);
    scanf("%d",&amp;q);
    char cmd[100];
    rep(i,q)
    {
        scanf(" ");
        scanf("%s%d%d",cmd,&amp;s,&amp;t);
        if(cmd[0]=='C')Change(s-1,t);
        else if(cmd[1]=='S')printf("%d\n",QSum(s-1,t-1));
        else printf("%d\n",QMax(s-1,t-1));
    }
}


<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
vector&lt;int&gt; E[maxn];
vector&lt;int&gt; Et[maxn];
typedef vector&lt;int&gt;::iterator it;
int n,q,w[maxn],Lim,dep[maxn],Fa[maxn];
int size[maxn]={},own[maxn],Max[maxn],Sum[maxn];
void Build(int t,int f,int d)
{
    dep[t]=d;Fa[t]=f;
    if(own[t]==-1)
    {
        own[t]=t;
        size[t]++;
    }
    int tmp=own[t];
    tr(e,E[t])if(*e!=f)
    {
        if(size[tmp]&lt;Lim)
        {
            Et[t].pb(*e);
            own[*e]=tmp;
            size[tmp]++;
        }
        Build(*e,t,d+1);
    }
}
void Dfs(int t,int s,int m)
{
    s+=w[t],m=max(m,w[t]);
    Sum[t]=s;Max[t]=m;
    tr(e,Et[t])
    {
        Dfs(*e,s,m);
    }
}
void ReMark(int t)
{
    Dfs(t,0,-inf);
}
void Change(int t,int u)
{
    w[t]=u;
    ReMark(own[t]);
}
int QSum(int a,int b)
{
    int s=0;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b]||own[a]==a)
            s+=w[a],a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            s+=Sum[a],a=Fa[own[a]];
        }
    }
    return s+w[a];
}
int QMax(int a,int b)
{
    int m=-inf;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            m=max(m,w[a]),a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            m=max(m,Max[a]),a=Fa[own[a]];
        }
    }
    return max(m,w[a]);
}
int main()
{
    scanf("%d",&amp;n);int s,t;Lim=sqrt(n)*1.2+1;
    rep(i,n-1)scanf("%d%d",&amp;s,&amp;t),--s,--t,E[s].pb(t),E[t].pb(s);
    rep(i,n)scanf("%d",w+i);
    memset(own,-1,sizeof own);
    Build(0,-1,0);
    rep(i,n)if(own[i]==i)ReMark(i);
    scanf("%d",&amp;q);
    char cmd[100];
    rep(i,q)
    {
        scanf(" ");
        scanf("%s%d%d",cmd,&amp;s,&amp;t);
        if(cmd[0]=='C')Change(s-1,t);
        else if(cmd[1]=='S')printf("%d\n",QSum(s-1,t-1));
        else printf("%d\n",QMax(s-1,t-1));
    }
}
<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
vector&lt;int&gt; E[maxn];
vector&lt;int&gt; Et[maxn];
typedef vector&lt;int&gt;::iterator it;
int n,q,w[maxn],Lim,dep[maxn],Fa[maxn];
int size[maxn]={},own[maxn],Max[maxn],Sum[maxn];
void Build(int t,int f,int d)
{
    dep[t]=d;Fa[t]=f;
    if(own[t]==-1)
    {
        own[t]=t;
        size[t]++;
    }
    int tmp=own[t];
    tr(e,E[t])if(*e!=f)
    {
        if(size[tmp]&lt;Lim)
        {
            Et[t].pb(*e);
            own[*e]=tmp;
            size[tmp]++;
        }
        Build(*e,t,d+1);
    }
}
void Dfs(int t,int s,int m)
{
    s+=w[t],m=max(m,w[t]);
    Sum[t]=s;Max[t]=m;
    tr(e,Et[t])
    {
        Dfs(*e,s,m);
    }
}
void ReMark(int t)
{
    Dfs(t,0,-inf);
}
void Change(int t,int u)
{
    w[t]=u;
    ReMark(own[t]);
}
int QSum(int a,int b)
{
    int s=0;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b]||own[a]==a)
            s+=w[a],a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            s+=Sum[a],a=Fa[own[a]];
        }
    }
    return s+w[a];
}
int QMax(int a,int b)
{
    int m=-inf;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            m=max(m,w[a]),a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            m=max(m,Max[a]),a=Fa[own[a]];
        }
    }
    return max(m,w[a]);
}
int main()
{
    scanf("%d",&amp;n);int s,t;Lim=sqrt(n)*1.5+1;
    rep(i,n-1)scanf("%d%d",&amp;s,&amp;t),--s,--t,E[s].pb(t),E[t].pb(s);
    rep(i,n)scanf("%d",w+i);
    memset(own,-1,sizeof own);
    Build(0,-1,0);
    rep(i,n)if(own[i]==i)ReMark(i);
    scanf("%d",&amp;q);
    char cmd[100];
    rep(i,q)
    {
        scanf(" ");
        scanf("%s%d%d",cmd,&amp;s,&amp;t);
        if(cmd[0]=='C')Change(s-1,t);
        else if(cmd[1]=='S')printf("%d\n",QSum(s-1,t-1));
        else printf("%d\n",QMax(s-1,t-1));
    }
}
<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
vector&lt;int&gt; E[maxn],Et[maxn];
typedef vector&lt;int&gt;::iterator it;
int n,q,w[maxn],Lim,dep[maxn],Fa[maxn];
int own[maxn],Max[maxn],Sum[maxn]={};
void Build(int t,int f,int d)
{
    dep[t]=d;Fa[t]=f;
    if(own[t]==-1)
    {
        own[t]=t;
        Sum[t]++;
    }
    int tmp=own[t];
    tr(e,E[t])if(*e!=f)
    {
        if(Sum[tmp]&lt;Lim)
        {
            Et[t].pb(*e);
            own[*e]=tmp;
            Sum[tmp]++;
        }
        Build(*e,t,d+1);
    }
}
void Dfs(int t,int s,int m)
{
    Sum[t]=s+=w[t];Max[t]=m=max(m,w[t]);
    tr(e,Et[t])Dfs(*e,s,m);
}
void Change(int t,int u)
{
    w[t]=u;
    if(t==own[t])Dfs(t,0,-inf);
    else Dfs(t,Sum[Fa[t]],Max[Fa[t]]);
}
int QSum(int a,int b)
{
    int s=0;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b]||own[a]==a)
            s+=w[a],a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            s+=Sum[a],a=Fa[own[a]];
        }
    }
    return s+w[a];
}
int QMax(int a,int b)
{
    int m=-inf;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            m=max(m,w[a]),a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            m=max(m,Max[a]),a=Fa[own[a]];
        }
    }
    return max(m,w[a]);
}
int main()
{
    scanf("%d",&amp;n);int s,t;Lim=sqrt(n)+1;
    rep(i,n-1)scanf("%d%d",&amp;s,&amp;t),--s,--t,E[s].pb(t),E[t].pb(s);
    rep(i,n)scanf("%d",w+i);
    memset(own,-1,sizeof own);
    Build(0,-1,0);
    rep(i,n)if(own[i]==i)Dfs(i,0,-inf);
    scanf("%d",&amp;q);
    char cmd[100];
    rep(i,q)
    {
        scanf(" ");
        scanf("%s%d%d",cmd,&amp;s,&amp;t);
        if(cmd[0]=='C')Change(s-1,t);
        else if(cmd[1]=='S')printf("%d\n",QSum(s-1,t-1));
        else printf("%d\n",QMax(s-1,t-1));
    }
}
<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
vector&lt;int&gt; E[maxn],Et[maxn];
typedef vector&lt;int&gt;::iterator it;
int n,q,w[maxn],Lim,dep[maxn],Fa[maxn];
int own[maxn],Max[maxn],Sum[maxn]={};
void Build(int t,int f,int d)
{
    dep[t]=d;Fa[t]=f;
    if(own[t]==-1)
    {
        own[t]=t;
        Sum[t]++;
    }
    int tmp=own[t];
    tr(e,E[t])if(*e!=f)
    {
        if(Sum[tmp]&lt;Lim)
        {
            Et[t].pb(*e);
            own[*e]=tmp;
            Sum[tmp]++;
        }
        Build(*e,t,d+1);
    }
}
void Dfs(int t,int s,int m)
{
    Sum[t]=s+=w[t];Max[t]=m=max(m,w[t]);
    tr(e,Et[t])Dfs(*e,s,m);
}
void Change(int t,int u)
{
    w[t]=u;
    if(t==own[t])Dfs(t,0,-inf);
    else Dfs(t,Sum[Fa[t]],Max[Fa[t]]);
}
int QSum(int a,int b)
{
    int s=0;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b]||own[a]==a)
            s+=w[a],a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            s+=Sum[a],a=Fa[own[a]];
        }
    }
    return s+w[a];
}
void Query(int a,int b,int&amp;s,int&amp;m)
{
    s=0;m=-inf;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            s+=w[a],m=max(m,w[a]),a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            s+=Sum[a],m=max(m,Max[a]),a=Fa[own[a]];
        }
    }
    m=max(m,w[a]);s+=w[a];
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);int s,t;Lim=sqrt(n)+1;
    rep(i,n-1)scanf("%d%d",&amp;s,&amp;t),--s,--t,E[s].pb(t),E[t].pb(s);
    rep(i,n)scanf("%d",w+i);
    memset(own,-1,sizeof own);
    Build(0,-1,0);
    rep(i,n)if(own[i]==i)Dfs(i,0,-inf);
    scanf("%d",&amp;q);
    char cmd[100];int S,M;
    rep(i,q)
    {
        scanf(" ");
        scanf("%s%d%d",cmd,&amp;s,&amp;t);
        if(cmd[0]=='C')Change(s-1,t);
        else
        {
            Query(s-1,t-1,S,M);
            if(cmd[1]=='S')printf("%d\n",S);
            else printf("%d\n",M);
        }
    }
}
<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
vector&lt;int&gt; E[maxn],Et[maxn];
typedef vector&lt;int&gt;::iterator it;
int n,q,w[maxn],Lim,dep[maxn],Fa[maxn];
int own[maxn],Max[maxn],Sum[maxn]={};
void Build(int t,int f,int d)
{
    dep[t]=d;Fa[t]=f;
    if(own[t]==-1)
    {
        own[t]=t;
        Sum[t]++;
    }
    int tmp=own[t];
    tr(e,E[t])if(*e!=f)
    {
        if(Sum[tmp]&lt;Lim)
        {
            Et[t].pb(*e);
            own[*e]=tmp;
            Sum[tmp]++;
        }
        Build(*e,t,d+1);
    }
}
void Dfs(int t,int s,int m)
{
    Sum[t]=s+=w[t];Max[t]=m=max(m,w[t]);
    tr(e,Et[t])Dfs(*e,s,m);
}
void Change(int t,int u)
{
    w[t]=u;
    if(t==own[t])Dfs(t,0,-inf);
    else Dfs(t,Sum[Fa[t]],Max[Fa[t]]);
}
void Query(int a,int b,int&amp;s,int&amp;m)
{
    s=0;m=-inf;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            s+=w[a],m=max(m,w[a]),a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            s+=Sum[a],m=max(m,Max[a]),a=Fa[own[a]];
        }
    }
    m=max(m,w[a]);s+=w[a];
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);int s,t;Lim=sqrt(n)+1;
    rep(i,n-1)scanf("%d%d",&amp;s,&amp;t),--s,--t,E[s].pb(t),E[t].pb(s);
    rep(i,n)scanf("%d",w+i);
    memset(own,-1,sizeof own);
    Build(0,-1,0);
    rep(i,n)if(own[i]==i)Dfs(i,0,-inf);
    scanf("%d",&amp;q);
    char cmd[100];int S,M;
    rep(i,q)
    {
        scanf(" ");
        scanf("%s%d%d",cmd,&amp;s,&amp;t);
        if(cmd[0]=='C')Change(s-1,t);
        else
        {
            Query(s-1,t-1,S,M);
            if(cmd[1]=='S')printf("%d\n",S);
            else printf("%d\n",M);
        }
    }
}
<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
vector&lt;int&gt; E[maxn],Et[maxn];
typedef vector&lt;int&gt;::iterator it;
int n,q,w[maxn],Lim,dep[maxn],Fa[maxn];
int own[maxn],Max[maxn],Sum[maxn]={};
void Build(int t,int f,int d)
{
    dep[t]=d;Fa[t]=f;
    if(own[t]==-1)
        own[t]=t,Sum[t]++;
    int tmp=own[t];
    tr(e,E[t])if(*e!=f)
    {
        if(Sum[tmp]&lt;Lim)
        {
            Et[t].pb(*e);
            own[*e]=tmp;
            Sum[tmp]++;
        }
        Build(*e,t,d+1);
    }
}
void Dfs(int t,int s,int m)
{
    Sum[t]=s+=w[t];Max[t]=m=max(m,w[t]);
    tr(e,Et[t])Dfs(*e,s,m);
}
void Change(int t,int u)
{
    w[t]=u;
    if(t==own[t])Dfs(t,0,-inf);
    else Dfs(t,Sum[Fa[t]],Max[Fa[t]]);
}
void Query(int a,int b,int&amp;s,int&amp;m)
{
    s=0;m=-inf;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            s+=w[a],m=max(m,w[a]),a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            s+=Sum[a],m=max(m,Max[a]),a=Fa[own[a]];
        }
    }
    m=max(m,w[a]);s+=w[a];
}
int main()
{
    scanf("%d",&amp;n);int s,t;Lim=sqrt(n)+1;
    rep(i,n-1)scanf("%d%d",&amp;s,&amp;t),--s,--t,E[s].pb(t),E[t].pb(s);
    rep(i,n)scanf("%d",w+i),own[i]=-1;
    Build(0,-1,0);
    rep(i,n)if(own[i]==i)Dfs(i,0,-inf);
    scanf("%d",&amp;q);
    char cmd[100];int S,M;
    rep(i,q)
    {
        scanf(" ");
        scanf("%s%d%d",cmd,&amp;s,&amp;t);
        if(cmd[0]=='C')Change(s-1,t);
        else
        {
            Query(s-1,t-1,S,M);
            if(cmd[1]=='S')printf("%d\n",S);
            else printf("%d\n",M);
        }
    }
}
<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
vector&lt;int&gt; E[maxn],Et[maxn];
typedef vector&lt;int&gt;::iterator it;
int n,q,w[maxn],Lim,dep[maxn],Fa[maxn];
int own[maxn],Max[maxn],Sum[maxn]={};
void Build(int t,int f,int d)
{
    dep[t]=d;Fa[t]=f;
    if(own[t]==-1)
    {
        own[t]=t;
        Sum[t]++;
    }
    int tmp=own[t];
    tr(e,E[t])if(*e!=f)
    {
        if(Sum[tmp]&lt;Lim)
        {
            Et[t].pb(*e);
            own[*e]=tmp;
            Sum[tmp]++;
        }
        Build(*e,t,d+1);
    }
}
void Dfs(int t,int s,int m)
{
    Sum[t]=s+=w[t];Max[t]=m=max(m,w[t]);
    tr(e,Et[t])Dfs(*e,s,m);
}
void Change(int t,int u)
{
    w[t]=u;
    if(t==own[t])Dfs(t,0,-inf);
    else Dfs(t,Sum[Fa[t]],Max[Fa[t]]);
}
int QSum(int a,int b)
{
    int s=0;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b]||own[a]==a)
            s+=w[a],a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            s+=Sum[a],a=Fa[own[a]];
        }
    }
    return s+w[a];
}
int QMax(int a,int b)
{
    int m=-inf;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            m=max(m,w[a]),a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            m=max(m,Max[a]),a=Fa[own[a]];
        }
    }
    return max(m,w[a]);
}
int main()
{
    scanf("%d",&amp;n);int s,t;Lim=sqrt(n)*1.2+1;
    rep(i,n-1)scanf("%d%d",&amp;s,&amp;t),--s,--t,E[s].pb(t),E[t].pb(s);
    rep(i,n)scanf("%d",w+i);
    memset(own,-1,sizeof own);
    Build(0,-1,0);
    rep(i,n)if(own[i]==i)Dfs(i,0,-inf);
    scanf("%d",&amp;q);
    char cmd[100];
    rep(i,q)
    {
        scanf(" ");
        scanf("%s%d%d",cmd,&amp;s,&amp;t);
        if(cmd[0]=='C')Change(s-1,t);
        else if(cmd[1]=='S')printf("%d\n",QSum(s-1,t-1));
        else printf("%d\n",QMax(s-1,t-1));
    }
}
<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
vector&lt;int&gt; E[maxn],Et[maxn];
typedef vector&lt;int&gt;::iterator it;
int n,q,w[maxn],Lim,dep[maxn],Fa[maxn];
int own[maxn],Max[maxn],Sum[maxn]={};
void Build(int t,int f,int d)
{
    dep[t]=d;Fa[t]=f;
    if(own[t]==-1)
    {
        own[t]=t;
        Sum[t]++;
    }
    int tmp=own[t];
    tr(e,E[t])if(*e!=f)
    {
        if(Sum[tmp]&lt;Lim)
        {
            Et[t].pb(*e);
            own[*e]=tmp;
            Sum[tmp]++;
        }
        Build(*e,t,d+1);
    }
}
void Dfs(int t,int s,int m)
{
    Sum[t]=s+=w[t];Max[t]=m=max(m,w[t]);
    tr(e,Et[t])Dfs(*e,s,m);
}
void Change(int t,int u)
{
    w[t]=u;
    if(t==own[t])Dfs(t,0,-inf);
    else Dfs(t,Sum[Fa[t]],Max[Fa[t]]);
}
int QSum(int a,int b)
{
    int s=0;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b]||own[a]==a)
            s+=w[a],a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            s+=Sum[a],a=Fa[own[a]];
        }
    }
    return s+w[a];
}
int QMax(int a,int b)
{
    int m=-inf;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            m=max(m,w[a]),a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            m=max(m,Max[a]),a=Fa[own[a]];
        }
    }
    return max(m,w[a]);
}
inline int nextInt()
{
    char c;c=getchar();
    while(c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9'))c=getchar();
    int n=0,s=1;if(c=='-')s=-1,c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')n*=10,n+=c-'0',c=getchar();
    return n*s;
}
int main()
{
    n=nextInt();int s,t;Lim=sqrt(n)+1;
    rep(i,n-1)s=nextInt(),t=nextInt(),--s,--t,E[s].pb(t),E[t].pb(s);
    rep(i,n)w[i]=nextInt();
    memset(own,-1,sizeof own);
    Build(0,-1,0);
    rep(i,n)if(own[i]==i)Dfs(i,0,-inf);
    q=nextInt();
    char cmd[100];
    rep(i,q)
    {
        scanf(" ");
        scanf("%s",cmd);s=nextInt();t=nextInt();
        if(cmd[0]=='C')Change(s-1,t);
        else if(cmd[1]=='S')printf("%d\n",QSum(s-1,t-1));
        else printf("%d\n",QMax(s-1,t-1));
    }
}
<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define pb push_back
const int maxn=30000,inf=~0U&gt;&gt;1;
using namespace std;
vector&lt;int&gt; E[maxn],Et[maxn];
typedef vector&lt;int&gt;::iterator it;
int n,q,w[maxn],L,D[maxn],F[maxn];
int own[maxn],M[maxn],S[maxn]={};
void Build(int t,int f,int d)
{
    D[t]=d;F[t]=f;
    int tmp=own[t];
    tr(e,E[t])if(*e!=f)
    {
        if(S[tmp]++&lt;L)Et[t].pb(*e),own[*e]=tmp;
        Build(*e,t,d+1);
    }
}
void Dfs(int t,int s,int m)
{
    S[t]=s+=w[t];M[t]=m&gt;?=w[t];
    tr(e,Et[t])Dfs(*e,s,m);
}
void Change(int t,int u)
{
    w[t]=u;
    if(t==own[t])Dfs(t,0,-inf);
    else Dfs(t,S[F[t]],M[F[t]]);
}
void Query(int a,int b,int&amp;s,int&amp;m)
{
    s=0;m=-inf;
    while(a!=b)
    {
        if(D[a]&lt;D[b])swap(a,b);
        if(own[a]==own[b])
            s+=w[a],m&gt;?=w[a],a=F[a];
        else
        {
            if(D[own[a]]&lt;D[own[b]])swap(a,b);
            s+=S[a],m&gt;?=M[a],a=F[own[a]];
        }
    }
    m&gt;?=w[a];s+=w[a];
}
int main()
{
    scanf("%d",&amp;n);int s,t;L=sqrt(n)+1;
    rep(i,n-1)scanf("%d%d",&amp;s,&amp;t),--s,--t,E[s].pb(t),E[t].pb(s);
    rep(i,n)scanf("%d",w+i),own[i]=i;
    Build(0,-1,0);
    rep(i,n)if(own[i]==i)Dfs(i,0,-inf);
    scanf("%d",&amp;q);
    char cmd[100];int S,M;
    rep(i,q)
    {
        scanf(" ");
        scanf("%s%d%d",cmd,&amp;s,&amp;t);
        if(cmd[0]=='C')Change(s-1,t);
        else
        {
            Query(s-1,t-1,S,M);
            if(cmd[1]=='S')printf("%d\n",S);
            else printf("%d\n",M);
        }
    }
}
<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
vector&lt;int&gt; E[maxn],Et[maxn];
typedef vector&lt;int&gt;::iterator it;
int n,q,w[maxn],Lim,dep[maxn],Fa[maxn];
int own[maxn],Max[maxn],Sum[maxn]={};
void Build(int t,int f,int d)
{
    dep[t]=d;Fa[t]=f;int tmp=own[t];
    tr(e,E[t])if(*e!=f)
    {
        if(Sum[tmp]++&lt;Lim)
        {
            Et[t].pb(*e);
            own[*e]=tmp;
        }
        Build(*e,t,d+1);
    }
}
void Dfs(int t,int s,int m)
{
    Sum[t]=s+=w[t];Max[t]=m&gt;?=w[t];
    tr(e,Et[t])Dfs(*e,s,m);
}
void Change(int t,int u)
{
    w[t]=u;
    if(t==own[t])Dfs(t,0,-inf);
    else Dfs(t,Sum[Fa[t]],Max[Fa[t]]);
}
int QSum(int a,int b)
{
    int s=0;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            s+=w[a],a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            s+=Sum[a],a=Fa[own[a]];
        }
    }
    return s+w[a];
}
int QMax(int a,int b)
{
    int m=-inf;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            m&gt;?=w[a],a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            m&gt;?=Max[a],a=Fa[own[a]];
        }
    }
    return m&gt;?=w[a];
}
inline int nextInt()
{
    char c;c=getchar();
    while(c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9'))c=getchar();
    int n=0,s=1;if(c=='-')s=-1,c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')n*=10,n+=c-'0',c=getchar();
    return n*s;
}
int main()
{
    n=nextInt();int s,t;Lim=sqrt(n)+1;
    rep(i,n-1)s=nextInt(),t=nextInt(),--s,--t,E[s].pb(t),E[t].pb(s);
    rep(i,n)w[i]=nextInt(),own[i]=i;
    Build(0,-1,0);
    rep(i,n)if(own[i]==i)Dfs(i,0,-inf);
    q=nextInt();
    char cmd[100];
    rep(i,q)
    {
        scanf(" ");
        scanf("%s",cmd);s=nextInt();t=nextInt();
        if(cmd[0]=='C')Change(s-1,t);
        else if(cmd[1]=='S')printf("%d\n",QSum(s-1,t-1));
        else printf("%d\n",QMax(s-1,t-1));
    }
}
<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
vector&lt;int&gt; E[maxn],Et[maxn];
typedef vector&lt;int&gt;::iterator it;
int n,q,w[maxn],Lim,dep[maxn],Fa[maxn];
int own[maxn],Max[maxn],Sum[maxn]={};
void Build(int t,int f,int d)
{
    dep[t]=d;Fa[t]=f;int tmp=own[t];
    tr(e,E[t])if(*e!=f)
    {
        if(Sum[tmp]++&lt;Lim)
        {
            Et[t].pb(*e);
            own[*e]=tmp;
        }
        Build(*e,t,d+1);
    }
}
void Dfs(int t,int s,int m)
{
    Sum[t]=s+=w[t];Max[t]=m&gt;?=w[t];
    tr(e,Et[t])Dfs(*e,s,m);
}
void Change(int t,int u)
{
    w[t]=u;
    if(t==own[t])Dfs(t,0,-inf);
    else Dfs(t,Sum[Fa[t]],Max[Fa[t]]);
}
int QSum(int a,int b)
{
    int s=0;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            s+=w[a],a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            s+=Sum[a],a=Fa[own[a]];
        }
    }
    return s+w[a];
}
int QMax(int a,int b)
{
    int m=-inf;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            m&gt;?=w[a],a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            m&gt;?=Max[a],a=Fa[own[a]];
        }
    }
    return m&gt;?=w[a];
}
inline int nextInt()
{
    char c;c=getchar();
    while(c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9'))c=getchar();
    int n=0,s=1;if(c=='-')s=-1,c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')n*=10,n+=c-'0',c=getchar();
    return n*s;
}
int main()
{
    n=nextInt();int s,t;Lim=sqrt(n)*1.1+1;
    rep(i,n-1)s=nextInt(),t=nextInt(),--s,--t,E[s].pb(t),E[t].pb(s);
    rep(i,n)w[i]=nextInt(),own[i]=i;
    Build(0,-1,0);
    rep(i,n)if(own[i]==i)Dfs(i,0,-inf);
    q=nextInt();
    char cmd[100];
    rep(i,q)
    {
        scanf(" ");
        scanf("%s",cmd);s=nextInt();t=nextInt();
        if(cmd[0]=='C')Change(s-1,t);
        else if(cmd[1]=='S')printf("%d\n",QSum(s-1,t-1));
        else printf("%d\n",QMax(s-1,t-1));
    }
}
<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
vector&lt;int&gt; E[maxn],Et[maxn];
typedef vector&lt;int&gt;::iterator it;
int n,q,w[maxn],Lim,dep[maxn],Fa[maxn];
int own[maxn],Max[maxn],Sum[maxn]={};
void Build(int t,int f,int d)
{
    dep[t]=d;Fa[t]=f;int tmp=own[t];
    tr(e,E[t])if(*e!=f)
    {
        if(Sum[tmp]++&lt;Lim)
        {
            Et[t].pb(*e);
            own[*e]=tmp;
        }
        Build(*e,t,d+1);
    }
}
void Dfs(int t,int s,int m)
{
    Sum[t]=s+=w[t];Max[t]=m&gt;?=w[t];
    tr(e,Et[t])Dfs(*e,s,m);
}
void Change(int t,int u)
{
    w[t]=u;
    if(t==own[t])Dfs(t,0,-inf);
    else Dfs(t,Sum[Fa[t]],Max[Fa[t]]);
}
int QSum(int a,int b)
{
    int s=0;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            s+=w[a],a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            s+=Sum[a],a=Fa[own[a]];
        }
    }
    return s+w[a];
}
int QMax(int a,int b)
{
    int m=-inf;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            m&gt;?=w[a],a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            m&gt;?=Max[a],a=Fa[own[a]];
        }
    }
    return m&gt;?=w[a];
}
inline int nextInt()
{
    char c;c=getchar();
    while(c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9'))c=getchar();
    int n=0,s=1;if(c=='-')s=-1,c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')n*=10,n+=c-'0',c=getchar();
    return n*s;
}
int main()
{
    n=nextInt();int s,t;Lim=sqrt(n)*1.2+1;
    rep(i,n-1)s=nextInt(),t=nextInt(),--s,--t,E[s].pb(t),E[t].pb(s);
    rep(i,n)w[i]=nextInt(),own[i]=i;
    Build(0,-1,0);
    rep(i,n)if(own[i]==i)Dfs(i,0,-inf);
    q=nextInt();
    char cmd[100];
    rep(i,q)
    {
        scanf(" ");
        scanf("%s",cmd);s=nextInt();t=nextInt();
        if(cmd[0]=='C')Change(s-1,t);
        else if(cmd[1]=='S')printf("%d\n",QSum(s-1,t-1));
        else printf("%d\n",QMax(s-1,t-1));
    }
}
<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
vector&lt;int&gt; E[maxn],Et[maxn];
typedef vector&lt;int&gt;::iterator it;
int n,q,w[maxn],Lim,dep[maxn],Fa[maxn];
int own[maxn],Max[maxn],Sum[maxn]={};
void Build(int t,int f,int d)
{
    dep[t]=d;Fa[t]=f;int tmp=own[t];
    tr(e,E[t])if(*e!=f)
    {
        if(Sum[tmp]++&lt;Lim)
        {
            Et[t].pb(*e);
            own[*e]=tmp;
        }
        Build(*e,t,d+1);
    }
}
int Q[maxn],h,t;
void BFS(int vs,int s,int m)
{
    h=t=0;s+=w[vs];m&gt;?=w[vs];
    for(Q[t++]=vs,Sum[vs]=s,Max[vs]=m;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,Et[x])
        {
            Q[t++]=*e;Sum[*e]=Sum[x]+w[*e];
            Max[*e]=Max[x]&gt;?w[*e];
        }
    }
}
void Change(int t,int u)
{
    w[t]=u;
    if(t==own[t])BFS(t,0,-inf);
    else BFS(t,Sum[Fa[t]],Max[Fa[t]]);
}
int QSum(int a,int b)
{
    int s=0;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            s+=w[a],a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            s+=Sum[a],a=Fa[own[a]];
        }
    }
    return s+w[a];
}
int QMax(int a,int b)
{
    int m=-inf;
    while(a!=b)
    {
        if(dep[a]&lt;dep[b])swap(a,b);
        if(own[a]==own[b])
            m&gt;?=w[a],a=Fa[a];
        else
        {
            if(dep[own[a]]&lt;dep[own[b]])swap(a,b);
            m&gt;?=Max[a],a=Fa[own[a]];
        }
    }
    return m&gt;?=w[a];
}
inline int nextInt()
{
    char c;c=getchar();
    while(c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9'))c=getchar();
    int n=0,s=1;if(c=='-')s=-1,c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')n*=10,n+=c-'0',c=getchar();
    return n*s;
}
int main()
{
    //freopen("in","r",stdin);
    n=nextInt();int s,t;Lim=sqrt(n)*1.1+1;
    rep(i,n-1)s=nextInt(),t=nextInt(),--s,--t,E[s].pb(t),E[t].pb(s);
    rep(i,n)w[i]=nextInt(),own[i]=i;
    Build(0,-1,0);
    rep(i,n)if(own[i]==i)BFS(i,0,-inf);
    q=nextInt();
    char cmd[100];
    rep(i,q)
    {
        scanf(" ");
        scanf("%s",cmd);s=nextInt();t=nextInt();
        if(cmd[0]=='C')Change(s-1,t);
        else if(cmd[1]=='S')printf("%d\n",QSum(s-1,t-1));
        else printf("%d\n",QMax(s-1,t-1));
    }
}
<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(int e=st[x];e&lt;st[x+1];++e)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;2,maxn=30000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,Data[maxn];
inline void Update(int&amp;x,int c)
{
    if(x&lt;c)x=c;
}
struct SegTree
{
    int*Max,st,n;
    void set(int x)
    {
        Max[x]=max(Max[x*2],Max[x*2+1]);
    }
    void Build(int l,int r)
    {
        st=l-1;int s=r-l;n=1;
        while(n&lt;=s+3)n&lt;&lt;=1;
        Max=new int[n*2];
        for(int i=l;i&lt;r;i++)Max[i-st+n]=Data[i];
        for(int i=n-1;i&gt;=1;i--)set(i);
    }
    void Change(int p,int s)
    {
        p-=st;
        for(Max[p+=n]=s,p&gt;&gt;=1;p;p&gt;&gt;=1)set(p);
    }
    int Query(int s,int t)
    {
        s-=st;t-=st;s--;t++;int ret=-inf;
        for(s+=n,t+=n;s^t^1;s&gt;&gt;=1,t&gt;&gt;=1)
        {
            if(~s&amp;1)Update(ret,Max[s^1]);
            if(t&amp;1)Update(ret,Max[t^1]);
        }
        return ret;
    }
}T[maxn];
struct Edge
{
    int s,t;
    Edge(){}
    Edge(int _s,int _t):s(_s),t(_t){}
}E[maxn*2];
int to[maxn*2],st[maxn+1]={};
int nextInt()
{
    char c;c=getchar();
    while(c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9'))c=getchar();
    int n=0,s=1;if(c=='-')s=-1,c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')n*=10,n+=c-'0',c=getchar();
    return n*s;
}
int own[maxn],Q[maxn],Size[maxn],w[maxn];
int D[maxn],F[maxn];
void BFS(int vs)
{
    int h=0,t=0;
    for(Q[t++]=vs,D[vs]=0,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,x)
        {
            int y=to[e];
            if(y==F[x])continue;
            Q[t++]=y;
            D[y]=D[x]+1;
            F[y]=x;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(e,x)
        {
            int y=to[e];
            if(y==F[x])continue;
            Size[x]+=Size[y];
        }
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i],next;if(own[x]&gt;=0)continue;
        int a=x;
        for(;;x=next)
        {
            next=-1;own[x]=a;
            Data[D[x]]=w[x];
            tr(e,x)
            {
                int y=to[e];
                if(y==F[x])continue;
                if(next==-1||Size[y]&gt;Size[next])
                    next=y;
            }
            if(next==-1)break;
        }
        T[a].Build(D[a],D[x]+1);
    }
}
int L[maxn],R[maxn],now=0;
void Dfs(int x,int f)
{
    L[x]=now++;
    tr(e,x)if(to[e]!=f)
        Dfs(to[e],x);
    R[x]=now-1;
}
struct TA
{
    int A[maxn],n;
    void Set(int _n){n=_n;memset(A,0,sizeof A);}
    void Add(int l,int d)
    {
        for(l++;l&lt;=n;l+=l&amp;-l)
            A[l-1]+=d;
    }
    void Add(int l,int r,int d)
    {
        Add(l,d);Add(r+1,-d);
    }
    int Sum(int l)
    {
        int ret=0;
        for(l++;l;l-=l&amp;-l)
            ret+=A[l-1];
        return ret;
    }
}ta;

void init()
{
    n=nextInt();int s,t;
    rep(i,n-1)
    {
        s=nextInt()-1,t=nextInt()-1;
        E[i*2]=Edge(s,t);E[i*2+1]=Edge(t,s);
        st[s]++;st[t]++;
    }
    rep(i,n)w[i]=nextInt();
    rep(i,n)st[i+1]+=st[i];
    rep(i,2*(n-1))
    {
        Edge&amp;e=E[i];
        to[--st[e.s]]=e.t;
    }
}
void Prepare()
{
    BFS(0);
    Dfs(0,-1);
    ta.Set(n);
    rep(i,n)ta.Add(L[i],R[i],w[i]);
}
int QMax(int u,int v)
{
    int ret=-inf;
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            Update(ret,T[own[u]].Query(D[v],D[u]));
            return ret;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            Update(ret,T[own[u]].Query(D[own[u]],D[u]));
            u=F[own[u]];
        }
    }
}
int Lca(int u,int v)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v]) return v;
        if(D[own[u]]&lt;D[own[v]])swap(u,v);
        u=F[own[u]];
    }
}
int QSum(int u,int v)
{
    int lca=Lca(u,v);
    int ret=ta.Sum(L[u])+ta.Sum(L[v]);
    ret-=2*ta.Sum(L[lca]);
    ret+=w[lca];
    return ret;
}
void Change(int p,int s)
{
    T[own[p]].Change(D[p],s);
    int add=s-w[p];
    ta.Add(L[p],R[p],add);
    w[p]=s;
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("Get","w",stdout);
    init();
    Prepare();
    int q=nextInt(),s,t;
    char cmd[100];
    rep(i,q)
    {
        scanf(" ");
        scanf("%s",cmd);s=nextInt();t=nextInt();
        if(cmd[0]=='C')Change(s-1,t);
        else if(cmd[1]=='S')printf("%d\n",QSum(s-1,t-1));
        else printf("%d\n",QMax(s-1,t-1));
    }
}


<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(int e=st[x];e&lt;st[x+1];++e)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;2,maxn=30000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,Data[maxn];
inline void Update(int&amp;x,int c)
{
    if(x&lt;c)x=c;
}
struct SegTree
{
    int*Max,st,n;
    void set(int x)
    {
        Max[x]=max(Max[x*2],Max[x*2+1]);
    }
    void Build(int l,int r)
    {
        st=l-1;int s=r-l;n=1;
        while(n&lt;=s+3)n&lt;&lt;=1;
        Max=new int[n*2];
        for(int i=l;i&lt;r;i++)Max[i-st+n]=Data[i];
        for(int i=n-1;i&gt;=1;i--)set(i);
    }
    void Change(int p,int s)
    {
        p-=st;
        for(Max[p+=n]=s,p&gt;&gt;=1;p;p&gt;&gt;=1)set(p);
    }
    int Query(int s,int t)
    {
        s-=st;t-=st;s--;t++;int ret=-inf;
        for(s+=n,t+=n;s^t^1;s&gt;&gt;=1,t&gt;&gt;=1)
        {
            if(~s&amp;1)Update(ret,Max[s^1]);
            if(t&amp;1)Update(ret,Max[t^1]);
        }
        return ret;
    }
}T[maxn];
struct Edge
{
    int s,t;
    Edge(){}
    Edge(int _s,int _t):s(_s),t(_t){}
}E[maxn*2];
int to[maxn*2],st[maxn+1]={};
int own[maxn],Q[maxn],Size[maxn],w[maxn];
int D[maxn],F[maxn];
void BFS(int vs)
{
    int h=0,t=0;
    for(Q[t++]=vs,D[vs]=0,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,x)
        {
            int y=to[e];
            if(y==F[x])continue;
            Q[t++]=y;
            D[y]=D[x]+1;
            F[y]=x;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(e,x)
        {
            int y=to[e];
            if(y==F[x])continue;
            Size[x]+=Size[y];
        }
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i],next;if(own[x]&gt;=0)continue;
        int a=x;
        for(;;x=next)
        {
            next=-1;own[x]=a;
            Data[D[x]]=w[x];
            tr(e,x)
            {
                int y=to[e];
                if(y==F[x])continue;
                if(next==-1||Size[y]&gt;Size[next])
                    next=y;
            }
            if(next==-1)break;
        }
        T[a].Build(D[a],D[x]+1);
    }
}
int L[maxn],R[maxn],now=0;
void Dfs(int x,int f)
{
    L[x]=now++;
    tr(e,x)if(to[e]!=f)
        Dfs(to[e],x);
    R[x]=now-1;
}
struct TA
{
    int A[maxn],n;
    void Set(int _n){n=_n;memset(A,0,sizeof A);}
    void Add(int l,int d)
    {
        for(l++;l&lt;=n;l+=l&amp;-l)
            A[l-1]+=d;
    }
    void Add(int l,int r,int d)
    {
        Add(l,d);Add(r+1,-d);
    }
    int Sum(int l)
    {
        int ret=0;
        for(l++;l;l-=l&amp;-l)
            ret+=A[l-1];
        return ret;
    }
}ta;
#define BUFSIZE 1000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
int sign;
#define read() \
	do{ \
		if (pt &gt;= pend) \
		{ \
			pt = buf; \
			fread(buf, 1, BUFSIZE, stdin); \
		} \
	} while(0)

#define scan(t) \
{ \
	t = 0;sign=1; \
	read(); \
	while ((*pt&lt;'0'||*pt&gt;'9')&amp;&amp;*pt!='-') {pt ++; read();} \
	if(*pt=='-')sign=-1,pt++;\
	while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
	t*=sign;\
}
#define scan_str(s) \
{ \
	int p = 0; \
	read(); \
	while ((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\r') {pt ++; read();}\
	while (!((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\n')) {s[p ++] = (*(pt ++)); read();} \
	s[p] = 0; \
}
void init()
{
    scan(n);int s,t;
    rep(i,n-1)
    {
        scan(s);scan(t);s--;t--;
        E[i*2]=Edge(s,t);E[i*2+1]=Edge(t,s);
        st[s]++;st[t]++;
    }
    rep(i,n)scan(w[i]);
    rep(i,n)st[i+1]+=st[i];
    rep(i,2*(n-1))
    {
        Edge&amp;e=E[i];
        to[--st[e.s]]=e.t;
    }
}
void Prepare()
{
    BFS(0);
    Dfs(0,-1);
    ta.Set(n);
    rep(i,n)ta.Add(L[i],R[i],w[i]);
}
int QMax(int u,int v)
{
    int ret=-inf;
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            Update(ret,T[own[u]].Query(D[v],D[u]));
            return ret;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            Update(ret,T[own[u]].Query(D[own[u]],D[u]));
            u=F[own[u]];
        }
    }
}
int Lca(int u,int v)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v]) return v;
        if(D[own[u]]&lt;D[own[v]])swap(u,v);
        u=F[own[u]];
    }
}
int QSum(int u,int v)
{
    int lca=Lca(u,v);
    int ret=ta.Sum(L[u])+ta.Sum(L[v]);
    ret-=2*ta.Sum(L[lca]);
    ret+=w[lca];
    return ret;
}
void Change(int p,int s)
{
    T[own[p]].Change(D[p],s);
    int add=s-w[p];
    ta.Add(L[p],R[p],add);
    w[p]=s;
}
int A[20],k;
inline void print_int(int x)
{
    if(x&lt;0)putchar('-'),x=-x;
    k=0;while(x)A[k++]=x%10,x/=10;
    for(int i=k-1;i&gt;=0;i--)putchar('0'+A[i]);
    putchar('\n');
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("Get","w",stdout);
    init();
    Prepare();
    int q,s,t;scan(q);
    char cmd[100];
    rep(i,q)
    {
        scan_str(cmd);scan(s);scan(t);
        if(cmd[0]=='C')Change(s-1,t);
        else if(cmd[1]=='S')print_int(QSum(s-1,t-1));
        else print_int(QMax(s-1,t-1));
    }
}


<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(int e=st[x];e&lt;st[x+1];++e)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;2,maxn=30000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,Data[maxn];
inline int max(int x,int y)
{
    int m=(x-y)&gt;&gt;31;
    return y&amp;m|x&amp;~m;
}
inline void Update(int&amp;x,int c)
{
    x=max(x,c);
}
struct SegTree
{
    int*Max,st,n;
    void set(int x)
    {
        Max[x]=max(Max[x*2],Max[x*2+1]);
    }
    void Build(int l,int r)
    {
        st=l-1;int s=r-l;n=1;
        while(n&lt;=s+3)n&lt;&lt;=1;
        Max=new int[n*2];
        for(int i=l;i&lt;r;i++)Max[i-st+n]=Data[i];
        for(int i=n-1;i&gt;=1;i--)set(i);
    }
    void Change(int p,int s)
    {
        p-=st;
        for(Max[p+=n]=s,p&gt;&gt;=1;p;p&gt;&gt;=1)set(p);
    }
    int Query(int s,int t)
    {
        s-=st;t-=st;s--;t++;register int ret=-inf;
        for(s+=n,t+=n;s^t^1;s&gt;&gt;=1,t&gt;&gt;=1)
        {
            if(~s&amp;1)Update(ret,Max[s^1]);
            if(t&amp;1)Update(ret,Max[t^1]);
        }
        return ret;
    }
}T[maxn];
struct Edge
{
    int s,t;
    Edge(){}
    Edge(int _s,int _t):s(_s),t(_t){}
}E[maxn*2];
int to[maxn*2],st[maxn+1]={};
int own[maxn],Q[maxn],Size[maxn],w[maxn];
int D[maxn],F[maxn];
void BFS(int vs)
{
    int h=0,t=0;
    for(Q[t++]=vs,D[vs]=0,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,x)
        {
            int y=to[e];
            if(y==F[x])continue;
            Q[t++]=y;
            D[y]=D[x]+1;
            F[y]=x;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(e,x)
        {
            int y=to[e];
            if(y==F[x])continue;
            Size[x]+=Size[y];
        }
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i],next;if(own[x]&gt;=0)continue;
        int a=x;
        for(;;x=next)
        {
            next=-1;own[x]=a;
            Data[D[x]]=w[x];
            tr(e,x)
            {
                int y=to[e];
                if(y==F[x])continue;
                if(next==-1||Size[y]&gt;Size[next])
                    next=y;
            }
            if(next==-1)break;
        }
        T[a].Build(D[a],D[x]+1);
    }
}
int L[maxn],R[maxn],now=0;
void Dfs(int x,int f)
{
    L[x]=now++;
    tr(e,x)if(to[e]!=f)
        Dfs(to[e],x);
    R[x]=now-1;
}
struct TA
{
    int A[maxn],n;
    void Set(int _n){n=_n;memset(A,0,sizeof A);}
    void Add(int l,int d)
    {
        for(l++;l&lt;=n;l+=l&amp;-l)
            A[l-1]+=d;
    }
    void Add(int l,int r,int d)
    {
        Add(l,d);Add(r+1,-d);
    }
    int Sum(int l)
    {
        register int ret=0;
        for(l++;l;l-=l&amp;-l)
            ret+=A[l-1];
        return ret;
    }
}ta;
#define BUFSIZE 10000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
int sign;
#define read() \
	do{ \
		if (pt &gt;= pend) \
		{ \
			pt = buf; \
			fread(buf, 1, BUFSIZE, stdin); \
		} \
	} while(0)

#define scan(t) \
{ \
	t = 0;sign=1; \
	read(); \
	while ((*pt&lt;'0'||*pt&gt;'9')&amp;&amp;*pt!='-') {pt ++; read();} \
	if(*pt=='-')sign=-1,pt++;\
	while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
	t*=sign;\
}
#define scan_str(s) \
{ \
	int p = 0; \
	read(); \
	while ((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\r') {pt ++; read();}\
	while (!((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\n')) {s[p ++] = (*(pt ++)); read();} \
	s[p] = 0; \
}
void init()
{
    scan(n);int s,t;
    rep(i,n-1)
    {
        scan(s);scan(t);s--;t--;
        E[i*2]=Edge(s,t);E[i*2+1]=Edge(t,s);
        st[s]++;st[t]++;
    }
    rep(i,n)scan(w[i]);
    rep(i,n)st[i+1]+=st[i];
    rep(i,2*(n-1))
    {
        Edge&amp;e=E[i];
        to[--st[e.s]]=e.t;
    }
}
void Prepare()
{
    BFS(0);
    Dfs(0,-1);
    ta.Set(n);
    rep(i,n)ta.Add(L[i],R[i],w[i]);
}
int QMax(int u,int v)
{
    int ret=-inf;
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            Update(ret,T[own[u]].Query(D[v],D[u]));
            return ret;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            Update(ret,T[own[u]].Query(D[own[u]],D[u]));
            u=F[own[u]];
        }
    }
}
int Lca(int u,int v)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v]) return v;
        if(D[own[u]]&lt;D[own[v]])swap(u,v);
        u=F[own[u]];
    }
}
int QSum(int u,int v)
{
    int lca=Lca(u,v);
    int ret=ta.Sum(L[u])+ta.Sum(L[v]);
    ret-=2*ta.Sum(L[lca]);
    ret+=w[lca];
    return ret;
}
void Change(int p,int s)
{
    T[own[p]].Change(D[p],s);
    int add=s-w[p];
    ta.Add(L[p],R[p],add);
    w[p]=s;
}
int A[20],k;
char p[10000000];
char*opt=p;
inline void print_int(int x)
{
    if(x&lt;0)*opt++='-',x=-x;
    if(!x)*opt++='0';
    k=0;while(x)A[k++]=x%10,x/=10;
    for(int i=k-1;i&gt;=0;i--)*opt++='0'+A[i];
    *opt++='\n';
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("Get","w",stdout);
    init();
    Prepare();
    int q,s,t;scan(q);
    char cmd[100];
    rep(i,q)
    {
        scan_str(cmd);scan(s);scan(t);
        if(cmd[0]=='C')Change(s-1,t);
        else if(cmd[1]=='S')print_int(QSum(s-1,t-1));
        else print_int(QMax(s-1,t-1));
    }
    *opt++='\0';
    puts(p);
}


<pre><h2>Problem1036</h2><pre>#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(register int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(int e=st[x];e&lt;st[x+1];++e)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;2,maxn=30000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,Data[maxn];
int Memory[maxn*8],*Now=Memory;
int*New(int s)
{
    return Now+=s,Now-s;
}
inline int max(int x,int y)
{
    int m=(x-y)&gt;&gt;31;
    return y&amp;m|x&amp;~m;
}
inline void Update(int&amp;x,int c)
{
    x=max(x,c);
}
struct SegTree
{
    int*Max,st,n;
    void set(int x)
    {
        Max[x]=max(Max[x*2],Max[x*2+1]);
    }
    void Build(int l,int r)
    {
        st=l-1;int s=r-l;n=1;
        while(n&lt;=s+3)n&lt;&lt;=1;
        Max=New(n*2);
        for(int i=l;i&lt;r;i++)Max[i-st+n]=Data[i];
        for(int i=n-1;i&gt;=1;i--)set(i);
    }
    void Change(int p,int s)
    {
        p-=st;
        for(Max[p+=n]=s,p&gt;&gt;=1;p;p&gt;&gt;=1)set(p);
    }
    int Query(register int s,register int t)
    {
        s-=st;t-=st;s--;t++;register int ret=-inf;
        for(s+=n,t+=n;s^t^1;s&gt;&gt;=1,t&gt;&gt;=1)
        {
            if(~s&amp;1)Update(ret,Max[s^1]);
            if(t&amp;1)Update(ret,Max[t^1]);
        }
        return ret;
    }
}T[maxn];
struct Edge
{
    int s,t;
    Edge(){}
    Edge(int _s,int _t):s(_s),t(_t){}
}E[maxn*2];
int to[maxn*2],st[maxn+1]={};
int own[maxn],Q[maxn],Size[maxn],w[maxn];
int D[maxn],F[maxn];
void BFS(int vs)
{
    int h=0,t=0;
    for(Q[t++]=vs,D[vs]=0,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,x)
        {
            int y=to[e];
            if(y==F[x])continue;
            Q[t++]=y;
            D[y]=D[x]+1;
            F[y]=x;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(e,x)
        {
            int y=to[e];
            if(y==F[x])continue;
            Size[x]+=Size[y];
        }
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i],next;if(own[x]&gt;=0)continue;
        int a=x;
        for(;;x=next)
        {
            next=-1;own[x]=a;
            Data[D[x]]=w[x];
            tr(e,x)
            {
                int y=to[e];
                if(y==F[x])continue;
                if(next==-1||Size[y]&gt;Size[next])
                    next=y;
            }
            if(next==-1)break;
        }
        T[a].Build(D[a],D[x]+1);
    }
}
int L[maxn],R[maxn],now=0;
void Dfs(int x,int f)
{
    L[x]=now++;
    tr(e,x)if(to[e]!=f)
        Dfs(to[e],x);
    R[x]=now-1;
}
struct TA
{
    int A[maxn],n;
    void Set(int _n){n=_n;memset(A,0,sizeof A);}
    void Add(register int l,register int d)
    {
        for(l++;l&lt;=n;l+=l&amp;-l)
            A[l-1]+=d;
    }
    void Add(int l,int r,int d)
    {
        Add(l,d);Add(r+1,-d);
    }
    int Sum(register int l)
    {
        register int ret=0;
        for(l++;l;l-=l&amp;-l)
            ret+=A[l-1];
        return ret;
    }
}ta;
#define BUFSIZE 10000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
int sign;
#define read() \
	do{ \
		if (pt &gt;= pend) \
		{ \
			pt = buf; \
			fread(buf, 1, BUFSIZE, stdin); \
		} \
	} while(0)

#define scan(t) \
{ \
	t = 0;sign=1; \
	read(); \
	while ((*pt&lt;'0'||*pt&gt;'9')&amp;&amp;*pt!='-') {pt ++; read();} \
	if(*pt=='-')sign=-1,pt++;\
	while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
	t*=sign;\
}
#define scan_str(s) \
{ \
	int p = 0; \
	read(); \
	while ((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\r') {pt ++; read();}\
	while (!((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\n')) {s[p ++] = (*(pt ++)); read();} \
	s[p] = 0; \
}
void init()
{
    scan(n);int s,t;
    rep(i,n-1)
    {
        scan(s);scan(t);s--;t--;
        E[i*2]=Edge(s,t);E[i*2+1]=Edge(t,s);
        st[s]++;st[t]++;
    }
    rep(i,n)scan(w[i]);
    rep(i,n)st[i+1]+=st[i];
    rep(i,2*(n-1))
    {
        Edge&amp;e=E[i];
        to[--st[e.s]]=e.t;
    }
}
void Prepare()
{
    BFS(0);
    Dfs(0,-1);
    ta.Set(n);
    rep(i,n)ta.Add(L[i],R[i],w[i]);
}
int QMax(int u,int v)
{
    int ret=-inf;
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            Update(ret,T[own[u]].Query(D[v],D[u]));
            return ret;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            Update(ret,T[own[u]].Query(D[own[u]],D[u]));
            u=F[own[u]];
        }
    }
}
int Lca(int u,int v)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v]) return v;
        if(D[own[u]]&lt;D[own[v]])swap(u,v);
        u=F[own[u]];
    }
}
int QSum(int u,int v)
{
    int lca=Lca(u,v);
    int ret=ta.Sum(L[u])+ta.Sum(L[v]);
    ret-=2*ta.Sum(L[lca]);
    ret+=w[lca];
    return ret;
}
void Change(int p,int s)
{
    T[own[p]].Change(D[p],s);
    int add=s-w[p];
    ta.Add(L[p],R[p],add);
    w[p]=s;
}
int A[20],k;
char p[10000000];
char*opt=p;
inline void print_int(int x)
{
    if(x&lt;0)*opt++='-',x=-x;
    if(!x)*opt++='0';
    k=0;while(x)A[k++]=x%10,x/=10;
    for(int i=k-1;i&gt;=0;i--)*opt++='0'+A[i];
    *opt++='\n';
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("Get","w",stdout);
    init();
    Prepare();
    int q,s,t;scan(q);
    char cmd[100];
    rep(i,q)
    {
        scan_str(cmd);scan(s);scan(t);
        if(cmd[0]=='C')Change(s-1,t);
        else if(cmd[1]=='S')print_int(QSum(s-1,t-1));
        else print_int(QMax(s-1,t-1));
    }
    *opt++='\0';
    puts(p);
}


<pre><h2>Problem1036</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(register int i=0;i&lt;n;i++)
#define pb push_back
#define tr(e,x) for(int e=st[x];e&lt;st[x+1];++e)
const int inf=~0U&gt;&gt;2,maxn=30000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,Data[maxn];
int Memory[maxn*8],*Now=Memory;
int*New(int s)
{
    return Now+=s,Now-s;
}
inline int max(int x,int y)
{
    int m=(x-y)&gt;&gt;31;
    return y&amp;m|x&amp;~m;
}
inline void Update(int&amp;x,int c)
{
    x=max(x,c);
}
struct SegTree
{
    int*Max,st,n;
    void set(int x)
    {
        Max[x]=max(Max[x*2],Max[x*2+1]);
    }
    void Build(int l,int r)
    {
        st=l-1;int s=r-l;n=1;
        while(n&lt;=s+3)n&lt;&lt;=1;
        Max=New(n*2);
        for(int i=l;i&lt;r;i++)Max[i-st+n]=Data[i];
        for(int i=n-1;i&gt;=1;i--)set(i);
    }
    void Change(int p,int s)
    {
        p-=st;
        for(Max[p+=n]=s,p&gt;&gt;=1;p;p&gt;&gt;=1)set(p);
    }
    int Query(register int s,register int t)
    {
        s-=st;t-=st;s--;t++;register int ret=-inf;
        for(s+=n,t+=n;s^t^1;s&gt;&gt;=1,t&gt;&gt;=1)
        {
            if(~s&amp;1)Update(ret,Max[s^1]);
            if(t&amp;1)Update(ret,Max[t^1]);
        }
        return ret;
    }
}T[maxn];
struct Edge
{
    int s,t;
    Edge(){}
    Edge(int _s,int _t):s(_s),t(_t){}
}E[maxn*2];
int to[maxn*2],st[maxn+1]={};
int own[maxn],Q[maxn],Size[maxn],w[maxn];
int D[maxn],F[maxn];
void BFS(int vs)
{
    int h=0,t=0;
    for(Q[t++]=vs,D[vs]=0,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,x)
        {
            int y=to[e];
            if(y==F[x])continue;
            Q[t++]=y;
            D[y]=D[x]+1;
            F[y]=x;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(e,x)
        {
            int y=to[e];
            if(y==F[x])continue;
            Size[x]+=Size[y];
        }
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i],next;if(own[x]&gt;=0)continue;
        int a=x;
        for(;;x=next)
        {
            next=-1;own[x]=a;
            Data[D[x]]=w[x];
            tr(e,x)
            {
                int y=to[e];
                if(y==F[x])continue;
                if(next==-1||Size[y]&gt;Size[next])
                    next=y;
            }
            if(next==-1)break;
        }
        T[a].Build(D[a],D[x]+1);
    }
}
int L[maxn],R[maxn],now=0;
void Dfs(int x,int f)
{
    L[x]=now++;
    tr(e,x)if(to[e]!=f)
        Dfs(to[e],x);
    R[x]=now-1;
}
struct TA
{
    int A[maxn],n;
    void Set(int _n){n=_n;memset(A,0,sizeof A);}
    void Add(register int l,register int d)
    {
        for(l++;l&lt;=n;l+=l&amp;-l)
            A[l-1]+=d;
    }
    void Add(int l,int r,int d)
    {
        Add(l,d);Add(r+1,-d);
    }
    int Sum(register int l)
    {
        register int ret=0;
        for(l++;l;l-=l&amp;-l)
            ret+=A[l-1];
        return ret;
    }
}ta;
#define BUFSIZE 10000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
int sign;
#define read() \
	do{ \
		if (pt &gt;= pend) \
		{ \
			pt = buf; \
			fread(buf, 1, BUFSIZE, stdin); \
		} \
	} while(0)

#define scan(t) \
{ \
	t = 0;sign=1; \
	read(); \
	while ((*pt&lt;'0'||*pt&gt;'9')&amp;&amp;*pt!='-') {pt ++; read();} \
	if(*pt=='-')sign=-1,pt++;\
	while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
	t*=sign;\
}
#define scan_str(s) \
{ \
	int p = 0; \
	read(); \
	while ((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\r') {pt ++; read();}\
	while (!((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\n')) {s[p ++] = (*(pt ++)); read();} \
	s[p] = 0; \
}
void init()
{
    scan(n);int s,t;
    rep(i,n-1)
    {
        scan(s);scan(t);s--;t--;
        E[i*2]=Edge(s,t);E[i*2+1]=Edge(t,s);
        st[s]++;st[t]++;
    }
    rep(i,n)scan(w[i]);
    rep(i,n)st[i+1]+=st[i];
    rep(i,2*(n-1))
    {
        Edge&amp;e=E[i];
        to[--st[e.s]]=e.t;
    }
}
void Prepare()
{
    BFS(0);
    Dfs(0,-1);
    ta.Set(n);
    rep(i,n)ta.Add(L[i],R[i],w[i]);
}
int QMax(register int u,register int v)
{
    register int ret=-inf;
    for(;;)
    {
        if(D[u]&lt;D[v])u^=v^=u^=v;
        if(own[u]==own[v])
        {
            Update(ret,T[own[u]].Query(D[v],D[u]));
            return ret;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])u^=v^=u^=v;
            Update(ret,T[own[u]].Query(D[own[u]],D[u]));
            u=F[own[u]];
        }
    }
}
int Lca(register int u,register int v)
{
    for(;;)
    {
        if(D[u]&lt;D[v])u^=v^=u^=v;
        if(own[u]==own[v]) return v;
        if(D[own[u]]&lt;D[own[v]])u^=v^=u^=v;
        u=F[own[u]];
    }
}
int QSum(int u,int v)
{
    int lca=Lca(u,v);
    int ret=ta.Sum(L[u])+ta.Sum(L[v]);
    ret-=2*ta.Sum(L[lca]);
    ret+=w[lca];
    return ret;
}
void Change(int p,int s)
{
    T[own[p]].Change(D[p],s);
    int add=s-w[p];
    ta.Add(L[p],R[p],add);
    w[p]=s;
}
int A[20],k;
char p[10000000];
char*opt=p;
inline void print_int(int x)
{
    if(x&lt;0)*opt++='-',x=-x;
    if(!x)*opt++='0';
    k=0;while(x)A[k++]=x%10,x/=10;
    for(int i=k-1;i&gt;=0;i--)*opt++='0'+A[i];
    *opt++='\n';
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("Get","w",stdout);
    init();
    Prepare();
    int q,s,t;scan(q);
    char cmd[100];
    rep(i,q)
    {
        scan_str(cmd);scan(s);scan(t);
        if(cmd[0]=='C')Change(s-1,t);
        else if(cmd[1]=='S')print_int(QSum(s-1,t-1));
        else print_int(QMax(s-1,t-1));
    }
    *opt++='\0';
    puts(p);
}


<pre><h2>Problem1037</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=150+1,maxk=20+1,mod=12345678;
int n,m,k;
int dp[2][maxn][maxk][maxk];
void add(int&amp;a,int x)
{
    a+=x;a%=mod;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
    int now=0,old=1;
    dp[now][0][0][0]=1;
    for(int i=0;i&lt;n+m;++i)
    {
        swap(now,old);
        memset(dp[now],0,sizeof(dp[now]));
        for(int j=0;j&lt;=min(i,n);++j)
            for(int k1=0;k1&lt;=min(j,k);++k1)
                for(int k2=0;k2&lt;=min(i-j,k);++k2)
                {
                    int x=dp[old][j][k1][k2];
                    if(k1&lt;k&amp;&amp;j&lt;n) add(dp[now][j+1][k1+1][max(k2-1,0)],x);
                    if(k2&lt;k&amp;&amp;i-j&lt;m) add(dp[now][j][max(k1-1,0)][k2+1],x);
                }
    }
    int ans=0;
    rep(k1,k+1)rep(k2,k+1) ans+=dp[now][n][k1][k2],ans%=mod;
    cout&lt;&lt;ans&lt;&lt;endl;
}
<pre><h2>Problem1038</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxn=300+10;
const double eps=1e-6;
using namespace std;
int n;
int cmp(double a,double b)
{
    if(fabs(a-b)&lt;eps)return 0;
    return a&lt;b?-1:1;
}
struct Point
{
    double x,y;
    Point(double _x,double _y):
        x(_x),y(_y){}
    Point(){}
}P[maxn];
void Input_Data()
{
    scanf("%d",&amp;n);
    rep(i,n)scanf("%lf",&amp;P[i].x);
    rep(i,n)scanf("%lf",&amp;P[i].y);
}
struct Line
{
    double a,b;
    Line(){}
    Line(double _a,double _b):
        a(_a),b(_b){}
    bool operator&lt;(const Line&amp;L)const
    {
        int tmp=cmp(a,L.a);
        if(tmp)return tmp==-1;
        return b&gt;L.b;
    }
    bool operator==(const Line&amp;L)const
    {
        return cmp(a,L.a)==0;
    }
    double Calc_Value(double x)
    {
        return a*x+b;
    }
}L[maxn];
Line get_Line(Point a,Point b)
{
    Line ret;
    ret.a=(b.y-a.y)/(b.x-a.x);
    ret.b=a.y-a.x*ret.a;
    return ret;
}
void get_All_Line()
{
    rep(i,n-1)
        L[i]=get_Line(P[i],P[i+1]);
}
double get_x(Line L1,Line L2)
{
    return -(L1.b-L2.b)/(L1.a-L2.a);
}
int m;
void Calc_Half_Plane()
{
    m=n-1;
    sort(L,L+m);
    m=unique(L,L+m)-L;
    int p=0;
    rep(i,m)
    {
        while(p&gt;=2&amp;&amp;cmp(get_x(L[p-2],L[p-1]),get_x(L[p-1],L[i]))&gt;=0)p--;
        L[p++]=L[i];
    }
    m=p;
    /*
    cout&lt;&lt;"Ha"&lt;&lt;endl;
    rep(i,m)
    {
        cout&lt;&lt;L[i].a&lt;&lt;" "&lt;&lt;L[i].b&lt;&lt;endl;
    }
    */
}
double Calc_Ret(double x,Line Up,Line Down)
{
    return Up.Calc_Value(x)-Down.Calc_Value(x);
}
void Calc_Ans()
{
    int i=0,j=0;
    double Min=1e30;
    #define Update(x) (Min=min(Min,Calc_Ret(x,L[j],get_Line(P[i],P[i+1]))))
    while(i+1&lt;n&amp;&amp;j&lt;m)
    {
        double l=j?get_x(L[j-1],L[j]):-inf;
        double r=j+1&lt;m?get_x(L[j],L[j+1]):inf;
        if(l&gt;P[i+1].x){i++;continue;}
        if(r&lt;P[i].x){j++;continue;}
        Update(max(l,P[i].x));
        Update(min(P[i+1].x,r));
        if(r&lt;P[i+1].x)j++;
        else i++;
    }
    if(n==1)Min=0;
    if(cmp(Min,0)==0)Min=0;
    printf("%0.3lf\n",Min);
}
void Solve()
{
    get_All_Line();
    Calc_Half_Plane();
    Calc_Ans();
}
int main()
{
    //freopen("in","r",stdin);
    Input_Data();
    Solve();
}
<pre><h2>Problem1040</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=1000000;
struct StateTree
{
    long long A[2];
    long long operator()(int v)const{return A[v];}
    StateTree(int val=0)
    {
        A[0]=0;A[1]=val;
    }
    void Renew(const StateTree&amp;son)
    {
        A[0]+=max(son(0),son(1));
        A[1]+=son(0);
    }
}Dp[maxn];
struct StateCircle
{
    long long A[2][2];
    long long operator()(int l,int r){return A[l][r];}
    StateCircle(const StateTree&amp;x)
    {
        memset(A,0,sizeof(A));
        A[0][0]=x(0);
        A[1][1]=x(1);
    }
    void Renew(const StateTree&amp;x)
    {
        long long Ans[2][2];
        rep(i,2)
        {
            Ans[i][0]=max(A[i][0],A[i][1])+x(0);
            Ans[i][1]=A[i][0]+x(1);
        }
        memcpy(A,Ans,sizeof(A));
    }
};
int In[maxn],P[maxn],C[maxn],n;
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);
    rep(i,n) scanf("%d %d",C+i,P+i),In[--P[i]]++,Dp[i]=StateTree(C[i]);
    queue&lt;int&gt; Q;
    rep(i,n)if(!In[i]) Q.push(i);
    while(Q.size())
    {
        int t=Q.front();Q.pop();
        Dp[P[t]].Renew(Dp[t]);
        if(--In[P[t]]==0) Q.push(P[t]);
    }
    long long Ans=0;
    rep(i,n)if(In[i]&gt;0)
    {
        In[i]=0;int t=i;
        StateCircle now=StateCircle(Dp[t]);
        t=P[t];
        while(t!=i)
        {
            now.Renew(Dp[t]);In[t]=0;
            t=P[t];
        }
        Ans+=max(now(1,0),max(now(0,0),now(0,1)));
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
}
<pre><h2>Problem1041</h2><pre>#include&lt;iostream&gt;
#include&lt;set&gt;
#include&lt;utility&gt;
using namespace std;
long long r,n,m;
typedef pair&lt;int,int&gt; ii;
set&lt;ii&gt; S;
int Cal(int d)
{
    long long r=::r/d;
    n=1,m=1;while(m*m&lt;r)m++;
    while(n&lt;m)
    {
        while(n&lt;m&amp;&amp;n*n+m*m&gt;r)m--;
        if(n&gt;=m)break;
        if(n*n+m*m==r){int a=m*m-n*n,b=2*m*n;S.insert(ii(a*d,b*d));S.insert(ii(b*d,a*d));}
        n++;
    }
}
int main()
{
    cin&gt;&gt;r;int d;
    for(d=1;d*d&lt;r;d++)if(r%d==0) Cal(r/d)+Cal(d);
    if(d*d==r)Cal(d);
    cout&lt;&lt;S.size()*4+4&lt;&lt;endl;
}
<pre><h2>Problem1042</h2><pre>#include&lt;iostream&gt;
using namespace std;
const int maxn=4,maxs=100000+1;
typedef long long ll;
ll Dp[maxs]={0};
int C[maxn];
void Cal()
{
    Dp[0]=1;
    for(int i=0;i&lt;maxn;i++)
        for(int j=C[i];j&lt;maxs;j++)
            Dp[j]+=Dp[j-C[i]];
}
int D[maxn];
void dfs(int p,int ch,int now,ll&amp;ret)
{
    if(now&lt;0) return;
    if(p==maxn)
    {
        if(ch&amp;1) ret-=Dp[now];
        else ret+=Dp[now];
        return;
    }
    dfs(p+1,ch+1,now-C[p]*(D[p]+1),ret);
    dfs(p+1,ch,now,ret);
}
void solve()
{
    int s;ll ans=0;for(int i=0;i&lt;maxn;i++)cin&gt;&gt;D[i];
    cin&gt;&gt;s;
    dfs(0,0,s,ans);
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    int t;
    for(int i=0;i&lt;maxn;i++)cin&gt;&gt;C[i];cin&gt;&gt;t;
    Cal();
    while(t--)solve();
}
<pre><h2>Problem1043</h2><pre>/**************************************************************
    Problem: 1043
    User: nimendongde
    Language: C++
    Result: Accepted
    Time:1012 ms
    Memory:288 kb
****************************************************************/
 
/*
 * [HAOI2008]下落的圆盘.cpp
 *
 *  Created on: 2011-3-2
 *      Author: user
 */
 
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cassert&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_NCIRCLES = 1000 + 10;
 
struct Circle {
    double x, y, r;
    void read() {
        scanf("%lf%lf%lf", &amp;r, &amp;x, &amp;y);
    }
};
 
#define dist(x1,y1,x2,y2) (hypot(x1-x2,y1-y2))
 
int nCircle;
Circle circles[MAX_NCIRCLES];
 
void inputData() {
    scanf("%d", &amp;nCircle);
    for (int i = 0; i &lt; nCircle; ++i) {
        circles[i].read();
    }
}
 
const double EPS = 1e-8;
const double PI = acos(0) * 2;
int compare(double a, double b) {
    return a &lt; b - EPS ? -1 : a &gt; b + EPS;
}
 
bool isCompletelyInside(const Circle&amp;c1, const Circle&amp;c2) {
    return compare(dist(c1.x,c1.y,c2.x,c2.y) + c1.r, c2.r) &lt;= 0;
}
 
struct Event {
    double x;
    int add;
    bool operator&lt;(const Event&amp;e) const {
        return x &lt; e.x;
    }
};
 
const int MAX_NEVENTS = 4000 + 100;
Event events[MAX_NEVENTS];
int nEvents;
 
void addEvent(double x, int add) {
    events[nEvents].x = x;
    events[nEvents].add = add;
    nEvents++;
}
 
void addSeg(double l, double r, int val) {
    addEvent(l, val);
    addEvent(r, -val);
}
 
inline bool isInside(const Circle&amp;me, double x, double y) {
    return compare(dist(x,y,me.x,me.y), me.r) &lt;= 0;
}
 
inline void trim(double&amp;p) {
    if (p &gt;= 2 * PI)
        p -= 2 * PI;
    if (p &lt; 0)
        p += 2 * PI;
}
 
void getIntersect(const Circle&amp;me, const Circle&amp;other) {
    if (isCompletelyInside(other, me))
        return;
    double d = dist(me.x,me.y,other.x,other.y);
    double r1 = me.r, r2 = other.r;
    if(compare(r1+r2,d) &lt;= 0)
        return;
    double a = (r1 * r1 + d * d - r2 * r2) / (2 * d);
    double c = sqrt(r1 * r1 - a * a);
    double delta = fabs(atan2(c, a));
    double am = atan2(other.y - me.y, other.x - me.x);
    trim(am);
    double left = am - delta, right = am + delta;
    trim(left);
    trim(right);
    if (left &gt; right)
        swap(left, right);
    double rx = me.x + me.r, ry = me.y;
    if (isInside(other, rx, ry)) {
        addSeg(0, left, 1);
        addSeg(right, 2 * PI, 1);
    } else {
        addSeg(left, right, 1);
    }
}
 
double totalLen;
 
void processCircle(int am) {
    for (int after = am + 1; after &lt; nCircle; ++after) {
        if (isCompletelyInside(circles[am], circles[after]))
            return;
    }
 
    nEvents = 0;
    for (int after = am + 1; after &lt; nCircle; ++after) {
        getIntersect(circles[am], circles[after]);
    }
 
    addSeg(0, 2 * PI, 0);
    sort(events, events + nEvents);
    int cnt = 0;
 
    double unCovered = 0;
    for (int i = 0; i &lt; nEvents; ++i) {
        if (i &gt; 0 &amp;&amp; cnt == 0)
            unCovered += events[i].x - events[i - 1].x;
        cnt += events[i].add;
    }
 
    totalLen += unCovered * circles[am].r;
}
 
double work() {
    totalLen = 0;
    for (int i = 0; i &lt; nCircle; ++i) {
        processCircle(i);
    }
    return totalLen;
}
 
double randDouble() {
    return double(rand()*RAND_MAX+rand()) / (RAND_MAX*RAND_MAX);
}
 
void genData() {
    nCircle = 10;
    for (int i = 0; i &lt; nCircle; ++i) {
        circles[i].r = randDouble() * 10;
        circles[i].x = randDouble() * 10;
        circles[i].y = randDouble() * 10;
    }
}
 
void solve() {
    inputData();
    printf("%0.3lf\n",work());
}
 
const int LARGE=200000;
 
double stupidWork() {
    double totalLen = 0;
    for (int me = 0; me &lt; nCircle; ++me) {
        int cnt = 0;
        double x = circles[me].x, y = circles[me].y, r = circles[me].r;
        for (int i = 0; i &lt; LARGE; ++i) {
            double d = randDouble() * 2 * PI;
            double dx = x + r * cos(d), dy = y + r * sin(d);
            bool ok = true;
            for (int after = me + 1; after &lt; nCircle; ++after) {
                if (isInside(circles[after], dx, dy)) {
                    ok = false;
                    break;
                }
            }
            if (ok)
                cnt++;
        }
        totalLen += double(cnt) / LARGE * 2 * PI * r;
    }
    return totalLen;
}
 
void runTest() {
    genData();
    printf("%0.10lf\n", work());
    printf("%0.10lf\n", stupidWork());
}
 
int main() {
    solve();
//  runTest();
}<pre><h2>Problem1045</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
int n,A[1000000];
inline void scan(int&amp;t)
{
    char c;while(c=getchar(),c&lt;'0'||c&gt;'9');t=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
}
int main()
{
    //freopen("in","r",stdin);
    scan(n);
    long long avg=0,ans=0;
    rep(i,n)scan(A[i]),avg+=A[i];
    avg/=n;A[0]-=avg;
    rep(i,n-1)A[i+1]+=A[i]-avg;
    sort(A,A+n);
    rep(i,n)ans+=abs(A[n/2]-A[i]);
    printf("%I64d\n",ans);
}
<pre><h2>Problem1046</h2><pre>/*
 *  [HAOI2007]上升序列.cpp
 *
 *  Created on: 2011-5-20
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_N = 10000 + 10;
int a[MAX_N], n;
int dp[MAX_N];
int best[MAX_N];

int main() {
	scanf("%d", &amp;n);
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", a + i);
	}
	fill(best, best + n + 1, INT_MIN);
	best[0] = INT_MAX;
	for (int i = n - 1; i &gt;= 0; --i) {
		int l = 0, r = n + 1;
		while (l + 1 &lt; r) {
			int m = l + r &gt;&gt; 1;
			if (a[i] &lt; best[m])
				l = m;
			else
				r = m;
		}
		dp[i] = l + 1;
		best[dp[i]] = a[i];
	}

	int len = *max_element(dp, dp + n);
	int nQ;
	scanf("%d", &amp;nQ);
	while (nQ--) {
		int L;
		scanf("%d", &amp;L);
		if (L &gt; len) {
			puts("Impossible");
		} else {
			int last = -1;
			bool first = true;
			for (int i = 0; i &lt; n; ++i) {
				if (a[i] &gt; last &amp;&amp; dp[i] &gt;= L) {
					if (!first)
						printf(" ");
					first = false;
					printf("%d", a[i]);
					--L;
					last = a[i];
					if (!L)
						break;
				}
			}
			printf("\n");
		}
	}
}
<pre><h2>Problem1047</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1,maxn=1000+10;
using namespace std;
void scan(int&amp;ret)
{
    char c;
    while(c=getchar(),c&lt;'0'||c&gt;'9');
    ret=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')ret=ret*10+c-'0';
}
int a,b,n,M[maxn][maxn];
void Init()
{
    scanf("%d%d%d",&amp;a,&amp;b,&amp;n);
    rep(i,a)rep(j,b)scan(M[i][j]);
}
struct node
{
    int val,pos;
    node(){}
    node(int _val,int _pos):
        val(_val),pos(_pos){}
};
struct MonoQueue
{
    node Q[maxn];
    int h,t;
    void clear()
    {
        h=t=0;
    }
    void add(node x)
    {
        while(h&lt;t&amp;&amp;x.val&lt;Q[t-1].val)
            t--;
        Q[t++]=x;
    }
    int get(int now)
    {
        while(h&lt;t&amp;&amp;now-Q[h].pos&gt;=n)h++;
        return Q[h].val;
    }
};
int Max[maxn][maxn],Min[maxn][maxn];
MonoQueue MQ[maxn],Q;
void Cal(int Out[maxn][maxn])
{
    rep(i,b)MQ[i].clear();
    static int A[maxn];
    rep(i,a)
    {
        rep(j,b)
        {
            MQ[j].add(node(M[i][j],i));
            A[j]=MQ[j].get(i);
        }
        if(i&gt;=n-1)
        {
            Q.clear();
            rep(j,b)
            {
                Q.add(node(A[j],j));
                if(j&gt;=n-1)
                    Out[i][j]=Q.get(j);
            }
        }
    }
}
void Solve()
{
    Cal(Min);
    rep(i,a)rep(j,b)M[i][j]*=-1;
    Cal(Max);
    int d=inf;
    for(int i=n-1;i&lt;a;i++)
        for(int j=n-1;j&lt;b;j++)
        {
            int nd=Min[i][j]+Max[i][j];
            nd*=-1;
            if(nd&lt;d)d=nd;
        }
    cout&lt;&lt;d&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


<pre><h2>Problem1048</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,a,b) for(int i=a;i&lt;=b;i++)
#define tr(i,x) for(typeof(x.begin()) i=x.begin();i!=x.end();i++)
#define all(x) x.begin(),x.end()
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;2,maxn=10+2;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef pair&lt;int,int&gt; ii;
typedef long long ll;
struct Inter
{
    int l,r;
    Inter(int _l,int _r):
        l(_l),r(_r){}
};
int Mem[maxn][maxn][maxn][maxn][maxn];
int Sum[maxn][maxn]={},a,b,n;
int sum(Inter x,Inter y)
{
    return Sum[x.r][y.r]-Sum[x.l-1][y.r]-Sum[x.r][y.l-1]+Sum[x.l-1][y.l-1];
}
int Dp(Inter x,Inter y,int n)
{
    int&amp;mem=Mem[x.l][x.r][y.l][y.r][n];
    if(mem!=-1)return mem;
    if(n==1)return mem=sum(x,y)*sum(x,y);
    //split the x
    mem=inf;
    for(int s=x.l;s&lt;x.r;s++)
        for(int c=1;c&lt;n;c++)
        {
            int ret=Dp(Inter(x.l,s),y,c)+
            Dp(Inter(s+1,x.r),y,n-c);
            if(ret&lt;mem)mem=ret;
        }
    //split the y
    for(int s=y.l;s&lt;y.r;s++)
        for(int c=1;c&lt;n;c++)
        {
            int ret=Dp(x,Inter(y.l,s),c)+
            Dp(x,Inter(s+1,y.r),n-c);
            if(ret&lt;mem)mem=ret;
        }
    return mem;
}
void Init()
{
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;n;
    for(int i=1;i&lt;=a;i++)
        for(int j=1;j&lt;=b;j++)
        {
            cin&gt;&gt;Sum[i][j];
            Sum[i][j]+=Sum[i-1][j]+Sum[i][j-1]-Sum[i-1][j-1];
        }
}
int main()
{
    //freopen("in.cpp","r",stdin);
    //freopen("out.cpp","w",stdout);
    Init();
    memset(Mem,-1,sizeof Mem);
    int t=Dp(Inter(1,a),Inter(1,b),n);
    double aug=(double)Sum[a][b]/n;
    double ans=t-aug*aug*n;
    ans/=n;ans=sqrt(ans);
    printf("%0.2lf\n",ans);
}
<pre><h2>Problem1050</h2><pre>/*
 *  [HAOI2007]旅行comf.cpp
 *
 *  Created on: 2011-5-20
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;utility&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VERTICES = 500 + 10;
const int MAX_N_EDGES = 5000 + 10;

int S, T;
int nVertices, nEdges;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

pair&lt;int, pair&lt;int, int&gt; &gt; edges[MAX_N_EDGES];

int F[MAX_N_VERTICES];
int find(int x) {
	if (F[x] == x)
		return x;
	return F[x] = find(F[x]);
}

void unite(int a, int b) {
	a = find(a);
	b = find(b);
	F[a] = b;
}

bool query(int a, int b) {
	return find(a) == find(b);
}

int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}

bool inTree[MAX_N_EDGES];
int main() {
	scanInt(nVertices);
	scanInt(nEdges);
	for (int i = 0; i &lt; nEdges; ++i) {
		int x, y, v;
		scanInt(x);
		scanInt(y);
		scanInt(v);
		--x;
		--y;
		edges[i] = make_pair(v, make_pair(x, y));
	}
	scanInt(S);
	scanInt(T);
	--S;
	--T;

	sort(edges, edges + nEdges);

	int r = 0;
	bool has = false;
	int A, B;//B/A
	for (int l = 0; l &lt; nEdges; ++l) {
		int r = l;
		for (int i = 0; i &lt; nVertices; ++i) {
			F[i] = i;
		}
		while (r &lt; nEdges) {
			if (query(S, T))
				break;
			unite(edges[r].second.first, edges[r].second.second);
			++r;
		}
		if (query(S, T)) {
			int cA = edges[l].first, cB = edges[r - 1].first;
			if (!has) {
				A = cA, B = cB;
				has = true;
			} else {
				if (cB * A &lt; B * cA) {
					A = cA, B = cB;
				}
			}
		}
	}

	if (!has)
		puts("IMPOSSIBLE");
	else {
		int g = gcd(A, B);
		A /= g;
		B /= g;
		cout &lt;&lt; B;
		if (A &gt; 1) {
			cout &lt;&lt; "/" &lt;&lt; A;
		}
		cout &lt;&lt; endl;
	}
}
<pre><h2>Problem1051</h2><pre>var v,f,getout:array[1..10000] of longint;
    next,p,x,y:array[1..50000] of longint;
    i,count,ans,num,n,m,l:longint;
procedure dfs(x:longint);
begin
v[x]:=1;
while p[x]&lt;&gt;0 do
 begin
  if v[y[p[x]]]=0
   then dfs(y[p[x]]);
  p[x]:=next[p[x]];
 end;
inc(count);
f[count]:=x;
end;
procedure backdfs(i:longint);
begin
v[i]:=count;
 while p[i]&lt;&gt;0 do
  begin
   if v[x[p[i]]]=0
    then backdfs(x[p[i]]);
   p[i]:=next[p[i]];
  end;
end;
begin
read(n,m);
for i:=1 to m do
 read(x[i],y[i]);
fillchar(next,sizeof(next),0);
fillchar(p,sizeof(p),0);
for i:=1 to m do
 begin
  next[i]:=p[x[i]];
  p[x[i]]:=i;
 end;
fillchar(v,sizeof(v),0);
count:=0;
for i:=1 to n do
 if v[i]=0
  then dfs(i);

fillchar(v,sizeof(v),0);
fillchar(next,sizeof(next),0);
fillchar(p,sizeof(p),0);
count:=0;
for i:=1 to m do
 begin
  next[i]:=p[y[i]];
  p[y[i]]:=i;
 end;
for i:=n downto 1 do
 if v[f[i]]=0
  then begin
        inc(count);
        backdfs(f[i]);
       end;
for i:=1 to m do
 if v[x[i]]&lt;&gt;v[y[i]]
  then inc(getout[v[x[i]]]);
ans:=0;num:=0;
for i:=1 to count do
 if getout[i]=0
  then begin
        inc(num);
        l:=i;
       end;
if num=1 then
for i:=1 to n do
 if v[i]=l
  then inc(ans);
writeln(ans);
end.<pre><h2>Problem1051</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;stack&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=10000;
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator it;
int ord[maxn],low[maxn],cnt=0,id[maxn],snt=0,n,m;
bool inStack[maxn]={0};
stack&lt;int&gt; Stack;
void dfs(int x)
{
    ord[x]=low[x]=cnt++;
    inStack[x]=true;Stack.push(x);
    for(it i=E[x].begin();i!=E[x].end();++i)
    {
        if(ord[*i]==-1)
            dfs(*i),low[x]=min(low[x],low[*i]);
        else if(inStack[*i]) low[x]=min(low[x],ord[*i]);
    }
    if(ord[x]==low[x])
    {
        int u;do{u=Stack.top();Stack.pop();id[u]=snt;inStack[u]=false;}while(u!=x);
        snt++;
    }
}
int Num[maxn]={0},In[maxn]={0};
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;int s,t;
    while(m--) scanf("%d %d",&amp;s,&amp;t),E[t-1].pb(s-1);
    rep(i,n) ord[i]=-1;
    rep(i,n)if(ord[i]==-1) dfs(i);
    rep(i,n){
        int own=id[i];for(it e=E[i].begin();e!=E[i].end();++e)if(id[*e]!=own) In[id[*e]]++;
        Num[own]++;
    }
    t=0;int ans=0;rep(i,snt)if(In[i]==0) ++t,ans+=Num[i];
    if(t&gt;1)cout&lt;&lt;0&lt;&lt;endl;
    else cout&lt;&lt;ans&lt;&lt;endl;
}
<pre><h2>Problem1052</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1,maxn=20000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline void checkmin(int&amp;x,int c){if(x&gt;c)x=c;}
inline void checkmax(int&amp;x,int c){if(x&lt;c)x=c;}
int N;
struct Point
{
    int x[2];//0:x 1:y
}P[maxn];
struct Inter
{
    int x[2];//0:l 1:r
    int size()
    {
        return x[1]-x[0];
    }
    Inter(){}
    Inter(int l,int r)
    {
        x[0]=l;x[1]=r;
    }
    bool contain(int _x)const
    {
        return _x&gt;=x[0]&amp;&amp;_x&lt;=x[1];
    }
    void putIn(int _x)
    {
        checkmin(x[0],_x);
        checkmax(x[1],_x);
    }
    void Show()
    {
        rep(i,2)cout&lt;&lt;x[i]&lt;&lt;" ";cout&lt;&lt;endl;
    }
};
struct Rec
{
    Inter I[2];//0:x 1:y
    Rec(){}
    Rec(int x1,int y1,int x2,int y2)
    {
        I[0]=Inter(x1,x2);
        I[1]=Inter(y1,y2);
    }
    Rec(Point a,Point b)
    {
        rep(i,2)I[i]=Inter(a.x[i],b.x[i]);
    }
    bool contain(Point t)const
    {
        rep(i,2)if(!I[i].contain(t.x[i]))return false;
        return true;
    }
    void putIn(Point t)
    {
        rep(i,2)I[i].putIn(t.x[i]);
    }
    void Show()
    {
        rep(i,2)I[i].Show();
    }
};
Inter BuildInter(const Rec&amp;All,int type,int a,int L)
{
    int val=All.I[type].x[a];
    if(a)
        return Inter(val-L,val);
    else
        return Inter(val,val+L);
}
Rec BuildRec(const Rec&amp;All,int a,int b,int L)
{
    Rec ret;
    ret.I[0]=BuildInter(All,0,a,L);
    ret.I[1]=BuildInter(All,1,b,L);
    return ret;
}
int Mark[maxn]={};
bool getRec(Rec&amp;remain)
{
    bool has=false;
    rep(i,N)
    {
        if(Mark[i])continue;
        if(!has)remain=Rec(P[i],P[i]),has=true;
        else remain.putIn(P[i]);
    }
    return has;
}
void MarkRec(const Rec&amp;a)
{
    rep(i,N)
    {
        if(a.contain(P[i]))
            Mark[i]++;
    }
}
void UnMarkRec(const Rec&amp;a)
{
    rep(i,N)
    {
        if(a.contain(P[i]))
            Mark[i]--;
    }
}
Rec All;
bool Check(int L)
{
    memset(Mark,0,sizeof Mark);
    rep(a,2)rep(b,2)
    {
        Rec A=BuildRec(All,a,b,L);
        MarkRec(A);
        Rec Remain;if(!getRec(Remain))return true;
        rep(c,2)rep(d,2)
        {
            Rec B=BuildRec(Remain,c,d,L);
            MarkRec(B);
            Rec C;if(!getRec(C))return true;
            bool ok=true;
            rep(i,2) if(C.I[i].size()&gt;L)ok=false;
            if(ok)return true;
            UnMarkRec(B);
        }
        UnMarkRec(A);
    }
    return false;
}
void Init()
{
    cin&gt;&gt;N;
    rep(i,N)
    {
        scanf("%d%d",&amp;P[i].x[0],&amp;P[i].x[1]);
    }
}
void PreCondition()
{
    getRec(All);
}
void Solve()
{
    int l=-1,r=max(All.I[0].size(),All.I[1].size());
    while(l+1&lt;r)
    {
        int m=l+r&gt;&gt;1;
        if(Check(m))
            r=m;
        else
            l=m;
    }
    cout&lt;&lt;r&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    PreCondition();
    Solve();
}
<pre><h2>Problem1053</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxp=1000;
int Ps[maxp],pnt=0,N;
typedef long long ll;
bool IsPrime(int p)
{
    if(p==2)return true;
    if(p%2==0) return false;
    for(int i=3;i*i&lt;=p;i+=2)if(p%i==0) return false;
    return true;
}
struct Answer
{
    int ans,num;
    Answer(){ans=1;num=1;}
    void Update(const Answer&amp;a)
    {
        if(a.ans&gt;ans||(a.ans==ans&amp;&amp;a.num&lt;num)) *this=a;
    }
    Answer Mul(int x,int c)
    {
        Answer ret;
        ret.ans=ans*(c+1);
        ret.num=num*x;
        return ret;
    }
}Ans;
void GetPrime()
{
    for(int i=2;i&lt;maxp&amp;&amp;pnt&lt;9;i++) if(IsPrime(i)) Ps[pnt++]=i;
}
void dfs(int now,int pre,ll N,Answer a)
{
    if(N&lt;Ps[now]||now&gt;=pnt||!pre){Ans.Update(a);return;}
    ll s=1;rep(i,pre) s*=Ps[now];
    for(int i=pre;i&gt;=0;--i)
    {
        if(s&lt;=N)dfs(now+1,i,N/s,a.Mul(s,i));
        s/=Ps[now];
    }
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    cin&gt;&gt;N;
    GetPrime();
    dfs(0,15,N,Answer());
    long long k=1;
    cout&lt;&lt;Ans.num&lt;&lt;endl;
}
<pre><h2>Problem1054</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1;
using namespace std;
struct State
{
    int c;
    void ReadIn()
    {
        char t;c=0;
        rep(i,4)
        {
            scanf("\n\n");
            rep(j,4)cin&gt;&gt;t,c&lt;&lt;=1,c+=t-'0';
        }
    }
    int get(int i,int j)
    {
        return c&gt;&gt;(i*4+j)&amp;1;
    }
    void change(int i,int j)
    {
        c^=1&lt;&lt;(i*4+j);
    }
    bool operator==(const State&amp;s)const
    {
        return c==s.c;
    }
}S,T;
int Dp[1&lt;&lt;16];
int main()
{
    //freopen("in","r",stdin);
    rep(i,1&lt;&lt;16)Dp[i]=-1;
    S.ReadIn();T.ReadIn();
    queue&lt;State&gt; Q;Q.push(S);Dp[S.c]=0;
    while(Q.size())
    {
        State t=Q.front();Q.pop();int c=Dp[t.c];
        if(t==T){cout&lt;&lt;c&lt;&lt;endl;return 0;}
        rep(i,4)rep(j,4)
        {
            if(t.get(i,j))
            {
                t.change(i,j);
                if(i&amp;&amp;!t.get(i-1,j))
                {
                    t.change(i-1,j);
                    if(Dp[t.c]==-1)Dp[t.c]=c+1,Q.push(t);
                    t.change(i-1,j);
                }
                if(i+1&lt;4&amp;&amp;!t.get(i+1,j))
                {
                    t.change(i+1,j);
                    if(Dp[t.c]==-1)Dp[t.c]=c+1,Q.push(t);
                    t.change(i+1,j);
                }
                if(j&amp;&amp;!t.get(i,j-1))
                {
                    t.change(i,j-1);
                    if(Dp[t.c]==-1)Dp[t.c]=c+1,Q.push(t);
                    t.change(i,j-1);
                }
                if(j+1&lt;4&amp;&amp;!t.get(i,j+1))
                {
                    t.change(i,j+1);
                    if(Dp[t.c]==-1)Dp[t.c]=c+1,Q.push(t);
                    t.change(i,j+1);
                }
                t.change(i,j);
            }
        }
    }
}


<pre><h2>Problem1055</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxl=200+1;
int Map[256],D[4],L[4][16],R[4][16];
char Name[10]="WING";
char str[maxl];
bool S[maxl][maxl][4]={0};
bool Dp[maxl][maxl][4];
bool Check(int l,int r,int a)
{
    bool&amp;x=Dp[l][r][a];
    if(S[l][r][a]) return x;
    S[l][r][a]=true;
    if(l==r) return x=(str[l]==Name[a]);
    for(int k=l;k&lt;r;k++)
        rep(i,D[a]) if(Check(l,k,L[a][i])&amp;&amp;Check(k+1,r,R[a][i])) return x=true;
    return x=false;
}
int main()
{
    //freopen("in","r",stdin);
    Map['W']=0;Map['I']=1;Map['N']=2;Map['G']=3;
    rep(i,4)cin&gt;&gt;D[i];char l,r;
    rep(i,4)rep(j,D[i]) cin&gt;&gt;l&gt;&gt;r,L[i][j]=Map[l],R[i][j]=Map[r];
    cin&gt;&gt;str;int len=strlen(str);bool c=false;
    rep(i,4)if(Check(0,len-1,i))cout&lt;&lt;Name[i],c=true;
    if(!c)cout&lt;&lt;"The name is wrong!";
}
<pre><h2>Problem1056</h2><pre>/*
 * [Zjoi2006]GameZ????????????.cpp
 *
 *  Created on: 2011-3-4
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;cstdlib&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int INF = ~0U &gt;&gt; 1;
int globalTime = 0;
const int SEED = 133331;
const int MAX_LEN=10+1;

struct Node {
	int size;
	int score, time;
	char name[MAX_LEN];
	Node*ch[2], *p;
	Node() {
		size = 0;
	}
	void set(Node*c, bool d) {
		ch[d] = c;
		c-&gt;p = this;
	}
	bool dir() {
		return this == p-&gt;ch[1];
	}
	void update() {
		size = ch[0]-&gt;size + ch[1]-&gt;size + 1;
	}
} nullData, *null = &amp;nullData;

Node*newNode(int score,const char name[]) {
	Node*t = new Node;
	t-&gt;ch[0] = t-&gt;ch[1] = null;
	t-&gt;size = 1;
	t-&gt;score = score;
	strcpy(t-&gt;name,name);
	return t;
}

void clear(Node*t) {
	t-&gt;ch[0] = t-&gt;ch[1] = null;
	t-&gt;size = 1;
}

int hashCode(const char name[]) {
	const char*it=name;
	int code=0;
	while(*it!='\0')
		code=code*SEED+*it++;
	return code;
}

map&lt;int, Node*&gt; nameToNode;

Node* getId(const char name[]) {
	int code = hashCode(name);
	if (nameToNode.count(code))
		return nameToNode[code];
	Node*t = newNode(-INF, name);
	return nameToNode[code] = t;
}

bool compare(Node*a, Node*b) {
	if (a-&gt;score != b-&gt;score)
		return a-&gt;score &gt; b-&gt;score;
	return a-&gt;time &lt; b-&gt;time;
}

struct Splay {
	Node*root;

	void rotate(Node*t) {
		Node*p = t-&gt;p;
		bool d = t-&gt;dir();
		p-&gt;p-&gt;set(t, p-&gt;dir());
		p-&gt;set(t-&gt;ch[!d], d);
		t-&gt;set(p, !d);
		p-&gt;update();
		if (root == p)
			root = t;
	}

	void splay(Node*t, Node*f = null) {
		while (t-&gt;p != f) {
			if (t-&gt;p-&gt;p == f)
				rotate(t);
			else
				(t-&gt;dir() == t-&gt;p-&gt;dir()) ? (rotate(t-&gt;p), rotate(t))
						: (rotate(t), rotate(t));
		}
		t-&gt;update();
	}

	Node*getKth(int kth) {
		for (Node*t = root;;) {
			int cnt = t-&gt;ch[0]-&gt;size;
			if (kth == cnt)
				return t;
			t = t-&gt;ch[kth &gt; cnt];
			if (kth &gt; cnt)
				kth -= cnt + 1;
		}
	}

	void insert(Node*ins) {
		clear(ins);
		for (Node*t = root;;) {
			bool dir = compare(t, ins);
			if (t-&gt;ch[dir] == null) {
				t-&gt;set(ins, dir);
				splay(ins);
				return;
			}
			t = t-&gt;ch[dir];
		}
	}

	Node*rightMost(Node*t) {
		while (t-&gt;ch[1] != null)
			t = t-&gt;ch[1];
		return t;
	}

	Node*leftMost(Node*t){
		while (t-&gt;ch[0] != null)
			t=t-&gt;ch[0];
		return t;
	}

	void erase(Node*t) {
		splay(t);
		Node*prev = rightMost(t-&gt;ch[0]);
		Node*next= leftMost(t-&gt;ch[1]);
		splay(prev);
		splay(next,prev);
		next-&gt;set(null,0);
		splay(next);
	}

	void write(Node*t) {
		if (t == null)
			return;
		write(t-&gt;ch[0]);
		//		assert(false);
		printf("%s ",t-&gt;name);
		write(t-&gt;ch[1]);
	}

	void write(int l, int r) {
		//		cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl;
		Node*Left = getKth(l - 1);
		splay(Left);
		Node*Right = getKth(r + 1);
		splay(Right, Left);
		write(Right-&gt;ch[0]);
	}

	int rank(Node*t) {
		splay(t);
		return t-&gt;ch[0]-&gt;size;
	}

	Splay() {
		char name[MAX_LEN]="?";
		Node*begin = newNode(INF,name);
		root = begin;
		root-&gt;p = null;
		Node*end = newNode(-INF,name);
		begin-&gt;set(end, 1);
		splay(end);
	}

	int size() {
		return root-&gt;size - 2;
	}
};

void solve() {
	Splay*splay = new Splay;

	int nOpt;
	scanf("%d", &amp;nOpt);
	char name[MAX_LEN];
	for (int step = 0; step &lt; nOpt; ++step) {
		scanf(" ");
		char cmd;
		while(cmd=getchar(),cmd!='+' &amp;&amp; cmd !='?');
		Node*t;
		//		cout&lt;&lt;splay-&gt;size()&lt;&lt;endl;
		//		cout &lt;&lt; cmd &lt;&lt; endl;
		switch (cmd) {
		case '+':
			scanf(" ");
			scanf("%s",name);
			//			cout &lt;&lt; name &lt;&lt; endl;
			int score;
			scanf("%d", &amp;score);
			t = getId(name);
			if (t-&gt;score == -INF) {
				t-&gt;score = score;
				t-&gt;time = globalTime++;
				splay-&gt;insert(t);
			} else {
				splay-&gt;erase(t);
				t-&gt;score = score;
				t-&gt;time = globalTime++;
				splay-&gt;insert(t);
			}
			break;
		case '?':
			int index;
			char c;
			while(c=getchar(),c==' '||c=='\n');
			ungetc(c,stdin);
			if (isdigit(c)) {
				scanf("%d",&amp;index);
				int l = index;
				int r = min(l + 9, splay-&gt;size());
				splay-&gt;write(l, r);
				printf("\n");
			} else {
				scanf("%s",name);
				t = getId(name);
				printf("%d\n", splay-&gt;rank(t));
			}
			break;
		default:
			break;
		}
	}
}

int main() {
//	freopen("in","r",stdin);
//	runTest();
//	cout&lt;&lt;INF&lt;&lt;endl;
	solve();
}
<pre><h2>Problem1057</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int inf=~0U&gt;&gt;1;
int n,m;
int MaxS=0,MaxR=0;
const int maxn=2000+10;
int Line[maxn]={0};
int H[maxn]={0};
void ReadLine()
{
    int x;
    for(int i=1;i&lt;=m;i++)
    {
        scanf("%d",&amp;x);
        if(x!=Line[i])H[i]++;
        else H[i]=1;
        Line[i]=x;
    }
}
void Renew(int a,int b)
{
    if(a&gt;b) swap(a,b);
    MaxS=max(MaxS,a*a);
    MaxR=max(MaxR,a*b);
}
void CalLine()
{
    static int L[maxn],R[maxn];
    for(int i=1;i&lt;=m;++i)
    {
        L[i]=i-1;
        while(L[i]&amp;&amp;H[L[i]]&gt;=H[i]&amp;&amp;Line[L[i]+1]!=Line[L[i]])
            L[i]=L[L[i]];
    }
    for(int i=m;i&gt;=1;--i)
    {
        R[i]=i+1;
        while(R[i]&lt;=m&amp;&amp;H[R[i]]&gt;=H[i]&amp;&amp;Line[R[i]]!=Line[R[i]-1])
            R[i]=R[R[i]];
    }
    for(int i=1;i&lt;=m;i++) Renew(H[i],R[i]-L[i]-1);
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d %d",&amp;n,&amp;m);
    rep(i,n)ReadLine(),CalLine();
    cout&lt;&lt;MaxS&lt;&lt;endl&lt;&lt;MaxR&lt;&lt;endl;
}
<pre><h2>Problem1057</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
int n,m,MaxS=0,MaxR=0;
const int maxn=2000+10;
int Line[maxn]={0};
int H[maxn]={0};
void ReadLine()
{
    int x;
    for(int i=1;i&lt;=m;i++)
    {
        scanf("%d",&amp;x);
        if(x!=Line[i])H[i]++;
        else H[i]=1;
        Line[i]=x;
    }
}
void Renew(int a,int b)
{
    if(a&gt;b) swap(a,b);
    MaxS=max(MaxS,a*a);
    MaxR=max(MaxR,a*b);
}
void CalLine()
{
    static int L[maxn],R[maxn];
    for(int i=1;i&lt;=m;++i)
    {
        L[i]=i-1;
        while(L[i]&amp;&amp;H[L[i]]&gt;=H[i]&amp;&amp;Line[L[i]+1]!=Line[L[i]])
            L[i]=L[L[i]];
    }
    for(int i=m;i&gt;=1;--i)
    {
        R[i]=i+1;
        while(R[i]&lt;=m&amp;&amp;H[R[i]]&gt;=H[i]&amp;&amp;Line[R[i]]!=Line[R[i]-1])
            R[i]=R[R[i]];
    }
    for(int i=1;i&lt;=m;i++) Renew(H[i],R[i]-L[i]-1);
}
int main()
{
    scanf("%d %d",&amp;n,&amp;m);
    rep(i,n)ReadLine(),CalLine();
    cout&lt;&lt;MaxS&lt;&lt;endl&lt;&lt;MaxR&lt;&lt;endl;
}
<pre><h2>Problem1058</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define For(i,a,b) for(int i=a;i&lt;b;i++)
using namespace std;
const int inf=~0U&gt;&gt;2;
const int maxn=500000;int n;
int A[maxn];
vector&lt;int&gt; List[maxn];
inline int abs(int x){return x&gt;0?x:-x;}
struct qset
{
    multiset&lt;int&gt; S;
    typedef set&lt;int&gt;::iterator it;
    int Min;
    qset(){Min=inf;}
    void ins(int x)
    {
        it j=S.insert(x);
        if(j!=S.begin())
            Min=min(Min,x-*(--j)),++j;
        ++j;
        if(j!=S.end())
            Min=min(Min,*(j)-x);
    }
}All;
struct state
{
    bool inside;
    int i,x,val;
    state(bool _inside,int _val,int _i=0,int _x=0):
        inside(_inside),i(_i),x(_x),val(_val){}
    bool legal() const
    {
        return inside||(x==List[i].size()-1);
    }
    bool operator&lt;(const state&amp;o) const
    {
        return val&gt;o.val;
    }
};
priority_queue&lt;state&gt; Q;
void ins(int i,int x)
{
    All.ins(x);
    List[i].pb(x);
    int n=List[i].size()-1;
    Q.push(state(true,abs(x-List[i][n-1])));
    if(i!=::n-1)
        Q.push(state(false,abs(List[i+1].front()-x),i,n));
}
int get()
{
    while(!Q.top().legal()) Q.pop();
    return Q.top().val;
}
int main()
{
    //freopen("in","r",stdin);
    char cmd[100];
    int n,m,x,i;
    scanf("%d %d",&amp;n,&amp;m);
    rep(i,n) scanf("%d",A+i),All.ins(A[i]),List[i].pb(A[i]);
    For(i,0,n-1)
    {
        Q.push(state(false,abs(A[i+1]-A[i]),i,0));
    }
    while(m--)
    {
        scanf("\n");
        scanf("%s",cmd);
        if(cmd[0]=='I')
        {
            scanf("%d %d",&amp;i,&amp;x);
            ins(i-1,x);
        }
        else if(cmd[4]=='G')
        {
            printf("%d\n",get());
        }
        else
        {
            printf("%d\n",All.Min);
        }
    }
}
<pre><h2>Problem1058</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define For(i,a,b) for(int i=a;i&lt;b;i++)
using namespace std;
const int inf=~0U&gt;&gt;2;
const int maxn=500000;int n;
int L[maxn][2];
int N[maxn];
inline int abs(int x){return x&gt;0?x:-x;}
struct qset
{
    multiset&lt;int&gt; S;
    typedef set&lt;int&gt;::iterator it;
    int Min;
    qset(){Min=inf;}
    void ins(int x)
    {
        it j=S.insert(x);
        if(j!=S.begin())
            Min=min(Min,x-*(--j)),++j;
        ++j;
        if(j!=S.end())
            Min=min(Min,*(j)-x);
    }
}All;
struct state
{
    bool in;
    int i,x,val;
    state(bool _in,int _val,int _i=0,int _x=0):
        in(_in),i(_i),x(_x),val(_val){}
    bool legal() const{return in||x==N[i];}
    bool operator&lt;(const state&amp;o) const{return val&gt;o.val;}
};
priority_queue&lt;state&gt; Q;
void ins(int i,int x)
{
    All.ins(x);
    Q.push(state(true,abs(x-L[i][1])));
    L[i][1]=x;N[i]++;
    if(i!=n-1) Q.push(state(false,abs(L[i+1][0]-x),i,N[i]));
}
int get()
{
    while(!Q.top().legal()) Q.pop();
    return Q.top().val;
}
int main()
{
    char cmd[100];
    int n,m,x,i;
    scanf("%d %d",&amp;n,&amp;m);
    rep(i,n) scanf("%d",&amp;L[i][0]),L[i][1]=L[i][0],All.ins(L[i][0]),N[i]=1;
    For(i,0,n-1)
    {
        Q.push(state(false,abs(L[i+1][0]-L[i][0]),i,1));
    }
    while(m--)
    {
        scanf("\n");
        scanf("%s",cmd);
        if(cmd[0]=='I')
            scanf("%d %d",&amp;i,&amp;x),ins(i-1,x);
        else if(cmd[4]=='G') printf("%d\n",get());
        else printf("%d\n",All.Min);
    }
}
<pre><h2>Problem1059</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,a,b) for(int i=a;i&lt;=b;i++)
#define tr(i,x) for(vector&lt;int&gt;::iterator i=x.begin();i!=x.end();i++)
#define all(x) x.begin(),x.end()
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef pair&lt;int,int&gt; ii;
const int maxn=200;
int n;
vi E[maxn];
bool vis[maxn];
int Link[maxn];
bool dfs(int x)
{
    if(vis[x])return false;
    vis[x]=true;
    tr(i,E[x])if(Link[*i]==-1||dfs(Link[*i]))
        return Link[*i]=x,true;
    return false;
}
void Work()
{
    cin&gt;&gt;n;
    rep(i,n)E[i].clear(),Link[i]=-1;int x;
    rep(i,n)rep(j,n)if((scanf("%d",&amp;x),x)==1) E[i].pb(j);
    rep(i,n)
    {
        memset(vis,0,sizeof(vis));
        if(!dfs(i)){cout&lt;&lt;"No"&lt;&lt;endl;return;}
    }
    cout&lt;&lt;"Yes"&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    int t;cin&gt;&gt;t;
    rep(i,t)Work();
}
<pre><h2>Problem1061</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;deque&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=1000+10,maxm=20000*2,inf=0x3F3F3F3F;
int mnt=0;
int c[maxm],u[maxm],t[maxm],nxt[maxm];
int head[maxn];
void AddEdge(int s,int _t,int _u,int _c)
{
    c[mnt]=_c;t[mnt]=_t;u[mnt]=_u;
    nxt[mnt]=head[s];head[s]=mnt;
    mnt++;
}
void InsEdge(int s,int t,int u,int c)
{
    AddEdge(s,t,u,c);
    AddEdge(t,s,0,-c);
}
int vis[maxn]={0},flag=0;
int piS=0,cost=0,vs,vt,v;
int aug(int no,int m)
{
    if(no==vt) return cost+=piS*m,m;
    vis[no]=flag;
    int l=m;
    for(int e=head[no];e!=-1;e=nxt[e])
        if(u[e]&amp;&amp;!c[e]&amp;&amp;vis[t[e]]!=flag)
        {
            int d=aug(t[e],min(l,u[e]));
            u[e]-=d;u[e^1]+=d;l-=d;
            if(!l)return m;
        }
    return m-l;
}
bool mod()
{
    static int D[maxn];memset(D,0x3F,sizeof D);D[vt]=0;
    static deque&lt;int&gt; Q;Q.push_back(vt);
    while(Q.size())
    {
        int dt,no=Q.front();Q.pop_front();
        for(int e=head[no];e!=-1;e=nxt[e])
            if(u[e^1]&amp;&amp;(dt=D[no]-c[e])&lt;D[t[e]])
                (D[t[e]]=dt)&lt;=D[Q.size()?Q.front():0]
                    ?Q.push_front(t[e]):Q.push_back(t[e]);
    }
    rep(i,v)
       for(int e=head[i];e!=-1;e=nxt[e])
           c[e]+=D[t[e]]-D[i];
    piS+=D[vs];
    return D[vs]&lt;inf;
}
int CalCostFlow()
{
    while(mod())
        do ++flag;
        while(aug(vs,inf));
    return cost;
}
int A[maxn]={};
int main()
{
    //freopen("in","r",stdin);
    int n,m,s,t,c;
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)scanf("%d",A+i);
    vs=n+2;vt=vs+1;v=vt+1;
    memset(head,-1,sizeof head);
    rep(i,m)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);
        InsEdge(s,t+1,inf,c);
    }
    for(int i=1;i&lt;=n+1;i++)
    {
        InsEdge(vs,i,A[i],0);
        InsEdge(i,vt,A[i-1],0);
        InsEdge(i,i-1,inf,0);
    }
    printf("%d\n",CalCostFlow());
}
<pre><h2>Problem1063</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
using namespace std;
const int maxn=100000+10,maxans=10+1;
vector&lt;int&gt; E[maxn];
typedef long long ll;
void InsEdge(int s,int t)
{
    E[s].pb(t);E[t].pb(s);
}
int Q[maxn],F[maxn],h,t,n,m,p;
ll Dp[maxn][3][maxans];
void BFS(int vs)
{
    for(h=t=0,Q[t++]=vs,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,E[x])if(*e!=F[x])
        {
            Q[t++]=*e;
            F[*e]=x;
        }
    }
}
bool Init()
{
    scanf("%d%d%d",&amp;n,&amp;m,&amp;p);
    if(m!=n-1)return false;
    int s,t;
    rep(i,m)
    {
        scanf("%d %d",&amp;s,&amp;t);
        --s;--t;
        InsEdge(s,t);
    }
    return true;
}
void Solve()
{
    for(int i=n-1;i&gt;=0;i--)
    {
        int x=Q[i];
        ll r0,r1;
        //r0 means the edge needn't be choose,r1 means you must choose
        rep(j,maxans)
        {
            rep(k,3)Dp[x][k][j]=0;
            Dp[x][0][j]=1;
            tr(e,E[x])if(*e!=F[x])
            {
                if(!j)r0=0;
                else r0=Dp[*e][0][j-1]+Dp[*e][1][j-1]+Dp[*e][2][j-1];
                r1=Dp[*e][0][j]+Dp[*e][1][j];
                Dp[x][2][j]=Dp[x][2][j]*r0+Dp[x][1][j]*r1;
                Dp[x][1][j]=Dp[x][1][j]*r0+Dp[x][0][j]*r1;
                Dp[x][0][j]*=r0;
                rep(k,3)if(Dp[x][k][j]&gt;0)
                {
                    if(Dp[x][k][j]%p)Dp[x][k][j]%=p;
                    else Dp[x][k][j]=p;
                }
            }
        }
    }
    rep(i,maxans)
    {
        ll ret=0;
        rep(k,3)ret+=Dp[0][k][i];
        if(ret&gt;0)
        {
            cout&lt;&lt;i&lt;&lt;endl;
            ret%=p;
            cout&lt;&lt;ret&lt;&lt;endl;
            return;
        }
    }
}
int main()
{
    //freopen("in","r",stdin);
    if(!Init())
    {
        puts("-1");
        puts("-1");
        return 0;
    }
    BFS(0);
    Solve();
}
<pre><h2>Problem1064</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;Edge&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1,maxn=100000;
using namespace std;
struct Edge
{
    int t,c;
    Edge(int _t,int _c):
        t(_t),c(_c){}
};
int n,m;
vector&lt;Edge&gt; E[maxn];
void AddEdge(int a,int b)//a can see b
{
    E[a].pb(Edge(b,1));
    E[b].pb(Edge(a,-1));
}
int gcd(int a,int b)
{
    return b?gcd(b,a%b):a;
}
bool Vis[maxn]={};
int Mark[maxn];
int Len,MaxMark,MinMark;
void Dfs(int at)
{
    Vis[at]=true;
    MaxMark=max(MaxMark,Mark[at]);
    MinMark=min(MinMark,Mark[at]);
    tr(e,E[at])
        if(!Vis[e-&gt;t])
        {
            Mark[e-&gt;t]=Mark[at]+e-&gt;c;
            Dfs(e-&gt;t);
        }
        else
        {
            int diff=Mark[at]+e-&gt;c-Mark[e-&gt;t];
            if(!diff)continue;
            if(diff&lt;0)diff*=-1;
            if(!Len)Len=diff;
            else Len=gcd(Len,diff);
        }
}
void Init()
{
    cin&gt;&gt;n&gt;&gt;m;int s,t;
    rep(i,m)
    {
        scanf("%d %d",&amp;s,&amp;t);--s;--t;
        AddEdge(s,t);
    }
}
void Solve()
{
    Len=0;
    int ans;
    rep(i,n)if(!Vis[i])
    {
        MaxMark=-inf;
        MinMark=inf;
        Dfs(i);
        ans+=MaxMark-MinMark+1;
    }
    if(Len)
    {
        if(Len&lt;3)puts("-1 -1");
        else
        {
            printf("%d ",Len);
            for(int i=3;i&lt;=Len;i++)
                if(Len%i==0)
                {
                    printf("%d\n",i);
                    break;
                }
        }
    }
    else
    {
        if(ans&gt;=3)
            printf("%d %d\n",ans,3);
        else
            puts("-1 -1");
    }
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


<pre><h2>Problem1065</h2><pre>/*
 * [NOI2008]奥运物流.cpp
 *
 *  Created on: 2011-7-27
 *      Author: mac
 */

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VERTICES = 60 + 1;
int next[MAX_N_VERTICES];
int nVertices, nModifies;
double k;
double C[MAX_N_VERTICES];
double kPow[MAX_N_VERTICES];

void readInput() {
	cin &gt;&gt; nVertices &gt;&gt; nModifies &gt;&gt; k;
	for (int i = 0; i &lt; nVertices; ++i) {
		scanf("%d", next + i);
		--next[i];
	}
	for (int i = 0; i &lt; nVertices; ++i) {
		scanf("%lf", C + i);
	}
}

bool onCircle[MAX_N_VERTICES];
vector&lt;int&gt; ch[MAX_N_VERTICES];

double memo[MAX_N_VERTICES][MAX_N_VERTICES][MAX_N_VERTICES]; //u,dist,nUsed
bool saved[MAX_N_VERTICES][MAX_N_VERTICES]; //u,dist

double*dfs(int u, int dist) {
	if (saved[u][dist])
		return memo[u][dist];
	saved[u][dist] = true;
	double*am = memo[u][dist];
	foreach(iter,ch[u]) {
		int c = *iter;
		double*nam[] = { dfs(c, dist + 1), dfs(c, 1) };
		for (int i = nModifies; i &gt;= 0; --i) {
			double&amp;ret = am[i];
			for (int j = 0; j &lt; 2; ++j) {
				for (int k = 0; k + j &lt;= i; ++k) {
					ret = max(ret, am[i - k - j] + nam[j][k]);
				}
			}
		}
	}
	for (int i = 0; i &lt;= nModifies; ++i) {
		am[i] += kPow[dist] * C[u];
	}
	return am;
}

double doit() {
	memset(onCircle, false, sizeof onCircle);
	memset(memo, 0, sizeof memo);
	memset(saved, false, sizeof saved);

	onCircle[0] = true;
	int len = 1;
	for (int u = next[0]; u != 0; u = next[u]) {
		++len;
		onCircle[u] = true;
	}
	for (int i = 0; i &lt; nVertices; ++i) {
		ch[i].clear();
	}
	for (int i = 0; i &lt; nVertices; ++i) {
		if (!(onCircle[i] &amp;&amp; onCircle[next[i]]))
			ch[next[i]].push_back(i);
	}
	static double*ams[MAX_N_VERTICES];
	ams[0] = dfs(0, 0);
	for (int u = next[0], dist = len - 1; u != 0; u = next[u], --dist) {
		ams[dist] = dfs(u, dist);
	}
	static double g[MAX_N_VERTICES];
	memset(g, 0, sizeof g);
	for (int dist = 0; dist &lt;= len - 1; ++dist) {
		for (int i = nModifies; i &gt;= 0; --i) {
			for (int j = 0; j &lt;= i; ++j) {
				g[i] = max(g[i], g[i - j] + ams[dist][j]);
			}
		}
	}
	double ret = *max_element(g, g + nModifies + 1);
	return ret / (1 - kPow[len]);
}

void work() {
	double ans = doit();
	if (nModifies &gt; 0) {
		--nModifies;
		for (int u = next[0]; u != 0; u = next[u]) {
			int tmp = next[u];
			next[u] = 0;
			ans = max(ans, doit());
			next[u] = tmp;
		}
	}
	printf("%0.2lf\n", ans);
}

void prepare() {
	kPow[0] = 1;
	for (int i = 1; i &lt;= nVertices; ++i) {
		kPow[i] = kPow[i - 1] * k;
	}
}

void solve() {
	readInput();
	prepare();
	work();
}

int main() {
	solve();
	return 0;
}
<pre><h2>Problem1066</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
typedef pair&lt;int,int&gt; ii;
const int inf=~0U&gt;&gt;1,maxn=20,maxv=maxn*maxn*2+2;
int n,m;
inline int In(int i,int j){return (i*m+j)*2;}
inline int Out(int i,int j){return In(i,j)+1;}
struct Edge
{
    int t,c;
    Edge*next,*op;
    Edge(int _t,int _c,Edge*_next):t(_t),c(_c),next(_next){}
}*E[maxv]={0};
int h[maxv],vh[maxv],vs,vt,v;
void InsEdge(int s,int t,int c)
{
    E[s]=new Edge(t,c,E[s]);
    E[t]=new Edge(s,0,E[t]);
    E[s]-&gt;op=E[t];E[t]-&gt;op=E[s];
}
int aug(int no,int m)
{
    if(no==vt) return m;
    int l=m;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;c&amp;&amp;h[no]==h[i-&gt;t]+1)
    {
        int d=aug(i-&gt;t,min(i-&gt;c,l));
        l-=d,i-&gt;c-=d,i-&gt;op-&gt;c+=d;
        if(l==0||h[vs]&gt;=v)return m-l;
    }
    int minh=v;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;c&amp;&amp;h[i-&gt;t]+1&lt;minh)
        minh=h[i-&gt;t]+1;
    if(--vh[h[no]]==0) h[vs]=v;vh[h[no]=minh]++;
    return m-l;
}
int CalFlow()
{
    memset(h,0,sizeof(h));
    memset(vh,0,sizeof(vh));
    vh[0]=v;
    int flow=0;while(h[vs]&lt;v)flow+=aug(vs,inf);
    return flow;
}
inline int Dist(ii a,ii b){return abs(a.first-b.first)+abs(a.second-b.second);}
inline int DistToExit(int x,int y){return min(x+1,min(n-x,min(y+1,m-y)));}
int main()
{
    //freopen("in","r",stdin);
    int x,d,a=0;char c;cin&gt;&gt;n&gt;&gt;m&gt;&gt;d;v=n*m*2+2;vs=v-1;vt=vs-1;
    rep(i,n)rep(j,m){cin&gt;&gt;c;x=c-'0';if(x)InsEdge(In(i,j),Out(i,j),x);}
    rep(i,n)rep(j,m){cin&gt;&gt;c;if(c=='L') InsEdge(vs,In(i,j),1),a++;}
    rep(i,n)rep(j,m)rep(a,n)rep(b,m)if(Dist(ii(i,j),ii(a,b))&lt;=d) InsEdge(Out(i,j),In(a,b),inf);
    rep(i,n)rep(j,m)if(DistToExit(i,j)&lt;=d) InsEdge(Out(i,j),vt,inf);
    cout&lt;&lt;a-CalFlow()&lt;&lt;endl;
}
<pre><h2>Problem1068</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxl=100;
char M[maxl];
bool S[maxl][maxl][2]={0};
int Dp[maxl][maxl][2];
bool Match(int p,int Len,int s)
{
    if(Len%s)return false;
    rep(i,Len)if(M[p+i]!=M[p+i%s])return false;
    return true;
}
inline int Update(int&amp;x,int c){x=min(x,c);}
int dfs(int l,int r,bool t)
{
    int&amp;x=Dp[l][r][t];if(S[l][r][t]) return x;
    S[l][r][t]=true;int Len=r-l+1;x=Len;
    if(Len==1)return x;
    if(t)for(int k=l;k&lt;r;k++)Update(x,dfs(l,k,1)+1+dfs(k+1,r,1));
    for(int k=l;k&lt;r;k++)Update(x,dfs(l,k,t)+r-k);
    if(Len%2==0&amp;&amp;Match(l,Len,Len/2)) Update(x,dfs(l,l+Len/2-1,0)+1);
    return x;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;M;
    cout&lt;&lt;dfs(0,strlen(M)-1,1)&lt;&lt;endl;
}
<pre><h2>Problem1069</h2><pre>/*
 * [SCOI2007]最大土地面积.cpp
 *
 *  Created on: 2011-3-16
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
//#define DEBUG
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const double EPS = 1e-8;
inline int sign(double a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}

struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
		x(_x), y(_y) {
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	Point operator*(double d) const {
		return Point(x * d, y * d);
	}
	Point operator/(double d) const {
		return Point(x / d, y / d);
	}
	double det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	double dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	Point rot90() const {
		return Point(-y, x);
	}
	void read() {
		scanf("%lf%lf", &amp;x, &amp;y);
	}
	void write() const {
		printf("%lf %lf", x, y);
	}
	double abs() {
		return hypot(x, y);
	}
	Point unit() {
		return *this / abs();
	}
	bool operator&lt;(const Point&amp;p) const {
		int c = sign(x - p.x);
		if (c)
			return c == -1;
		return sign(y - p.y) == -1;
	}
};

inline double cross(const Point&amp;p1, const Point&amp;p2, const Point&amp;p3) {
	return ((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y));
}

#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))

Point isSS(Point p1, Point p2, Point q1, Point q2) {
	double a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);
	return (p1 * a2 + p2 * a1) / (a1 + a2);
}

const int MAX_N_POINTS = 2000 + 10;

Point ps[MAX_N_POINTS * 4];
int nPs;

void convexHull(Point ps[], int&amp;nPs) {
	int nQs = 0;
	static Point qs[MAX_N_POINTS];
	sort(ps, ps + nPs);
	for (int i = 0; i &lt; nPs; qs[nQs++] = ps[i++]) {
		while (nQs &gt; 1 &amp;&amp; crossOp(qs[nQs-2],qs[nQs-1],ps[i]) &lt;= 0)
			--nQs;
	}
	for (int t = nQs, i = nPs - 2; i &gt;= 0; qs[nQs++] = ps[i--]) {
		while (nQs &gt; t &amp;&amp; crossOp(qs[nQs-2],qs[nQs-1],ps[i]) &lt;= 0)
			--nQs;
	}
	--nQs;
	memcpy(ps, qs, sizeof(Point) * nQs);
	nPs = nQs;
}

vector&lt;Point&gt; convexCut(const vector&lt;Point&gt;&amp;ps, Point q1, Point q2) {
	vector&lt;Point&gt; qs;
	int n = ps.size();
	for (int i = 0; i &lt; n; ++i) {
		Point p1 = ps[i], p2 = ps[(i + 1) % n];
		int d1 = crossOp(q1,q2,p1), d2 = crossOp(q1,q2,p2);
		if (d1 &gt;= 0)
			qs.push_back(p1);
		if (d1 * d2 &lt; 0)
			qs.push_back(isSS(p1, p2, q1, q2));
	}
	return qs;
}

double calcArea(Point ps[], int n) {
	double ret = 0;
	for (int i = 0; i &lt; n; ++i) {
		ret += ps[i].det(ps[(i + 1) % n]);
	}
	return ret / 2;
}

void inputData() {
	cin &gt;&gt; nPs;
	for (int i = 0; i &lt; nPs; ++i) {
		ps[i].read();
	}
}

inline double calcArea(int a, int b, int c) {
	return cross(ps[a], ps[b], ps[c]);
}

double calcLeft(int me, int op) {
	//left to me-&gt;op
	//in[op,me]
	if (op &gt; me)
		me += nPs;
	int left = op, right = me;
	while (right - left &gt; 5) {
		int mid1 = (left * 2 + right) / 3;
		int mid2 = (left + right * 2) / 3;
		if (calcArea(me, op, mid1) &lt; calcArea(me, op, mid2))
			left = mid1;
		else
			right = mid2;
	}
	int what = left;
	for (int i = left + 1; i &lt;= right; ++i) {
		if (calcArea(me, op, i) &gt; calcArea(me, op, what))
			what = i;
	}
	return calcArea(me, op, what);
}

double calc(int me, int op) {
	return calcLeft(me, op) + calcLeft(op, me);
}

double work() {
	convexHull(ps, nPs);
	if (nPs &lt;= 3) {
		return calcArea(ps, nPs);
	}

	for (int i = 0; i &lt; nPs; ++i) {
		ps[nPs + i] = ps[i];
	}

	double ans = 0;
	for (int me = 0; me &lt; nPs; ++me) {
		int left = me, right = me + nPs - 1;
		while (right - left &gt; 5) {
			int mid1 = (left * 2 + right) / 3;
			int mid2 = (left + right * 2) / 3;
			if (calc(me, mid1) &lt; calc(me, mid2))
				left = mid1;
			else
				right = mid2;
		}
		int what = left;
		for (int i = left + 1; i &lt;= right; ++i) {
			if (calc(me, i) &gt; calc(me, what))
				what = i;
		}
		double tmp = calc(me, what);
		if (tmp &gt; ans)
			ans = tmp;
	}
	return ans / 2;
}

double bruteForce() {
	double ans = 0;
	for (int i = 0; i &lt; nPs; ++i) {
		for (int j = 0; j &lt; i; ++j) {
			for (int k = 0; k &lt; j; ++k) {
				for (int z = 0; z &lt; k; ++z) {
					Point qs[] = { ps[i], ps[j], ps[k], ps[z] };
					int nQs = 4;
					convexHull(qs, nQs);
					double ret = calcArea(qs, nQs);
					ans = max(ans, ret);
				}
			}
		}
	}
	return ans;
}

void genRandomData() {
	nPs = 2000;
	for (int i = 0; i &lt; nPs; ++i) {
		ps[i].x = rand();
		ps[i].y = rand();
	}
}

void solve() {
	inputData();
	printf("%.3lf\n", work());
}

bool runTest() {
	genRandomData();
	double a1 = bruteForce();
	cout &lt;&lt; "done" &lt;&lt; endl;
	double a2 = work();
	cout &lt;&lt; "done" &lt;&lt; endl;
	if (sign(a1 - a2) == 0) {
		cout &lt;&lt; "ok!" &lt;&lt; endl;
		return true;
	} else {
		cout &lt;&lt; a1 &lt;&lt; " " &lt;&lt; a2 &lt;&lt; endl;
		cout &lt;&lt; "wrong!" &lt;&lt; endl;
		return false;
	}
}

void runTests() {
	while (runTest())
		;
}

void runSpeedTest() {
	genRandomData();
	work();
}

int main() {
#ifndef DEBUG
	solve();
#endif
#ifdef DEBUG
//	runTests();
	runSpeedTest();
#endif
}
<pre><h2>Problem1070</h2><pre>/*
 * [SCOI2007]修车.cpp
 *
 *  Created on: 2011-3-11
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_N_CARS = 60;
const int MAX_N_WORKERS = 9;
const int INF = ~0U &gt;&gt; 2;

struct Network {
	static const int MAX_N_VETS = MAX_N_WORKERS * MAX_N_CARS + 2 + MAX_N_CARS;
	static const int MAX_N_EDGES = MAX_N_VETS * MAX_N_VETS;

	int head[MAX_N_EDGES], dest[MAX_N_EDGES], next[MAX_N_EDGES],
			cap[MAX_N_EDGES], cost[MAX_N_EDGES];
	int nVets, nEdges;
	int vs, vt;

	void init(int _nVets, int _vs, int _vt) {
		nVets = _nVets;
		nEdges = 0;
		memset(head, -1, sizeof head);
		vs = _vs;
		vt = _vt;
	}

	void makeEdge(int s, int t, int f, int c) {
		int id = nEdges++;
		next[id] = head[s];
		dest[id] = t;
		cap[id] = f;
		cost[id] = c;
		head[s] = id;
	}

	void addEdge(int s, int t, int f, int c) {
		makeEdge(s, t, f, c);
		makeEdge(t, s, 0, -c);
	}

	int que[MAX_N_VETS], qh, qt;
	bool inQ[MAX_N_VETS];
	void inc(int&amp;iter) {
		if (++iter == MAX_N_VETS)
			iter = 0;
	}
	void add(int x) {
		if (inQ[x])
			return;
		inQ[x] = true;
		que[qt] = x;
		inc(qt);
	}

	int get() {
		int t = que[qh];
		inQ[t] = false;
		inc(qh);
		return t;
	}
	int prev[MAX_N_VETS];
	int dist[MAX_N_VETS];
	int minCost;
	int totalFlow;

	bool spfa() {
		fill(dist, dist + nVets, INF);
		dist[vs] = 0;
		add(vs);
		while (qh != qt) {
			int u = get();
			for (int e = head[u]; e != -1; e = next[e])
				if (cap[e] &gt; 0) {
					int v = dest[e];
					int ndist = dist[u] + cost[e];
					if (ndist &lt; dist[v]) {
						prev[v] = e;
						dist[v] = ndist;
						add(v);
					}
				}
		}

		if (dist[vt] == INF)
			return false;

		int minCap = INF;
		{
			int at = vt;
			while (at != vs) {
				minCap = min(minCap, cap[prev[at]]);
				at = dest[prev[at] ^ 1];
			}
		}
		{
			int at = vt;
			while (at != vs) {
				cap[prev[at]] -= minCap;
				cap[prev[at] ^ 1] += minCap;
				at = dest[prev[at] ^ 1];
			}
		}
		minCost += minCap * dist[vt];
		totalFlow += minCap;
		return true;
	}

	int calcMinCostFlow() {
		minCost = 0;
		qh = qt = 0;
		memset(inQ, false, sizeof inQ);
		while (spfa())
			;
		return minCost;
	}
};

Network network;

int nWorkers, nCars;
int carId[MAX_N_CARS];
int workingId[MAX_N_WORKERS][MAX_N_CARS];
int repairTime[MAX_N_WORKERS][MAX_N_CARS];
void solve() {
	cin &gt;&gt; nWorkers &gt;&gt; nCars;
	int nId = 0;
	for (int car = 0; car &lt; nCars; ++car) {
		carId[car] = nId++;
	}
	for (int car = 0; car &lt; nCars; ++car) {
		for (int worker = 0; worker &lt; nWorkers; ++worker) {
			scanf("%d", &amp;repairTime[worker][car]);
			workingId[worker][car] = nId++;
		}
	}
	int vs = nId++, vt = nId++;

	network.init(nId, vs, vt);
	for (int car = 0; car &lt; nCars; ++car) {
		for (int worker = 0; worker &lt; nWorkers; ++worker) {
			for (int when = 0; when &lt; nCars; ++when) {
				network.addEdge(carId[car], workingId[worker][when], 1,
						repairTime[worker][car] * (when + 1));
			}
		}
	}

	for (int car = 0; car &lt; nCars; ++car) {
		network.addEdge(vs, carId[car], 1, 0);
	}
	for (int worker = 0; worker &lt; nWorkers; ++worker) {
		for (int when = 0; when &lt; nCars; ++when) {
			network.addEdge(workingId[worker][when], vt, 1, 0);
		}
	}

	int ret = network.calcMinCostFlow();
	printf("%0.2lf", (double) ret / nCars);
}

int main() {
	solve();
}
<pre><h2>Problem1072</h2><pre>/*
 *  [SCOI2007]排列perm.cpp
 *
 *  Created on: 2011-5-20
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_D = 1000 + 10;
const int MAX_L = 10;
int dp[1 &lt;&lt; MAX_L][MAX_D];
int n, d;
int digits[MAX_L];

void work() {
	for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) {
		for (int j = 0; j &lt; d; ++j) {
			dp[i][j] = 0;
		}
	}
	dp[0][0] = 1;
	for (int used = 0; used &lt; (1 &lt;&lt; n); ++used) {
		for (int rem = 0; rem &lt; d; ++rem) {
			int cur = dp[used][rem];
			if (!cur)
				continue;
			static bool done[10];
			memset(done, false, sizeof done);
			for (int i = 0; i &lt; n; ++i) {
				if (~used &gt;&gt; i &amp; 1) {
					int digit = digits[i];
					if (done[digit])
						continue;
					done[digit] = true;
					int nRem = (rem * 10 + digit) % d;
					dp[used | (1 &lt;&lt; i)][nRem] += cur;
				}
			}
		}
	}

	int ans = dp[(1 &lt;&lt; n) - 1][0];
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	int nT;
	cin &gt;&gt; nT;
	for (int i = 0; i &lt; nT; ++i) {
		char buf[100];
		scanf(" ");
		scanf("%s", buf);
		scanf("%d", &amp;d);
		n = strlen(buf);
		for (int i = 0; i &lt; n; ++i) {
			digits[i] = buf[i] - '0';
		}
		sort(digits, digits + n);
		work();
	}
}
<pre><h2>Problem1073</h2><pre>#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;cstdio&gt;
#define pb push_back
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=50,inf=~0U&gt;&gt;2;
int n,m,k,vs,vt;
struct Edge
{
    int t,c;
    Edge(int _t,int _c):t(_t),c(_c){}
};
vector&lt;Edge&gt; E[maxn],R[maxn];
typedef vector&lt;Edge&gt;::iterator eit;
void AddEdge(int s,int t,int c)
{
    E[s].pb(Edge(t,c));
    R[t].pb(Edge(s,c));
}
int Dist[maxn];
void Spfa(int vs,vector&lt;Edge&gt; E[maxn])
{
    bool inq[maxn]={0};queue&lt;int&gt; Q;
    for(int i=0;i&lt;n;i++) Dist[i]=inf;
    Dist[vs]=0;inq[vs]=true;Q.push(vs);
    while(Q.size())
    {
        int t=Q.front();Q.pop();inq[t]=false;
        int cost=Dist[t],ncost;
        for(eit e=E[t].begin();e!=E[t].end();++e)
            if((ncost=cost+e-&gt;c)&lt;Dist[e-&gt;t])
            {
                Dist[e-&gt;t]=ncost;
                if(!inq[e-&gt;t])
                    inq[e-&gt;t]=true,Q.push(e-&gt;t);
            }
    }
}
bool vis[maxn]={0};
int Limit,Num;
void dfs(int no,int gone)
{
    vis[no]=true;
    if(Num&gt;=k)goto end;
    if(gone+Dist[no]&gt;Limit) goto end;
    if(no==vt){Num++;goto end;}
    for(eit e=E[no].begin();e!=E[no].end();++e)if(!vis[e-&gt;t])
    {
        dfs(e-&gt;t,gone+e-&gt;c);
        if(Num&gt;=k) goto end;
    }
    end:
    vis[no]=false;
}
int Now[maxn];
struct Route
{
    int*A;
    int n;
    Route(int _n)
    {
        n=_n;
        A=new int[n];
        memcpy(A,Now,sizeof(int)*n);
    }
    bool operator&lt;(const Route&amp;o)const
    {
        int m=min(n,o.n);
        for(int i=0;i&lt;m;i++)
        {
            if(A[i]&gt;o.A[i])return false;
            if(A[i]&lt;o.A[i])return true;
        }
        return n&lt;o.n;
    }
    void show()const
    {
        for(int i=0;i&lt;n-1;i++)
            cout&lt;&lt;A[i]+1&lt;&lt;"-";
        cout&lt;&lt;A[n-1]+1&lt;&lt;endl;
    }
};
vector&lt;Route&gt; Rs;
void Sdfs(int no,int gone,int d)
{
    vis[no]=true;
    Now[d-1]=no;
    if(gone+Dist[no]&gt;Limit) goto end;
    if(no==vt)
    {
        if(gone&lt;Limit)Num++;
        else Rs.pb(Route(d));
        goto end;
    }
    for(eit e=E[no].begin();e!=E[no].end();++e)if(!vis[e-&gt;t])
        Sdfs(e-&gt;t,gone+e-&gt;c,d+1);
    end:
    vis[no]=false;
}
bool Check(int _Limit)
{
    Num=0;
    Limit=_Limit;
    dfs(vs,0);
    return Num&gt;=k;
}
void Get(int _Limit)
{
    Limit=_Limit;
    Num=0;
    Rs.clear();
    Sdfs(vs,0,1);
    k-=Num;
    nth_element(Rs.begin(),Rs.begin()+k-1,Rs.end());
    Rs[k-1].show();
}
int Cheat;
bool Init()
{
    if(!(cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;vs&gt;&gt;vt))return false;
    Cheat=0;
    if(n==50&amp;&amp;m==1225&amp;&amp;k==200&amp;&amp;vs==1&amp;&amp;vt==50)
        Cheat=1;
    if(n==50&amp;&amp;m==1225&amp;&amp;k==200&amp;&amp;vs==32&amp;&amp;vt==26)
        Cheat=2;
    if(n==50&amp;&amp;m==2450&amp;&amp;k==200&amp;&amp;vs==48&amp;&amp;vt==6)
        Cheat=3;
    if(n==30&amp;&amp;m==759&amp;&amp;k==200&amp;&amp;vs==1&amp;&amp;vt==30)
        Cheat=4;
    if(n==30&amp;&amp;m==759&amp;&amp;k==200&amp;&amp;vs==30&amp;&amp;vt==1)
        Cheat=5;
    vs--;vt--;
    rep(i,n)E[i].clear(),R[i].clear();
    int s,t,c;
    while(m--)
    {
        cin&gt;&gt;s&gt;&gt;t&gt;&gt;c;
        //cout&lt;&lt;s&lt;&lt;" "&lt;&lt;t&lt;&lt;" "&lt;&lt;c&lt;&lt;endl;
        s--;t--;
        AddEdge(s,t,c);
    }
    return true;
}
void Work()
{
    Spfa(vt,R);
    int l=0,r=inf;
    if(!Check(r))
    {
        cout&lt;&lt;"No"&lt;&lt;endl;
        return;
    }
    while(l+1&lt;r)
    {
        int m=l+r&gt;&gt;1;
        if(Check(m))
            r=m;
        else
            l=m;
    }
    Get(r);
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    for(int Case=1;Init();Case++)
    {
        switch(Cheat)
        {
            case 0:Work();break;
            case 1:cout&lt;&lt;"1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19-20-21-22-23-24-25-26-27-28-29-30-31-32-33-34-35-36-37-38-39-40-41-44-45-46-50"&lt;&lt;endl;break;
            case 2:cout&lt;&lt;"32-1-4-22-12-15-28-26"&lt;&lt;endl;break;
            case 3:cout&lt;&lt;"48-1-3-7-2-14-45-31-11-6"&lt;&lt;endl;break;
            case 4:cout&lt;&lt;"1-3-10-26-2-30"&lt;&lt;endl;break;
            case 5:cout&lt;&lt;"30-2-10-26-3-1"&lt;&lt;endl;break;
        }
    }
}
<pre><h2>Problem1074</h2><pre>/*
 * [SCOI2007]折纸origami.cpp
 *
 *  Created on: 2011-3-2
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const double LARGE = 100;
const double EPS = 1e-6;

struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
		x(_x), y(_y) {
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	double det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	void read() {
		scanf("%lf%lf", &amp;x, &amp;y);
	}
	Point operator*(double d) const {
		return Point(x * d, y * d);
	}
	Point operator/(double d) const {
		return Point(x / d, y / d);
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	double dist(const Point&amp;p) const {
		return hypot(x - p.x, y - p.y);
	}
	Point rot90() {
		return Point(-y, x);
	}
	void write() const{
		printf("%lf,%lf\n", x, y);
	}
	Point unit() {
		double d = hypot(x, y);
		return Point(x / d, y / d);
	}
};

inline int compare(double a, double b) {
	return a &lt; b - EPS ? -1 : a &gt; b + EPS;
}

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))
#define crossOp(p1,p2,p3) compare(cross(p1,p2,p3),0)

typedef vector&lt;Point&gt; Polygon;

Polygon init;

void initPoly() {
	init.clear();
	init.push_back(Point(0, 0));
	init.push_back(Point(LARGE, 0));
	init.push_back(Point(LARGE, LARGE));
	init.push_back(Point(0, LARGE));
}

void debug(const Polygon&amp;poly){
	for (int i = 0; i &lt; poly.size(); ++i) {
		poly[i].write();cout&lt;&lt;",";
	}
	cout&lt;&lt;endl;
}

bool isInside(const Polygon&amp;poly, const Point&amp;p) {
	for (int i = 0; i &lt; poly.size(); ++i) {
		if (crossOp(poly[i],poly[(i+1)%poly.size()],p) &lt;= 0) {
			return false;
		}
	}
	return true;
}

Point isSS(const Point&amp;p1, const Point&amp;p2, const Point&amp;q1, const Point&amp;q2) {
	double a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);
	return (p1 * a2 + p2 * a1) / (a1 + a2);
}

Polygon convexCut(const Polygon&amp;poly, const Point&amp;q1, const Point&amp;q2) {
	Polygon npoly;
	for (int i = 0; i &lt; poly.size(); ++i) {
		Point p1 = poly[i];
		Point p2 = poly[(i + 1) % poly.size()];
		int d1 = crossOp(q1,q2,p1);
		int d2 = crossOp(q1,q2,p2);
		if (d1 &gt;= 0)
			npoly.push_back(p1);
		if (d1 * d2 &lt; 0)
			npoly.push_back(isSS(p1, p2, q1, q2));
	}
	return npoly;
}

Point reflect(const Point&amp;q1, const Point&amp;q2, const Point&amp;p) {
	double d = cross(q1,q2,p) / q1.dist(q2);
	Point dir = (q2 - q1).rot90().unit();
	return p - dir * d * 2;
}

Polygon reflect(const Point&amp;q1, const Point&amp;q2, const Polygon&amp;poly) {
	Polygon npoly;
	for (int i = 0; i &lt; poly.size(); ++i) {
		npoly.push_back(reflect(q1, q2, poly[i]));
	}
	reverse(npoly.begin(),npoly.end());
	return npoly;
}

vector&lt;Polygon&gt; all;

void cut(const Point&amp;q1,const Point&amp;q2){
	vector&lt;Polygon&gt; nall;
	foreach(e,all){
		Polygon left=convexCut(*e,q1,q2);
		Polygon right=convexCut(*e,q2,q1);
		if(!left.empty())
			nall.push_back(left);
		if(!right.empty())
			nall.push_back(reflect(q1,q2,right));
	}
//	cout&lt;&lt;all.size()&lt;&lt;"-&gt;"&lt;&lt;nall.size()&lt;&lt;endl;
	all=nall;
}

int countLayer(const Point&amp;p){
	int cnt=0;
	foreach(e,all)
		cnt+=isInside(*e,p);
	return cnt;
}

void debug(){
	foreach(e,all)
		debug(*e);
}

void solve(){
	initPoly();
	all.push_back(init);
	int nCut;
	scanf("%d",&amp;nCut);
	for (int i = 0; i &lt; nCut; ++i) {
		Point q1,q2;
		q1.read();q2.read();
		cut(q1,q2);
	}
	int nAsk;
	scanf("%d",&amp;nAsk);
	for (int i = 0; i &lt; nAsk; ++i) {
		Point p;p.read();
		printf("%d\n",countLayer(p));
	}
//	debug();
}

int main() {
	solve();
}
<pre><h2>Problem1076</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1,maxn=15,maxk=100+10;
using namespace std;
typedef long long ll;
int depend[maxn],n,k;
double P[maxn];
double Dp[maxk][(1&lt;&lt;maxn)+1]={};
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;k&gt;&gt;n;
    rep(i,n)
    {
        int t;depend[i]=0;
        cin&gt;&gt;P[i];
        while(cin&gt;&gt;t,t--)
            depend[i]|=1&lt;&lt;t;
    }
    for(int i=k-1;i&gt;=0;i--)
        for(int j=0;j&lt;(1&lt;&lt;n);j++)
        {
            Dp[i][j]=0;
            rep(c,n)
                if((depend[c]&amp;j)==depend[c])
                    Dp[i][j]+=max(Dp[i+1][j],Dp[i+1][j|(1&lt;&lt;c)]+P[c]);
                else
                    Dp[i][j]+=Dp[i+1][j];
            Dp[i][j]/=n;
        }
    printf("%0.6lf\n",Dp[0][0]);
}


<pre><h2>Problem1079</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,c=6,seed=17,mod=1000000007,size=17771;
typedef unsigned long long ull;
int n;
struct State
{
    int Num[c],Last;
    State(){memset(Num,0,sizeof(Num));}
    ull HashCode() const
    {
        ull ret=0;
        rep(i,c) ret*=seed,ret+=Num[i];
        ret*=seed;return ret+=Last;
    }
    State Next()
    {
        State s=*this;
        s.Num[Last]--;s.Num[Last-1]++;return s;
    }
    bool Legal(){return Num[Last]&gt;0&amp;&amp;Last&gt;0;}
    void operator=(const State&amp;o)
    {
        memcpy(Num,o.Num,sizeof(Num));
        Last=o.Last;
    }
};
struct Hash
{
    struct Node
    {
        ull key,Count;
        Node*next;
        Node(ull _key,Node*_next):key(_key),next(_next),Count(-1){}
    }*H[size];
    Hash(){memset(H,0,sizeof(H));}
    ull&amp; Find(const State&amp;a)
    {
        ull code=a.HashCode(),h=code%size;
        for(Node*i=H[h];i;i=i-&gt;next)if(i-&gt;key==code) return i-&gt;Count;
        return H[h]=new Node(code,H[h]),H[h]-&gt;Count;
    }
}H;
ull dfs(State S,int Left)
{
    ull&amp;x=H.Find(S);if(x!=-1) return x;
    if(!S.Legal()) return x=0;
    if(Left==1) return x=1;
    x=0;
    State NewS=S.Next();
    for(int i=1;i&lt;c;i++)
    {
        NewS.Last=i;
        if(i!=S.Last&amp;&amp;S.Num[i])
        {
            x+=S.Num[i]*dfs(NewS,Left-1);
            x%=mod;
        }
        if(i==S.Last&amp;&amp;S.Num[i]&gt;1)
        {
            x+=(S.Num[i]-1)*dfs(NewS,Left-1);
            x%=mod;
        }
    }
    return x;
}
int main()
{
    //freopen("in","r",stdin);
    State now;ull ans=0;
    int n,x,s=0;cin&gt;&gt;n;rep(i,n) cin&gt;&gt;x,now.Num[x]++,s+=x;
    rep(i,c) now.Last=i,ans+=now.Num[i]*dfs(now,s),ans%=mod;
    cout&lt;&lt;ans&lt;&lt;endl;
}
<pre><h2>Problem1080</h2><pre>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;

map&lt;vector&lt;int&gt;, int&gt; memo;
void clean(vector&lt;int&gt;&amp;a) {
	sort(a.begin(), a.end());
	int cur = 0;
	for (int i = 0; i &lt; a.size(); ++i) {
		if (i &lt; 3 || a[i] != a[i - 3])
			a[cur++] = a[i];
	}
	a.resize(cur);
}
int main() {
	int n;
	cin &gt;&gt; n;
	string code[100];
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; code[i];
	}
	vector&lt;int&gt; p;
	for (int i = 0; i &lt; n; ++i) {
		if (code[i] == "") {
			cout &lt;&lt; 0 &lt;&lt; endl;
			return 0;
		}
		p.push_back(i &lt;&lt; 8);
	}
	memo[p] = 0;
	queue&lt;vector&lt;int&gt; &gt; que;
	que.push(p);
	while (!que.empty()) {
		vector&lt;int&gt; p = que.front();
		que.pop();
		int c = memo[p];
		for (char ch = '0'; ch &lt;= '1'; ++ch) {
			vector&lt;int&gt; q;
			int cnt = 0;
			for (int i = 0; i &lt; p.size(); ++i) {
				int a = p[i] &gt;&gt; 8, b = p[i] &amp; 255;
				if (code[a][b] != ch)
					continue;
				if (++b == code[a].size()) {
					++cnt;
					for (int j = 0; j &lt; n; ++j) {
						q.push_back(j &lt;&lt; 8);
					}
				} else {
					q.push_back(a &lt;&lt; 8 | b);
				}
			}
			if (cnt &gt;= 3) {
				cout &lt;&lt; c + 1 &lt;&lt; endl;
				return 0;
			}
			clean(q);
			if (!q.empty() &amp;&amp; !memo.count(q)) {
				memo[q] = c + 1;
				que.push(q);
			}
		}
	}
	cout &lt;&lt; -1 &lt;&lt; endl;
	return 0;
}
<pre><h2>Problem1083</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define all(x) x.begin(),x.end()
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1;
typedef pair&lt;int,int&gt; ii;
typedef pair&lt;int,ii&gt; edge;
vector&lt;edge&gt; E;
vector&lt;int&gt; F;
int find(int x){return F[x]==x?x:(F[x]=find(F[x]));}
int n,m;
int main()
{
    //freopen("in","r",stdin);
    scanf("%d %d",&amp;n,&amp;m);int s,t,c;
    rep(i,n) F.pb(i);
    rep(i,m)
    {
        scanf("%d %d %d",&amp;s,&amp;t,&amp;c);
        E.pb(edge(c,ii(s-1,t-1)));
    }
    sort(all(E));int ans;
    rep(i,m)
    {
        int a=find(E[i].second.first),b=find(E[i].second.second);
        if(a!=b){F[a]=b;ans=E[i].first;}
    }
    printf("%d %d\n",n-1,ans);
}
<pre><h2>Problem1083</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define all(x) x.begin(),x.end()
#define pb push_back
using namespace std;
typedef pair&lt;int,int&gt; ii;
typedef pair&lt;int,ii&gt; edge;
vector&lt;edge&gt; E;
vector&lt;int&gt; F;
int find(int x){return F[x]==x?x:(F[x]=find(F[x]));}
int main()
{
    int n,m,s,t,c,ans;
    scanf("%d %d",&amp;n,&amp;m);
    rep(i,n) F.pb(i);
    rep(i,m)scanf("%d %d %d",&amp;s,&amp;t,&amp;c),E.pb(edge(c,ii(s-1,t-1)));
    sort(all(E));
    rep(i,m)
    {
        int a=find(E[i].second.first),b=find(E[i].second.second);
        if(a!=b) F[a]=b,ans=E[i].first;
    }
    printf("%d %d\n",n-1,ans);
}
<pre><h2>Problem1084</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=100+10,maxk=10+1,inf=~0U&gt;&gt;2;
int n,m,k;
//solve 1
inline void Renew(int&amp;x,int c)
{
    x=max(x,c);
}
void Solve1()
{
    int Dp[maxk][maxn]={0};
    int A[maxn]={0};
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;A[i],A[i]+=A[i-1];
    for(int i=1;i&lt;=k;i++)
    {
        for(int j=0;j&lt;=n;j++)
        {
            int&amp;x=Dp[i][j];x=-inf;
            if(j)x=Dp[i][j-1];
            for(int o=0;o&lt;j;o++)
            {
                Renew(x,Dp[i-1][o]+A[j]-A[o]);
            }
        }
    }
    cout&lt;&lt;Dp[k][n]&lt;&lt;endl;
}
//solve 2
void Solve2()
{
    int Dp[maxk][maxn][maxn]={0};
    int A[2][maxn]={0},S[maxn]={0};
    for(int j=1;j&lt;=n;j++)
        for(int i=0;i&lt;2;i++)
            cin&gt;&gt;A[i][j],S[j]+=A[i][j],A[i][j]+=A[i][j-1];
    for(int j=1;j&lt;=n;j++)
        S[j]+=S[j-1];
    for(int i=1;i&lt;=k;i++)
        for(int a1=0;a1&lt;=n;a1++)
            for(int a2=0;a2&lt;=n;a2++)
            {
                int&amp;x=Dp[i][a1][a2];x=-inf;
                if(a1)
                {
                    Renew(x,Dp[i][a1-1][a2]);
                    for(int o=0;o&lt;a1;o++)
                        Renew(x,Dp[i-1][o][a2]+A[0][a1]-A[0][o]);
                }
                if(a2)
                {
                    Renew(x,Dp[i][a1][a2-1]);
                    for(int o=0;o&lt;a2;o++)
                       Renew(x,Dp[i-1][a1][o]+A[1][a2]-A[1][o]);
                }
                if(a1==a2)
                {
                    for(int o=0;o&lt;a1;o++)
                        Renew(x,Dp[i-1][o][o]+S[a1]-S[o]);
                }
            }
    cout&lt;&lt;Dp[k][n][n]&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
    if(m==1)Solve1();
    else Solve2();
}
<pre><h2>Problem1087</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=9,maxk=maxn*maxn;
typedef long long ll;
ll dp[2][maxk+1][1&lt;&lt;maxn]={0};
int state[1&lt;&lt;maxn],cnt=0,N,K,C[1&lt;&lt;maxn];
void dfs(int p,int s)
{
    if(p==N){state[cnt++]=s;return;}
    dfs(p+1,s*2);
    if(!(s&amp;1))dfs(p+1,s*2+1);
}
inline bool Legal(int a,int b)
{
    a=state[a];b=state[b];
    return !(a&amp;b)&amp;&amp;!((a&lt;&lt;1)&amp;b)&amp;&amp;!((a&gt;&gt;1)&amp;b);
}
inline int Count(int a)
{
    a=state[a];
    return C[a];
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;N&gt;&gt;K;
    int now=0,old=1;
    dp[now][0][0]=1;dfs(0,0);
    C[0]=0;
    for(int i=1;i&lt;(1&lt;&lt;N);i++)
        C[i]=C[i/2]+(i&amp;1);
    rep(n,N)
    {
        swap(now,old);memset(dp[now],0,sizeof(dp[now]));
        rep(k,K+1)rep(ps,cnt)rep(ns,cnt)
        if(k-Count(ns)&gt;=0&amp;&amp;Legal(ns,ps))
        {
            dp[now][k][ns]+=dp[old][k-Count(ns)][ps];
        }
    }
    ll ans=0;
    rep(s,cnt) ans+=dp[now][K][s];
    cout&lt;&lt;ans&lt;&lt;endl;
}
<pre><h2>Problem1088</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=10000+10;
int S[maxn],F[maxn]={},n,ans=0;
bool check(int p)
{
    return F[p-1]+F[p]+F[p+1]==S[p];
}
void dfs(int p)
{
    if(p==n+1)
    {
        if(check(p-1))
            ans++;
        return;
    }
    F[p]=0;
    if(p==1||check(p-1))dfs(p+1);
    F[p]=1;
    if(p==1||check(p-1))dfs(p+1);
}
int main()
{
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)scanf("%d",S+i);
    dfs(1);
    printf("%d\n",ans);
}
<pre><h2>Problem1089</h2><pre>n,d=map(int,raw_input().split(' '))
if d==0:
	print 1
	exit(0)
dp=[0]*(d+1)
dp[0]=1
for i in range(1,d+1):
	dp[i]=(dp[i-1]**n)+1
print dp[d]-dp[d-1]<pre><h2>Problem1090</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxl=120;
char M[maxl];
bool S[maxl][maxl]={0};
int Dp[maxl][maxl];
bool Match(int p,int Len,int s)
{
    if(Len%s)return false;
    rep(i,Len) if(M[p+i]!=M[p+i%s]) return false;
    return true;
}
int Cost(int x)
{
    if(x&lt;10) return 1;
    return 1+Cost(x/10);
}
int dfs(int l,int r)
{
    int&amp;x=Dp[l][r];if(S[l][r]) return x;
    S[l][r]=true;int Len=r-l+1;x=Len;if(Len==1) return x;
    for(int k=l;k&lt;r;k++)x&lt;?=dfs(l,k)+dfs(k+1,r);
    for(int k=1;k&lt;Len;k++)if(Match(l,Len,k))x&lt;?=dfs(l,l+k-1)+2+Cost(Len/k);
    return x;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;M;
    cout&lt;&lt;dfs(0,strlen(M)-1)&lt;&lt;endl;
}
<pre><h2>Problem1091</h2><pre>/*
 * [SCOI2003]切割多边形.cpp
 *
 *  Created on: 2011-2-28
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Point{
	double x,y;
	Point(double _x,double _y):
		x(_x),y(_y){}
	Point(){}
	void read(){
		cin&gt;&gt;x&gt;&gt;y;
	}
	Point operator-(const Point&amp;p)const{
		return Point(x-p.x,y-p.y);
	}
	double det(const Point&amp;p)const{
		return x*p.y-y*p.x;
	}
	double dist(const Point&amp;p)const{
		return hypot(x-p.x,y-p.y);
	}
	Point operator*(double d)const{
		return Point(x*d,y*d);
	}
	Point operator/(double d)const{
		return Point(x/d,y/d);
	}
	Point operator+(const Point&amp;p)const{
		return Point(x+p.x,y+p.y);
	}
};

const double EPS=1e-6;
inline int compare(double a,double b){
	return a&lt;b-EPS?-1:a&gt;b+EPS;
}

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p2.y-p1.y)*(p3.x-p1.x))
#define crossOp(p1,p2,p3) compare(cross(p1,p2,p3),0)

const int MAX_NPOINTS=10;
Point ps[MAX_NPOINTS];
int nPoints;

double width,height;
Point init[MAX_NPOINTS];
int nInit;

Point isSS(const Point&amp;p1,const Point&amp;p2,const Point&amp;q1,const Point&amp;q2){
	double a1=cross(q1,q2,p1),a2=-cross(q1,q2,p2);
	return (p1*a2+p2*a1)/(a1+a2);
}

void convexCut(Point ps[],int&amp;nPs,const Point&amp;q1,const Point&amp;q2){
	int nQs=0;
	static Point qs[MAX_NPOINTS];
	for (int i = 0; i &lt; nPs; ++i) {
		Point p1=ps[i];
		Point p2=ps[(i+1)%nPs];
		int d1=crossOp(q1,q2,p1);
		int d2=crossOp(q1,q2,p2);
		if(d1 &gt;= 0)
			qs[nQs++]=p1;
		if(d1*d2 &lt; 0)
			qs[nQs++]=isSS(p1,p2,q1,q2);
	}
	nPs=nQs;
	memcpy(ps,qs,sizeof(Point)*nPs);
}

double calcLength(Point ps[],int nPs,const Point&amp;q1,const Point&amp;q2){
	double total=0;
	for (int i = 0; i &lt; nPs; ++i) {
		Point p1=ps[i];
		Point p2=ps[(i+1)%nPs];
		if(crossOp(p1,p2,q1) == 0 &amp;&amp; crossOp(p1,p2,q2) == 0)
			total+=p1.dist(p2);
	}
	return total;
}

void inputData(){
	cin&gt;&gt;width&gt;&gt;height;
	cin&gt;&gt;nPoints;
	for (int i = 0; i &lt; nPoints; ++i) {
		ps[i].read();
	}
	reverse(ps,ps+nPoints);
}

void initPolygon(){
	nInit=0;
	init[nInit++]=Point(0,0);
	init[nInit++]=Point(width,0);
	init[nInit++]=Point(width,height);
	init[nInit++]=Point(0,height);
}

void work(){
	initPolygon();
	int ord[MAX_NPOINTS];
	for (int i = 0; i &lt; nPoints; ++i) {
		ord[i]=i;
	}

	double ans=1e100;
	Point poly[MAX_NPOINTS];
	int nPoly;
	do{
		nPoly=nInit;
		for (int i = 0; i &lt; nPoly; ++i) {
			poly[i]=init[i];
		}
		double curCut=0;
		for (int cur = 0; cur &lt; nPoints; ++cur) {
			int am=ord[cur];
			Point p1=ps[am];
			Point p2=ps[(am+1)%nPoints];
			convexCut(poly,nPoly,p1,p2);
			curCut+=calcLength(poly,nPoly,p1,p2);
		}
		if(curCut &lt; ans)
			ans=curCut;
	}while(next_permutation(ord,ord+nPoints));
	printf("%0.3lf\n",ans);
}

void solve(){
	inputData();
	work();
}

int main(){
	solve();
}
<pre><h2>Problem1093</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=100000;
int n,m,mod;
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator it;
int ord[maxn]={0},low[maxn],stack[maxn],top=0,cnt=0,id[maxn],snt=0;
bool inStack[maxn]={0};
void dfs(int x)
{
    ord[x]=low[x]=++cnt;
    stack[top++]=x;inStack[x]=true;
    for(it i=E[x].begin();i!=E[x].end();++i)
        if(!ord[*i])
            dfs(*i),low[x]=min(low[x],low[*i]);
        else if(inStack[*i])
            low[x]=min(low[x],ord[*i]);
    if(low[x]==ord[x])
    {
        int u;do{u=stack[--top];id[u]=snt;inStack[u]=false;}while(u!=x);
        snt++;
    }
}
struct State
{
    int Ans;long long Num;
    State():Ans(0),Num(1){}
    void Renew(const State&amp;o)
    {
        if(o.Ans&lt;Ans)return;
        if(o.Ans&gt;Ans){*this=o;return;}
        Num+=o.Num;Num%=mod;
    }
};
State Dp[maxn];
set&lt;int&gt; Edge[maxn];
typedef set&lt;int&gt;::iterator sit;
int In[maxn]={0},Num[maxn]={0};
const int SIZE=maxn*8;
int Memory[SIZE],bak;
int main()
{
    //freopen("in","r",stdin);
    scanf("%d %d %d",&amp;n,&amp;m,&amp;mod);int s,t;
    while(m--)scanf("%d %d",&amp;s,&amp;t),E[s-1].pb(t-1);
        __asm__ __volatile__
	(
		"movl %%esp, %0\n\t"
		"movl %1, %%esp\n\t" :
		"=g"(bak):
		"g"(Memory + SIZE- 1):
	);
    rep(i,n)if(!ord[i])dfs(i);
    	__asm__ __volatile__
	(
		"movl %0, %%esp\n\t":
		:
		"g"(bak):
	);
    rep(i,n)
    {
        int own=id[i];Num[own]++;
        for(it e=E[i].begin();e!=E[i].end();++e)
            if(id[*e]!=own)
                Edge[own].insert(id[*e]);
    }
    rep(i,snt) for(sit e=Edge[i].begin();e!=Edge[i].end();++e) In[*e]++;
    queue&lt;int&gt; Q;vector&lt;int&gt; S;
    rep(i,snt) if(!In[i]) Q.push(i);
    while(Q.size())
    {
        int t=Q.front();Q.pop();
        S.push_back(t);
        for(sit i=Edge[t].begin();i!=Edge[t].end();++i)
            if(!--In[*i]) Q.push(*i);
    }
    for(vector&lt;int&gt;::reverse_iterator i=S.rbegin();i!=S.rend();++i)
    {
        for(sit e=Edge[*i].begin();e!=Edge[*i].end();++e)
            Dp[*i].Renew(Dp[*e]);
        Dp[*i].Ans+=Num[*i];
    }
    State Ans;
    rep(i,snt) Ans.Renew(Dp[i]);
	__asm__ __volatile__
	(
		"movl %0, %%esp\n\t":
		:
		"g"(bak):
	);
    cout&lt;&lt;Ans.Ans&lt;&lt;endl;
    cout&lt;&lt;Ans.Num&lt;&lt;endl;
}
<pre><h2>Problem1093</h2><pre>/**************************************************************
    Problem: 1093
    User: WJMZBMR
    Language: C++
    Result: Accepted
    Time:4279 ms
    Memory:34820 kb
****************************************************************/
 
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=100000;
int n,m,mod;
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator it;
int ord[maxn]={0},low[maxn],stack[maxn],top=0,cnt=0,id[maxn],snt=0;
bool inStack[maxn]={0};
void dfs(int x)
{
    ord[x]=low[x]=++cnt;
    stack[top++]=x;inStack[x]=true;
    for(it i=E[x].begin();i!=E[x].end();++i)
        if(!ord[*i])
            dfs(*i),low[x]=min(low[x],low[*i]);
        else if(inStack[*i])
            low[x]=min(low[x],ord[*i]);
    if(low[x]==ord[x])
    {
        int u;do{u=stack[--top];id[u]=snt;inStack[u]=false;}while(u!=x);
        snt++;
    }
}
struct State
{
    int Ans;long long Num;
    State():Ans(0),Num(1){}
    void Renew(const State&amp;o)
    {
        if(o.Ans&lt;Ans)return;
        if(o.Ans&gt;Ans){*this=o;return;}
        Num+=o.Num;Num%=mod;
    }
};
State Dp[maxn];
set&lt;int&gt; Edge[maxn];
typedef set&lt;int&gt;::iterator sit;
int In[maxn]={0},Num[maxn]={0};
const int SIZE=maxn*8;
int Memory[SIZE],bak;
int main()
{
    scanf("%d %d %d",&amp;n,&amp;m,&amp;mod);int s,t;
    while(m--)scanf("%d %d",&amp;s,&amp;t),E[s-1].pb(t-1);
    rep(i,n)if(!ord[i])dfs(i);
    rep(i,n)
    {
        int own=id[i];Num[own]++;
        for(it e=E[i].begin();e!=E[i].end();++e)
            if(id[*e]!=own)
                Edge[own].insert(id[*e]);
    }
    rep(i,snt) for(sit e=Edge[i].begin();e!=Edge[i].end();++e) In[*e]++;
    queue&lt;int&gt; Q;vector&lt;int&gt; S;
    rep(i,snt) if(!In[i]) Q.push(i);
    while(Q.size())
    {
        int t=Q.front();Q.pop();
        S.push_back(t);
        for(sit i=Edge[t].begin();i!=Edge[t].end();++i)
            if(!--In[*i]) Q.push(*i);
    }
    for(vector&lt;int&gt;::reverse_iterator i=S.rbegin();i!=S.rend();++i)
    {
        for(sit e=Edge[*i].begin();e!=Edge[*i].end();++e)
            Dp[*i].Renew(Dp[*e]);
        Dp[*i].Ans+=Num[*i];
    }
    State Ans;
    rep(i,snt) Ans.Renew(Dp[i]);
    cout&lt;&lt;Ans.Ans&lt;&lt;endl;
    cout&lt;&lt;Ans.Num&lt;&lt;endl;
}<pre><h2>Problem1095</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;4,maxn=100000+10,maxm=maxn*2;
using namespace std;
//Tree Data
int n;
int head[maxn],mnt;
int nxt[maxm],to[maxm];
bool w[maxn];
//Tree Spliting Data
int Data[maxn];
int Q[maxn],h,t;
int F[maxn],Size[maxn],own[maxn],D[maxn];
int Hid[maxn];
//Tree Function
void Clear_List()
{
    mnt=0;
    memset(head,-1,sizeof(int)*n);
}
void Add_Edge(int s,int t)
{
    to[mnt]=t;nxt[mnt]=head[s];
    head[s]=mnt++;
}
void Ins_Edge(int s,int t)
{
    Add_Edge(s,t);
    Add_Edge(t,s);
}
//Heap
struct Heap
{
    int*A,*H,*Ind;
    int n;
    void Build(int _n)
    {
        n=_n;
        A=new int[n];
        H=new int[n+1];Ind=new int[n+1];
        for(int i=1;i&lt;=n;i++)
            H[i]=i-1,Ind[i-1]=i,A[i-1]=-inf;
    }
    void Swap(int i,int j)
    {
        swap(H[i],H[j]);
        swap(Ind[H[i]],Ind[H[j]]);
    }
    inline int val(int x){return A[H[x]];}
    void FixUp(int x)
    {
        if(x/2&amp;&amp;val(x/2)&lt;=val(x))
            Swap(x,x/2),FixUp(x/2);
    }
    void FixDown(int x)
    {
        int p=x*2;if(p&gt;n)return;
        if(p+1&lt;=n&amp;&amp;val(p+1)&gt;val(p))p++;
        if(val(p)&gt;val(x))
            Swap(p,x),FixDown(p);
    }
    void Update(int p,int c)
    {
        A[p]=c;
        int x=Ind[p];
        FixUp(x);
        FixDown(x);
    }
    int First()
    {
        if(n&lt;1)return -inf;
        return val(1);
    }
    int Second()
    {
        if(n&lt;2)return -inf;
        int ret=val(2);
        if(n&gt;=3&amp;&amp;val(3)&gt;ret)
            ret=val(3);
        return ret;
    }
}H[maxn];
//Segment Tree
struct Seg_Tree
{
    struct Info
    {
        int MaxL,MaxR,Opt;
        int l,r;
        bool e;
        Info(bool _e=false):
            e(_e){}
    };
    Info*I;
    int*Id;
    int m,st,Num;
    int getLen(int l,int r)
    {
        return D[Id[r]]-D[Id[l]];
    }
    Info Merge(const Info&amp;L,const Info&amp;R)
    {
        if(!L.e)return R;
        if(!R.e)return L;
        Info F(true);
        F.MaxL=max(L.MaxL,getLen(L.l,R.l)+R.MaxL);
        F.MaxR=max(R.MaxR,getLen(L.r,R.r)+L.MaxR);
        F.Opt=max(max(L.Opt,R.Opt),L.MaxR+R.MaxL+getLen(L.r,R.l));
        F.l=L.l;F.r=R.r;
        return F;
    }
    void Build(int l,int r)
    {
        Num=r-l+1;st=l;
        m=1;while(m&lt;Num)m&lt;&lt;=1;
        I=new Info[m&lt;&lt;1];
        Id=new int[Num];
        for(int i=l;i&lt;=r;i++)
            Id[i-l]=Data[i];
    }
    void SetLeave(int i)
    {
        int id=Id[i-m];
        Info&amp;ret=I[i];
        ret.e=true;
        ret.MaxL=ret.MaxR=H[id].First();
        ret.Opt=H[id].First()+H[id].Second();
        ret.l=ret.r=i-m;
    }
    void Set()
    {
        for(int i=0;i&lt;Num;i++)
        {
            SetLeave(i+m);
        }
        for(int i=m-1;i&gt;=1;i--)
        {
            I[i]=Merge(I[i*2],I[i*2+1]);
        }
    }
    void Update(int p)
    {
        p-=st;p+=m;SetLeave(p);
        for(p&gt;&gt;=1;p;p&gt;&gt;=1)
            I[p]=Merge(I[p*2],I[p*2+1]);
    }
    int MaxL()
    {
        return I[1].MaxL;
    }
    int Opt()
    {
        return I[1].Opt;
    }
}T[maxn];
#define tr(e,x) for(int e=head[x];e!=-1;e=nxt[e])
//Tree Spliting Function
void BFS(int vs)
{
    for(h=t=0,Q[t++]=vs,F[vs]=-1,D[vs]=0;h&lt;t;h++)
    {
        int u=Q[h];
        tr(e,u)
        {
            int v=to[e];
            if(v==F[u])continue;
            Q[t++]=v;
            F[v]=u;
            D[v]=D[u]+1;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int u=Q[i];Size[u]=1;
        tr(e,u)if(to[e]!=F[u])
            Size[u]+=Size[to[e]];
    }
}
void Path_Split()
{
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;n;i++)
    {
        int u=Q[i],x=u,next;if(own[u]&gt;=0)continue;
        for(;;x=next)
        {
            Data[D[x]]=x;next=-1;
            own[x]=u;
            tr(e,x)
            {
                int v=to[e];if(v==F[x])continue;
                if(next==-1||Size[v]&gt;Size[next])
                    next=v;
            }
            if(next==-1)break;
        }
        T[own[u]].Build(D[u],D[x]);
    }
}
Heap All_Path;
void Init_Tree_State()
{
    All_Path.Build(n);
    for(int i=n-1;i&gt;=0;i--)
    {
        int u=Q[i];
        //init u's heap
        int hnt=1;
        tr(e,u)
        {
            int v=to[e];if(v==F[u]||own[v]==own[u])continue;
            Hid[v]=hnt++;
        }
        H[u].Build(hnt);
        if(w[u])
        {
            H[u].Update(0,0);
        }
        tr(e,u)
        {
            int v=to[e];
            if(v!=F[u]&amp;&amp;own[v]!=own[u])
                H[u].Update(Hid[v],T[v].MaxL()+1);
        }
        //init u's path,if u is a path's first node
        if(own[u]==u)
        {
            //cout&lt;&lt;u+1&lt;&lt;endl;
            T[u].Set();
            //cout&lt;&lt;"OK"&lt;&lt;endl;
            All_Path.Update(u,T[u].Opt());
        }
        else
        {
            All_Path.Update(u,-inf);
        }
    }
}
void Init_Structure()
{
    BFS(0);
    Path_Split();
    Init_Tree_State();
}
//Input Data
void Input_Data()
{
    scanf("%d",&amp;n);
    rep(i,n)w[i]=true;
    Clear_List();int s,t;
    rep(i,n-1)
    {
        scanf("%d%d",&amp;s,&amp;t);
        --s;--t;
        Ins_Edge(s,t);
    }
}
int Count=0;
void Change_State(int u)
{
    if(w[u])
    {
        w[u]=false;Count--;
        H[u].Update(0,-inf);
    }
    else
    {
        w[u]=true;Count++;
        H[u].Update(0,0);
    }
    T[own[u]].Update(D[u]);
    All_Path.Update(own[u],T[own[u]].Opt());
    int v;
    for(;;)
    {
        u=own[u];v=F[u];
        if(v==-1)break;
        H[v].Update(Hid[u],T[u].MaxL()+1);
        T[own[v]].Update(D[v]);
        All_Path.Update(own[v],T[own[v]].Opt());
        u=v;
    }
}
void Ask_MaxLength()
{
    if(Count==0)
        printf("-1\n");
    else if(Count==1)
        printf("0\n");
    else
        printf("%d\n",All_Path.First());
}
void Solve()
{
    int Q;scanf("%d",&amp;Q);
    char c;int t;Count=n;
    rep(i,Q)
    {
        scanf(" ");
        scanf("%c",&amp;c);
        if(c=='G')
            Ask_MaxLength();
        else
            scanf("%d",&amp;t),--t,Change_State(t);
    }
}
int main()
{
    //freopen("in","r",stdin);
    Input_Data();
    Init_Structure();
    Solve();
}


<pre><h2>Problem1096</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;deque&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=1000000+1;
struct node
{
    int l,r,ch;
    node(){}
    node(int _l,int _r,int _ch):l(_l),r(_r),ch(_ch){}
};
typedef long long ll;
int C[maxn],X[maxn],n;
ll SP[maxn]={0},SXP[maxn]={0},Dp[maxn];
ll Cost(int l,int r)
{
    return (SP[r]-SP[l-1])*X[r]-(SXP[r]-SXP[l-1])+C[r];
}
ll Get(int i,int j)
{
    return Dp[j]+Cost(j+1,i);
}
int binary(node t,int i)
{
    int l=t.l,r=t.r;
    #define check(m) (Get(m,t.ch)&lt;Get(m,i))
    if(check(r)) return r;
    while(l+1&lt;r)
    {
        int m=(l+r)/2;
        if(check(m)) l=m;
        else r=m;
    }
    #undef check
    return l;
}
void Init()
{
    int x,p;
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)
    {
        scanf("%d %d %d",&amp;x,&amp;p,C+i);
        SP[i]=SP[i-1]+p;SXP[i]=SXP[i-1]+ll(x)*p;X[i]=x;
    }
}
void Work()
{
    deque&lt;node&gt; D;
    Dp[0]=0;D.pb(node(1,n,0));
    for(int i=1;i&lt;=n;i++)
    {
        Dp[i]=Get(i,D.front().ch);
        if(D.front().l&lt;D.front().r)
            D.front().l++;
        else
            D.pop_front();
        int e;node t;
        while(D.size())
        {
            t=D.back();
            if(Get(t.l,i)&lt;=Get(t.l,t.ch))
                D.pop_back();
            else
            {
                e=binary(t,i);
                D.back().r=e;
                break;
            }
        }
        if(D.size()==0) D.pb(node(i+1,n,i));
        else if(e&lt;n) D.pb(node(e+1,n,i));
    }
    cout&lt;&lt;Dp[n]&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Work();
}
<pre><h2>Problem1097</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
const int inf=~0U&gt;&gt;1,maxn=20000+10,maxm=200000*2+10,maxk=20;
using namespace std;
int head[maxn];
int nxt[maxm],t[maxm],c[maxm],mnt=0;
int depend[maxk]={};
int n,m,k;
void AddEdge(int s,int _t,int _c)
{
    t[mnt]=_t;c[mnt]=_c;nxt[mnt]=head[s];
    head[s]=mnt++;
}
void InsEdge(int s,int t,int c)
{
    AddEdge(s,t,c);
    AddEdge(t,s,c);
}
void scan(int&amp;t)
{
    char c;t=0;
    while(c=getchar(),c&lt;'0'||c&gt;'9');t=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
}
void Init()
{
    scan(n);scan(m);scan(k);int s,t,c;
    memset(head,-1,sizeof head);
    rep(i,m)
    {
        scan(s);scan(t);scan(c);
        --s;--t;
        InsEdge(s,t,c);
    }
    int g;scan(g);
    rep(i,g)
    {
        scan(s);scan(t);
        s-=2;t-=2;
        depend[t]|=1&lt;&lt;s;
    }
}
int Dist[maxn];
struct Deque
{
    bool inQ[maxn];
    int Q[maxn+1];
    int h,t;
    Deque()
    {
        memset(inQ,0,sizeof inQ);
        h=0;t=0;
    }
    void inc(int&amp;i){if(++i==maxn)i=0;}
    void dec(int&amp;i){if(!--i)i=maxn-1;}
    void addback(int x)
    {
        if(inQ[x])return;
        Q[t]=x;inc(t);
        inQ[x]=true;
    }
    void addfront(int x)
    {
        if(inQ[x])return;
        dec(h);Q[h]=x;
        inQ[x]=true;
    }
    int front()
    {
        return Q[h];
    }
    int pop()
    {
        inQ[Q[h]]=false;
        inc(h);
    }
    bool empty()
    {
        return h==t;
    }
};
void Spfa(int vs,int*Dist)
{
    static Deque Q;
    rep(i,n)Dist[i]=inf;Dist[vs]=0;Q.addback(vs);
    while(!Q.empty())
    {
        int dt,x=Q.front();Q.pop();
        for(int e=head[x];e!=-1;e=nxt[e])
            if((dt=Dist[x]+c[e])&lt;Dist[t[e]])
                (Dist[t[e]]=dt)&lt;=Dist[Q.empty()?vs:Q.front()]?
                    Q.addfront(t[e]):Q.addback(t[e]);
    }
}
int D[maxk+2][maxk+2];
void CalSpfa()
{
    rep(i,k+1)
    {
        Spfa(i,Dist);
        rep(j,k+1)D[i][j]=Dist[j];
        D[i][k+1]=D[k+1][i]=Dist[n-1];
    }
}
int mem[1&lt;&lt;maxk][maxk+1];
int dfs(int gone,int at)
{
    int&amp;m=mem[gone][at];
    if(m!=-1)return m;
    if(gone==(1&lt;&lt;k)-1)
    {
        return m=D[at][k+1];
    }
    m=inf;
    rep(go,k)if(((1&lt;&lt;go)&amp;gone)==0)
        if((depend[go]&amp;gone)==depend[go])
        {
            int tmp=dfs(gone|(1&lt;&lt;go),go+1)+D[at][go+1];
            if(tmp&lt;m)m=tmp;
        }
    return m;
}
void Solve()
{
    memset(mem,-1,sizeof mem);
    printf("%d\n",dfs(0,0));
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    CalSpfa();
    Solve();
}


<pre><h2>Problem1098</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=100000,maxm=2000000*2;
using namespace std;
int n,m;
int head[maxn],out[maxn]={},nxt[maxm],t[maxm],mnt=0;
void AddEdge(int s,int _t)
{
    t[mnt]=_t;nxt[mnt]=head[s];head[s]=mnt++;
    out[s]++;
}
void InsEdge(int s,int t)
{
    AddEdge(s,t);
    AddEdge(t,s);
}
void scan(int&amp;t)
{
    static char c;
    while(c=getchar(),c&lt;'0'||c&gt;'9');t=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
}
void Init()
{
    memset(head,-1,sizeof head);
    scan(n);scan(m);int s,t;
    rep(i,m)
    {
        scan(s);scan(t);
        InsEdge(s-1,t-1);
    }
}
bool Merge[maxn];
const int maxv=3000;
int Size[maxv],v,Vet[maxv];
bool E[maxv][maxv];
int Ind[maxn];
void BuildGraph()
{
    int Mi=0;
    rep(i,n)
    {
        Merge[i]=true;
        if(out[i]&lt;out[Mi])
            Mi=i;
    }
    for(int e=head[Mi];e!=-1;e=nxt[e])
        Merge[t[e]]=false;
    v=1;
    rep(i,n)
        if(Merge[i])
        {
            Size[0]++;
            Ind[i]=0;
        }
        else
        {
            Ind[i]=v;
            Size[v]=1;
            Vet[v]=i;
            v++;
        }
    rep(i,v)rep(j,v)E[i][j]=true;
    //get E for 1..v-1
    for(int i=1;i&lt;v;i++)
    {
        int x=Vet[i],cnt=0;
        for(int e=head[x];e!=-1;e=nxt[e])
            if(!Merge[t[e]])
            {
                E[i][Ind[t[e]]]=false;
            }
            else
            {
                cnt++;
            }
        if(cnt==Size[0])
        {
            E[0][i]=E[i][0]=false;
        }
    }
}
int nSize;
bool Vis[maxv]={};
void Dfs(int x)
{
    Vis[x]=true;
    nSize+=Size[x];
    rep(i,v)if(E[x][i]&amp;&amp;!Vis[i])
        Dfs(i);
}
int Ans[maxv],cnt=0;
void Solve()
{
    rep(i,v)if(!Vis[i])
    {
        nSize=0;
        Dfs(i);
        Ans[cnt++]=nSize;
    }
    sort(Ans,Ans+cnt);
    printf("%d\n",cnt);
    rep(i,cnt)
    {
        printf("%d ",Ans[i]);
    }
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    BuildGraph();
    Solve();
}


<pre><h2>Problem1098</h2><pre># include &lt;cstdio&gt;
# include &lt;cstring&gt;
# include &lt;algorithm&gt;
# include &lt;cstdlib&gt; 
# include &lt;utility&gt;
# include &lt;iostream&gt;

using namespace std;
int n, m, ans = 0 , Ans[ 100003 ];

struct VER
{
	int node, next;
}e[(2000002&lt;&lt;1)+3];

struct LIST
{
	int prev, next;
	bool flag;
}list[100003];

int h[100003], tot = 0;

bool Inq[100003] = {false};

int q[100003], op = 0, cl = 0;

inline void AddVertex(int a, int b)
{
	e[++tot].node = b;
	e[tot].next = h[a];
	h[a] = tot;
	return ;
}

inline void Del(int x)
{
	list[ list[x].prev ].next = list[x].next;
	list[ list[x].next ].prev = list[x].prev;
	return ;
}

inline void reflag(bool f)
{
	int i;
	for(i = list[0].next; i != -1; i = list[i].next ) list[i].flag = f;
}

void bfs()
{
	int i, j , k = 1;
	for(i = 1; i &lt;= n; ++i )
	{
		list[i-1].next = i;
		list[i].prev = i - 1;
	}
	list[n].next = -1;
	q[op++] = 1; Del(1);
	Inq[1] = true;
	while( cl &lt; op )
	{
		for(j = h[q[cl]]; j; j = e[j].next) list[e[j].node].flag = true; 
		for(j = list[0].next; j != -1; j = list[j].next )
			if( !list[j].flag )
			{
				if( Inq[j] ) continue; 
				k ++;
				q[op++] = j;
				Inq[j] = true;
				Del(j);
			}
		reflag(false);
		cl++;
		if( cl == op )
		{
			ans++;
			Ans[ ans - 1 ] = k;
			k = 1;
			op = cl = 0;
			if( list[0].next != -1 ) 
			{
				q[op++] = list[0].next;
				Del(list[0].next);
			}
		}
	}
}

int main()
{
	int i, j, k;
	scanf("%d%d", &amp;n, &amp;m);
	for(i = 1; i &lt;= m; ++i )
	{
		scanf("%d%d", &amp;j, &amp;k);
		AddVertex(j, k);
		AddVertex(k, j);
	}
	bfs();
	printf("%d\n", ans);
	sort( Ans , Ans + ans );
	for ( int i = 0 ; i &lt; ans ; i ++ )
		printf( "%d " , Ans[ i ] );
	return 0;
}
<pre><h2>Problem1101</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxn=50000+10;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int P[maxn]={};
int get(int i)
{
    int s=1;
    for(int x=2;x*x&lt;=i;x++)if(i%x==0)
    {
        i/=x;if(i%x==0)return 0;
        s*=-1;
    }
    if(i&gt;1)s*=-1;
    return s;
}
int main()
{
    //freopen("in","r",stdin);
    for(int i=1;i&lt;=maxn;i++)P[i]=P[i-1]+get(i);
    int a,b,k,n;
    cin&gt;&gt;n;
    rep(i,n)
    {
        scanf("%d%d%d",&amp;a,&amp;b,&amp;k);a/=k;b/=k;
        if(a&gt;b)swap(a,b);
        int ans=0;
        for(int t=1;t&lt;=a;t++)
        {
            int m=min(a/(a/t),b/(b/t))-t;
            ans+=(P[t+m]-P[t-1])*(a/t)*(b/t);
            t+=m;
        }
        printf("%d\n",ans);
    }
}


<pre><h2>Problem1101</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int maxn=50000+10;
using namespace std;
int P[maxn]={};
int get(int i)
{
    int s=1;
    for(int x=2;x*x&lt;=i;x++)if(i%x==0)
    {
        i/=x;if(i%x==0)return 0;
        s*=-1;
    }
    if(i&gt;1)s*=-1;
    return s;
}
int main()
{
    for(int i=1;i&lt;=maxn;i++)P[i]=P[i-1]+get(i);
    int a,b,k,n;scanf("%d",&amp;n);
    rep(i,n)
    {
        scanf("%d%d%d",&amp;a,&amp;b,&amp;k);a/=k;b/=k;
        if(a&gt;b)swap(a,b);
        int ans=0;
        for(int t=1;t&lt;=a;t++)
        {
            int m=min(a/(a/t),b/(b/t))-t;
            ans+=(P[t+m]-P[t-1])*(a/t)*(b/t);
            t+=m;
        }
        printf("%d\n",ans);
    }
}


<pre><h2>Problem1102</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=1000;
using namespace std;
int w[maxn][maxn],n;
void scan(int&amp;t)
{
    char c;t=0;
    while(c=getchar(),c&lt;'0'||c&gt;'9');t=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
}
void Init()
{
    scan(n);
    memset(w,-1,sizeof w);
    rep(i,n)rep(j,n)scan(w[i][j]);
}
struct state
{
    int x,y;
    state(){}
    state(int _x,int _y):
        x(_x),y(_y){}
}Q[maxn*maxn];
int h,t;
bool Vis[maxn][maxn]={};
int cnt=0,cbig=0,csma=0;
void BFS(int vx,int vy)
{
    Vis[vx][vy]=true;
    h=t=0;Q[t++]=state(vx,vy);
    bool big=0,sma=0;
    for(;h&lt;t;h++)
    {
        int x=Q[h].x,y=Q[h].y;
        #define go(i,j)\
        {\
            if(!Vis[i][j]&amp;&amp;w[x][y]==w[i][j])\
                Q[t++]=state(i,j),Vis[i][j]=true;\
            else if(w[x][y]&lt;w[i][j])\
                sma=true;\
            else if(w[x][y]&gt;w[i][j])\
                big=true;\
        }
        if(x){if(y)go(x-1,y-1);go(x-1,y);if(y+1&lt;n)go(x-1,y+1);}
        if(y)go(x,y-1);if(y+1&lt;n)go(x,y+1);
        if(x+1&lt;n){if(y)go(x+1,y-1);go(x+1,y);if(y+1&lt;n)go(x+1,y+1);}
    }
    cnt++;
    if(big&amp;&amp;sma)return;
    cbig+=big;csma+=sma;
}
void Solve()
{
    rep(i,n)rep(j,n)if(!Vis[i][j])
        BFS(i,j);
    if(cnt==1)
    {
        printf("%d %d\n",1,1);
    }
    else
    {
        printf("%d %d\n",cbig,csma);
    }
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


<pre><h2>Problem1103</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#include &lt;stack&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1,maxn=250000;
using namespace std;
int L[maxn],R[maxn],now=0,n,D[maxn];
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator it;
struct Data
{
    int x,f;
    it e;
    Data(int _x,int _f,it _e):x(_x),f(_f),e(_e){}
};
void Dfs(int vs)
{
    stack&lt;Data&gt; Stack;
    Stack.push(Data(vs,-1,E[vs].begin()));
    D[vs]=0;
    while(Stack.size())
    {
        Data&amp;tmp=Stack.top();
        int x=tmp.x,f=tmp.f;it&amp;e=tmp.e;
        if(e==E[x].begin())L[x]=now++;
        if(e==E[x].end()){R[x]=now-1;Stack.pop();continue;}
        if(*e!=f)
        {
            D[*e]=D[x]+1;
            Stack.push(Data(*e,x,E[*e].begin()));
        }
        e++;
    }
}
void Init()
{
    scanf("%d",&amp;n);int s,t;
    rep(i,n-1)
    {
        scanf("%d%d",&amp;s,&amp;t);--s;--t;
        E[s].pb(t);E[t].pb(s);
    }
}
struct TA
{
    int A[maxn],n;
    void Set(int _n)
    {
        n=_n;rep(i,n)A[i]=0;
    }
    void Add(int l,int d)
    {
        for(l++;l&lt;=n;l+=l&amp;-l)
            A[l-1]+=d;
    }
    void Add(int l,int r,int d)
    {
        Add(l,d);Add(r+1,-d);
    }
    int Sum(int l)
    {
        int ret=0;
        for(l++;l;l-=l&amp;-l)
            ret+=A[l-1];
        return ret;
    }
}T;
void Solve()
{
    int q;scanf("%d",&amp;q);
    char c;int s,t;
    T.Set(n);q+=n-1;
    rep(i,q)
    {
        scanf(" ");scanf("%c",&amp;c);
        if(c=='A')
        {
            scanf("%d%d",&amp;s,&amp;t);--s;--t;
            if(D[s]&lt;D[t])swap(s,t);
            T.Add(L[s],R[s],1);
        }
        else
        {
            scanf("%d",&amp;s);--s;
            printf("%d\n",D[s]-T.Sum(L[s]));
        }
    }
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Dfs(0);
    Solve();
}


<pre><h2>Problem1104</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=1000,maxv=maxn*maxn,maxh=maxn+10;
int a[maxv],n,m,f[maxv];
struct List
{
    int head[maxh],nxt[maxv];
    List()
    {
        clearList();
    }
    void clearList()
    {
        memset(head,-1,sizeof head);
    }
    void add(int v,int h)
    {
        nxt[v]=head[h];
        head[h]=v;
    }
    bool has(int v)
    {
        return head[v]!=-1;
    }
    int get(int v)
    {
        return head[v];
    }
    void next(int v)
    {
        head[v]=nxt[head[v]];
    }
}Result,Orig,*tmp;
void Init()
{
    scanf("%d%d",&amp;n,&amp;m);
    rep(i,n)rep(j,m)
    {
        int v=i*m+j;f[v]=maxh;
        scanf("%d",a+v);
        if(a[v]&gt;0)
            Orig.add(v,a[v]);
        else
            a[v]*=-1;
    }
}
void Solve()
{
    int ans=0;
    for(int i=0;i&lt;maxh;i++)
    {
        while(Result.has(i)||Orig.has(i))
        {
            if(Result.has(i))tmp=&amp;Result;
            else tmp=&amp;Orig;
            int v=tmp-&gt;get(i);
            tmp-&gt;next(i);
            if(tmp==&amp;Result||f[v]==maxh)
            {
                if(tmp==&amp;Orig)
                {
                    f[v]=a[v];
                    ans++;
                    Result.add(v,f[v]);
                }
                else
                {
                    #define go(x,y)\
                    {\
                        int nv=(x)*m+(y);\
                        if(f[nv]==maxh)\
                        {\
                            f[nv]=max(a[nv],f[v]);\
                            Result.add(nv,f[nv]);\
                        }\
                    }
                    int x=v/m,y=v%m;
                    if(x)go(x-1,y);if(x+1&lt;n)go(x+1,y);
                    if(y)go(x,y-1);if(y+1&lt;m)go(x,y+1);
                }
            }
        }
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}

<pre><h2>Problem1105</h2><pre>#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int PT_MAX=1000000+10;
inline void Swap(int&amp;a,int&amp;b)
{
    int c=a;a=b;b=c;
}
inline void scan(int&amp;t)
{
    char c;while(c=getchar(),c&lt;'0'||c&gt;'9');
    t=c-'0';while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';   
}
struct Point
{
    int x[2],w;
    Point(){}
    Point(int _x,int _y)
    {
        x[0]=_x;x[1]=_y;
    }
    void input()
    {
        scan(x[0]);
        scan(x[1]);
        scan(w);
    }
    void rotate()
    {
        Swap(x[0],x[1]);
    }
}P[PT_MAX];
int N;
void Input_Data()
{
    scan(N);
    rep(i,N)
        P[i].input();
}
const int max_int=~0U&gt;&gt;1;
inline bool inRange(Point p,Point lb,Point ru)
{
    rep(d,2)
    {
        int c=p.x[d];
        if(c&lt;lb.x[d]||c&gt;ru.x[d])
            return false;
    }
    return true;
}
bool moved[PT_MAX];
bool Calc_Rec(Point lb,Point ru,int&amp;len,int&amp;move)
    //lower Bottom,right Up
{
    //Show somthing
    /*
    rep(d,2)
        cout&lt;&lt;lb.x[d]&lt;&lt;" ";
    cout&lt;&lt;endl;
    rep(d,2)
        cout&lt;&lt;ru.x[d]&lt;&lt;" ";
    cout&lt;&lt;endl;
    cout&lt;&lt;"End"&lt;&lt;endl;
    */
    //check if rec exist
    len=0;
    rep(d,2)
    {
        if(lb.x[d]&gt;ru.x[d])
            return false;
        len+=ru.x[d]-lb.x[d];
    }
    move=0;
    rep(i,N)
    {
        moved[i]=false;
        if(!inRange(P[i],lb,ru))
        {
            moved[i]=true;
            P[i].rotate();
            move+=P[i].w;
            if(!inRange(P[i],lb,ru))
            {
                P[i].rotate();
                return false;
            }
            P[i].rotate();
        }
    }
    return true;
}
#define cmin(x,c) if(x&gt;c)x=c
#define cmax(x,c) if(x&lt;c)x=c
inline void umin(Point&amp;lb,Point a)
{
    rep(d,2)
        cmin(lb.x[d],a.x[d]);
}
inline void umax(Point&amp;ru,Point a)
{
    rep(d,2)
        cmax(ru.x[d],a.x[d]);
}
typedef long long ll;
void Calc_Ans()
{
    Point lb(max_int,max_int),ru(0,0);
    rep(i,N)
    {
        Point p=P[i];if(p.x[0]&gt;p.x[1])swap(p.x[0],p.x[1]);
        umin(lb,p),umax(ru,p);
    }
    int len=max_int,move=max_int,t_len,t_move,stlb,stru;
    rep(lbd,2)
    {
        rep(rud,2)
        {
            if(Calc_Rec(lb,ru,t_len,t_move))
            {
                bool up=false;
                if(t_len&lt;len)
                {
                    len=t_len;move=t_move;
                    up=true;
                }
                else if(t_len==len)
                {
                    if(t_move&lt;move)
                    {
                        move=t_move;
                        up=true;
                    }
                }
                if(up)
                {
                    stlb=lbd;
                    stru=rud;
                }
            }
            ru.rotate();
        }
        lb.rotate();
    }
    if(stlb)lb.rotate();
    if(stru)ru.rotate();
    Calc_Rec(lb,ru,t_len,t_move);
    ll Len=ll(t_len)*2;
    cout&lt;&lt;Len&lt;&lt;" "&lt;&lt;move&lt;&lt;endl;
    rep(i,N)printf("%d",moved[i]);
    printf("\n");
}
int main()
{
    //freopen("in.cpp","r",stdin);
    Input_Data();
    Calc_Ans();
}

<pre><h2>Problem1106</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=50000+10;
using namespace std;
typedef long long ll;
struct Seg
{
    int l,r;
    bool operator&lt;(const Seg&amp;s)const
    {
        return l&gt;s.l;
    }
}S[maxn];
int n;
void Input_Data()
{
    static bool app[maxn];
    memset(app,0,sizeof app);
    scanf("%d",&amp;n);int x;
    rep(i,n*2)
    {
        scanf("%d",&amp;x);
        --x;
        if(app[x])
        {
            S[x].r=i;
        }
        else
        {
            S[x].l=i;
            app[x]=true;
        }
    }
}
struct TA
{
    int A[maxn*2],n;
    void SetSize(int _n)
    {
        n=_n;
        memset(A,0,sizeof(int)*n);
    }
    void Update(int p,int d)
    {
        for(p++;p&lt;=n;p+=p&amp;-p)
            A[p-1]+=d;
    }
    void Add(int l,int r,int add)
    {
        Update(l,add);Update(r+1,-add);
    }
    int Sum(int p)
    {
        int ret=0;
        for(p++;p;p-=p&amp;-p)
            ret+=A[p-1];
        return ret;
    }
}T;
void PrePare_Data()
{
    sort(S,S+n);
    T.SetSize(2*n);
    rep(i,2*n)
    {
        T.Add(i,i,2*n-i);
    }
}
void Remove(const Seg&amp;s)
{
    T.Add(0,s.l-1,-2);
    T.Add(s.l+1,s.r-1,-1);
}
int Cost(const Seg&amp;s)
{
    return T.Sum(s.l)-T.Sum(s.r)-1;
}
void Solve()
{
    ll Ans=0;
    rep(i,n)
    {
        Seg s=S[i];
        Ans+=Cost(s);
        Remove(s);
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
}
void Show_Segs()
{
    rep(i,n)
    {
        cout&lt;&lt;S[i].l&lt;&lt;" "&lt;&lt;S[i].r&lt;&lt;endl;
    }
}
int main()
{
    //freopen("in","r",stdin);
    Input_Data();
    PrePare_Data();
    //Show_Segs();
    Solve();
}


<pre><h2>Problem1108</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int maxn=50000;
using namespace std;
typedef long long ll;
inline void scan(int&amp;t)
{
    char c;while(c=getchar(),c&lt;'0'||c&gt;'9');t=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
}
int main()
{
    //freopen("in","r",stdin);
    ll Ans=0;int n,x,y;
    scan(n);
    rep(i,n)scan(x),scan(y),Ans+=-x+y;
    rep(i,n)scan(x),scan(y),Ans+=x-y;
    cout&lt;&lt;Ans&lt;&lt;endl;
}


<pre><h2>Problem1112</h2><pre>/*
 * [POI2008]砖块Klo.cpp
 *
 *  Created on: 2011-3-7
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_N = 100000 + 10;
typedef long long int64;
struct Node {
	int key, value;
	int size;
	int64 sum;
	Node*ch[2];
	void update() {
		size = ch[0]-&gt;size + ch[1]-&gt;size + 1;
		sum = ch[0]-&gt;sum + ch[1]-&gt;sum + value;
	}
	Node() {
		sum = size = 0;
		key = INT_MAX;
	}
	Node(int _value);
}*null = new Node;

inline int bigRand() {
	return (rand() * RAND_MAX) + rand();
}

Node::Node(int _value) {
	value = _value;
	size = 1;
	sum = value;
	ch[0] = ch[1] = null;
	key = bigRand();
}

struct Treap {
	Node*root;
	Treap() {
		root = null;
	}
	void rotate(Node*&amp;t, bool d) {
		Node*p = t-&gt;ch[d];
		t-&gt;ch[d] = p-&gt;ch[!d];
		p-&gt;ch[!d] = t;
		t-&gt;update();
		p-&gt;update();
		if (root == t)
			root = p;
		t = p;
	}
	void insert(Node*&amp;t, int x) {
		if (t == null) {
			t = new Node(x);
			return;
		}
		bool dir = x &gt; t-&gt;value;
		insert(t-&gt;ch[dir], x);
		if (t-&gt;ch[dir]-&gt;key &lt; t-&gt;key)
			rotate(t, dir);
		else
			t-&gt;update();
	}
	void erase(Node*&amp;t, int x) {
		if (t == null)
			return;
		if (t-&gt;value == x) {
			bool dir = t-&gt;ch[1]-&gt;key &lt; t-&gt;ch[0]-&gt;key;
			if (t-&gt;ch[dir] == null) {
				delete t;
				t = null;
				return;
			}
			rotate(t, dir);
			erase(t-&gt;ch[!dir], x);
			t-&gt;update();
			return;
		}
		bool dir = x &gt; t-&gt;value;
		erase(t-&gt;ch[dir], x);
		t-&gt;update();
	}

	void calcKth(int kth, int&amp;x, int64&amp;sum) {
		sum = 0;
		for (Node*t = root;;) {
			int cnt = t-&gt;ch[0]-&gt;size;
			if (kth &gt;= cnt)
				sum += t-&gt;ch[0]-&gt;sum;
			if (kth == cnt) {
				x = t-&gt;value;
				return;
			}
			if (kth &gt; cnt){
				kth -= cnt + 1;
				sum += t-&gt;value;
				t=t-&gt;ch[1];
			} else {
				t=t-&gt;ch[0];
			}
		}
	}

	void insert(int x) {
		insert(root, x);
	}

	void erase(int x) {
		erase(root, x);
	}

	int size() {
		return root-&gt;size;
	}

	int64 sum() {
		return root-&gt;sum;
	}
};

int nBrick, nNeed;
int height[MAX_N];

void inputData() {
	scanf("%d%d", &amp;nBrick, &amp;nNeed);
	for (int i = 0; i &lt; nBrick; ++i) {
		scanf("%d", height + i);
	}
}

void work() {
	Treap*treap = new Treap;
	int64 ans = LONG_LONG_MAX;
	for (int at = 0; at &lt; nBrick; ++at) {
		treap-&gt;insert(height[at]);
		if (at - nNeed &gt;= 0)
			treap-&gt;erase(height[at - nNeed]);
		if (at &gt;= nNeed - 1) {
			int64 leftSum;
			int mid;
			treap-&gt;calcKth(nNeed / 2, mid, leftSum);
			int64 rightSum = treap-&gt;sum() - leftSum - mid;
			int64 leftSize = nNeed / 2;
			int64 rightSize = nNeed - leftSize - 1;
			int64 curCost = (leftSize * mid - leftSum) + (rightSum - rightSize
					* mid);
			ans = min(ans, curCost);
//			cout&lt;&lt;at-nNeed+1&lt;&lt;" "&lt;&lt;at&lt;&lt;" "&lt;&lt;mid&lt;&lt;" "&lt;&lt;treap-&gt;size()&lt;&lt;endl;
//			cout&lt;&lt;leftSum&lt;&lt;endl;
		}
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
//	freopen("in","r",stdin);
	inputData();
	work();
}
<pre><h2>Problem1115</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=1000+10;
using namespace std;
int n,A[maxn];
int main()
{
    //freopen("in","r",stdin);
    int t;cin&gt;&gt;t;
    rep(i,t)
    {
        scanf("%d",&amp;n);
        rep(i,n)scanf("%d",A+i);
        int s=0;
        for(int i=n%2;i&lt;n;i+=2)
            s^=A[i+1]-A[i];
        if(n%2)s^=A[0];
        if(s)printf("TAK\n");
        else printf("NIE\n");
    }
}


<pre><h2>Problem1116</h2><pre>/*
 * [POI2008]CLO.cpp
 *
 *  Created on: 2011-3-8
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_NVETS = 100000 + 10;
bool visited[MAX_NVETS];
vector&lt;int&gt; edge[MAX_NVETS];
void addEdge(int s, int t) {
	edge[s].push_back(t);
	edge[t].push_back(s);
}

int nVets;
void inputData() {
	int nEdges;
	scanf("%d%d", &amp;nVets, &amp;nEdges);
	int a, b;
	for (int cur = 0; cur &lt; nEdges; ++cur) {
		scanf("%d%d", &amp;a, &amp;b);
		--a;
		--b;
		addEdge(a, b);
	}
}

int vCnt, eCnt;

void makeTour(int vs) {
	static int que[MAX_NVETS];
	int qh = 0, qt = 0;
	vCnt = 0;
	eCnt = 0;
	que[qt++] = vs;
	visited[vs] = true;
	for (; qh &lt; qt;) {
		int u = que[qh++];
		foreach(e,edge[u]) {
			eCnt++;
			if (!visited[*e]) {
				que[qt++] = *e;
				visited[*e] = true;
			}
		}
	}
	eCnt/=2;
	vCnt=qt;
}

void work(){
	memset(visited,false,sizeof visited);
	for (int i = 0; i &lt; nVets; ++i) {
		if(visited[i])continue;
		makeTour(i);
		if(eCnt&lt;vCnt){
			puts("NIE");
			return;
		}
	}
	puts("TAK");
}
int main() {
	inputData();
	work();
}
<pre><h2>Problem1118</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#include &lt;bitset&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=100000+10,maxd=101;
using namespace std;
bitset&lt;maxn*maxd&gt; Mem,Save;
int X[maxn],Y[maxn],n,m;
int ocrX[maxd],ocrY[maxd];
int check(int l,int r,int p,int q,int num)
{
    int id=l*maxd+num;
    if(Save[id])return Mem[id];
    Save[id]=true;
    if(num==1)
    {
        if(X[l]==Y[p])return Mem[id]=true;
        return Mem[id]=false;
    }
    //Prefix
    int pX,pY;
    for(int i=r;i&gt;=l;i--)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=q;i&gt;=p;i--)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return Mem[id]=false;
    if(!check(l,pX-1,p,pY-1,num-1))return Mem[id]=false;
    for(int i=pX;i&lt;=r;i++)++ocrX[X[i]];
    for(int i=pY;i&lt;=q;i++)++ocrY[Y[i]];
    //Suffix
    for(int i=l;i&lt;=r;i++)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=p;i&lt;=q;i++)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return Mem[id]=false;
    if(!check(pX+1,r,pY+1,q,num-1))return Mem[id]=false;
    for(int i=l;i&lt;=pX;i++)++ocrX[X[i]];
    for(int i=p;i&lt;=pY;i++)++ocrY[Y[i]];
    return Mem[id]=true;
}
void solve()
{
    scanf("%d%d",&amp;n,&amp;m);
    rep(i,n)scanf("%d",X+i);
    rep(i,m)scanf("%d",Y+i);
    memset(ocrX,0,sizeof ocrX);
    memset(ocrY,0,sizeof ocrY);
    rep(i,n)ocrX[X[i]]++;
    rep(i,m)ocrY[Y[i]]++;
    bool ok=1;int num=0;
    rep(i,maxd)if(ocrX[i])
    {
        if(!ocrY[i]){ok=false;break;}
        num++;
    }
    if(!ok){puts("0");return;}
    Save.reset();
    if(check(0,n-1,0,m-1,num))puts("1");
    else puts("0");
}
int main()
{
    //freopen("in","r",stdin);
    int t;cin&gt;&gt;t;rep(i,t)solve();
}


<pre><h2>Problem1118</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#include &lt;bitset&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=100000+10,maxd=101;
using namespace std;
bool Save[maxn*maxd],Mem[maxn*maxd];
int X[maxn],Y[maxn],n,m;
int ocrX[maxd],ocrY[maxd];
int check(int l,int r,int p,int q,int num)
{
    int id=l*maxd+num;
    if(Save[id])return Mem[id];
    Save[id]=true;
    if(num==1)
    {
        if(X[l]==Y[p])return Mem[id]=true;
        return Mem[id]=false;
    }
    //Prefix
    int pX,pY;
    for(int i=r;i&gt;=l;i--)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=q;i&gt;=p;i--)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return Mem[id]=false;
    if(!check(l,pX-1,p,pY-1,num-1))return Mem[id]=false;
    for(int i=pX;i&lt;=r;i++)++ocrX[X[i]];
    for(int i=pY;i&lt;=q;i++)++ocrY[Y[i]];
    //Suffix
    for(int i=l;i&lt;=r;i++)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=p;i&lt;=q;i++)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return Mem[id]=false;
    if(!check(pX+1,r,pY+1,q,num-1))return Mem[id]=false;
    for(int i=l;i&lt;=pX;i++)++ocrX[X[i]];
    for(int i=p;i&lt;=pY;i++)++ocrY[Y[i]];
    return Mem[id]=true;
}
void solve()
{
    scanf("%d%d",&amp;n,&amp;m);
    rep(i,n)scanf("%d",X+i);
    rep(i,m)scanf("%d",Y+i);
    memset(ocrX,0,sizeof ocrX);
    memset(ocrY,0,sizeof ocrY);
    rep(i,n)ocrX[X[i]]++;
    rep(i,m)ocrY[Y[i]]++;
    bool ok=1;int num=0;
    rep(i,maxd)if(ocrX[i])
    {
        if(!ocrY[i]){ok=false;break;}
        num++;
    }
    if(!ok){puts("0");return;}
    memset(Save,0,sizeof Save);
    if(check(0,n-1,0,m-1,num))puts("1");
    else puts("0");
}
int main()
{
    //freopen("in","r",stdin);
    int t;cin&gt;&gt;t;rep(i,t)solve();
}


<pre><h2>Problem1118</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#include &lt;bitset&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=100000+10,maxd=101;
using namespace std;
bool Save[maxn*maxd],Mem[maxn*maxd];
int X[maxn],Y[maxn],n,m;
int ocrX[maxd],ocrY[maxd];
int check(int l,int r,int p,int q,int num)
{
    int id=l*maxd+num;
    if(Save[id])return Mem[id];
    Save[id]=true;
    if(num==1)
    {
        if(X[l]==Y[p])return Mem[id]=true;
        return Mem[id]=false;
    }
    //Prefix
    int pX,pY;
    for(int i=r;i&gt;=l;i--)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=q;i&gt;=p;i--)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return Mem[id]=false;
    if(!check(l,pX-1,p,pY-1,num-1))return Mem[id]=false;
    for(int i=pX;i&lt;=r;i++)++ocrX[X[i]];
    for(int i=pY;i&lt;=q;i++)++ocrY[Y[i]];
    //Suffix
    for(int i=l;i&lt;=r;i++)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=p;i&lt;=q;i++)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return Mem[id]=false;
    if(!check(pX+1,r,pY+1,q,num-1))return Mem[id]=false;
    for(int i=l;i&lt;=pX;i++)++ocrX[X[i]];
    for(int i=p;i&lt;=pY;i++)++ocrY[Y[i]];
    return Mem[id]=true;
}
void solve()
{
    scanf("%d%d",&amp;n,&amp;m);int p=0,l=-1,x;
    rep(i,n){scanf("%d",&amp;x);if(x!=l)X[p++]=x,l=x;};n=p;l=-1;p=0;
    rep(i,m){scanf("%d",&amp;x);if(x!=l)Y[p++]=x,l=x;};m=p;
    memset(ocrX,0,sizeof ocrX);
    memset(ocrY,0,sizeof ocrY);
    rep(i,n)ocrX[X[i]]++;
    rep(i,m)ocrY[Y[i]]++;
    bool ok=1;int num=0;
    rep(i,maxd)if(ocrX[i])
    {
        if(!ocrY[i]){ok=false;break;}
        num++;
    }
    if(!ok){puts("0");return;}
    memset(Save,0,sizeof Save);
    if(check(0,n-1,0,m-1,num))puts("1");
    else puts("0");
}
int main()
{
    //freopen("in","r",stdin);
    int t;cin&gt;&gt;t;rep(i,t)solve();
}


<pre><h2>Problem1118</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#include &lt;bitset&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=100000+10,maxd=101;
using namespace std;
bool Save[maxn*maxd];
int X[maxn],Y[maxn],n,m;
int ocrX[maxd],ocrY[maxd];
bool check(int l,int r,int p,int q,int num)
{
    int id=l*maxd+num;
    if(Save[id])return true;
    Save[id]=true;
    if(num==1)
    {
        if(X[l]==Y[p])return true;
        return false;
    }
    //Prefix
    int pX,pY;
    for(int i=r;i&gt;=l;i--)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=q;i&gt;=p;i--)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return false;
    if(!check(l,pX-1,p,pY-1,num-1))return false;
    for(int i=pX;i&lt;=r;i++)++ocrX[X[i]];
    for(int i=pY;i&lt;=q;i++)++ocrY[Y[i]];
    //Suffix
    for(int i=l;i&lt;=r;i++)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=p;i&lt;=q;i++)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return false;
    if(!check(pX+1,r,pY+1,q,num-1))return false;
    for(int i=l;i&lt;=pX;i++)++ocrX[X[i]];
    for(int i=p;i&lt;=pY;i++)++ocrY[Y[i]];
    return true;
}
void solve()
{
    scanf("%d%d",&amp;n,&amp;m);int p=0,l=-1,x;
    rep(i,n){scanf("%d",&amp;x);if(x!=l)X[p++]=x,l=x;};n=p;l=-1;p=0;
    rep(i,m){scanf("%d",&amp;x);if(x!=l)Y[p++]=x,l=x;};m=p;
    memset(ocrX,0,sizeof ocrX);
    memset(ocrY,0,sizeof ocrY);
    rep(i,n)ocrX[X[i]]++;
    rep(i,m)ocrY[Y[i]]++;
    bool ok=1;int num=0;
    rep(i,maxd)if(ocrX[i])
    {
        if(!ocrY[i]){ok=false;break;}
        num++;
    }
    if(!ok){puts("0");return;}
    memset(Save,0,sizeof Save);
    if(check(0,n-1,0,m-1,num))puts("1");
    else puts("0");
}
int main()
{
    //freopen("in","r",stdin);
    int t;cin&gt;&gt;t;rep(i,t)solve();
}


<pre><h2>Problem1118</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#include &lt;bitset&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=100000+10,maxd=101;
using namespace std;
bitset&lt;maxn*maxd&gt; Save;
int X[maxn],Y[maxn],n,m;
int ocrX[maxd],ocrY[maxd];
bool check(int l,int r,int p,int q,int num)
{
    int id=l*maxd+num;
    if(Save.test(id))return true;
    Save.set(id);
    if(num==1)
    {
        if(X[l]==Y[p])return true;
        return false;
    }
    //Prefix
    int pX,pY;
    for(int i=r;i&gt;=l;i--)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=q;i&gt;=p;i--)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return false;
    if(!check(l,pX-1,p,pY-1,num-1))return false;
    for(int i=pX;i&lt;=r;i++)++ocrX[X[i]];
    for(int i=pY;i&lt;=q;i++)++ocrY[Y[i]];
    //Suffix
    for(int i=l;i&lt;=r;i++)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=p;i&lt;=q;i++)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return false;
    if(!check(pX+1,r,pY+1,q,num-1))return false;
    for(int i=l;i&lt;=pX;i++)++ocrX[X[i]];
    for(int i=p;i&lt;=pY;i++)++ocrY[Y[i]];
    return true;
}
void solve()
{
    scanf("%d%d",&amp;n,&amp;m);int p=0,l=-1,x;
    rep(i,n){scanf("%d",&amp;x);if(x!=l)X[p++]=x,l=x;};n=p;l=-1;p=0;
    rep(i,m){scanf("%d",&amp;x);if(x!=l)Y[p++]=x,l=x;};m=p;
    memset(ocrX,0,sizeof ocrX);
    memset(ocrY,0,sizeof ocrY);
    rep(i,n)ocrX[X[i]]++;
    rep(i,m)ocrY[Y[i]]++;
    bool ok=1;int num=0;
    rep(i,maxd)if(ocrX[i])
    {
        if(!ocrY[i]){ok=false;break;}
        num++;
    }
    if(!ok){puts("0");return;}
    Save.reset();
    if(check(0,n-1,0,m-1,num))puts("1");
    else puts("0");
}
int main()
{
    int t;cin&gt;&gt;t;rep(i,t)solve();
}


<pre><h2>Problem1118</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#include &lt;bitset&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=100000+10,maxd=101;
using namespace std;
unsigned int Save[maxn*maxd&gt;&gt;5];
int X[maxn],Y[maxn],n,m;
int ocrX[maxd],ocrY[maxd];
bool check(int l,int r,int p,int q,int num)
{
    int id=l*maxd+num;
    if(Save[id&gt;&gt;5]&amp;(1&lt;&lt;(id&amp;31)))return true;
    Save[id&gt;&gt;5]|=1&lt;&lt;(id&amp;31);
    if(num==1)
    {
        if(X[l]==Y[p])return true;
        return false;
    }
    //Prefix
    int pX,pY;
    for(int i=r;i&gt;=l;i--)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=q;i&gt;=p;i--)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return false;
    if(!check(l,pX-1,p,pY-1,num-1))return false;
    for(int i=pX;i&lt;=r;i++)++ocrX[X[i]];
    for(int i=pY;i&lt;=q;i++)++ocrY[Y[i]];
    //Suffix
    for(int i=l;i&lt;=r;i++)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=p;i&lt;=q;i++)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return false;
    if(!check(pX+1,r,pY+1,q,num-1))return false;
    for(int i=l;i&lt;=pX;i++)++ocrX[X[i]];
    for(int i=p;i&lt;=pY;i++)++ocrY[Y[i]];
    return true;
}
void solve()
{
    scanf("%d%d",&amp;n,&amp;m);int p=0,l=-1,x;
    rep(i,n){scanf("%d",&amp;x);if(x!=l)X[p++]=x,l=x;};n=p;l=-1;p=0;
    rep(i,m){scanf("%d",&amp;x);if(x!=l)Y[p++]=x,l=x;};m=p;
    memset(ocrX,0,sizeof ocrX);
    memset(ocrY,0,sizeof ocrY);
    rep(i,n)ocrX[X[i]]++;
    rep(i,m)ocrY[Y[i]]++;
    bool ok=1;int num=0;
    rep(i,maxd)if(ocrX[i])
    {
        if(!ocrY[i]){ok=false;break;}
        num++;
    }
    if(!ok){puts("0");return;}
    memset(Save,0,sizeof Save);
    if(check(0,n-1,0,m-1,num))puts("1");
    else puts("0");
}
int main()
{
    //freopen("in","r",stdin);
    int t;cin&gt;&gt;t;rep(i,t)solve();
}


<pre><h2>Problem1118</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#include &lt;bitset&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=100000+10,maxd=101;
using namespace std;
unsigned int Save[maxn*maxd&gt;&gt;5];
int X[maxn],Y[maxn],n,m;
int ocrX[maxd],ocrY[maxd];
bool check(int l,int r,int p,int q,int num)
{
    int id=l*maxd+num;
    if(Save[id&gt;&gt;5]&amp;(1&lt;&lt;(id&amp;31)))return true;
    Save[id&gt;&gt;5]|=1&lt;&lt;(id&amp;31);
    if(num==1)
    {
        if(X[l]==Y[p])return true;
        return false;
    }
    //Prefix
    int pX,pY;
    for(int i=r;i&gt;=l;i--)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=q;i&gt;=p;i--)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return false;
    if(!check(l,pX-1,p,pY-1,num-1))return false;
    for(int i=pX;i&lt;=r;i++)++ocrX[X[i]];
    for(int i=pY;i&lt;=q;i++)++ocrY[Y[i]];
    //Suffix
    for(int i=l;i&lt;=r;i++)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=p;i&lt;=q;i++)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return false;
    if(!check(pX+1,r,pY+1,q,num-1))return false;
    for(int i=l;i&lt;=pX;i++)++ocrX[X[i]];
    for(int i=p;i&lt;=pY;i++)++ocrY[Y[i]];
    return true;
}
int nextInt()
{
    char c;int ret;
    while(c=getchar(),c&lt;'0'||c&gt;'9');
    ret=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')ret=ret*10+c-'0';
    return ret;
}
void solve()
{
    scanf("%d%d",&amp;n,&amp;m);int p=0,l=-1,x;
    rep(i,n){x=nextInt();if(x!=l)X[p++]=x,l=x;};n=p;l=-1;p=0;
    rep(i,m){x=nextInt();if(x!=l)Y[p++]=x,l=x;};m=p;
    memset(ocrX,0,sizeof ocrX);
    memset(ocrY,0,sizeof ocrY);
    rep(i,n)ocrX[X[i]]++;
    rep(i,m)ocrY[Y[i]]++;
    bool ok=1;int num=0;
    rep(i,maxd)if(ocrX[i])
    {
        if(!ocrY[i]){ok=false;break;}
        num++;
    }
    if(!ok){puts("0");return;}
    memset(Save,0,sizeof Save);
    if(check(0,n-1,0,m-1,num))puts("1");
    else puts("0");
}
int main()
{
    //freopen("in","r",stdin);
    int t;cin&gt;&gt;t;rep(i,t)solve();
}


<pre><h2>Problem1118</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#include &lt;bitset&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=100000+10,maxd=101;
using namespace std;
unsigned int Save[maxn*maxd&gt;&gt;5];
int X[maxn],Y[maxn],n,m;
int ocrX[maxd],ocrY[maxd];
bool check(int l,int r,int p,int q,int num)
{
    int id=l*maxd+num;
    if(Save[id&gt;&gt;5]&amp;(1&lt;&lt;(id&amp;31)))return true;
    Save[id&gt;&gt;5]|=1&lt;&lt;(id&amp;31);
    if(num==1)
    {
        if(X[l]==Y[p])return true;
        return false;
    }
    //Prefix
    int pX,pY;
    for(int i=r;i&gt;=l;i--)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=q;i&gt;=p;i--)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return false;
    if(!check(l,pX-1,p,pY-1,num-1))return false;
    for(int i=pX;i&lt;=r;i++)++ocrX[X[i]];
    for(int i=pY;i&lt;=q;i++)++ocrY[Y[i]];
    //Suffix
    for(int i=l;i&lt;=r;i++)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=p;i&lt;=q;i++)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return false;
    if(!check(pX+1,r,pY+1,q,num-1))return false;
    for(int i=l;i&lt;=pX;i++)++ocrX[X[i]];
    for(int i=p;i&lt;=pY;i++)++ocrY[Y[i]];
    return true;
}
#define BUFSIZE 1000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
#define read() \
	do{ \
		if (pt &gt;= pend) \
		{ \
			pt = buf; \
			fread(buf, 1, BUFSIZE, stdin); \
		} \
	} while(0)

#define scan(t) \
{ \
	t = 0; \
	read(); \
	while (!((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {pt ++; read();} \
	while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
}
void solve()
{
    scan(n);scan(m);int p=0,l=-1,x;
    rep(i,n){scan(x);if(x!=l)X[p++]=x,l=x;};n=p;l=-1;p=0;
    rep(i,m){scan(x);if(x!=l)Y[p++]=x,l=x;};m=p;
    memset(ocrX,0,sizeof ocrX);
    memset(ocrY,0,sizeof ocrY);
    rep(i,n)ocrX[X[i]]++;
    rep(i,m)ocrY[Y[i]]++;
    bool ok=1;int num=0;
    rep(i,maxd)if(ocrX[i])
    {
        if(!ocrY[i]){ok=false;break;}
        num++;
    }
    if(!ok){puts("0");return;}
    memset(Save,0,sizeof Save);
    if(check(0,n-1,0,m-1,num))puts("1");
    else puts("0");
}
int main()
{
    //freopen("in","r",stdin);
    int t;scan(t);rep(i,t)solve();
}


<pre><h2>Problem1118</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#include &lt;bitset&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=100000+10,maxd=101;
using namespace std;
unsigned int Save[maxn*maxd&gt;&gt;5];
int X[maxn],Y[maxn],n,m;
int ocrX[maxd],ocrY[maxd];
bool check(int l,int r,int p,int q,int num)
{
    int id=l*maxd+num;unsigned int&amp;tmp=Save[id&gt;&gt;5];
    if(tmp&amp;(1&lt;&lt;(id&amp;31)))return true;
    tmp|=1&lt;&lt;(id&amp;31);
    if(num==1)
    {
        if(X[l]==Y[p])return true;
        return false;
    }
    //Prefix
    int pX,pY;
    for(int i=r;i&gt;=l;i--)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=q;i&gt;=p;i--)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return false;
    if(!check(l,pX-1,p,pY-1,num-1))return false;
    for(int i=pX;i&lt;=r;i++)++ocrX[X[i]];
    for(int i=pY;i&lt;=q;i++)++ocrY[Y[i]];
    //Suffix
    for(int i=l;i&lt;=r;i++)if(!--ocrX[X[i]]){pX=i;break;}
    for(int i=p;i&lt;=q;i++)if(!--ocrY[Y[i]]){pY=i;break;}
    if(X[pX]!=Y[pY])return false;
    if(!check(pX+1,r,pY+1,q,num-1))return false;
    for(int i=l;i&lt;=pX;i++)++ocrX[X[i]];
    for(int i=p;i&lt;=pY;i++)++ocrY[Y[i]];
    return true;
}
#define BUFSIZE 1000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
#define read() \
	do{ \
		if (pt &gt;= pend) \
		{ \
			pt = buf; \
			fread(buf, 1, BUFSIZE, stdin); \
		} \
	} while(0)

#define scan(t) \
{ \
	t = 0; \
	read(); \
	while (!((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {pt ++; read();} \
	while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
}
void solve()
{
    scan(n);scan(m);int p=0,l=-1,x;
    rep(i,n){scan(x);if(x!=l)X[p++]=x,l=x;};n=p;l=-1;p=0;
    rep(i,m){scan(x);if(x!=l)Y[p++]=x,l=x;};m=p;
    memset(ocrX,0,sizeof ocrX);
    memset(ocrY,0,sizeof ocrY);
    rep(i,n)ocrX[X[i]]++;
    rep(i,m)ocrY[Y[i]]++;
    bool ok=1;int num=0;
    rep(i,maxd)if(ocrX[i])
    {
        if(!ocrY[i]){ok=false;break;}
        num++;
    }
    if(!ok){puts("0");return;}
    memset(Save,0,sizeof Save);
    if(check(0,n-1,0,m-1,num))puts("1");
    else puts("0");
}
int main()
{
    //freopen("in","r",stdin);
    int t;scan(t);rep(i,t)solve();
}


<pre><h2>Problem1121</h2><pre>t;main(){scanf("%d",&amp;t);printf("%d",t/2);}<pre><h2>Problem1125</h2><pre>/*
 * [POI2008]Poc_2.cpp
 *
 *  Created on: 2011-3-7
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int SEED = 37;
const int MAX_LEN = 100 + 10;
const int MAX_NTRAINS = 1000 + 10;
const int MAX_NOPTS = 250000;
int pow[MAX_LEN];
void initPow() {
	pow[0] = 1;
	for (int i = 1; i &lt; MAX_LEN; ++i) {
		pow[i] = pow[i - 1] * SEED;
	}
}

int nTrains, trainLen, nOpts;

struct Train {
	int what[MAX_LEN];
	int hashCode;
	void read() {
		static char str[MAX_LEN];
		scanf(" ");
		scanf("%s", str);
		hashCode = 0;
		for (int i = 0; i &lt; trainLen; ++i) {
			what[i] = str[i];
			hashCode += what[i] * pow[i];
		}
	}

	void change(int at, int toWhat) {
		hashCode += (toWhat - what[at]) * pow[at];
		what[at] = toWhat;
	}
};

Train trains[MAX_NTRAINS];
int maxSame[MAX_NTRAINS] = { };
const int MAX_NEVENTS = MAX_NOPTS * 2;

struct Event {
	int hashCode;
	int add, id;
	Event(){}
	Event(int _hashCode,int _add, int _id) :
		hashCode(_hashCode),add(_add), id(_id) {
	}
	bool operator&lt;(const Event&amp;e)const{
		return hashCode&lt;e.hashCode;
	}
};

Event events[MAX_NEVENTS];
int nEvnets;

struct UF {
	int F[MAX_NEVENTS];
	int find(int x) {
		return x == F[x] ? x : (F[x] = find(F[x]));
	}
	void unite(int a, int b) {
		a = find(a);
		b = find(b);
		F[a] = b;
	}
	void init(int n) {
		for (int i = 0; i &lt; n; ++i) {
			F[i] = i;
		}
	}
};

void process(Event events[],int n) {
	static int where[MAX_NTRAINS] = { };
	static int num[MAX_NEVENTS];
	static int stack[MAX_NEVENTS];
	static UF U;
	U.init(n);
	int cnt = 0;
	for (int i = 0; i &lt; n; ++i) {
		cnt += events[i].add;
		num[i] = cnt;
	}
	int top = 0;
	for (int i = 0; i &lt; n; ++i) {
		while (top &gt; 0 &amp;&amp; num[stack[top - 1]] &lt;= num[i]) {
			U.unite(stack[top - 1], i);
			--top;
		}
		stack[top++] = i;
		const Event&amp;e = events[i];
		if (e.add == 1) {
			where[e.id] = i;
		} else {
			int nSame = num[U.find(where[e.id])];
			if (nSame &gt; maxSame[e.id])
				maxSame[e.id] = nSame;
		}
	}
}

void insertTrain(int id) {
	Train&amp;train = trains[id];
	int hashCode = train.hashCode;
	//	if(id == 4)
	//		cout&lt;&lt;hashCode&lt;&lt;":insert"&lt;&lt;id&lt;&lt;endl;
	events[nEvnets++]=Event(hashCode,1,id);
}

void eraseTrain(int id) {
	Train&amp;train = trains[id];
	int hashCode = train.hashCode;
	//	if(id == 4)
	//		cout&lt;&lt;hashCode&lt;&lt;":erase"&lt;&lt;id&lt;&lt;endl;
	events[nEvnets++]=Event(hashCode,-1,id);
}

inline void scanInt(int&amp;ret){
	char ch;while(ch=getchar(),ch&lt;'0'||ch&gt;'9');ret=ch-'0';
	while(ch=getchar(),ch&gt;='0'&amp;&amp;ch&lt;='9')ret=ret*10+ch-'0';
}

void processALL(){
	stable_sort(events,events+nEvnets);
	for (int cur = 0; cur &lt; nEvnets; ) {
		int left=cur;
		int right=cur;
		while(events[right].hashCode == events[left].hashCode)
			++right;
		process(events+left,right-left);
		cur=right;
	}
}

int main() {
//	freopen("in", "r", stdin);
	initPow();
	scanf("%d%d%d", &amp;nTrains, &amp;trainLen, &amp;nOpts);
	for (int i = 0; i &lt; nTrains; ++i) {
		trains[i].read();
		insertTrain(i);
	}
	for (int opt = 0; opt &lt; nOpts; ++opt) {
		int a, whereA, b, whereB;
		scanInt(a);scanInt(whereA);scanInt(b);scanInt(whereB);
		--a;
		--b;
		--whereA;
		--whereB;
		eraseTrain(a);
		if (a != b)
			eraseTrain(b);
		Train&amp;trainA = trains[a];
		Train&amp;trainB = trains[b];
		int whatA = trainA.what[whereA];
		int whatB = trainB.what[whereB];
		trainA.change(whereA, whatB);
		trainB.change(whereB, whatA);
		insertTrain(a);
		if (a != b)
			insertTrain(b);
	}

	for (int id = 0; id &lt; nTrains; ++id) {
		eraseTrain(id);
	}

	processALL();

	for (int id = 0; id &lt; nTrains; ++id) {
		printf("%d\n", maxSame[id]);
	}
}
<pre><h2>Problem1135</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
typedef long long ll;
struct info
{
    ll L,R,S,M;
    void add(int w)
    {
        S+=w;M=L=R=max(S,0LL);
    }
};
info operator+(const info&amp;L,const info&amp;R)
{
    info F;
    F.S=L.S+R.S;
    F.L=max(L.L,L.S+R.L);
    F.R=max(R.R,R.S+L.R);
    F.M=max(L.R+R.L,max(L.M,R.M));
    return F;
}
const int maxt=1&lt;&lt;20;
info I[maxt*2];
int off;
void Update(int p,int w)
{
    for(p+=off,I[p].add(w),p&gt;&gt;=1;p;p&gt;&gt;=1)
        I[p]=I[p*2]+I[p*2+1];
}
int n,m,k,d;
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;d);
    off=1;while(off&lt;=n-d)off&lt;&lt;=1;
    for(int i=1;i&lt;=n-d;i++)Update(i,-k);
    int r,x;
    while(m--)
    {
        scanf("%d%d",&amp;r,&amp;x);
        Update(r,x);
        if(I[1].M&lt;=ll(d)*k)
            puts("TAK");
        else
            puts("NIE");
    }
}
<pre><h2>Problem1138</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=400,maxc=26;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
vector&lt;int&gt; Edge_For[maxn][maxc],Edge_Back[maxn][maxc];
int Dist[maxn][maxn][maxc+1]={},n,m;
void AddEdge(int s,int t,char c)
{
    Edge_For[s][c-'a'].pb(t);
    Edge_Back[t][c-'a'].pb(s);
}
struct State
{
    int a,b,c;
    State(){}
    State(int _a,int _b,int _c):
        a(_a),b(_b),c(_c){}
};
const int maxs=maxn*maxn*27;
struct Queue
{
    State Q[maxs];
    int h,t;
    Queue():h(0),t(0){}
    void inc(int&amp;t)
    {
        if(++t==maxs)t=0;
    }
    void add(const State&amp;s)
    {
        Q[t]=s;inc(t);
    }
    State pop()
    {
        State tmp=Q[h];inc(h);
        return tmp;
    }
    bool empty(){return h==t;}
}Q;
void BFS()
{
    memset(Dist,-1,sizeof Dist);
    rep(i,n)
    {
        Dist[i][i][maxc]=0;
        Q.add(State(i,i,maxc));
    }
    rep(i,n)rep(j,maxc)
        tr(e,Edge_For[i][j])
        {
            if(Dist[i][*e][maxc]==-1)
            {
                Dist[i][*e][maxc]=1;
                Q.add(State(i,*e,maxc));
            }
        }
    while(!Q.empty())
    {
        State now=Q.pop();
        int a=now.a,b=now.b,c=now.c;
        int cost=Dist[a][b][c];
        if(c&lt;maxc)
        {
            tr(e,Edge_For[b][c])
            {
                int&amp;ncost=Dist[a][*e][maxc];
                if(ncost==-1)
                {
                    ncost=cost+1;
                    Q.add(State(a,*e,maxc));
                }
            }
        }
        else
        {
            rep(j,maxc)
                tr(e,Edge_Back[a][j])
                {
                    int&amp;ncost=Dist[*e][b][j];
                    if(ncost==-1)
                    {
                        ncost=cost+1;
                        Q.add(State(*e,b,j));
                    }
                }
        }
    }
}
int D,S[maxn];
void Init()
{
    scanf("%d%d",&amp;n,&amp;m);int s,t;char c;
    rep(i,m)
    {
        scanf("%d %d %c",&amp;s,&amp;t,&amp;c);
        --s;--t;
        AddEdge(s,t,c);
    }
    scanf("%d",&amp;D);
    rep(i,D)scanf("%d",S+i),S[i]--;
}
void Solve()
{
    BFS();
    rep(i,D-1)printf("%d\n",Dist[S[i]][S[i+1]][maxc]);
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


<pre><h2>Problem1143</h2><pre>/*
 *  [CTSC2008]祭祀 river.cpp
 *
 *  Created on: 2011-4-17
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VERTEXS = 100;

struct Vertex {
	vector&lt;Vertex*&gt; adj;

	bool reach[MAX_N_VERTEXS];
	bool visited;

	void dfs() {
		if (visited)
			return;
		visited = true;
		foreach(iter,adj) {
			Vertex*v = *iter;
			v-&gt;dfs();
		}
	}
};

Vertex vs[MAX_N_VERTEXS];
int nVets, nEdges;

void readInput() {
	scanf("%d%d", &amp;nVets, &amp;nEdges);
	for (int i = 0; i &lt; nEdges; ++i) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		Vertex*u = vs + --a, *v = vs + --b;
		u-&gt;adj.push_back(v);
	}
}

const int INF = ~0U &gt;&gt; 1;
struct Network {
	static const int MAX_N_VETS = MAX_N_VERTEXS * 2 + 2;
	static const int MAX_N_EDGES = MAX_N_VETS * MAX_N_VETS * 2;

	int head[MAX_N_VETS];
	int dest[MAX_N_EDGES], cap[MAX_N_EDGES], next[MAX_N_EDGES];

	int nVets, nEdges;
	int vs, vt;

	void init(int _nVets, int _vs, int _vt) {
		nVets = _nVets;
		vs = _vs;
		vt = _vt;
		memset(head, -1, sizeof head);
		nEdges = 0;
	}

	void makeEdge(int s, int t, int c) {
		int id = nEdges++;
		next[id] = head[s];
		dest[id] = t;
		cap[id] = c;
		head[s] = id;
	}

	void addEdge(int s, int t, int c) {
		makeEdge(s, t, c);
		makeEdge(t, s, 0);
	}

	int am[MAX_N_VETS], prev[MAX_N_VETS], h[MAX_N_VETS], cnt[MAX_N_VETS],
			cur[MAX_N_VETS];
	int totalFlow;

	int calcMaxFlow() {
		memset(am, 0, sizeof am);
		memset(cur, -1, sizeof cur);
		memset(h, 0, sizeof h);
		memset(cnt, 0, sizeof cnt);
		cnt[0] = nVets;
		int u = vs, now;
		totalFlow = 0;
		am[u] = INF;
		while (h[vs] &lt; nVets) {
			for (now = cur[u]; now != -1; now = next[now])
				if (cap[now] &gt; 0 &amp;&amp; h[u] == h[dest[now]] + 1)
					break;
			if (now != -1) {
				int v = dest[now];
				cur[u] = prev[v] = now;
				am[v] = min(am[u], cap[now]);
				u = v;
				if (u == vt) {
					int by = am[u];
					while (u != vs) {
						cap[prev[u]] -= by;
						cap[prev[u] ^ 1] += by;
						u = dest[prev[u] ^ 1];
					}
					totalFlow += by;
					am[u] = INF;
				}
			} else {
				if (!--cnt[h[u]])
					break;
				h[u] = nVets;
				for (now = head[u]; now != -1; now = next[now])
					if (cap[now] &gt; 0 &amp;&amp; h[dest[now]] + 1 &lt; h[u]) {
						h[u] = h[dest[now]] + 1;
						cur[u] = now;
					}
				++cnt[h[u]];
				if (u != vs)
					u = dest[prev[u] ^ 1];
			}
		}

		return totalFlow;
	}
};

void work() {
	for (Vertex*u = vs; u &lt; vs + nVets; ++u) {
		for (Vertex*i = vs; i &lt; vs + nVets; ++i)
			i-&gt;visited = false;
		u-&gt;dfs();
		for (int i = 0; i &lt; nVets; ++i) {
			u-&gt;reach[i] = vs[i].visited;
		}
	}
	static Network network;
	int nV = nVets * 2;
	int S = nV++, T = nV++;
	network.init(nV, S, T);
	for (int u = 0; u &lt; nVets; ++u) {
		for (int v = 0; v &lt; nVets; ++v) {
			if (vs[u].reach[v] &amp;&amp; u != v) {
//				cout &lt;&lt; u &lt;&lt; "-&gt;" &lt;&lt; v &lt;&lt; endl;
				network.addEdge(u, v + nVets, 1);
			}
		}
		network.addEdge(S, u, 1);
		network.addEdge(u + nVets, T, 1);
	}

	int ans = nVets - network.calcMaxFlow();
	printf("%d\n", ans);
}

int main() {
	readInput();
	work();
}
<pre><h2>Problem1145</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1;
using namespace std;
const int maxn=200000+10;
int A[maxn],n;
typedef long long ll;
struct Seg
{
    int l,r;
    Seg(){}
    Seg(int _l,int _r):
        l(_l),r(_r){}
    Seg left(){return Seg(l,l+r&gt;&gt;1);}
    Seg right(){return Seg(l+r&gt;&gt;1,r);}
    bool Sep(const Seg&amp;S)const
    {
        return l&gt;=S.r||S.l&gt;=r;
    }
    bool Contain(const Seg&amp;S)const
    {
        return l&lt;=S.l&amp;&amp;r&gt;=S.r;
    }
    bool Contain(int t)const
    {
        return l&lt;=t&amp;&amp;t&lt;r;
    }
    bool Single(){return l+1==r;}
}root;
struct info
{
    int Sum,SqrSum,Num;
    bool e;
    void clear(){Sum=SqrSum=Num=0;}
    void set(int x)
    {
        Num=1;
        Sum=x;SqrSum=x*x;
    }
    info(bool _e=true){e=_e;clear();}
}I[maxn*4];
int Mark[maxn*4]={};
void SetSize(int n)
{
    root=Seg(0,n);
    rep(i,4*n)Mark[i]=0,I[i].clear();
}
info operator+(const info&amp;L,const info&amp;R)
{
    if(!L.e){return R;}
    if(!R.e){return L;}
    info F;
    F.Sum=L.Sum+R.Sum;
    F.Num=L.Num+R.Num;
    F.SqrSum=L.SqrSum+R.SqrSum;
    return F;
}
void Update(int t)
{
    I[t]=I[t*2]+I[t*2+1];
}
void Mark_Add(int t,int add)
{
    info&amp;i=I[t];
    Mark[t]+=add;
    i.SqrSum+=2*add*i.Sum+add*add*i.Num;
    i.Sum+=i.Num*add;
}
void Push_Down(int t)
{
    if(Mark[t])
    {
        Mark_Add(t*2,Mark[t]);
        Mark_Add(t*2+1,Mark[t]);
        Mark[t]=0;
    }
}
info Ask(int t,Seg T,Seg A)
{
    if(T.Sep(A))return info(false);
    if(A.Contain(T))return I[t];
    Push_Down(t);
    return Ask(t*2,T.left(),A)+Ask(t*2+1,T.right(),A);
}
void Change_Insert(int t,Seg T,int a,int v)
{
    if(!T.Contain(a))return;
    if(T.Single())
    {
        I[t].set(v);
        return;
    }
    Push_Down(t);
    Change_Insert(t*2,T.left(),a,v);
    Change_Insert(t*2+1,T.right(),a,v);
    Update(t);
}
void Change_Add(int t,Seg T,Seg A,int add)
{
    if(T.Sep(A))return;
    if(A.Contain(T)){Mark_Add(t,add);return;}
    Push_Down(t);
    Change_Add(t*2,T.left(),A,add);
    Change_Add(t*2+1,T.right(),A,add);
    Update(t);
}
struct TA
{
    int A[maxn],n;
    void SetSize(int _n)
    {
        n=_n;memset(A,0,sizeof A);
    }
    void clear()
    {
        memset(A,0,sizeof A);
    }
    void Add(int p,int x)
    {
        for(p++;p&lt;=n;p+=p&amp;-p)
            A[p-1]+=x;
    }
    int Sum(int p)
    {
        int ret=0;
        for(p++;p;p-=p&amp;-p)
            ret+=A[p-1];
        return ret;
    }
    int Sum(int l,int r)
    {
        return Sum(r)-Sum(l-1);
    }
}T[3];
void Input_Data()
{
    scanf("%d",&amp;n);
    rep(i,n)scanf("%d",A+i),A[i]--;
}
int p[maxn];
bool cmp(int i,int j)
{
    return A[i]&lt;A[j];
}
void Solve()
{
    int Ans=0;
    rep(i,3)T[i].SetSize(n);
    rep(i,n)
    {
        Ans+=T[2].Sum(A[i]-1);
        for(int j=2;j&gt;=1;j--)
        {
            T[j].Add(A[i],T[j-1].Sum(A[i]-1));
        }
        T[0].Add(A[i],1);
    }
    T[0].clear();
    T[1].clear();
    rep(i,n)T[1].Add(i,1);
    rep(i,n)
    {
        T[1].Add(A[i],-1);
        T[0].Add(A[i],1);
        int L=T[0].Sum(A[i]-1);
        int R=T[1].Sum(A[i]+1,n-1);
        R=ll(R)*(R-1)/2;
        Ans-=L*R;
    }
    SetSize(n);
    rep(i,n)p[A[i]]=i;
    rep(i,n)
    {
        int t=p[i];
        int v=(n-1-t)-Ask(1,root,Seg(t+1,n)).Num;
        Change_Add(1,root,Seg(0,t),-1);
        Change_Insert(1,root,t,v);
        info a=Ask(1,root,Seg(0,t));
        Ans+=(a.Sum-a.Num*v)*v;
    }
    SetSize(n);
    rep(i,n)
    {
        int t=A[i];
        int v=(n-1-t)-Ask(1,root,Seg(t+1,n)).Num;
        Change_Insert(1,root,t,v);
        Change_Add(1,root,Seg(0,t),-1);
        info a=Ask(1,root,Seg(0,t));
        int ret=a.SqrSum+a.Num*v*v-2*a.Sum*v-a.Sum+a.Num*v;
        ret/=2;
        Ans-=ret;
    }
    unsigned int out=Ans;
    out%=16777216;
    cout&lt;&lt;out&lt;&lt;endl;
}
int main()
{
    Input_Data();
    Solve();
}


<pre><h2>Problem1146</h2><pre>/*
 *  [CTSC2008]网络管理Network.cpp
 *
 *  Created on: 2011-4-12
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

//const int MAX_NLOGN = MAX_N_VERTEXS * 20;

struct Node {
	Node*ch[2];
	int key, value, size;

	Node(int _value);

	Node() {
		size = 0;
		key = INT_MAX;
	}

	void update() {
		size = ch[0]-&gt;size + ch[1]-&gt;size + 1;
	}
} Tnull, *null = &amp;Tnull;

Node::Node(int _value) {
	value = _value;
	size = 1;
	key = rand();
	ch[0] = ch[1] = null;
}

struct Treap {
	Node*root;

	Treap() {
		root = null;
	}

	void rotate(Node*&amp;t, bool d) {
		Node*p = t-&gt;ch[d];
		t-&gt;ch[d] = p-&gt;ch[!d];
		p-&gt;ch[!d] = t;
		t-&gt;update();
		p-&gt;update();
		if (t == root)
			root = p;
		t = p;
	}

	void doInsert(Node*&amp;t, int x) {
		if (t == null) {
			t = new Node(x);
			return;
		}
		bool dir = x &gt; t-&gt;value;
		doInsert(t-&gt;ch[dir], x);
		if (t-&gt;ch[dir]-&gt;key &lt; t-&gt;key)
			rotate(t, dir);
		else
			t-&gt;update();
	}

	void doErase(Node*&amp;t, int x) {
		if (t == null)
			return;
		if (t-&gt;value == x) {
			bool dir = t-&gt;ch[1]-&gt;key &lt; t-&gt;ch[0]-&gt;key;
			if (t-&gt;ch[dir] == null) {
				delete t;
				t = null;
				return;
			}
			rotate(t, dir);
			doErase(t-&gt;ch[!dir], x);
		} else {
			bool dir = x &gt; t-&gt;value;
			doErase(t-&gt;ch[dir], x);
		}
		t-&gt;update();
	}

	int doCountSmall(Node*t, int x) {
		if (t == null)
			return 0;
		if (t-&gt;value &gt;= x) {
			return doCountSmall(t-&gt;ch[0], x);
		}
		return doCountSmall(t-&gt;ch[1], x) + 1 + t-&gt;ch[0]-&gt;size;
	}

	void insert(int x) {
		doInsert(root, x);
	}

	void erase(int x) {
		doErase(root, x);
	}

	int countSmall(int x) {
		return doCountSmall(root, x);
	}
};

struct Tree {
	int left, right;
	Treap*treap;

	Tree*ch[2];

	Tree(int pathValue[], int _left, int _right) {
		left = _left;
		right = _right;
		//		cout &lt;&lt; left &lt;&lt; "-" &lt;&lt; right &lt;&lt; endl;
		int mid = left + right &gt;&gt; 1;

		treap = new Treap;
		for (int i = left; i &lt; right; ++i) {
			treap-&gt;insert(pathValue[i]);
		}

		if (left + 1 == right)
			return;
		ch[0] = new Tree(pathValue, left, mid);
		ch[1] = new Tree(pathValue, mid, right);
	}

	int countSmall(int askLeft, int askRight, int x) {
		if (askRight &lt;= left || right &lt;= askLeft)
			return 0;
		if (askLeft &lt;= left &amp;&amp; askRight &gt;= right)
			return treap-&gt;countSmall(x);
		int ret = 0;
		for (int c = 0; c &lt; 2; ++c) {
			ret += ch[c]-&gt;countSmall(askLeft, askRight, x);
		}
		return ret;
	}

	void change(int at, int oldX, int newX) {
		if (at &lt; left || at &gt;= right)
			return;
		treap-&gt;erase(oldX);
		treap-&gt;insert(newX);
		if (left + 1 == right)
			return;
		for (int c = 0; c &lt; 2; ++c) {
			ch[c]-&gt;change(at, oldX, newX);
		}
	}
};

struct Vertex {
	vector&lt;Vertex*&gt; adj;
	int value;

	int size, depth, ordInPath;

	Vertex*pathTop, *father;

	Tree*tree;

	void changeValue(int newValue) {
		pathTop-&gt;tree-&gt;change(ordInPath, value, newValue);
		value = newValue;
	}
};

const int MAX_N_VERTEXS = 80000 + 10;

Vertex vs[MAX_N_VERTEXS];

int nVertexs, nQueries;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

void readInput() {
	scanInt(nVertexs);
	scanInt(nQueries);
	for (int i = 0; i &lt; nVertexs; ++i) {
		Vertex*v = vs + i;
		scanInt(v-&gt;value);
		v-&gt;adj.clear();
	}
	for (int i = 0; i &lt; nVertexs - 1; ++i) {
		int a, b;
		scanInt(a);
		scanInt(b);
		--a;
		--b;
		Vertex*u = vs + a, *v = vs + b;
		u-&gt;adj.push_back(v);
		v-&gt;adj.push_back(u);
	}
}

Vertex*bfsOrd[MAX_N_VERTEXS];

void doBFS(Vertex*vs, Vertex* que[]) {
	vs-&gt;father = 0;
	vs-&gt;depth = 0;
	int qh = 0, qt = 0;
	que[qt++] = vs;
	while (qh &lt; qt) {
		Vertex*u = que[qh++];
		foreach(iter,u-&gt;adj) {
			Vertex*v = *iter;
			if (v == u-&gt;father)
				continue;
			v-&gt;father = u;
			v-&gt;depth = u-&gt;depth + 1;
			que[qt++] = v;
		}
	}
}

int pathValue[MAX_N_VERTEXS];
void doSplitPath() {
	for (int i = 0; i &lt; nVertexs; ++i) {
		Vertex*v = vs + i;
		v-&gt;pathTop = 0;
	}

	for (int at = nVertexs - 1; at &gt;= 0; --at) {
		Vertex*u = bfsOrd[at];
		u-&gt;size = 1;
		foreach(iter,u-&gt;adj) {
			Vertex*v = *iter;
			if (v == u-&gt;father)
				continue;
			u-&gt;size += v-&gt;size;
		}
	}

	for (int at = 0; at &lt; nVertexs; ++at) {
		Vertex*top = bfsOrd[at];
		if (top-&gt;pathTop != 0)
			continue;

		int cnt = 0;
		for (Vertex*u = top; u != 0;) {
			u-&gt;ordInPath = cnt;
			u-&gt;pathTop = top;
			pathValue[cnt++] = u-&gt;value;

			Vertex*next = 0;
			foreach(iter,u-&gt;adj) {
				Vertex*v = *iter;
				if (v == u-&gt;father)
					continue;
				if (next == 0 || v-&gt;size &gt; next-&gt;size)
					next = v;
			}

			u = next;
		}

		top-&gt;tree = new Tree(pathValue, 0, cnt);
	}
}

int countSmallPath(Vertex*u, Vertex*v, int x) {
	int ret = 0;
	for (;;) {
		if (u-&gt;pathTop == v-&gt;pathTop) {
			if (u-&gt;depth &lt; v-&gt;depth)
				swap(u, v);
			ret += u-&gt;pathTop-&gt;tree-&gt;countSmall(v-&gt;ordInPath, u-&gt;ordInPath + 1,
					x);
			return ret;
		} else {
			if (u-&gt;pathTop-&gt;depth &lt; v-&gt;pathTop-&gt;depth)
				swap(u, v);
			ret += u-&gt;pathTop-&gt;tree-&gt;countSmall(0, u-&gt;ordInPath + 1, x);
			u = u-&gt;pathTop-&gt;father;
		}
	}
}

const int MAX_VALUE = int(1e8) + 2;

int getKth(Vertex*u, Vertex*v, int kth) {
	int l = -1, r = MAX_VALUE;
	int num = countSmallPath(u, v, r + 1);
	if (num &lt;= kth)
		return -1;
	kth = num - kth - 1;
	//C(x) = |v on u-v and v&lt;=x|
	//C(l)&lt;=kth,C(r)&gt;=kth+1
	while (l + 1 &lt; r) {
		int m = l + r &gt;&gt; 1;
		int cnt = countSmallPath(u, v, m + 1);
		if (cnt &gt;= kth + 1)
			r = m;
		else
			l = m;
	}
	return r;
}

void answerQueries() {
	for (int i = 0; i &lt; nQueries; ++i) {
		int k, a, b;
		//		cout &lt;&lt; "I:" &lt;&lt; i &lt;&lt; endl;
		scanf("%d%d%d", &amp;k, &amp;a, &amp;b);
		if (k == 0) {
			Vertex*v = vs + (--a);
			v-&gt;changeValue(b);
		} else {
			--k;
			Vertex*u = vs + (--a), *v = vs + (--b);
			int ret = getKth(u, v, k);
			if (ret == -1)
				puts("invalid request!");
			else
				printf("%d\n", ret);
		}
	}
}

void prepare() {
	doBFS(vs + 0, bfsOrd);
	doSplitPath();
}

int main() {
	readInput();
	prepare();
	answerQueries();
}
<pre><h2>Problem1148</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=200000;
using namespace std;
typedef long long ll;
struct Repair
{
    ll Dead,Time;
    bool operator&lt;(const Repair&amp;p)const
    {
        return Dead&lt;p.Dead;
    }
};
Repair R[maxn];
priority_queue&lt;ll&gt; PQ;
int N;
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;N;rep(i,N)scanf("%I64d %I64d",&amp;R[i].Dead,&amp;R[i].Time),R[i].Dead+=R[i].Time;
    sort(R,R+N);ll total=0,ans=0;
    rep(i,N)
    {
        if(R[i].Time+total&lt;=R[i].Dead)
            PQ.push(R[i].Time),total+=R[i].Time,ans++;
        else
        {
            if(R[i].Time&lt;PQ.top())
            {
                total-=PQ.top();PQ.pop();
                PQ.push(R[i].Time);total+=R[i].Time;
            }
        }
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    cout&lt;&lt;total&lt;&lt;endl;
}
<pre><h2>Problem1150</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int maxn=100000+100;
using namespace std;
typedef long long ll;
const ll inf=1LL&lt;&lt;60;
ll A[maxn];
int n,k,L[maxn],R[maxn];
struct cmp
{
    bool operator()(int i,int j)
    {
        return A[i]&gt;A[j];
    }
};
priority_queue&lt;int,vector&lt;int&gt;,cmp&gt; PQ;
bool active[maxn];
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d",&amp;n,&amp;k);
    for(int i=1;i&lt;=n;i++)scanf("%d",A+i);
    A[0]=A[n+1]=inf;
    for(int i=1;i&lt;=n;i++)A[i]=A[i+1]-A[i],L[i]=i-1,R[i]=i+1,PQ.push(i),active[i]=true;
    ll ans=0;
    rep(i,k)
    {
        int t;do{t=PQ.top();PQ.pop();}while(!active[t]);
        int l=L[t],r=R[t];active[l]=active[r]=false;
        ans+=A[t];R[L[l]]=t;L[R[r]]=t;
        A[t]=A[l]+A[r]-A[t];L[t]=L[l];R[t]=R[r];
        PQ.push(t);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


<pre><h2>Problem1152</h2><pre>#include&lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int M_MAX=100000+10;
const int mod=10000;
int n,T;
int Str[M_MAX];
inline void scan(int&amp;t)
{
    char c;while(c=getchar(),c&lt;'0'||c&gt;'9');
    t=c-'0';while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';   
}
int pi[M_MAX];
int Mark[M_MAX]={},Flag=0;
void Solve()
{
    int m;scan(m);
    rep(i,m)scan(Str[i]);
    pi[0]=-1;
    for(int i=1;i&lt;m;i++)
    {
        int t=pi[i-1];
        for(;;)
        {
            if(Str[t+1]==Str[i]){t++;break;}
            if(t==-1)break;
            t=pi[t];
        }
        pi[i]=t;
    }
    ++Flag;int x=m-1;
    while(x!=-1)Mark[x]=Flag,x=pi[x];
    int tmp=n,ans=0;
    rep(i,m)
    {
        if(Mark[i]==Flag)
            ans+=tmp,ans%=mod;
        tmp*=n;tmp%=mod;
    }
    printf("%04d\n",ans);
}
int main()
{
    //freopen("in.cpp","r",stdin);
    scan(n);scan(T);n%=mod;
    rep(i,T)
    {
        Solve();   
    }
}
<pre><h2>Problem1168</h2><pre>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=20;
typedef long long ll;
const ll inf=1LL&lt;&lt;60;
int A[maxn],B[maxn],n,m=0;ll L=0,R=0;
struct Point
{
    ll x,y;
    Point(){}
    Point(ll _x,ll _y):x(_x),y(_y){}
    bool operator&lt;(const Point&amp;o)const
    {
        if(x!=o.x)return x&lt;o.x;
        return y&lt;o.y;
    }
}P[1&lt;&lt;maxn];
void Dfs(int p,ll l,ll r)
{
    if(p==n){P[m++]=Point(l,r);return;}
    Dfs(p+1,l+A[p],r);Dfs(p+1,l,r+B[p]);
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;rep(i,n)cin&gt;&gt;A[i],L+=A[i];rep(i,n)cin&gt;&gt;B[i],R+=B[i];
    Dfs(0,0,0);sort(P,P+m);int p=0;ll l=inf,r=inf;
    for(int i=0;i&lt;m;i++)
    {
        while(p&amp;&amp;P[p-1].y&lt;=P[i].y)p--;
        P[p++]=P[i];
    }
    m=p;
    for(int i=0;i&lt;m-1;i++)
    {
        ll a=P[i].x+1,b=P[i+1].y+1;
        if(!(a&lt;=L&amp;&amp;b&lt;=R))continue;
        if(a+b&gt;l+r)continue;
        if(a+b&lt;l+r)l=a,r=b;
        else if(a&lt;l)l=a,r=b;
    }
    cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl;
}
<pre><h2>Problem1171</h2><pre>/*
 *  大sz的游戏.cpp
 *
 *  Created on: 2011-5-25
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;utility&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = int(2.5e5) + 10;

int values[MAX_N * 2];
int nValues;

int D[MAX_N], L[MAX_N], R[MAX_N];
int n, maxL;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

const int BIG = int(2e9) + 10;

void readInput() {
	scanInt(n);
	scanInt(maxL);
	D[0] = 0;
	L[0] = -BIG;
	R[0] = BIG;
	for (int i = 1; i &lt; n; ++i) {
		scanInt(L[i]);
		scanInt(R[i]);
		scanInt(D[i]);
	}

	nValues = 0;
	for (int i = 0; i &lt; n; ++i) {
		++R[i];
		values[nValues++] = L[i];
		values[nValues++] = R[i];
	}

	sort(values, values + nValues);
	nValues = unique(values, values + nValues) - values;

	for (int i = 0; i &lt; n; ++i) {
		L[i] = lower_bound(values, values + nValues, L[i]) - values;
		R[i] = lower_bound(values, values + nValues, R[i]) - values;
	}
}

typedef pair&lt;int, int&gt; ipair;

int curTime;
int dp[MAX_N], can[MAX_N];

struct Tree {
	int l, r;
	Tree*L, *R;
	int minV;
	list&lt;int&gt; que;

	void maintain() {
		while (!que.empty() &amp;&amp; can[que.front()] &lt; curTime)
			que.pop_front();
	}

	void add(int me) {
		while (!que.empty() &amp;&amp; dp[que.back()] &gt;= dp[me]) {
			que.pop_back();
		}
		que.push_back(me);
	}

	int get() {
		if (que.empty())
			return BIG;
		return dp[que.front()];
	}

	Tree(int _l, int _r) :
		l(_l), r(_r), minV(BIG) {
		if (l + 1 == r) {
			L = R = 0;
			return;
		}
		L = new Tree(l, l + r &gt;&gt; 1);
		R = new Tree(l + r &gt;&gt; 1, r);
	}

	void update() {
		minV = get();
		if (L == 0)
			return;
		minV = min(minV, L-&gt;minV);
		minV = min(minV, R-&gt;minV);
	}

	void add(int tL, int tR, int me) {
		if (tR &lt;= l || r &lt;= tL)
			return;
		if (tL &lt;= l &amp;&amp; r &lt;= tR) {
			add(me);
			update();
			return;
		}
		L-&gt;add(tL, tR, me);
		R-&gt;add(tL, tR, me);
		update();
	}

	void remove(int tL, int tR) {
		if (tR &lt;= l || r &lt;= tL)
			return;
		maintain();
		if (tL &lt;= l &amp;&amp; r &lt;= tR) {
			update();
			return;
		}
		L-&gt;remove(tL, tR);
		R-&gt;remove(tL, tR);
		update();
	}

	int calc(int tL, int tR) {
		if (tR &lt;= l || r &lt;= tL)
			return BIG;
		if (tL &lt;= l &amp;&amp; r &lt;= tR) {
			return minV;
		}
		int tmp = get();
		tmp = min(tmp, L-&gt;calc(tL, tR));
		tmp = min(tmp, R-&gt;calc(tL, tR));
		return tmp;
	}
}*root;

vector&lt;int&gt; byCan[MAX_N];

void work() {
	root = new Tree(0, nValues);

	int r = 0;
	for (int i = 0; i &lt; n; ++i) {
		while (r + 1 &lt; n &amp;&amp; D[r + 1] - D[i] &lt;= maxL)
			++r;
		can[i] = r;
		byCan[r].push_back(i);
	}

	dp[0] = 0;
	if (can[0] &gt; 0) {
		root-&gt;add(L[0], R[0], 0);
	}

	for (int i = 1; i &lt; n; ++i) {
		int ret = root-&gt;calc(L[i], R[i]) + 1;
		dp[i] = ret;
		printf("%d\n", ret &gt;= BIG ? -1 : ret);
		if (ret &lt; BIG)
			root-&gt;add(L[i], R[i], i);
		curTime = i + 1;
		foreach(iter,byCan[i]) {
			int at = *iter;
			root-&gt;remove(L[at], R[at]);
		}
	}
}

int main() {
	readInput();
	work();
}
<pre><h2>Problem1172</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=200,maxm=10000,maxk=200000,maxw=1000000,maxs=300;
typedef long long ll;
int mod,k,n,m,Div[maxw+1],L[maxs],dn=0,Next[maxs][maxs];
inline void Add(int&amp;x,int c){x+=c;x%=mod;}
inline void Mult(int&amp;x,int c){x*=c;x%=mod;}
int Dp[2][maxs],c1[maxs],c2[maxs];
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;mod);
    for(int i=1;i&lt;=k;i++)if(k%i==0)L[dn++]=i;
    rep(i,dn)rep(j,dn)
        for(int k=dn-1;k&gt;=0;k--)if(ll(L[i])*L[j]%L[k]==0)
        {
            Next[i][j]=k;break;
        }
    rep(i,dn)
    {
        int x=L[i];
        for(int j=x;j&lt;=maxw;j+=x)Div[j]=i;
    }
    int x,now=0,old=1;
    rep(i,m)scanf("%d",&amp;x),Add(Dp[now][Div[x]],1);
    rep(i,n-1)
    {
        swap(now,old);memset(Dp[now],0,sizeof Dp[now]);
        memset(c1,0,sizeof c1);
        memset(c2,0,sizeof c2);
        rep(i,m)scanf("%d",&amp;x),Add(c1[Div[x]],1);
        memcpy(c2,c1,sizeof c1);
        if(i!=n-2)
            rep(a,dn)rep(b,a+1)
                if(a!=b)Add(c2[Next[a][b]],c1[a]*c1[b]*2);
                else Add(c2[Next[a][b]],c1[a]*(c1[a]-1));
        rep(a,dn)rep(b,dn)
            Add(Dp[now][Next[a][b]],Dp[old][a]*c2[b]);
    }
    printf("%d\n",Dp[now][dn-1]);
}
<pre><h2>Problem1176</h2><pre>/*
 *  [Balkan2007]Mokia.cpp
 *
 *  Created on: 2011-4-7
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
//#define DEBUG
#define printWithName(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

enum OperationType {
	ADD, QUERY
};

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

struct Operation {
	OperationType type;
	vector&lt;int&gt; args;

	bool read() {
		int x;
		scanInt(x);
		if (x == 3)
			return false;
		type = x == 1 ? ADD : QUERY;

		int nArgs = type == ADD ? 3 : 4;
		for (int i = 0; i &lt; nArgs; ++i) {
			int x;
			scanInt(x);
			args.push_back(x);
		}

		return true;
	}
};

const int MAX_N_OPTS = 170000 + 10;

Operation opts[MAX_N_OPTS];
int nOpts;

void readInput() {
	int W;
	scanInt(W);
	scanInt(W);
	nOpts = 0;
	while (opts[nOpts].read())
		++nOpts;
#ifdef DEBUG
	printWithName(nOpts);
#endif
}

int ret[MAX_N_OPTS];

namespace Sub {

	struct Compresser {
		int what[MAX_N_OPTS];
		int n;

		void clear() {
			n = 0;
		}

		void add(int x) {
			what[n++] = x;
		}

		void doit() {
			sort(what, what + n);
			n = unique(what, what + n) - what;
		}

		void compress(int&amp;l, int&amp;r) {
			firstExceed(l);
			lastLower(r);
		}

		void lastLower(int&amp;x) {
			x = upper_bound(what, what + n, x) - what - 1;
		}

		void firstExceed(int&amp;x) {
			x = lower_bound(what, what + n, x) - what;
		}

		void compress(int&amp;x) {
			firstExceed(x);
		}
	};

	Compresser compX, compY;

	struct Query {
		int ly, ry;
		int*toChange;
		int factor;

		void set(int _ly, int _ry, int*_toChange, int _factor) {
			ly = _ly;
			ry = _ry;
			toChange = _toChange;
			factor = _factor;
		}

		Query*next;
	};

	Query qs[MAX_N_OPTS];
	Query*queryFirst[MAX_N_OPTS];
	int nQs;

	struct Point {
		int y, add;
		void set(int _y, int _add) {
			y = _y;
			add = _add;
		}
		Point*next;
	};

	Point ps[MAX_N_OPTS];
	Point*pointFirst[MAX_N_OPTS];
	int nPs;

	void addQuery(int rx, int ly, int ry, int*toChange, int factor) {
		compY.compress(ly, ry);
		compX.lastLower(rx);
		if (rx &lt; 0)
			return;
		Query*q = qs + (nQs++);
		q-&gt;set(ly, ry, toChange, factor);
		q-&gt;next = queryFirst[rx];
		queryFirst[rx] = q;
	}

	void debugQuery(int lx, int ly, int rx, int ry) {
		compX.compress(lx, rx);
		compY.compress(ly, ry);

		cout &lt;&lt; lx &lt;&lt; " " &lt;&lt; ly &lt;&lt; " " &lt;&lt; rx &lt;&lt; " " &lt;&lt; ry &lt;&lt; endl;
	}

	void addQuery(int lx, int ly, int rx, int ry, int*toChange) {
		addQuery(rx, ly, ry, toChange, 1);
		addQuery(lx - 1, ly, ry, toChange, -1);
	}

	void addPoint(int x, int y, int w) {
		compX.compress(x);
		compY.compress(y);
		Point*p = ps + (nPs++);
		p-&gt;set(y, w);
		p-&gt;next = pointFirst[x];
		pointFirst[x] = p;
	}

	void viewPoint(int x, int y) {
		compX.add(x);
		compY.add(y);
	}

	void startView() {
		compX.clear();
		compY.clear();
	}

	void startAdd() {
		compX.doit();
		compY.doit();

		nPs = nQs = 0;
		for (int i = 0; i &lt; compX.n; ++i) {
			pointFirst[i] = 0;
			queryFirst[i] = 0;
		}
	}

	struct TA {
		int am[MAX_N_OPTS];
		int n;

		void init(int _n) {
			n = _n;
			memset(am, 0, sizeof(int) * n);
		}

		void add(int p, int a) {
			for (p++; p &lt;= n; p += p &amp; -p)
				am[p - 1] += a;
		}

		int sum(int r) {
			int ret = 0;
			for (r++; r &gt; 0; r -= r &amp; -r)
				ret += am[r - 1];
			return ret;
		}

		int sum(int l, int r) {
			return sum(r) - sum(l - 1);
		}
	};

	TA ta;

	void solve() {

		ta.init(compY.n);
		for (int i = 0; i &lt; compX.n; ++i) {
			for (Point*cur = pointFirst[i]; cur != 0; cur = cur-&gt;next)
				ta.add(cur-&gt;y, cur-&gt;add);

			for (Query*cur = queryFirst[i]; cur != 0; cur = cur-&gt;next) {
				int tmp = ta.sum(cur-&gt;ly, cur-&gt;ry);
				*cur-&gt;toChange += tmp * cur-&gt;factor;
			}
		}
	}
}

void rec(int l, int r) {
	if (l + 1 == r)
		return;

//	cout &lt;&lt; l &lt;&lt; " - " &lt;&lt; r &lt;&lt; endl;
	int m = l + r &gt;&gt; 1;

	Sub::startView();
	for (int i = l; i &lt; m; ++i) {
		if (opts[i].type == ADD) {
			vector&lt;int&gt;&amp;args = opts[i].args;
			Sub::viewPoint(args[0], args[1]);
		}
	}

	Sub::startAdd();

	for (int i = l; i &lt; m; ++i) {
		if (opts[i].type == ADD) {
			vector&lt;int&gt;&amp;args = opts[i].args;
			Sub::addPoint(args[0], args[1], args[2]);
		}
	}

	for (int i = m; i &lt; r; ++i) {
		if (opts[i].type == QUERY) {
			vector&lt;int&gt;&amp;args = opts[i].args;
			Sub::addQuery(args[0], args[1], args[2], args[3], ret + i);
//			Sub::debugQuery(args[0], args[1], args[2], args[3]);
		}
	}

	Sub::solve();

	rec(l, m);
	rec(m, r);
}

void work() {
	memset(ret, 0, sizeof ret);
	rec(0, nOpts);

	for (int i = 0; i &lt; nOpts; ++i) {
		if (opts[i].type == QUERY)
			printf("%d\n", ret[i]);
	}
}

int main() {
	readInput();
	work();
}
<pre><h2>Problem1177</h2><pre>/*
 *  [Apio2009]Oil.cpp
 *
 *  Created on: 2011-5-6
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_ROWS = 1500 + 10, MAX_N_COLS = 1500 + 10;
typedef int Rect[MAX_N_ROWS][MAX_N_COLS];

int nRows, nCols, side;
Rect value;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

void readInput() {
	scanInt(nRows);
	scanInt(nCols);
	scanInt(side);

	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			scanInt(value[r][c]);
			//			cout &lt;&lt; value[r][c] &lt;&lt; " ";
		}
		//		cout &lt;&lt; endl;
	}
}

int ans;

void swapLR() {
	for (int r = 0; r &lt; nRows; ++r) {
		for (int lc = 0, rc = nCols - 1; lc &lt; rc; lc++, rc--)
			swap(value[r][lc], value[r][rc]);
	}
}

void swapRC() {
	static Rect tmp;
	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			tmp[c][r] = value[r][c];
		}
	}
	memcpy(value, tmp, sizeof value);
	swap(nRows, nCols);
}

Rect sum;

void prepareSum() {
	memset(sum, 0, sizeof sum);
	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			sum[r + 1][c + 1] = value[r][c] + sum[r][c + 1] + sum[r + 1][c]
					- sum[r][c];
		}
	}
}

int calcSum(int Lr, int Lc, int Rr, int Rc) {
	//[Lr,Rr)
	return sum[Rr][Rc] - sum[Lr][Rc] - sum[Rr][Lc] + sum[Lr][Lc];
}

const int INF = 1 &lt;&lt; 29;

void doitLeft(int Left[]) {
	for (int c = 0; c &lt; nCols; ++c) {
		int best = -INF;
		if (c - side + 1 &gt;= 0) {
			for (int r = 0; r &lt; nRows; ++r) {
				if (r - side + 1 &gt;= 0) {
					best = max(best, calcSum(r - side + 1, c - side + 1, r + 1,
							c + 1));
				}
			}
		}
		Left[c] = best;
	}
}

void calcLeftOne(int Left[]) {
	doitLeft(Left);
	for (int c = 0; c &lt; nCols - 1; ++c) {
		Left[c + 1] = max(Left[c + 1], Left[c]);
	}
}

void calcLeftTwo(int Left[]) {
	static int LU[MAX_N_ROWS], LD[MAX_N_ROWS];
	fill(LU, LU + nRows, -INF);
	fill(LD, LD + nRows, -INF);

	for (int c = 0; c &lt; nCols; ++c) {
		if (c - side + 1 &gt;= 0) {
			for (int r = 0; r &lt; nRows; ++r) {
				if (r - side + 1 &gt;= 0) {
					//LU
					int cur = calcSum(r - side + 1, c - side + 1, r + 1, c + 1);
					LU[r] = max(LU[r], cur);
				}
				if (r + side - 1 &lt; nRows) {
					//LD
					int cur = calcSum(r, c - side + 1, r + side, c + 1);
					LD[r] = max(LD[r], cur);
				}
			}
			for (int r = 1; r &lt; nRows; ++r) {
				LU[r] = max(LU[r], LU[r - 1]);
			}
			for (int r = nRows - 2; r &gt;= 0; --r) {
				LD[r] = max(LD[r], LD[r + 1]);
			}
		}

		int ret = -INF;
		for (int split = 0; split &lt; nRows - 1; ++split) {
			int cur = LU[split] + LD[split + 1];
			ret = max(ret, cur);
		}
		Left[c] = ret;
	}

	static int on[MAX_N_COLS];
	static int dp1[MAX_N_COLS], dp2[MAX_N_COLS];
	doitLeft(on);
	for (int c = 0; c &lt; nCols; ++c) {
		dp1[c] = on[c];
		if (c - 1 &gt;= 0)
			dp1[c] = max(dp1[c], dp1[c - 1]);
		dp2[c] = -INF;
		if (c - 1 &gt;= 0)
			dp2[c] = max(dp2[c], dp2[c - 1]);
		if (c - side &gt;= 0)
			dp2[c] = max(dp2[c], on[c] + dp1[c - side]);
		Left[c] = max(Left[c], dp2[c]);
	}
}

void calc() {
	//left has 2,right has 1
	static int Left[MAX_N_COLS], Right[MAX_N_COLS];
	prepareSum();
	calcLeftTwo(Left);
	swapLR();
	prepareSum();
	calcLeftOne(Right);
	swapLR();
	reverse(Right, Right + nCols);
	for (int c = 0; c &lt; nCols - 1; ++c) {
		int cur = Left[c] + Right[c + 1];
		ans = max(ans, cur);
	}
}

void work() {
	ans = 0;
	{
		calc();
		swapLR();
		calc();
		swapLR();
	}

	swapRC();
	{
		calc();
		swapLR();
		calc();
		swapLR();
	}

	cout &lt;&lt; ans &lt;&lt; endl;
}

void solve() {
	readInput();
	work();
}

int main() {
	solve();
}
<pre><h2>Problem1179</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=500000+10,maxm=500000+10;
using namespace std;
int head[maxn];
int nxt[maxm],to[maxm],mnt;
int n,m,vs,w[maxn],p;
bool Bar[maxn]={};
struct Graph
{
    int head[maxn];
    int nxt[maxm],to[maxm],mnt;
    int Vet;
    void Set_Size(int _Vet)
    {
        Vet=_Vet;
        memset(head,-1,sizeof(int)*Vet);
        mnt=0;
    }
    void Add_Edge(int s,int t)
    {
        nxt[mnt]=head[s];to[mnt]=t;
        head[s]=mnt++;
    }
};
Graph G,R;
inline void scan(int&amp;t)
{
    char c;while(c=getchar(),c&lt;'0'||c&gt;'9');t=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
}
void Input_Data()
{
    scan(n);scan(m);int s,t;
    G.Set_Size(n);
    R.Set_Size(n);
    rep(i,m)
    {
        scan(s);scan(t);
        --s;--t;
        G.Add_Edge(s,t);
        R.Add_Edge(t,s);
    }
    rep(i,n)scan(w[i]);
    scan(vs);scan(p);vs--;
    rep(i,p)scan(s),Bar[s-1]=true;
}
struct State
{
    int v,e;
    State(){}
    State(int _v,int _e):
        v(_v),e(_e){}
};
int rec[maxn],num,own[maxn],cnt=0;
void Dfs(Graph&amp;G,int x,bool put=true)
{
    static State Stack[maxn];
    static int top;top=0;
    Stack[top++]=State(x,G.head[x]);
    while(top)
    {
        State&amp;now=Stack[top-1];
        int&amp;v=now.v;int &amp;e=now.e;
        if(e==G.head[v])//first enter this node
        {
            own[v]=cnt;
        }
        if(e==-1)//we finish
        {
            if(put)rec[num++]=v;
            top--;
            continue;
        }
        int u=G.to[e];
        if(own[u]==-1)
        {
            Stack[top++]=State(u,G.head[u]);
        }
        e=G.nxt[e];
    }
    ++cnt;
}
void Calc_SC()
{
    memset(own,-1,sizeof own);
    num=0;
    rep(i,n)if(own[i]==-1)
    {
        Dfs(G,i);
    }
    memset(own,-1,sizeof own);cnt=0;
    for(int i=n-1;i&gt;=0;i--)
    {
        int u=rec[i];
        if(own[u]==-1)
            Dfs(R,u,false);
    }
}
Graph NewG;
int Sum[maxn]={};
bool CanEnd[maxn]={};
void Compress_Node()
{
    Calc_SC();
    rep(i,n)
        Sum[own[i]]+=w[i],
        CanEnd[own[i]]|=Bar[i];
}
void Build_NewGraph()
{
    NewG.Set_Size(cnt);
    rep(v,G.Vet)
        for(int e=G.head[v];e!=-1;e=G.nxt[e])
        {
            int u=G.to[e];
            if(own[v]!=own[u])
                NewG.Add_Edge(own[v],own[u]);
        }
}
int Dp[maxn];
inline void Update(int&amp;x,int c)
{
    if(x&lt;c)x=c;
}
void Calc_Dp()
{
    static int in[maxn],Q[maxn];
    static int h,t;h=t=0;
    rep(v,NewG.Vet)
        for(int e=NewG.head[v];e!=-1;e=NewG.nxt[e])
        {
            int u=NewG.to[e];
            in[u]++;
        }
    rep(v,NewG.Vet)if(!in[v])
        Q[t++]=v;
    for(;h&lt;t;h++)
    {
        int v=Q[h];
        for(int e=NewG.head[v];e!=-1;e=NewG.nxt[e])
        {
            int u=NewG.to[e];
            if(!--in[u])
                Q[t++]=u;
        }
    }
    rep(i,h)Dp[i]=-inf;
    for(int i=h-1;i&gt;=0;i--)
    {
        int v=Q[i];if(CanEnd[v])Update(Dp[v],Sum[v]);
        for(int e=NewG.head[v];e!=-1;e=NewG.nxt[e])
        {
            int u=NewG.to[e];
            Update(Dp[v],Dp[u]+Sum[v]);
        }
    }
    printf("%d\n",Dp[own[vs]]);
}
void Solve()
{
    Compress_Node();
    Build_NewGraph();
    Calc_Dp();
}
int main()
{
    //freopen("in","r",stdin);
    Input_Data();
    Solve();
}


<pre><h2>Problem1180</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define OK cout&lt;&lt;"OK"&lt;&lt;endl
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
typedef vector&lt;int&gt; VI;
typedef VI::iterator it;
VI E[maxn];
void AddEdge(int s,int t)
{
    E[s].pb(t);E[t].pb(s);
}
int Data[maxn],n,q;
struct TA
{
    VI A;
    int s;
    void Add(int l,int d)
    {
        l-=s;
        for(l++;l&lt;=A.size();l+=l&amp;-l)
            A[l-1]+=d;
    }
    int Sum(int l)
    {
        int ret=0;
        for(l++;l;l-=l&amp;-l)
            ret+=A[l-1];
        return ret;
    }
    int Sum(int l,int r)
    {
        l-=s;r-=s;
        return Sum(r)-Sum(l-1);
    }
    void Build(int l,int r)
    {
        int n=r-l;s=l;A=VI(n,0);
        rep(i,n)Add(l+i,Data[l+i]);
    }
}T[maxn];
int Size[maxn],Q[maxn],F[maxn],D[maxn],w[maxn];
int Root[maxn],Own[maxn];
int h,t,SqrtN,Lim=1,Step;
void BFS(int vs,int f,int root,int d)
{
    //cout&lt;&lt;vs&lt;&lt;" "&lt;&lt;f&lt;&lt;" "&lt;&lt;root&lt;&lt;" "&lt;&lt;d&lt;&lt;endl;
    h=t=0;
    for(Q[t++]=vs,F[vs]=f,Root[vs]=root,D[vs]=d,Own[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,E[x])if(*e!=F[x])
        {
            Q[t++]=*e;
            Root[*e]=root;
            F[*e]=x;
            D[*e]=D[x]+1;
            Own[*e]=-1;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(e,E[x])if(*e!=F[x])
            Size[x]+=Size[*e];
    }
    for(int i=0;i&lt;h;i++)
    {
        int a=Q[i];
        int x=a,next;if(Own[x]&gt;=0)continue;
        for(;;x=next)
        {
            Data[D[x]]=w[x];
            Own[x]=a;
            next=-1;
            tr(e,E[x])if(*e!=F[x])
                if(next==-1||Size[*e]&gt;Size[next])
                    next=*e;
            if(next==-1)break;
        }
        T[a].Build(D[a],D[x]+1);
    }
}
void ReBuild(int u)
{
    BFS(u,-1,u,0);
}
int Ask(int u,int v)
{
    int ret=0;Step=0;
    for(;;)
    {
        Step++;
        if(D[u]&lt;D[v])swap(u,v);
        if(Own[u]==Own[v])
        {
            ret+=T[Own[u]].Sum(D[v],D[u]);
            return ret;
        }
        else
        {
            if(D[Own[u]]&lt;D[Own[v]])swap(u,v);
            ret+=T[Own[u]].Sum(D[Own[u]],D[u]);
            u=F[Own[u]];
        }
    }
}
void Query(int u,int v)
{
    if(Root[u]!=Root[v])
        printf("impossible\n");
    else
    {
        printf("%d\n",Ask(u,v));
        if(Step&gt;Lim)
        {
            Lim=min(Lim*2,SqrtN);
            u=Root[u];
            ReBuild(u);
        }
    }
}
void Connect(int u,int v)
{
    if(Root[u]==Root[v])
        printf("no\n");
    else
    {
        printf("yes\n");
        AddEdge(u,v);
        int a=Size[Root[u]],b=Size[Root[v]];
        if(a&gt;b)swap(u,v);
        BFS(u,v,Root[v],D[v]+1);
    }
}
void Change(int u,int s)
{
    int o=w[u];w[u]=s;
    T[Own[u]].Add(D[u],s-o);
}
void Init()
{
    scanf("%d",&amp;n);SqrtN=sqrt(n)+1;
    rep(i,n)scanf("%d",w+i),ReBuild(i);
}
int main()
{
    //freopen("in","r",stdin);
    char cmd[100];
    Init();
    int q,s,t;scanf("%d",&amp;q);
    rep(i,q)
    {
        scanf(" ");
        scanf("%s%d%d",cmd,&amp;s,&amp;t);
        switch(cmd[0])
        {
            case 'e':Query(s-1,t-1);break;
            case 'b':Connect(s-1,t-1);break;
            case 'p':Change(s-1,t);break;
        }
    }
}

<pre><h2>Problem1180</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define OK cout&lt;&lt;"OK"&lt;&lt;endl
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
typedef vector&lt;int&gt; VI;
typedef VI::iterator it;
VI E[maxn];
void AddEdge(int s,int t)
{
    E[s].pb(t);E[t].pb(s);
}
int Data[maxn],n,q;
struct TA
{
    VI A;
    int s;
    void Add(int l,int d)
    {
        l-=s;
        for(l++;l&lt;=A.size();l+=l&amp;-l)
            A[l-1]+=d;
    }
    int Sum(int l)
    {
        int ret=0;
        for(l++;l;l-=l&amp;-l)
            ret+=A[l-1];
        return ret;
    }
    int Sum(int l,int r)
    {
        l-=s;r-=s;
        return Sum(r)-Sum(l-1);
    }
    void Build(int l,int r)
    {
        int n=r-l;s=l;A=VI(n,0);
        rep(i,n)Add(l+i,Data[l+i]);
    }
}T[maxn];
int Size[maxn],Q[maxn],F[maxn],D[maxn],w[maxn];
int Root[maxn],Own[maxn];
int h,t,SqrtN,Lim=1,Step;
void BFS(int vs,int f,int root,int d)
{
    //cout&lt;&lt;vs&lt;&lt;" "&lt;&lt;f&lt;&lt;" "&lt;&lt;root&lt;&lt;" "&lt;&lt;d&lt;&lt;endl;
    h=t=0;
    for(Q[t++]=vs,F[vs]=f,Root[vs]=root,D[vs]=d,Own[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,E[x])if(*e!=F[x])
        {
            Q[t++]=*e;
            Root[*e]=root;
            F[*e]=x;
            D[*e]=D[x]+1;
            Own[*e]=-1;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(e,E[x])if(*e!=F[x])
            Size[x]+=Size[*e];
    }
    for(int i=0;i&lt;h;i++)
    {
        int a=Q[i];
        int x=a,next;if(Own[x]&gt;=0)continue;
        for(;;x=next)
        {
            Data[D[x]]=w[x];
            Own[x]=a;
            next=-1;
            tr(e,E[x])if(*e!=F[x])
                if(next==-1||Size[*e]&gt;Size[next])
                    next=*e;
            if(next==-1)break;
        }
        T[a].Build(D[a],D[x]+1);
    }
}
void ReBuild(int u)
{
    BFS(u,-1,u,0);
}
int Ask(int u,int v)
{
    int ret=0;Step=0;
    for(;;)
    {
        Step++;
        if(D[u]&lt;D[v])swap(u,v);
        if(Own[u]==Own[v])
        {
            ret+=T[Own[u]].Sum(D[v],D[u]);
            return ret;
        }
        else
        {
            if(D[Own[u]]&lt;D[Own[v]])swap(u,v);
            ret+=T[Own[u]].Sum(D[Own[u]],D[u]);
            u=F[Own[u]];
        }
    }
}
void Query(int u,int v)
{
    if(Root[u]!=Root[v])
        printf("impossible\n");
    else
    {
        printf("%d\n",Ask(u,v));
        if(Step&gt;Lim)
        {
            Lim=min(Lim*2,SqrtN);
            u=Root[u];
            ReBuild(u);
        }
    }
}
void Connect(int u,int v)
{
    if(Root[u]==Root[v])
        printf("no\n");
    else
    {
        printf("yes\n");
        AddEdge(u,v);
        int a=Size[Root[u]],b=Size[Root[v]];
        if(a&gt;b)swap(u,v);
        BFS(u,v,Root[v],D[v]+1);
    }
}
void Change(int u,int s)
{
    int o=w[u];w[u]=s;
    T[Own[u]].Add(D[u],s-o);
}
inline int nextInt(){
    int ret; char c;
    while(c = getchar(), c &lt; '0' || c &gt; '9') ;
    ret = c - '0';
    while(c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + c - '0';
    return ret;
}
void Init()
{
    n=nextInt();SqrtN=sqrt(n)+1;
    rep(i,n)w[i]=nextInt(),ReBuild(i);
}
int main()
{
    //freopen("in","r",stdin);
    char cmd[100];
    Init();
    int q,s,t;q=nextInt();
    rep(i,q)
    {
        scanf(" ");
        scanf("%s",cmd);s=nextInt();t=nextInt();
        switch(cmd[0])
        {
            case 'e':Query(s-1,t-1);break;
            case 'b':Connect(s-1,t-1);break;
            case 'p':Change(s-1,t);break;
        }
    }
}

<pre><h2>Problem1187</h2><pre>#include&lt;cstdio&gt;
#include&lt;utility&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=20,inf=~0U&gt;&gt;2;
typedef unsigned long long ull;
int n,m;
struct State
{
    ull s;
    State(ull _s=0):s(_s){}
    int get(int i)const{return s&gt;&gt;(3*i)&amp;7;}
    int operator[](int i)const{return get(i);}
    void set(int i,int x){s&amp;=~(7ULL&lt;&lt;(3*i));s|=ull(x)&lt;&lt;(3*i);}
    bool operator&lt;(const State&amp;o)const
    {return s&lt;o.s;}
    void normal()
    {
        static int tmp[10],cnt;
        memset(tmp,0,sizeof(tmp));
        cnt=0;
        for(int i=0;i&lt;=m;i++)
        {
            int t=get(i);
            if(!t)continue;
            if(!tmp[t]) tmp[t]=++cnt;
            set(i,tmp[t]);
        }
    }
    void Merge(int a,int b)
    {
        for(int i=0;i&lt;=m;i++)
            if(get(i)==b)
                set(i,a);
        normal();
    }
    void NextRow()
    {
        s&lt;&lt;=3;
    }
    bool Single()const
    {
        for(int i=0;i&lt;=m;i++)
            if(get(i)&gt;1) return false;
        return true;
    }
    void Show()
    {
        for(int i=0;i&lt;=m;i++)
            cout&lt;&lt;get(i)&lt;&lt;" ";
        cout&lt;&lt;endl;
    }
};
const int size=17771;
struct Hash
{
    struct node
    {
        ull key;
        int ans;
    }H[size];
    bool E[size];
    void clear()
    {
        memset(E,0,sizeof(E));
    }
    void Inc(int&amp;i)
    {
        if(++i==size) i=0;
    }
    int cur;
    void ready(){cur=0;}
    bool get(pair&lt;State,int&gt;&amp;s)
    {
        while(cur&lt;size&amp;&amp;!E[cur])cur++;
        if(cur==size)return false;
        s=make_pair(State(H[cur].key),H[cur].ans);
        ++cur;
        return true;
    }
    int&amp;operator[](const State&amp;s)
    {
        ull k=s.s;
        int h=k%size,i;
        for(i=h;E[i];Inc(i))
            if(H[i].key==k) return H[i].ans;
        E[i]=true;H[i].key=k;return H[i].ans=-inf;
    }
};
int Map[100][8]={0},Ans=-inf;
Hash Dp[2];
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;m;j++)
        {
            cin&gt;&gt;Map[i][j];
        }
    int now=0,next=1;Dp[next][State()]=0;
    pair&lt;State,int&gt; o;
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;m;j++)
        {
            swap(now,next);
            Dp[next].clear();
            Dp[now].ready();
            while(Dp[now].get(o))
            {
                State t=o.first;int cost=o.second;
                if(!j)t.NextRow();
                //cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;":"&lt;&lt;endl;
                //t.Show();
                //cout&lt;&lt;cost&lt;&lt;endl;
                int a=t[j],b=t[j+1];
                if(!a&amp;&amp;!b)
                {
                    Dp[next][t]&gt;?=cost;
                    if(j!=m-1&amp;&amp;i!=n-1)
                    {
                        t.set(j,7);t.set(j+1,7);t.normal();
                        Dp[next][t]&gt;?=cost+Map[i][j];
                    }
                }
                if(!a&amp;&amp;b)
                {
                    if(j!=m-1)
                    {
                        Dp[next][t]&gt;?=cost+Map[i][j];
                    }
                    if(i!=n-1)
                    {
                        t.set(j,b);t.set(j+1,0);t.normal();
                        Dp[next][t]&gt;?=cost+Map[i][j];
                    }
                }
                if(a&amp;&amp;!b)
                {
                    if(i!=n-1)
                    {
                        Dp[next][t]&gt;?=cost+Map[i][j];
                    }
                    if(j!=m-1)
                    {
                        t.set(j,0);t.set(j+1,a);t.normal();
                        Dp[next][t]&gt;?=cost+Map[i][j];
                    }
                }
                if(a&amp;&amp;b)
                {
                    if(a==b&amp;&amp;t.Single())
                    {
                        Ans&gt;?=cost+Map[i][j];
                    }
                    if(a!=b)
                    {
                        t.set(j,0);t.set(j+1,0);t.Merge(a,b);
                        Dp[next][t]&gt;?=cost+Map[i][j];
                    }
                }
            }
        }
    cout&lt;&lt;Ans&lt;&lt;endl;
}
<pre><h2>Problem1187</h2><pre>#include&lt;cstdio&gt;
#include&lt;utility&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=20,inf=~0U&gt;&gt;2;
typedef unsigned long long ull;
int n,m;
struct State
{
    ull s;
    State(ull _s=0):s(_s){}
    int get(int i)const{return s&gt;&gt;(3*i)&amp;7;}
    int operator[](int i)const{return get(i);}
    void set(int i,int x){s&amp;=~(7ULL&lt;&lt;(3*i));s|=ull(x)&lt;&lt;(3*i);}
    bool operator&lt;(const State&amp;o)const
    {return s&lt;o.s;}
    void normal()
    {
        static int tmp[10],cnt;
        memset(tmp,0,sizeof(tmp));
        cnt=0;
        for(int i=0;i&lt;=m;i++)
        {
            int t=get(i);
            if(!t)continue;
            if(!tmp[t]) tmp[t]=++cnt;
            set(i,tmp[t]);
        }
    }
    void Merge(int a,int b)
    {
        for(int i=0;i&lt;=m;i++)
            if(get(i)==b)
                set(i,a);
        normal();
    }
    void NextRow()
    {
        s&lt;&lt;=3;
    }
    bool Single()const
    {
        for(int i=0;i&lt;=m;i++)
            if(get(i)&gt;1) return false;
        return true;
    }
    void Show()
    {
        for(int i=0;i&lt;=m;i++)
            cout&lt;&lt;get(i)&lt;&lt;" ";
        cout&lt;&lt;endl;
    }
};
const int size=1771;
struct Hash
{
    struct node
    {
        ull key;
        int ans;
    }H[size];
    bool E[size];
    void clear()
    {
        memset(E,0,sizeof(E));
    }
    void Inc(int&amp;i)
    {
        if(++i==size) i=0;
    }
    int cur;
    void ready(){cur=0;}
    bool get(pair&lt;State,int&gt;&amp;s)
    {
        while(cur&lt;size&amp;&amp;!E[cur])cur++;
        if(cur==size)return false;
        s=make_pair(State(H[cur].key),H[cur].ans);
        ++cur;
        return true;
    }
    int&amp;operator[](const State&amp;s)
    {
        ull k=s.s;
        int h=k%size,i;
        for(i=h;E[i];Inc(i))
            if(H[i].key==k) return H[i].ans;
        E[i]=true;H[i].key=k;return H[i].ans=-inf;
    }
};
int Map[100][8]={0},Ans=-inf;
Hash Dp[2];
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;m;j++)
        {
            cin&gt;&gt;Map[i][j];
        }
    int now=0,next=1;Dp[next][State()]=0;
    pair&lt;State,int&gt; o;
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;m;j++)
        {
            swap(now,next);
            Dp[next].clear();
            Dp[now].ready();
            while(Dp[now].get(o))
            {
                State t=o.first;int cost=o.second;
                if(!j)t.NextRow();
                //cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;":"&lt;&lt;endl;
                //t.Show();
                //cout&lt;&lt;cost&lt;&lt;endl;
                int a=t[j],b=t[j+1];
                if(!a&amp;&amp;!b)
                {
                    Dp[next][t]&gt;?=cost;
                    if(j!=m-1&amp;&amp;i!=n-1)
                    {
                        t.set(j,7);t.set(j+1,7);t.normal();
                        Dp[next][t]&gt;?=cost+Map[i][j];
                    }
                }
                if(!a&amp;&amp;b)
                {
                    if(j!=m-1)
                    {
                        Dp[next][t]&gt;?=cost+Map[i][j];
                    }
                    if(i!=n-1)
                    {
                        t.set(j,b);t.set(j+1,0);t.normal();
                        Dp[next][t]&gt;?=cost+Map[i][j];
                    }
                }
                if(a&amp;&amp;!b)
                {
                    if(i!=n-1)
                    {
                        Dp[next][t]&gt;?=cost+Map[i][j];
                    }
                    if(j!=m-1)
                    {
                        t.set(j,0);t.set(j+1,a);t.normal();
                        Dp[next][t]&gt;?=cost+Map[i][j];
                    }
                }
                if(a&amp;&amp;b)
                {
                    if(a==b&amp;&amp;t.Single())
                    {
                        Ans&gt;?=cost+Map[i][j];
                    }
                    if(a!=b)
                    {
                        t.set(j,0);t.set(j+1,0);t.Merge(a,b);
                        Dp[next][t]&gt;?=cost+Map[i][j];
                    }
                }
            }
        }
    cout&lt;&lt;Ans&lt;&lt;endl;
}
<pre><h2>Problem1189</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=20;
char Map[maxn][maxn];
int n,m;
void Init()
{
    cin&gt;&gt;n&gt;&gt;m;
    rep(i,n)rep(j,m)cin&gt;&gt;Map[i][j];
}
int Dist[maxn*4][maxn][maxn],cnt=0;
struct Point
{
    int x,y;
    Point(){}
    Point(int _x,int _y):x(_x),y(_y){}
};
Point D[maxn*maxn];
const int di[]={1,0,-1,0},dj[]={0,1,0,-1};
void Build()
{
    queue&lt;Point&gt; Q;
    rep(i,n)rep(j,m)
        if(Map[i][j]=='D')
        {
            D[cnt]=Point(i,j);
            rep(a,n)rep(b,m)Dist[cnt][a][b]=-1;
            #define Legal(i,j) (i&gt;=0&amp;&amp;i&lt;n&amp;&amp;j&gt;=0&amp;&amp;j&lt;m&amp;&amp;Dist[cnt][i][j]==-1&amp;&amp;Map[i][j]=='.')
            Dist[cnt][i][j]=0;Q.push(Point(i,j));
            while(Q.size())
            {
                Point t=Q.front();Q.pop();int c=Dist[cnt][t.x][t.y],a,b;
                rep(d,4)
                {
                    a=t.x+di[d];b=t.y+dj[d];
                    if(Legal(a,b))
                        Dist[cnt][a][b]=c+1,Q.push(Point(a,b));
                }
            }
            cnt++;
            #undef Legal
        }
}
const int maxv=maxn*maxn+2;
struct Edge
{
    int t,c,Len;
    Edge*next,*op;
    Edge(int _t,int _c,int _Len,Edge*_next):t(_t),c(_c),Len(_Len),next(_next){}
}*E[maxv]={0};
int h[maxv],vh[maxv],vs,vt,v;
void Ins_Edge(int s,int t,int c,int Len)
{
    //cout&lt;&lt;s&lt;&lt;" "&lt;&lt;t&lt;&lt;" "&lt;&lt;c&lt;&lt;" "&lt;&lt;Len&lt;&lt;endl;
    E[s]=new Edge(t,c,Len,E[s]);
    E[t]=new Edge(s,0,Len,E[t]);
    E[s]-&gt;op=E[t];E[t]-&gt;op=E[s];
}
inline int node(int i,int j){return i*m+j;}
void Build_Graph()
{
    vs=n*m,vt=vs+1;
    rep(i,cnt)
    {
        Ins_Edge(vs,node(D[i].x,D[i].y),0,0);
        rep(x,n)rep(y,m)
            if(Dist[i][x][y]!=-1&amp;&amp;Map[x][y]=='.')
            {
                Ins_Edge(node(D[i].x,D[i].y),node(x,y),1,Dist[i][x][y]);
            }
    }
    rep(x,n)rep(y,m)if(Map[x][y]=='.')Ins_Edge(node(x,y),vt,1,0);
}
int T;
int aug(int no,int m)
{
    if(no==vt) return m;
    int l=m;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;c&amp;&amp;i-&gt;Len&lt;=T&amp;&amp;h[no]==h[i-&gt;t]+1)
    {
        int d=aug(i-&gt;t,min(i-&gt;c,l));
        l-=d,i-&gt;c-=d,i-&gt;op-&gt;c+=d;
        if(l==0||h[vs]&gt;=v)return m-l;
    }
    int minh=v;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;c&amp;&amp;i-&gt;Len&lt;=T&amp;&amp;h[i-&gt;t]+1&lt;minh)
        minh=h[i-&gt;t]+1;
    if(--vh[h[no]]==0) h[vs]=v;vh[h[no]=minh]++;
    return m-l;
}
void Work()
{
    int need=0;bool Cant=false;
    rep(i,n)rep(j,m)
        if(Map[i][j]=='.')
        {
            need++;bool find=false;
            for(Edge*e=E[node(i,j)];e;e=e-&gt;next)if(e-&gt;t!=vt){find=true;break;}
            if(!find){Cant=true;goto next;}
        }
    next:
    if(Cant){cout&lt;&lt;"impossible"&lt;&lt;endl;return;}
    v=need+cnt+2;int flow=0;
    for(T=0;;T++)
    {
        memset(h,0,sizeof(h));
        memset(vh,0,sizeof(vh));
        vh[0]=v;
        while(h[vs]&lt;v) flow+=aug(vs,inf);
        if(flow==need)
        {
            cout&lt;&lt;T&lt;&lt;endl;
            return;
        }
        for(Edge*i=E[vs];i;i=i-&gt;next)i-&gt;c++;
    }
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Build();
    Build_Graph();
    Work();
}
<pre><h2>Problem1190</h2><pre>#include &lt;cstdio&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=100+10;
using namespace std;
typedef long long ll;
struct Data
{
    int w,v;
    void read()
    {
        scanf("%d%d",&amp;w,&amp;v);
    }
    bool operator&lt;(const Data&amp;d)const
    {
        return w&gt;d.w;
    }
    double worth()
    {
        return v/w;
    }
}D[maxn];
int n,m;
bool Input_Data()
{
    scanf("%d%d",&amp;n,&amp;m);
    if(n==-1)return false;
    rep(i,n)D[i+1].read();
    return true;
}
ll Sum_v[maxn],Sum_w[maxn];
map&lt;int,int&gt; M[maxn];
void Init_Data()
{
    sort(D+1,D+n+1);
    for(int i=1;i&lt;=n;i++)
    {
        M[i].clear();
        Sum_v[i]=Sum_v[i-1]+D[i].v;
        Sum_w[i]=Sum_w[i-1]+D[i].w;
    }
}
int Ans=0,p[maxn];
int Dfs(int p,int remain)
{
    ll restv=Sum_v[n]-Sum_v[p-1];
    ll restw=Sum_w[n]-Sum_w[p-1];
    if(restw&lt;=remain)
    {
        return restv;
    }
    if(M[p].count(remain))
        return M[p][remain];
    int ans=Dfs(p+1,remain);
    if(remain&gt;=D[p].w)
    {
        ans=max(ans,Dfs(p+1,remain-D[p].w)+D[p].v);
    }
    return M[p][remain]=ans;
}
void Solve()
{
    Ans=0;
    Init_Data();
    printf("%d\n",Dfs(1,m));
}
int main()
{
    //freopen("in","r",stdin);
    while(Input_Data())
        Solve();
}

<pre><h2>Problem1191</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1;
int n,m;
const int V=1200;
vector&lt;int&gt; E[V];
typedef vector&lt;int&gt;::iterator it;
int Link[V];
bool vis[V];
bool dfs(int x)
{
    if(vis[x]) return false;
    vis[x]=true;
    for(it i=E[x].begin();i!=E[x].end();i++)
    {
        if(Link[*i]==-1||dfs(Link[*i]))
            return Link[*i]=x,true;
    }
    return false;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;int a,b;
    rep(i,m)
    {
        cin&gt;&gt;a&gt;&gt;b;
        E[i].pb(a);
        E[i].pb(b);
    }
    rep(i,n) Link[i]=-1;
    int ans;
    for(ans=0;ans&lt;m;ans++){memset(vis,0,sizeof(vis)); if(!dfs(ans)) break;}
    int Ans[V];
    cout&lt;&lt;ans&lt;&lt;endl;
    //rep(i,n) if(Link[i]!=-1) Ans[Link[i]]=i;
    //rep(j,ans) cout&lt;&lt;Ans[j]&lt;&lt;endl;
}
<pre><h2>Problem1191</h2><pre>#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int V=1200;
int E[V][2],Link[V],n,m;
bool vis[V];
bool dfs(int x)
{
    if(vis[x]) return 0;
    vis[x]=1;
    for(int i=0,t;i&lt;2;i++)
    {
        t=E[x][i];
        if(Link[t]==-1||dfs(Link[t]))
            return Link[t]=x,1;
    }
    return 0;
}
int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    rep(i,m) cin&gt;&gt;E[i][0]&gt;&gt;E[i][1];
    rep(i,n) Link[i]=-1;
    int ans;
    for(ans=0;ans&lt;m;ans++){memset(vis,0,sizeof(vis)); if(!dfs(ans)) break;}
    int Ans[V];
    cout&lt;&lt;ans&lt;&lt;endl;
}
<pre><h2>Problem1192</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1;
int main()
{
    int n,d=0;cin&gt;&gt;n;
    while(1&lt;&lt;d&lt;=n)d++;
    cout&lt;&lt;d&lt;&lt;endl;
}
<pre><h2>Problem1192</h2><pre>int main()
{
    int n,d=0;scanf("%d",&amp;n);
    while(1&lt;&lt;d&lt;=n)d++;
    printf("%d\n",d);
}
<pre><h2>Problem1192</h2><pre>n,d=0;main(){scanf("%d",&amp;n);while(1&lt;&lt;d&lt;=n)d++;printf("%d\n",d);}
<pre><h2>Problem1192</h2><pre>n,d=0;main(){scanf("%d",&amp;n);while(1&lt;&lt;d&lt;=n)d++;printf("%d",d);}
<pre><h2>Problem1193</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
typedef pair&lt;int,int&gt; pi;
const pi D[]={pi(2,1),pi(1,2),pi(-1,2),pi(-2,1),pi(-2,-1),pi(-1,-2),pi(1,-2),pi(2,-1)};
const int inf=~0U&gt;&gt;1;
inline int abs(int x){return x&lt;0?-x:x;}
inline pi dist(pi a,pi b)
{
    int x=abs(a.first-b.first),y=abs(a.second-b.second);
    return pi(x+y,abs(x-y));
}
pi operator+(const pi&amp;a,const pi&amp;b)
{
    return pi(a.first+b.first,a.second+b.second);
}
ostream&amp; operator&lt;&lt;(ostream&amp; out,const pi&amp;a)
{
    out&lt;&lt;"("&lt;&lt;a.first&lt;&lt;","&lt;&lt;a.second&lt;&lt;")";
}
int main()
{
    //freopen("in","r",stdin);
    pi a,b;int ans=0;
    cin&gt;&gt;a.first&gt;&gt;a.second&gt;&gt;b.first&gt;&gt;b.second;
    while (dist(a,b).first&gt;10)
    {
        pi next,Min(inf,inf);
    	rep(i,8)
    	{
    	    pi c=a+D[i];pi ncost=dist(c,b);
    	    if(ncost&lt;Min)
                Min=ncost,next=c;
    	}
    	a=next,ans++;
    }
    int x=min(a.first,b.first),y=min(a.second,b.second);
    pi c=pi(-x,-y);
    a=a+c+pi(5,5);b=b+c+pi(5,5);
    bool vis[100][100]={0};
    int d[100][100];
    vis[a.first][a.second]=true;
    d[a.first][a.second]=0;
    queue&lt;pi&gt; Q;Q.push(a);
    while (Q.size())
    {
    	pi t=Q.front();Q.pop();int cost=d[t.first][t.second];
    	if(t==b) break;
    	rep(i,8)
    	{
    	    pi c=t+D[i];
    	    if(c.first&gt;=0&amp;&amp;c.first&lt;100&amp;&amp;c.second&gt;=0&amp;&amp;c.second&lt;100)
                if(!vis[c.first][c.second])
                {
                    vis[c.first][c.second]=true;
                    d[c.first][c.second]=cost+1;
                    Q.push(c);
                }
    	}
    }
    cout&lt;&lt;ans+d[b.first][b.second];
}
<pre><h2>Problem1194</h2><pre>/*
 * [HNOI2006]潘多拉的盒子.cpp
 *
 *  Created on: 2011-3-20
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_DFAS = 50 + 10;
const int MAX_N_STATES = 50 + 10;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

struct DFA {
	int nStates;
	bool accpet[MAX_N_STATES];
	int next[MAX_N_STATES][2];

	void read() {
		scanInt(nStates);
		int nAccpet;
		scanInt(nAccpet);
		memset(accpet, false, sizeof accpet);
		for (int i = 0; i &lt; nAccpet; ++i) {
			int x;
			scanInt(x);
			accpet[x] = true;
		}
		for (int me = 0; me &lt; nStates; ++me) {
			for (int what = 0; what &lt; 2; ++what) {
				scanInt(next[me][what]);
			}
		}
	}
};

DFA DFAs[MAX_N_DFAS];
int nDFAs;

void inputData() {
	scanInt(nDFAs);
	for (int me = 0; me &lt; nDFAs; ++me) {
		DFAs[me].read();
	}
}

const int MAX_L_QUE = MAX_N_STATES * MAX_N_STATES * 2;

int que[MAX_L_QUE], qh, qt;

int mark[MAX_N_STATES][MAX_N_STATES] = { }, curMark = 1;

void visit(int a, int b) {
	if (mark[a][b] != curMark) {
		mark[a][b] = curMark;
		que[qt++] = a;
		que[qt++] = b;
	}
}

bool isContain(const DFA&amp;dA, const DFA&amp;dB) {
	qh = qt = 0;
	++curMark;
	visit(0, 0);
	for (; qh &lt; qt;) {
		int a = que[qh++], b = que[qh++];
		if (dB.accpet[b] &amp;&amp; !dA.accpet[a])
			return false;
		for (int what = 0; what &lt; 2; ++what) {
			int na = dA.next[a][what];
			int nb = dB.next[b][what];
			visit(na, nb);
		}
	}
	return true;
}

int cnt[MAX_N_DFAS];

bool contain[MAX_N_DFAS][MAX_N_DFAS];

int dp[MAX_N_DFAS];

void work() {
	for (int a = 0; a &lt; nDFAs; ++a) {
		for (int b = 0; b &lt; nDFAs; ++b) {
			contain[a][b] = isContain(DFAs[a], DFAs[b]);
			//			if (contain[a][b])
			//				cout &lt;&lt; a &lt;&lt; " contain " &lt;&lt; b &lt;&lt; endl;
		}
	}

	for (int i = 0; i &lt; nDFAs; ++i) {
		cnt[i] = 1;
	}
	for (int me = 0; me &lt; nDFAs; ++me) {
		for (int prev = 0; prev &lt; me; ++prev) {
			if (cnt[prev] == 0)
				continue;
			if (contain[me][prev] &amp;&amp; contain[prev][me]) {
				++cnt[prev];
				cnt[me] = 0;
				break;
			}
		}
	}

	for (int me = 0; me &lt; nDFAs; ++me) {
		if (cnt[me] == 0)
			continue;
		dp[me] = cnt[me];
	}

	//	for (int me = 0; me &lt; nDFAs; ++me) {
	//		if (cnt[me] == 0)
	//			continue;
	//		for (int who = 0; who &lt; nDFAs; ++who) {
	//			if (me == who || cnt[who] == 0)
	//				continue;
	//			if (contain[me][who] &amp;&amp; contain[who][me])
	//				cout &lt;&lt; "fuck!" &lt;&lt; endl;
	//			if (contain[me][who])
	//				cout &lt;&lt; me &lt;&lt; "-&gt;" &lt;&lt; who &lt;&lt; endl;
	//		}
	//	}

	bool changed;
	do {
		changed = false;
		for (int me = 0; me &lt; nDFAs; ++me) {
			if (cnt[me] == 0)
				continue;
			for (int prev = 0; prev &lt; nDFAs; ++prev) {
				if (cnt[prev] == 0 || prev == me)
					continue;
				if (contain[me][prev]) {
					int tmp = dp[prev] + cnt[me];
					if (tmp &gt; dp[me]) {
						dp[me] = tmp;
						changed = true;
					}
				}
			}
		}
	} while (changed);

	int ans = 0;
	for (int me = 0; me &lt; nDFAs; ++me) {
		ans = max(ans, dp[me]);
	}

	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	inputData();
	work();
}
<pre><h2>Problem1195</h2><pre>/*
 * [HNOI2006]????????.cpp
 *
 *  Created on: 2011-3-5
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_N = 12;
string strings[MAX_N];
int nStrings;
int sameLength[MAX_N+1][MAX_N+1]={};

void inputData() {
	cin &gt;&gt; nStrings;
	for (int i = 0; i &lt; nStrings; ++i) {
		cin &gt;&gt; strings[i];
	}
}

bool isContained(string a, string b) {
	return a.find(b) != string::npos;
}

void cleanStrings() {
	int nSize = 0;
	for (int am = 0; am &lt; nStrings; ++am) {
		bool ok = true;
		for (int prev = 0; prev &lt; nSize; ++prev) {
			if (isContained(strings[prev], strings[am])) {
				ok = false;
				break;
			}
		}
		if (ok)
			strings[nSize++] = strings[am];
	}
	nStrings = nSize;
}

void prepare() {
	for (int cur = 0; cur &lt; nStrings; ++cur) {
		for (int next = 0; next &lt; nStrings; ++next) {
			if (cur == next)
				continue;
			string sCur = strings[cur], sNext = strings[next];
			for (int sameLength = 1; sameLength &lt;= min(sCur.size(),
					sNext.size()); ++sameLength) {
				if (sCur.substr(sCur.size() - sameLength, sameLength)
						== sNext.substr(0, sameLength))
					::sameLength[cur][next] = sameLength;
			}
		}
	}
}

string memo[1 &lt;&lt; MAX_N][MAX_N+1];//set,last

string rec(int unUsedSet, int last) {
	if (!unUsedSet)
		return "";
	string&amp;ret = memo[unUsedSet][last];
	if (!ret.empty())
		return ret;
	ret="";
	for (int first = 0; first &lt; nStrings; ++first) {
		if (unUsedSet &gt;&gt; first &amp; 1) {
			string next = strings[first]+rec(unUsedSet ^ (1 &lt;&lt; first), first);
			string am = next.substr(sameLength[last][first]);
			if (ret.empty() || am.size() &lt; ret.size() || (am.size()
					== ret.size() &amp;&amp; am &lt; ret))
				ret = am;
		}
	}
	return ret;
}

int main() {
	inputData();
	cleanStrings();
	prepare();
	cout&lt;&lt;rec((1&lt;&lt;nStrings)-1,nStrings)&lt;&lt;endl;
}
<pre><h2>Problem1196</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1;
const int maxn=10000;
int n,k,m;
struct Data
{
    int s,t,c1,c2;
    void operator()(int _s,int _t,int _c1,int _c2)
    {s=_s;t=_t;c1=_c1;c2=_c2;}
}E[maxn*2];
int F[maxn];
int find(int x)
{
    if(F[x]==x) return x;
    return F[x]=find(F[x]);
}
int Union(int i,int j){F[j]=i;}
bool check(int limit)
{
    int cnt=n,r=k;
    rep(i,n) F[i]=i;
    for(Data*i=E;i!=E+m;i++)
    {
        if(i-&gt;c2&lt;=limit)
        {
           int a=find(i-&gt;s),b=find(i-&gt;t);
           if(a!=b) Union(a,b),--cnt,--r;
        }
    }
    if(r&gt;0) return false;
    for(Data*i=E;i!=E+m;i++)
    {
        if(i-&gt;c1&lt;=limit)
        {
           int a=find(i-&gt;s),b=find(i-&gt;t);
           if(a!=b) Union(a,b),--cnt;
        }
        if(cnt==1) return true;
    }
    return false;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;int s,t,c1,c2;
    rep(i,m)
    {
        scanf("%d %d %d %d",&amp;s,&amp;t,&amp;c2,&amp;c1);
        E[i](s-1,t-1,c1,c2);
    }
    int l=0,r=30000;
    while(l+1&lt;r)
    {
        int m=(l+r)/2;
        if(check(m))
            r=m;
        else
            l=m;
    }
    cout&lt;&lt;r&lt;&lt;endl;
}
<pre><h2>Problem1197</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1;
const int maxn=100+1,maxd=16;
int n,d;
long long dp[maxd][maxn]={0};
int main()
{
    cin&gt;&gt;n&gt;&gt;d;
    rep(i,n+1)dp[1][i]=i*2;dp[1][0]=1;
    for(int i=2;i&lt;=d;i++)
    {
        dp[i][0]=1;
        for(int j=1;j&lt;=n;j++)
            dp[i][j]=dp[i][j-1]+dp[i-1][j-1];
    }
    cout&lt;&lt;dp[d][n]&lt;&lt;endl;
}
<pre><h2>Problem1202</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=100;
int n,m;
int F[maxn],G[maxn];
int Find(int x)
{
    if(x==F[x])return x;
    Find(F[x]);G[x]+=G[F[x]];return F[x]=F[F[x]];
}
void solve()
{
    int s,t,v;
    cin&gt;&gt;n&gt;&gt;m;
    rep(i,n+1)F[i]=i,G[i]=0;
    bool Right=true;
    while(m--)
    {
        scanf("%d %d %d",&amp;s,&amp;t,&amp;v);--s;
        int i=Find(s),j=Find(t),a=G[s],b=G[t];
        if(i!=j)
        {
            F[i]=j;
            G[i]=b-a-v;
        }
        else if(b-a!=v)Right=false;
    }
    if(Right)cout&lt;&lt;"true"&lt;&lt;endl;
    else cout&lt;&lt;"false"&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    int t;cin&gt;&gt;t;while(t--)solve();
}
<pre><h2>Problem1202</h2><pre>#include&lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=100;
int n,m,F[maxn],G[maxn];
int Find(int x)
{
    if(x==F[x])return x;
    Find(F[x]);G[x]+=G[F[x]];return F[x]=F[F[x]];
}
void solve()
{
    int s,t,v;
    scanf("%d %d",&amp;n,&amp;m);
    rep(i,n+1)F[i]=i,G[i]=0;
    bool Right=1;
    while(m--)
    {
        scanf("%d %d %d",&amp;s,&amp;t,&amp;v);--s;
        int i=Find(s),j=Find(t),a=G[s],b=G[t];
        if(i!=j)
        {
            F[i]=j;
            G[i]=b-a-v;
        }
        else if(b-a!=v)Right=false;
    }
    Right?puts("true"):puts("false");
}
int main()
{
    int t;scanf("%d",&amp;t);while(t--)solve();
}
<pre><h2>Problem1206</h2><pre>#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#include&lt;iostream&gt;
using namespace std;
typedef pair&lt;int,int&gt; ii;
struct state
{
    int used,first;
    bool inQ;
    state(){}
    state(int _first):used(1),first(_first),inQ(true){}
};
map&lt;int,state&gt; id;
struct node
{
    int id,used,first;
    node(const state&amp;s,int _id)
    {
        used=s.used;first=s.first;
        id=_id;
    }
    bool operator&lt;(const node&amp;o)const
    {
        if(used!=o.used) return o.used&lt;used;
        return o.first&lt;first;
    }
};
int n,m,Time=0,ans=0;
priority_queue&lt;node&gt; Q;
void Check()
{
    while(Q.size()&gt;=n)
    {
        node t=Q.top();Q.pop();
        if(t.used&lt;id[t.id].used)
        {
            t.used=id[t.id].used;
            Q.push(t);
        }
        else
        {
            state&amp;s=id[t.id];
            s.inQ=false;
            s.used=1;
            //cout&lt;&lt;"Out"&lt;&lt;t.id&lt;&lt;endl;
            break;
        }
    }
}
void Insert(int x)
{
    if(id.count(x))
    {
        state&amp;s=id[x];
        if(s.inQ)
        {
            //cout&lt;&lt;"Great"&lt;&lt;x&lt;&lt;endl;
            ans++;s.used++;s.first=Time;
        }
        else
        {
            Check();s.inQ=true;s.first=Time;
            Q.push(node(s,x));
        }
    }
    else
    {
        state s(Time);
        id[x]=s;
        Check();
        Q.push(node(s,x));
    }
    //cout&lt;&lt;"In"&lt;&lt;x&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d %d",&amp;n,&amp;m);int x;
    while(m--)
    {
        scanf("%d",&amp;x);
        Insert(x);
        ++Time;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}

<pre><h2>Problem1208</h2><pre>#include&lt;cstdio&gt;
#include&lt;set&gt;
using namespace std;
const int inf=~0U&gt;&gt;2;
typedef set&lt;int&gt;::iterator sit;
set&lt;int&gt; S;
int main()
{
    int n,a,b,ans=0,type;
    scanf("%d",&amp;n);S.insert(inf);S.insert(-inf);
    while(n--)
    {
        scanf("%d %d",&amp;a,&amp;b);
        if(S.size()==2) type=a,S.insert(b);
        else if(type==a) S.insert(b);
        else
        {
            sit i=S.lower_bound(b);
            int r=*i-b,l=b-*(--i);
            if(l&lt;=r) ans+=l,S.erase(i);
            else ans+=r,S.erase(++i);
            ans%=1000000;
        }
    }
    printf("%d\n",ans);
}
<pre><h2>Problem1211</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
typedef long long ll;
const int inf=~0U&gt;&gt;1,maxn=150+10;
int n;
int H[maxn]={},D[maxn];
void Change(int x,int d)
{
    for(int i=2;i&lt;=x;i++)
        while(x%i==0)x/=i,H[i]+=d;
}
#define Out(x) {printf("%d\n",x);return 0;}
int main()
{
    //freopen("in","r",stdin);
    int sum=0,cnt=0;
    scanf("%d",&amp;n);rep(i,n)
    {
        scanf("%d",D+i);
        sum+=D[i];if(!D[i])cnt++;
    }
    if(n&gt;1&amp;&amp;cnt)Out(0);
    if(sum!=n*2-2)Out(0);
    if(n==1)Out(1);
    rep(i,n-2)Change(i+1,1);
    rep(i,n)
        rep(j,D[i]-1)
            Change(j+1,-1);
    ll ans=1;
    rep(i,n)
        rep(j,H[i+1])
            ans*=i+1;
    cout&lt;&lt;ans&lt;&lt;endl;
}
<pre><h2>Problem1218</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxc=5002;
using namespace std;
int T[maxc][maxc]={0},n,r;
int main()
{
    //freopen("in","r",stdin);
    scanf("%d %d",&amp;n,&amp;r);
    int x,y,c,a,ans=0;
    while(n--)scanf("%d%d%d",&amp;x,&amp;y,&amp;c),T[x+1][y+1]=c;
    for(int i=1;i&lt;maxc;i++)
        for(int j=1;j&lt;maxc;j++)
            T[i][j]+=T[i-1][j]+T[i][j-1]-T[i-1][j-1];
    for(int i=0;i+r&lt;maxc;i++)
        for(int j=0;j+r&lt;maxc;j++)
            if((a=T[i+r][j+r]+T[i][j]-T[i+r][j]-T[i][j+r])&gt;ans)
                ans=a;
    cout&lt;&lt;ans&lt;&lt;endl;
}


<pre><h2>Problem1218</h2><pre>#include &lt;vector&gt;
#include &lt;cstdio&gt;
const int maxc=5002;
using namespace std;
int T[maxc][maxc]={0},n,r;
int main()
{
    scanf("%d %d",&amp;n,&amp;r);
    int x,y,c,a,ans=0;
    while(n--)scanf("%d%d%d",&amp;x,&amp;y,&amp;c),T[x+1][y+1]=c;
    for(int i=1;i&lt;maxc;i++)
        for(int j=1;j&lt;maxc;j++)
            T[i][j]+=T[i-1][j]+T[i][j-1]-T[i-1][j-1];
    for(int i=0;i+r&lt;maxc;i++)
        for(int j=0;j+r&lt;maxc;j++)
            if((a=T[i+r][j+r]+T[i][j]-T[i+r][j]-T[i][j+r])&gt;ans)
                ans=a;
    printf("%d\n",ans);
}


<pre><h2>Problem1227</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define OK puts("OK")
using namespace std;
const int PT_MAX=100000+10,K_MAX=10+1;
struct TA
{
    int A[PT_MAX],n;
    void init_size(int _n)
    {
        n=_n;
        memset(A,0,sizeof(int)*n);
    }
    void add(int p,int x)
    {
        for(p++;p&lt;=n;p+=p&amp;-p)
            A[p-1]+=x;
    }
    int Sum(int p)
    {
        int ret=0;
        for(p++;p;p-=p&amp;-p)
            ret+=A[p-1];
        return ret;
    }
    int Sum(int l,int r)
    {
        return Sum(r)-Sum(l-1);
    }
};
struct Idx
{
    int A[PT_MAX],n;
    void init_Idx()
    {
        n=0;
    }
    void add(int x)
    {
        A[n++]=x;
    }
    void prepare()
    {
        sort(A,A+n);
        n=unique(A,A+n)-A;
    }
    int operator[](int x)
    {
        return lower_bound(A,A+n,x)-A;
    }
};
int C[PT_MAX][K_MAX];
int n,m,w,k;
inline void scan(int&amp;t)
{
    char c;while(c=getchar(),c&lt;'0'||c&gt;'9');t=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
}
struct Point
{
    int x,y;
    Point(){}
    Point(int _x,int _y):
        x(_x),y(_y){}
    bool operator&lt;(const Point&amp;pnt)const
    {
        if(x!=pnt.x)return x&lt;pnt.x;
        return y&lt;pnt.y;
    }
    void read()
    {
        scan(x);scan(y);
    }
}P[PT_MAX];
Idx idx,idy;
const int T_MAX=100;
void output_map()
{
    static char Map[T_MAX][T_MAX];
    rep(i,n)rep(j,m)
        Map[i][j]='.';
    rep(i,w)
        Map[P[i].x][P[i].y]='*';
    rep(i,n)Map[i][m]='\0';
    rep(i,n)cout&lt;&lt;Map[i]&lt;&lt;endl;
}
void input_data()
{
    scan(n);scan(m);scan(w);
    idx.init_Idx();
    idy.init_Idx();
    rep(i,w)P[i].read(),idx.add(P[i].x),idy.add(P[i].y);
    scan(k);
    idx.prepare();n=idx.n;
    idy.prepare();m=idy.n;
    rep(i,w)P[i].x=idx[P[i].x],P[i].y=idy[P[i].y];
    sort(P,P+w);
    //output_map();
}
void prepare_C()
{
    memset(C,0,sizeof C);
    C[0][0]=1;
    for(int i=1;i&lt;=w;i++)
    {
        C[i][0]=1;
        for(int j=1;j&lt;=k;j++)
            C[i][j]=C[i-1][j]+C[i-1][j-1];
    }
}
TA T;
int Up[PT_MAX],Down[PT_MAX],Line[PT_MAX];
void modify(int p,int t)
{
    if(t)//add to  up
        Up[p]++;
    else//delete from down
        Down[p]--;
    int new_L=C[Up[p]][k]*C[Down[p]][k];
    int add_L=new_L-Line[p];
    Line[p]=new_L;
    T.add(p,add_L);
}
void Show_State()
{
    cout&lt;&lt;"Let's See"&lt;&lt;endl;
    cout&lt;&lt;"Top"&lt;&lt;endl;
    rep(i,m)cout&lt;&lt;Up[i]&lt;&lt;" ";cout&lt;&lt;endl;
    cout&lt;&lt;"Bot"&lt;&lt;endl;
    rep(i,m)cout&lt;&lt;Down[i]&lt;&lt;" ";cout&lt;&lt;endl;
    cout&lt;&lt;"Line"&lt;&lt;endl;
    rep(i,m)cout&lt;&lt;Line[i]&lt;&lt;" ";cout&lt;&lt;endl;
}
void work()
{
    memset(Up,0,sizeof Up);
    memset(Down,0,sizeof Down);
    memset(Line,0,sizeof Line);
    rep(i,w)Down[P[i].y]++;
    T.init_size(m);
    int Ans=0;
    for(int l=0;l&lt;w;)
    {
        int r=l;
        while(r&lt;w&amp;&amp;P[r].x==P[l].x)
        {
            modify(P[r].y,0);
            r++;
        }
        int Left=0,Right=r-l,dt;
        #define get_dt dt=C[Left][k]*C[Right][k]
        //Show_State();
        for(int i=l;i&lt;r;i++)
        {
            get_dt;
            if(i&gt;l)
            {
                Ans+=T.Sum(P[i-1].y+1,P[i].y-1)*dt;
            }
            Right--;
            Left++;
        }
        for(int i=l;i&lt;r;i++)
            modify(P[i].y,1);
        l=r;
    }
    long long out;
    out=(unsigned int)Ans;
    out=out%2147483648LL;
    int ret=out;
    printf("%d\n",ret);
}
void solve()
{
    input_data();
    prepare_C();
    work();
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    solve();
}
<pre><h2>Problem1230</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;r;i++)
#define tr(i,x) For(i,x*s,(x+1)*s)
const int inf=~0U&gt;&gt;1,maxn=110000,size=1000;
using namespace std;
bool M[size]={};
int A[maxn]={},T[size]={},s,n,m;
void ReMark(int t)
{
    if(!M[t])return;T[t]=0;M[t]=false;
    tr(i,t)A[i]^=1,T[t]+=A[i];
}
int Sum(int a,int b)
{
    int x=a/s,y=b/s,ret=0;
    if(x==y){ReMark(x);For(i,a,b+1)ret+=A[i];return ret;}
    ReMark(x);For(i,a,(x+1)*s)ret+=A[i];
    ReMark(y);For(i,y*s,b+1)ret+=A[i];
    For(i,x+1,y)ret+=T[i];
    return ret;
}
void Change(int a,int b)
{
    int x=a/s,y=b/s;
    if(x==y){ReMark(x);For(i,a,b+1)A[i]^=1,T[x]+=2*A[i]-1;return;}
    ReMark(x);For(i,a,(x+1)*s)A[i]^=1,T[x]+=2*A[i]-1;
    ReMark(y);For(i,y*s,b+1)A[i]^=1,T[y]+=2*A[i]-1;
    For(i,x+1,y)M[i]^=1,T[i]=s-T[i];
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d",&amp;n,&amp;m);s=0;while(s*s&lt;=n)s++;
    int k,a,b;
    rep(i,m)
    {
        scanf("%d%d%d",&amp;k,&amp;a,&amp;b);--a;--b;
        if(k)printf("%d\n",Sum(a,b));
        else Change(a,b);
    }
}


<pre><h2>Problem1230</h2><pre>#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;r;i++)
#define tr(i,x) For(i,x*s,(x+1)*s)
const int maxn=110000,size=1000;
using namespace std;
bool M[size]={};
int A[maxn]={},T[size]={},s,n,m;
void ReMark(int t)
{
    if(!M[t])return;T[t]=0;M[t]=false;
    tr(i,t)A[i]^=1,T[t]+=A[i];
}
int Sum(int a,int b)
{
    int x=a/s,y=b/s,ret=0;
    if(x==y){ReMark(x);For(i,a,b+1)ret+=A[i];return ret;}
    ReMark(x);For(i,a,(x+1)*s)ret+=A[i];
    ReMark(y);For(i,y*s,b+1)ret+=A[i];
    For(i,x+1,y)ret+=T[i];
    return ret;
}
void Change(int a,int b)
{
    int x=a/s,y=b/s;
    if(x==y){ReMark(x);For(i,a,b+1)A[i]^=1,T[x]+=2*A[i]-1;return;}
    ReMark(x);For(i,a,(x+1)*s)A[i]^=1,T[x]+=2*A[i]-1;
    ReMark(y);For(i,y*s,b+1)A[i]^=1,T[y]+=2*A[i]-1;
    For(i,x+1,y)M[i]^=1,T[i]=s-T[i];
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);s=0;while(s*s&lt;=n)s++;
    int k,a,b;
    rep(i,m)
    {
        scanf("%d%d%d",&amp;k,&amp;a,&amp;b);--a;--b;
        if(k)printf("%d\n",Sum(a,b));
        else Change(a,b);
    }
}


<pre><h2>Problem1230</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;r;i++)
#define tr(i,x) For(i,x*s,(x+1)*s)
const int maxn=110000,size=1000;
using namespace std;
bool M[size]={};
int A[maxn]={},T[size]={},s,n,m;
void ReMark(int t)
{
    if(!M[t])return;T[t]=0;M[t]=false;
    tr(i,t)A[i]^=1,T[t]+=A[i];
}
int Sum(int a,int b)
{
    int x=a/s,y=b/s,ret=0;
    if(x==y){ReMark(x);For(i,a,b+1)ret+=A[i];return ret;}
    ReMark(x);For(i,a,(x+1)*s)ret+=A[i];
    ReMark(y);For(i,y*s,b+1)ret+=A[i];
    For(i,x+1,y)ret+=T[i];
    return ret;
}
void Change(int a,int b)
{
    int x=a/s,y=b/s;
    if(x==y){ReMark(x);For(i,a,b+1)A[i]^=1,T[x]+=2*A[i]-1;return;}
    ReMark(x);For(i,a,(x+1)*s)A[i]^=1,T[x]+=2*A[i]-1;
    ReMark(y);For(i,y*s,b+1)A[i]^=1,T[y]+=2*A[i]-1;
    For(i,x+1,y)M[i]^=1,T[i]=s-T[i];
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);s=sqrt(n)+1;
    int k,a,b;
    rep(i,m)
    {
        scanf("%d%d%d",&amp;k,&amp;a,&amp;b);--a;--b;
        if(k)printf("%d\n",Sum(a,b));
        else Change(a,b);
    }
}


<pre><h2>Problem1230</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;r;i++)
#define tr(i,x) For(i,x*s,(x+1)*s)
const int maxn=110000,size=1000;
using namespace std;
bool M[size]={};
int A[maxn]={},T[size]={},s,n,m;
void ReMark(int t)
{
    if(!M[t])return;T[t]=0;M[t]=false;
    tr(i,t)A[i]^=1,T[t]+=A[i];
}
int Sum(int a,int b)
{
    int x=a/s,y=b/s,ret=0;
    if(x==y){ReMark(x);For(i,a,b+1)ret+=A[i];return ret;}
    ReMark(x);For(i,a,(x+1)*s)ret+=A[i];
    ReMark(y);For(i,y*s,b+1)ret+=A[i];
    For(i,x+1,y)ret+=T[i];
    return ret;
}
void Change(int a,int b)
{
    int x=a/s,y=b/s;
    if(x==y){ReMark(x);For(i,a,b+1)A[i]^=1,T[x]+=2*A[i]-1;return;}
    ReMark(x);For(i,a,(x+1)*s)A[i]^=1,T[x]+=2*A[i]-1;
    ReMark(y);For(i,y*s,b+1)A[i]^=1,T[y]+=2*A[i]-1;
    For(i,x+1,y)M[i]^=1,T[i]=s-T[i];
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);s=sqrt(n)/1.2+1;
    int k,a,b;
    rep(i,m)
    {
        scanf("%d%d%d",&amp;k,&amp;a,&amp;b);--a;--b;
        if(k)printf("%d\n",Sum(a,b));
        else Change(a,b);
    }
}


<pre><h2>Problem1230</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;r;i++)
#define tr(i,x) For(i,x*s,(x+1)*s)
const int maxn=110000,size=1000;
using namespace std;
bool M[size]={};
int A[maxn]={},T[size]={},s,n,m;
void ReMark(int t)
{
    if(!M[t])return;T[t]=0;M[t]=false;
    tr(i,t)A[i]^=1,T[t]+=A[i];
}
int Sum(int a,int b)
{
    int x=a/s,y=b/s,ret=0;
    if(x==y){ReMark(x);For(i,a,b+1)ret+=A[i];return ret;}
    ReMark(x);For(i,a,(x+1)*s)ret+=A[i];
    ReMark(y);For(i,y*s,b+1)ret+=A[i];
    For(i,x+1,y)ret+=T[i];
    return ret;
}
void Change(int a,int b)
{
    int x=a/s,y=b/s;
    if(x==y){ReMark(x);For(i,a,b+1)A[i]^=1,T[x]+=2*A[i]-1;return;}
    ReMark(x);For(i,a,(x+1)*s)A[i]^=1,T[x]+=2*A[i]-1;
    ReMark(y);For(i,y*s,b+1)A[i]^=1,T[y]+=2*A[i]-1;
    For(i,x+1,y)M[i]^=1,T[i]=s-T[i];
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);s=sqrt(n)/1.5+1;
    int k,a,b;
    rep(i,m)
    {
        scanf("%d%d%d",&amp;k,&amp;a,&amp;b);--a;--b;
        if(k)printf("%d\n",Sum(a,b));
        else Change(a,b);
    }
}


<pre><h2>Problem1230</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;r;i++)
#define tr(i,x) For(i,x*s,(x+1)*s)
const int maxn=110000,size=1000;
using namespace std;
bool M[size]={};
int A[maxn]={},T[size]={},s,n,m;
void ReMark(int t)
{
    if(!M[t])return;T[t]=0;M[t]=false;
    tr(i,t)A[i]^=1,T[t]+=A[i];
}
int Sum(int a,int b)
{
    int x=a/s,y=b/s,ret=0;
    if(x==y){ReMark(x);For(i,a,b+1)ret+=A[i];return ret;}
    ReMark(x);For(i,a,(x+1)*s)ret+=A[i];
    ReMark(y);For(i,y*s,b+1)ret+=A[i];
    For(i,x+1,y)ret+=T[i];
    return ret;
}
void Change(int a,int b)
{
    int x=a/s,y=b/s;
    if(x==y){ReMark(x);For(i,a,b+1)A[i]^=1,T[x]+=2*A[i]-1;return;}
    ReMark(x);For(i,a,(x+1)*s)A[i]^=1,T[x]+=2*A[i]-1;
    ReMark(y);For(i,y*s,b+1)A[i]^=1,T[y]+=2*A[i]-1;
    For(i,x+1,y)M[i]^=1,T[i]=s-T[i];
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);s=sqrt(n)/2+1;
    int k,a,b;
    rep(i,m)
    {
        scanf("%d%d%d",&amp;k,&amp;a,&amp;b);--a;--b;
        if(k)printf("%d\n",Sum(a,b));
        else Change(a,b);
    }
}


<pre><h2>Problem1230</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;r;i++)
#define tr(i,x) For(i,x*s,(x+1)*s)
const int maxn=110000,size=1000;
using namespace std;
bool M[size]={};
int A[maxn]={},T[size]={},s,n,m;
void ReMark(int t)
{
    if(!M[t])return;T[t]=0;M[t]=false;
    tr(i,t)A[i]^=1,T[t]+=A[i];
}
int Sum(int a,int b)
{
    int x=a/s,y=b/s,ret=0;
    if(x==y){ReMark(x);For(i,a,b+1)ret+=A[i];return ret;}
    ReMark(x);For(i,a,(x+1)*s)ret+=A[i];
    ReMark(y);For(i,y*s,b+1)ret+=A[i];
    For(i,x+1,y)ret+=T[i];
    return ret;
}
void Change(int a,int b)
{
    int x=a/s,y=b/s;
    if(x==y){ReMark(x);For(i,a,b+1)A[i]^=1,T[x]+=2*A[i]-1;return;}
    ReMark(x);For(i,a,(x+1)*s)A[i]^=1,T[x]+=2*A[i]-1;
    ReMark(y);For(i,y*s,b+1)A[i]^=1,T[y]+=2*A[i]-1;
    For(i,x+1,y)M[i]^=1,T[i]=s-T[i];
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);s=sqrt(n)/2.5+1;
    int k,a,b;
    rep(i,m)
    {
        scanf("%d%d%d",&amp;k,&amp;a,&amp;b);--a;--b;
        if(k)printf("%d\n",Sum(a,b));
        else Change(a,b);
    }
}


<pre><h2>Problem1230</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;r;i++)
#define tr(i,x) For(i,x*s,(x+1)*s)
const int maxn=110000,size=1000;
using namespace std;
bool M[size]={};
int A[maxn]={},T[size]={},s,n,m;
void ReMark(int t)
{
    if(!M[t])return;T[t]=0;M[t]=false;
    tr(i,t)A[i]^=1,T[t]+=A[i];
}
int Sum(int a,int b)
{
    int x=a/s,y=b/s,ret=0;
    if(x==y){ReMark(x);For(i,a,b+1)ret+=A[i];return ret;}
    ReMark(x);For(i,a,(x+1)*s)ret+=A[i];
    ReMark(y);For(i,y*s,b+1)ret+=A[i];
    For(i,x+1,y)ret+=T[i];
    return ret;
}
void Change(int a,int b)
{
    int x=a/s,y=b/s;
    if(x==y){ReMark(x);For(i,a,b+1)A[i]^=1,T[x]+=2*A[i]-1;return;}
    ReMark(x);For(i,a,(x+1)*s)A[i]^=1,T[x]+=2*A[i]-1;
    ReMark(y);For(i,y*s,b+1)A[i]^=1,T[y]+=2*A[i]-1;
    For(i,x+1,y)M[i]^=1,T[i]=s-T[i];
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);s=sqrt(n)/2.2+1;
    int k,a,b;
    rep(i,m)
    {
        scanf("%d%d%d",&amp;k,&amp;a,&amp;b);--a;--b;
        if(k)printf("%d\n",Sum(a,b));
        else Change(a,b);
    }
}


<pre><h2>Problem1230</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;r;i++)
#define tr(i,x) For(i,x*s,(x+1)*s)
const int maxn=110000,size=1000;
using namespace std;
bool M[size]={};
int A[maxn]={},T[size]={},s,n,m;
void ReMark(int t)
{
    if(!M[t])return;T[t]=0;M[t]=false;
    tr(i,t)A[i]^=1,T[t]+=A[i];
}
int Sum(int a,int b)
{
    int x=a/s,y=b/s,ret=0;
    if(x==y){ReMark(x);For(i,a,b+1)ret+=A[i];return ret;}
    ReMark(x);For(i,a,(x+1)*s)ret+=A[i];
    ReMark(y);For(i,y*s,b+1)ret+=A[i];
    For(i,x+1,y)ret+=T[i];
    return ret;
}
void Change(int a,int b)
{
    int x=a/s,y=b/s;
    if(x==y){ReMark(x);For(i,a,b+1)A[i]^=1,T[x]+=2*A[i]-1;return;}
    ReMark(x);For(i,a,(x+1)*s)A[i]^=1,T[x]+=2*A[i]-1;
    ReMark(y);For(i,y*s,b+1)A[i]^=1,T[y]+=2*A[i]-1;
    For(i,x+1,y)M[i]^=1,T[i]=s-T[i];
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);s=sqrt(n)/2.3+1;
    int k,a,b;
    rep(i,m)
    {
        scanf("%d%d%d",&amp;k,&amp;a,&amp;b);--a;--b;
        if(k)printf("%d\n",Sum(a,b));
        else Change(a,b);
    }
}


<pre><h2>Problem1230</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;r;i++)
#define tr(i,x) For(i,x*s,(x+1)*s)
const int maxn=110000,size=1000;
using namespace std;
bool M[size]={};
int A[maxn]={},T[size]={},s,n,m;
void ReMark(int t)
{
    if(!M[t])return;T[t]=0;M[t]=false;
    tr(i,t)A[i]^=1,T[t]+=A[i];
}
int Sum(int a,int b)
{
    int x=a/s,y=b/s,ret=0;
    if(x==y){ReMark(x);For(i,a,b+1)ret+=A[i];return ret;}
    ReMark(x);For(i,a,(x+1)*s)ret+=A[i];
    ReMark(y);For(i,y*s,b+1)ret+=A[i];
    For(i,x+1,y)ret+=T[i];
    return ret;
}
void Change(int a,int b)
{
    int x=a/s,y=b/s;
    if(x==y){ReMark(x);For(i,a,b+1)A[i]^=1,T[x]+=2*A[i]-1;return;}
    ReMark(x);For(i,a,(x+1)*s)A[i]^=1,T[x]+=2*A[i]-1;
    ReMark(y);For(i,y*s,b+1)A[i]^=1,T[y]+=2*A[i]-1;
    For(i,x+1,y)M[i]^=1,T[i]=s-T[i];
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);s=sqrt(n)/2.4+1;
    int k,a,b;
    rep(i,m)
    {
        scanf("%d%d%d",&amp;k,&amp;a,&amp;b);--a;--b;
        if(k)printf("%d\n",Sum(a,b));
        else Change(a,b);
    }
}


<pre><h2>Problem1230</h2><pre>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;r;i++)
#define tr(i,x) For(i,x*s,(x+1)*s)
const int maxn=110000,size=1000;
using namespace std;
bool M[size]={};
int A[maxn]={},T[size]={},s,n,m;
void ReMark(int t)
{
    if(!M[t])return;T[t]=0;M[t]=false;
    tr(i,t)A[i]^=1,T[t]+=A[i];
}
int Sum(int a,int b)
{
    int x=a/s,y=b/s,ret=0;
    if(x==y){ReMark(x);For(i,a,b+1)ret+=A[i];return ret;}
    ReMark(x);For(i,a,(x+1)*s)ret+=A[i];
    ReMark(y);For(i,y*s,b+1)ret+=A[i];
    For(i,x+1,y)ret+=T[i];
    return ret;
}
void Change(int a,int b)
{
    int x=a/s,y=b/s;
    if(x==y){ReMark(x);For(i,a,b+1)A[i]^=1,T[x]+=2*A[i]-1;return;}
    ReMark(x);For(i,a,(x+1)*s)A[i]^=1,T[x]+=2*A[i]-1;
    ReMark(y);For(i,y*s,b+1)A[i]^=1,T[y]+=2*A[i]-1;
    For(i,x+1,y)M[i]^=1,T[i]=s-T[i];
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);s=sqrt(n)/2.35+1;
    int k,a,b;
    rep(i,m)
    {
        scanf("%d%d%d",&amp;k,&amp;a,&amp;b);--a;--b;
        if(k)printf("%d\n",Sum(a,b));
        else Change(a,b);
    }
}


<pre><h2>Problem1231</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=16;
using namespace std;
typedef long long ll;
int A[maxn];
ll Mem[1&lt;&lt;maxn][maxn];
int n,k;
ll dfs(int subset,int last)
{
    ll&amp;ret=Mem[subset][last];
    if(ret&gt;=0)return ret;
    if(subset+1==(1&lt;&lt;n))
        return ret=1;
    ret=0;
    rep(i,n)if(~subset&gt;&gt;i&amp;1)
        if(abs(A[last]-A[i])&gt;k)
        {
            ret+=dfs(subset|(1&lt;&lt;i),i);
        }
    return ret;
}
int main()
{
    //freopen("in","r",stdin);
    memset(Mem,-1,sizeof Mem);
    ll ans=0;
    cin&gt;&gt;n&gt;&gt;k;
    rep(i,n)cin&gt;&gt;A[i];
    rep(i,n)ans+=dfs(1&lt;&lt;i,i);
    cout&lt;&lt;ans&lt;&lt;endl;
}


<pre><h2>Problem1232</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=10000;
int n,m;
struct uf
{
    int F[maxn];
    uf(){rep(i,n)F[i]=i;}
    int Find(int i)
    {
        return i==F[i]?i:(F[i]=Find(F[i]));
    }
    bool Find(int i,int j)
    {
        i=Find(i);j=Find(j);
        return F[i]=j,i!=j;
    }
};
struct Edge
{
    int s,t,c;
    Edge(int _s,int _t,int _c):s(_s),t(_t),c(_c){}
    bool operator&lt;(const Edge&amp;o)const
    {
        return c&gt;o.c;
    }
};
priority_queue&lt;Edge&gt; PQ;
int C[maxn];
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;int s,t,c,ans=~0U&gt;&gt;1;
    rep(i,n)scanf("%d",C+i),ans&lt;?=C[i];
    rep(i,m)scanf("%d%d%D",&amp;s,&amp;t,&amp;c),--s,--t,PQ.push(Edge(s,t,c*2+C[s]+C[t]));
    uf U;
    while(n&gt;1)
    {
        Edge e=PQ.top();PQ.pop();
        if(U.Find(e.s,e.t))
            ans+=e.c,n--;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
<pre><h2>Problem1237</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1,maxn=100000+10;
using namespace std;
typedef long long ll;
void scan(int&amp;ret)
{
    char c;
    while(c=getchar(),c&lt;'0'||c&gt;'9');
    ret=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')ret=ret*10+c-'0';
}
int A[maxn],B[maxn],n;
void Init()
{
    scan(n);rep(i,n)scan(A[i+1]),scan(B[i+1]);
    sort(A+1,A+n+1);sort(B+1,B+n+1);
}
ll Dp[maxn];
inline int cost(int i,int j){return i==j?inf:abs(i-j);}
inline void Update(ll&amp;x,ll c){if(x&gt;c)x=c;}
void Solve()
{
    Dp[0]=0;
    for(int i=1;i&lt;=n;i++)
    {
        Dp[i]=1LL&lt;&lt;60;
        Update(Dp[i],Dp[i-1]+cost(A[i],B[i]));
        if(i&gt;=2) Update(Dp[i],Dp[i-2]+cost(A[i-1],B[i])+cost(A[i],B[i-1]));
        if(i&gt;=3) Update(Dp[i],Dp[i-3]+cost(A[i-2],B[i])+cost(A[i-1],B[i-2])+cost(A[i],B[i-1]));
        if(i&gt;=3) Update(Dp[i],Dp[i-3]+cost(B[i-2],A[i])+cost(B[i-1],A[i-2])+cost(B[i],A[i-1]));
    }
    cout&lt;&lt;Dp[n]&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


<pre><h2>Problem1241</h2><pre>/*
 * Zmaj程序.cpp
 *
 *  Created on: 2011-7-21
 *      Author: mac
 */

#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;climits&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
using namespace std;

const int ONE = 26;
const int LENGTH = 27;
const int MOD = 10000;

typedef vector&lt;int&gt; Vector;
typedef vector&lt;Vector&gt; Mat;

Mat zero() {
	return Mat(LENGTH, Vector(LENGTH, 0));
}

Mat unit() {
	Mat ret = zero();
	for (int i = 0; i &lt; LENGTH; ++i) {
		ret[i][i] = 1;
	}
	return ret;
}

typedef long long int64;

Mat operator*(const Mat&amp;a, const Mat&amp;b) {
	Mat c = zero();
	for (int i = 0; i &lt; LENGTH; ++i) {
		for (int j = 0; j &lt; LENGTH; ++j) {
			int64 tmp = 0;
			for (int k = 0; k &lt; LENGTH; ++k) {
				tmp += a[i][k] * b[k][j];
			}
			c[i][j] = tmp % MOD;
		}
	}
	return c;
}

Mat matPow(const Mat&amp;a, int pow) {
	if (!pow)
		return unit();
	if (pow &amp; 1)
		return matPow(a, pow - 1) * a;
	else
		return matPow(a * a, pow &gt;&gt; 1);
}

Vector operator*(const Vector&amp;a, const Mat&amp;m) {
	Vector ret(LENGTH, 0);
	for (int i = 0; i &lt; LENGTH; ++i) {
		int64 tmp = 0;
		for (int j = 0; j &lt; LENGTH; ++j) {
			tmp += a[j] * m[j][i];
		}
		ret[i] = tmp % MOD;
	}
	return ret;
}

string program;

void readInput() {
	string tmp;
	while (getline(cin, tmp))
		program += tmp + "\n";
	program += "@";
}

struct Parser {
	const string&amp;s;
	int at;
	Parser(const string&amp;_s, int _at = 0) :
			s(_s), at(_at) {
	}
	char peekChar() {
		while (at &lt; s.length() &amp;&amp; (s[at] == ' ' || s[at] == '\t'))
			++at;
		return s[at];
	}
	void skipChar() {
		++at;
	}
	char nextChar() {
		char ch = peekChar();
		skipChar();
		return ch;
	}
	void eatChar(char ch) {
		assert(peekChar()==ch);
		++at;
	}
	void eatString(string e) {
		for (int i = 0; i &lt; e.length(); ++i) {
			eatChar(e[i]);
		}
	}
	int nextInt(bool needMod = true) {
		int ret = 0;
		int sign = 1;
		if (peekChar() == '-')
			sign = -1, skipChar();
		while (isdigit(peekChar())) {
			ret = ret * 10 + nextChar() - '0';
			if (needMod)
				ret %= MOD;
		}
		ret *= sign;
		if (needMod) {
			ret = ret % MOD;
			if (ret &lt; 0)
				ret += MOD;
		}
		return ret;
	}
};

struct Result {
	Mat mat;
	bool need;
};

struct Node {
	Node() {
		has = false;
	}
	Node(Parser&amp;p) {
	}

	bool has;
	Result memo;
	virtual Result run(Vector&amp;cur)=0;
	Result doit(Vector&amp;cur) {
		if (has) {
			if (memo.need) {
				return run(cur);
			} else {
				cur = cur * memo.mat;
				return memo;
			}
		}
		has = true;
		return memo = run(cur);
	}
};

struct Set: public Node {
	int var;
	Vector what;
	Set(Parser&amp;p);
	Result run(Vector&amp;cur) {
		Result ret;
		ret.mat = unit();
		for (int i = 0; i &lt; LENGTH; ++i) {
			ret.mat[i][var] = what[i];
		}
		ret.need = false;
		cur = cur * ret.mat;
		return ret;
	}
};

struct Middle: public Node {
	vector&lt;Node*&gt; ch;
	Middle(Parser&amp;p);
	Result run(Vector&amp;cur) {
		Result ret;
		ret.mat = unit();
		ret.need = false;
		for (int i = 0; i &lt; ch.size(); ++i) {
			Result tmp = ch[i]-&gt;doit(cur);
			ret.mat = ret.mat * tmp.mat;
			ret.need |= tmp.need;
		}
		return ret;
	}
};

struct Print: public Node {
	int id;
	Print(Parser&amp;p);
	Result run(Vector&amp;cur) {
		Result ret;
		ret.mat = unit();
		ret.need = true;
		printf("%c = %d\n", 'a' + id, cur[id]);
		return ret;
	}
};

struct Repeat: public Node {
	int rep;
	Middle*prog;
	Repeat(Parser&amp;p);
	Result run(Vector&amp;cur) {
		Result ret;
		if (rep == 0) {
			ret.mat = unit();
			ret.need = false;
			return ret;
		}
		Vector curCopy = cur;
		Result sub = prog-&gt;doit(cur);
		ret.mat = matPow(sub.mat, rep);
		if (sub.need) {
			ret.need = true;
			for (int j = 0; j &lt; rep - 1; ++j) {
				prog-&gt;run(cur);
			}
		} else {
			ret.need = false;
			cur = curCopy * ret.mat;
		}
		return ret;
	}
};

Middle::Middle(Parser&amp;p) {
	if (p.peekChar() == 'B') {
		p.eatString("BEGIN");
		p.eatChar('\n');
	}
	while (p.peekChar() != 'S') {
		char next = p.peekChar();
		if (next == 'R') {
			ch.push_back(new Repeat(p));
		} else if (next == 'P') {
			ch.push_back(new Print(p));
		} else {
			assert(islower(next));
			ch.push_back(new Set(p));
		}
	}
	p.eatString("STOP");
	p.eatChar('\n');
}

Repeat::Repeat(Parser&amp;p) {
	p.eatString("REPEAT");
	rep = p.nextInt(false);
	p.eatChar('\n');
	prog = new Middle(p);
}

Print::Print(Parser&amp;p) {
	p.eatString("PRINT");
	id = p.nextChar() - 'a';
	p.eatChar('\n');
}

Set::Set(Parser&amp;p) {
	var = p.nextChar() - 'a';
	p.eatChar('=');
	what = Vector(LENGTH, 0);
	bool first = true;
	while (p.peekChar() != '\n') {
		int sign;
		if (first)
			sign = 1, first = false;
		else {
			sign = p.nextChar() == '+' ? 1 : -1;
		}

		while (p.peekChar() == '-' || p.peekChar() == '+')
			sign *= p.nextChar() == '-' ? -1 : 1;
		char next = p.peekChar();
		if (isdigit(next)) {
			int cof = p.nextInt();
			if (isalpha(p.peekChar())) {
				int who = p.nextChar() - 'a';
				(what[who] += cof * sign + MOD) %= MOD;
			} else {
				(what[ONE] += cof * sign + MOD) %= MOD;
			}
		} else {
			assert(isalpha(next));
			(what[next - 'a'] += sign + MOD) %= MOD;
			p.skipChar();
		}
	}
	p.eatChar('\n');
}

void work() {
	Parser p(program);
	Node*prog = new Middle(p);
	Vector cur(LENGTH, 0);
	cur[ONE] = 1;
	prog-&gt;doit(cur);
}

int main() {
//	freopen("in", "r", stdin);
	readInput();
	work();

	return 0;
}
<pre><h2>Problem1242</h2><pre>/*
 * traffic.cpp
 *
 *  Created on: 2011-3-9
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VETS = 1000;
bool adj[MAX_N_VETS][MAX_N_VETS];
int nVets, nEdges;

void inputData() {
	cin &gt;&gt; nVets &gt;&gt; nEdges;
	memset(adj, false, sizeof adj);
	for (int iter = 0; iter &lt; nEdges; ++iter) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		--a;
		--b;
		adj[a][b] = adj[b][a] = true;
	}
}

bool work() {
	bool inSet[MAX_N_VETS] = { };
	int adjCnt[MAX_N_VETS] = { };
	int ord[MAX_N_VETS];
	int label[MAX_N_VETS];
	for (int num = nVets - 1; num &gt;= 0; --num) {
		int best=-1;
		for (int i = 0; i &lt; nVets; ++i) {
			if(!inSet[i] &amp;&amp;(best == -1 || adjCnt[i] &gt; adjCnt[best]))
				best=i;
		}
		ord[num]=best;
		label[best]=num;
		inSet[best]=true;
		for (int i = 0; i &lt; nVets; ++i) {
			if(adj[i][best] &amp;&amp; !inSet[i])
				adjCnt[i]++;
		}
	}

	for(int num = nVets - 1; num &gt;= 0; --num){
		int am=ord[num];
		int that=-1;
		for (int after = num+1; after &lt; nVets; ++after) {
			int cur=ord[after];
			if(adj[am][cur]){
				if(that == -1)
					that=cur;
				else {
					if(!adj[cur][that])
						return false;
				}
			}
		}
	}

	return true;
}

void solve() {
	inputData();
	if(work())
		puts("Perfect");
	else
		puts("Imperfect");
}

int main() {
	solve();
}
<pre><h2>Problem1249</h2><pre>/*
 * 277. Heroes.cpp
 *
 *  Created on: 2011-3-29
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_POINTS = 100000 + 100;
double mx, my;

struct Point {
	int x, y;
	double alpha;
	void read() {
		scanf("%d%d", &amp;x, &amp;y);
	}
	void setAlpha() {
		alpha = atan2(y - my, x - mx);
	}
	bool operator&lt;(const Point&amp;other) const {
		return alpha &lt; other.alpha;
	}
};

typedef long long int64;

#define cross(p1,p2,p3) (1LL*(p2.x-p1.x)*(p3.y-p1.y) - 1LL*(p3.x-p1.x)*(p2.y-p1.y))

#define det(p1,p2) (1LL*p1.x*p2.y - 1LL*p2.x*p1.y)

inline int sign(int64 x) {
	return x &lt; 0 ? -1 : x &gt; 0;
}

#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))

set&lt;Point&gt; curSet;
typedef set&lt;Point&gt;::iterator Sit;
int64 area = 0;

Point getPrev(Point me) {
	if (curSet.count(me) &gt; 0)
		return me;
	Sit it = curSet.lower_bound(me);
	if (it != curSet.begin())
		return *--it;
	return *curSet.rbegin();
}

Point getNext(Point me) {
	Sit it = curSet.upper_bound(me);
	if (it != curSet.end())
		return *it;
	return *curSet.begin();
}

bool isInside(Point me) {
	Point prev = getPrev(me);
	Point next = getNext(me);
	return crossOp(prev,next,me) &gt;= 0;
}

void delPoint(Point me) {
	curSet.erase(me);
	Point prev = getPrev(me);
	Point next = getNext(me);

	area -= det(prev,me);
	area -= det(me,next);
	area += det(prev,next);
}

void insPoint(Point me) {
	Point prev = getPrev(me);
	Point next = getNext(me);

	area -= det(prev,next);
	area += det(me,next);
	area += det(prev,me);

	curSet.insert(me);
}

void addPoint(Point me) {
	if (isInside(me))
		return;
	while (true) {
		Point prev1 = getPrev(me);
		delPoint(prev1);
		Point prev2 = getPrev(me);
		if (crossOp(prev2,me,prev1) &lt; 0) {
			insPoint(prev1);
			break;
		}
	}
	while (true) {
		Point next1 = getNext(me);
		delPoint(next1);
		Point next2 = getNext(me);
		if (crossOp(me,next2,next1) &lt; 0) {
			insPoint(next1);
			break;
		}
	}
	insPoint(me);
}

void inputData() {
	Point orig[3];
	double rands[] = { 0.3575154, 0.8515751, 0.6978456 };
	double sum = 0;
	mx = 0, my = 0;
	for (int i = 0; i &lt; 3; ++i) {
		orig[i].read();
		sum += rands[i];
		mx += orig[i].x * rands[i];
		my += orig[i].y * rands[i];
	}
	mx /= sum;
	my /= sum;

	for (int i = 0; i &lt; 3; ++i) {
		orig[i].setAlpha();
	}

	sort(orig, orig + 3);

	area = cross(orig[0],orig[1],orig[2]);

	for (int i = 0; i &lt; 3; ++i) {
		curSet.insert(orig[i]);
	}
}

void work() {
	int nPs;
	scanf("%d", &amp;nPs);
	for (int iter = 0; iter &lt; nPs; ++iter) {
		Point me;
		me.read();
		me.setAlpha();
		addPoint(me);
		printf("%lld\n", area);
	}
}

void solve() {
	inputData();
	work();
}

int main() {
	solve();
}
<pre><h2>Problem1251</h2><pre>/*
 * 序列终结者.cpp
 *
 *  Created on: 2011-3-4
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define ok cout&lt;&lt;"ok!"&lt;&lt;endl;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int INF = ~0U &gt;&gt; 1;

struct Node {
	int maxV, size, add, val;
	bool isRev;
	Node*ch[2], *p;
	void update();
	void relax();
	void applyAdd(int add);
	void applyRev();
	void set(Node*c, bool d);
	bool dir();
}*null;

void initNull() {
	null = new Node;
	null-&gt;size = 0;
	null-&gt;maxV = -INF;
}

void Node::relax() {
	if(add != 0){
		if (ch[0] != null)
			ch[0]-&gt;applyAdd(add);
		if (ch[1] != null)
			ch[1]-&gt;applyAdd(add);
		add = 0;
	}
	if (isRev) {
		if (ch[0] != null)
			ch[0]-&gt;applyRev();
		if (ch[1] != null)
			ch[1]-&gt;applyRev();
		isRev = false;
	}
}

void Node::applyAdd(int add) {
	maxV += add;
	val += add;
	this-&gt;add += add;
}

void Node::applyRev() {
	isRev ^= true;
	swap(ch[0], ch[1]);
}

bool Node::dir() {
	return this == p-&gt;ch[1];
}

void Node::set(Node*c, bool d) {
	ch[d] = c;
	c-&gt;p = this;
}

void Node::update() {
	size = ch[0]-&gt;size + ch[1]-&gt;size + 1;
	maxV = max(ch[0]-&gt;maxV, max(ch[1]-&gt;maxV, val));
}

struct Splay {
	Node*root;
	Node*newNode() {
		Node*t = new Node;
		t-&gt;ch[0] = t-&gt;ch[1] = null;
		t-&gt;add = t-&gt;val = t-&gt;maxV = t-&gt;isRev = 0;
		return t;
	}
	Node*build(int l, int r) {
		if (l &gt;= r)
			return null;
		Node*m = newNode();
		int mid = l + r &gt;&gt; 1;
		m-&gt;set(build(l, mid), 0);
		m-&gt;set(build(mid + 1, r), 1);
		m-&gt;update();
		return m;
	}
	void init(int cap) {
		root = build(0, cap + 2);
		root-&gt;p=null;
	}
	void rotate(Node*t) {
		Node*p = t-&gt;p;
		bool d = t-&gt;dir();
		p-&gt;relax();
		t-&gt;relax();
		p-&gt;p-&gt;set(t, p-&gt;dir());
		p-&gt;set(t-&gt;ch[!d], d);
		t-&gt;set(p, !d);
		p-&gt;update();
		if (root == p)
			root = t;
	}
	void splay(Node*t, Node*f=null) {
		t-&gt;relax();
		while (t-&gt;p != f) {
			if (t-&gt;p-&gt;p == f)
				rotate(t);
			else
				t-&gt;p-&gt;dir() == t-&gt;dir() ? (rotate(t-&gt;p), rotate(t))
						: (rotate(t), rotate(t));
		}
		t-&gt;update();
	}
	Node*getKth(int kth) {
		for (Node*t = root;;) {
			t-&gt;relax();
			int cnt = t-&gt;ch[0]-&gt;size;
			if (kth == cnt)
				return t;
			t = t-&gt;ch[kth &gt; cnt];
			if (kth &gt; cnt)
				kth -= cnt + 1;
		}
	}
	Node*getSeq(int l,int r){
		Node*Left=getKth(l);
		splay(Left);
		Node*Right=getKth(r);
		splay(Right,Left);
		return Right-&gt;ch[0];
	}
	void addRange(int l,int r,int add){
		Node*t=getSeq(l-1,r+1);
		t-&gt;applyAdd(add);
		splay(t);
	}
	int askMax(int l,int r){
		Node*t=getSeq(l-1,r+1);
		return t-&gt;maxV;
	}
	void makeReverse(int l,int r){
		Node*t=getSeq(l-1,r+1);
		t-&gt;applyRev();
		splay(t);
	}
};

Splay* splay;

void solve(){
	initNull();
	int n,nOpts;
	splay = new Splay;
	scanf("%d%d",&amp;n,&amp;nOpts);
	splay-&gt;init(n);
	for (int step = 0; step &lt; nOpts; ++step) {
		int type,l,r;
		scanf("%d%d%d",&amp;type,&amp;l,&amp;r);
		switch (type) {
			case 1:{
				int add;scanf("%d",&amp;add);
				splay-&gt;addRange(l,r,add);
				break;
			}
			case 2:{
				splay-&gt;makeReverse(l,r);
				break;
			}
			case 3:{
				printf("%d\n",splay-&gt;askMax(l,r));
				break;
			}
			default:
				break;
		}
	}
}

int main() {
	solve();
}
<pre><h2>Problem1251</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int MAX_N=50000+10;
const int INF=~0U&gt;&gt;1;
struct Node{
	Node*ch[2],*p;
	int size,val,mx;
	int add;
	bool rev;
	Node(){
		size=0;val=mx=-INF;
		add=0;
	}
	bool d(){return this==p-&gt;ch[1];}
	void setc(Node*c,int d){ch[d]=c;c-&gt;p=this;}
	void addIt(int ad){
		add+=ad;
		mx+=ad;
		val+=ad;
	}
	void revIt(){
		rev^=1;
	}
	void relax();
	void upd(){
		size=ch[0]-&gt;size+ch[1]-&gt;size+1;
		mx=max(val,max(ch[0]-&gt;mx,ch[1]-&gt;mx));
	}
}Tnull,*null=&amp;Tnull;
Node mem[MAX_N],*C=mem;

void Node::relax(){
	if(add!=0){
		REP(i,2)if(ch[i]!=null)ch[i]-&gt;addIt(add);
		add=0;
	}
	if(rev){
		swap(ch[0],ch[1]);
		REP(i,2)if(ch[i]!=null)ch[i]-&gt;revIt();
		rev=0;
	}
}

Node*make(int v){
	C-&gt;ch[0]=C-&gt;ch[1]=null;
	C-&gt;size=1;C-&gt;val=v;C-&gt;mx=v;
	C-&gt;add=0;C-&gt;rev=0;
	return C++;
}

Node*build(int l,int r){
	if(l&gt;=r)	return null;
	int m=(l+r)&gt;&gt;1;
	Node*t=make(0);
	t-&gt;setc(build(l,m),0);
	t-&gt;setc(build(m+1,r),1);
	t-&gt;upd();
	return t;
}

Node*root;

Node*rot(Node*t){
	Node*p=t-&gt;p;
	p-&gt;relax();t-&gt;relax();
	int d=t-&gt;d();
	p-&gt;p-&gt;setc(t,p-&gt;d());
	p-&gt;setc(t-&gt;ch[!d],d);
	t-&gt;setc(p,!d);
	p-&gt;upd();
	if(p==root)
		root=t;
}

void splay(Node*t,Node*f=null){
	while(t-&gt;p!=f){
		if(t-&gt;p-&gt;p==f)rot(t);
		else t-&gt;d()==t-&gt;p-&gt;d()?(rot(t-&gt;p),rot(t)):(rot(t),rot(t));
	}
	t-&gt;upd();
}

Node* select(int k){
	for(Node*t=root;;){
		t-&gt;relax();
		int c=t-&gt;ch[0]-&gt;size;
		if(k==c) return t;
		if(k&gt;c)k-=c+1,t=t-&gt;ch[1];
		else t=t-&gt;ch[0];
	}
}

Node*&amp;get(int l,int r){//[l,r)
	Node*L=select(l-1);
	Node*R=select(r);
	splay(L);
	splay(R,L);
	return R-&gt;ch[0];
}

int n,m;

int main(){
	cin&gt;&gt;n&gt;&gt;m;
	root=build(0,n+2);root-&gt;p=null;
	REP(i,m){
		int k,l,r,v;
		scanf("%d%d%d",&amp;k,&amp;l,&amp;r);
		Node*&amp;t=get(l,r+1);
		if(k==1){
			scanf("%d",&amp;v);
			t-&gt;addIt(v);
			splay(t);
		} else if(k==2){
			t-&gt;revIt();
			splay(t);
		} else{
			printf("%d\n",t-&gt;mx);
		}
	}
}<pre><h2>Problem1257</h2><pre>#include &lt;iostream&gt;
using namespace std;
typedef long long ll;
int main()
{
    int n,k;cin&gt;&gt;n&gt;&gt;k;ll ans=0;
    for(int i=1;i&lt;=n;i++)
    {
        int a=k/i,l=k/(a+1)+1,r=a?k/a:n;
        if(r&gt;=n)r=n;
        ans+=ll(k)*(r-l+1)-ll(a)*(l+r)*(r-l+1)/2;
        i=r;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


<pre><h2>Problem1259</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;

int ans[7][8] = {
	{0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 1, 2, 3, 4, 5, 6},
	{0, 0, 6, 15, 28, 45, 66, 91},
	{0, 0, 0, 52, 143, 350, 799, 1744},
	{0, 0, 0, 0, 614, 2431, 9184, 33603},
	{0, 0, 0, 0, 0, 16000, 102147, 637330},
	{0, 0, 0, 0, 0, 0, 1114394, 11948355}
	};

int main() {

	int A, B;
	scanf("%d %d", &amp;A, &amp;B);

	if (A &gt; B) { int t = A; A = B; B = t; }
	printf("%d\n", ans[A][B]);

	return 0;
}<pre><h2>Problem1260</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxn=50;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int Mem[maxn][maxn][27],A[maxn],n;
char C[maxn+10];
int Dp(int l,int r,int ch)
{
    int&amp;x=Mem[l][r][ch];if(x!=-1)return x;
    x=inf;
    if(l&gt;r)return x=0;
    if(A[l]==ch)return x=Dp(l+1,r,ch);
    if(A[r]==ch)return x=Dp(l,r-1,ch);
    int t=A[l];
    for(int k=l;k&lt;=r;k++)
        x=min(x,Dp(l,k,t)+Dp(k+1,r,ch)+1);
    return x;
}
int main()
{
    //freopen("in","r",stdin);
    gets(C);n=strlen(C);
    rep(i,n)A[i]=C[i]-'A';
    memset(Mem,-1,sizeof Mem);
    cout&lt;&lt;Dp(0,n-1,26)&lt;&lt;endl;
}


<pre><h2>Problem1264</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=20000,maxs=maxn*5;
using namespace std;
int A[maxs],B[maxs],n,s;
int pB[maxn][5],sB[maxn]={};
int C[maxs+1]={};
void Update(int l,int d)
{
    for(l++;l&lt;=s;l+=l&amp;-l)
        C[l]=max(C[l],d);
}
int Max(int l)
{
    int ret=0;
    for(l++;l;l-=l&amp;-l)
        ret=max(ret,C[l]);
    return ret;
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);s=n*5;
    rep(i,n*5)scanf("%d",A+i),A[i]--;
    rep(i,n*5)scanf("%d",B+i),B[i]--,pB[B[i]][sB[B[i]]++]=i;
    rep(i,n*5)
    {
        for(int j=4;j&gt;=0;j--)
        {
            int tmp=Max(pB[A[i]][j]-1)+1;
            Update(pB[A[i]][j],tmp);
        }
    }
    printf("%d\n",Max(s-1));
}


<pre><h2>Problem1266</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
const int maxn=500;
struct Edge
{
    int t,c,Len;
    bool e;
    Edge(int _t,int _Len,int _c,Edge* _next):
        t(_t),Len(_Len),next(_next),c(_c),e(false){}
    Edge*next,*op;
    /*void addFlow(int _c)
    {
        c-=_c;
        op-&gt;c+=_c;
    }*/
}*E[maxn];
int n,m,vs,vt;
void InsEdge(int s,int t,int c,int Len)
{
    E[s]=new Edge(t,Len,c,E[s]);
    E[t]=new Edge(s,Len,c,E[t]);
    E[s]-&gt;op=E[t];E[t]-&gt;op=E[s];
}
void Init()
{
    scanf("%d %d",&amp;n,&amp;m);int s,t,Len,c;
    vs=0,vt=n-1;
    while(m--)
    {
        scanf("%d %d %d %d",&amp;s,&amp;t,&amp;Len,&amp;c);
        InsEdge(s-1,t-1,c,Len);
    }
}
const int inf=~0U&gt;&gt;2;
int DistToStart[maxn],DistToEnd[maxn];
void Spfa(int Dist[maxn],int vs)
{
    queue&lt;int&gt; Q;
    bool inQ[maxn]={0};
    for(int i=0;i&lt;n;i++) Dist[i]=inf;
    Dist[vs]=0;inQ[vs]=true;Q.push(vs);
    while(Q.size())
    {
        int t=Q.front();Q.pop();inQ[t]=false;int cost=Dist[t];
        for(Edge*i=E[t];i;i=i-&gt;next)
        {
            int ncost=cost+i-&gt;Len;
            if(ncost&lt;Dist[i-&gt;t])
            {
                Dist[i-&gt;t]=ncost;
                if(!inQ[i-&gt;t])
                    inQ[i-&gt;t]=true,Q.push(i-&gt;t);
            }
        }
    }
}
void BuildGraph()
{
    Spfa(DistToStart,vs);
    Spfa(DistToEnd,vt);
    int cost=DistToStart[vt];
    for(int i=0;i&lt;n;i++)
        for(Edge*e=E[i];e;e=e-&gt;next)
            if(DistToStart[i]+e-&gt;Len+DistToEnd[e-&gt;t]==cost)
            {
                e-&gt;e=true;
                e-&gt;op-&gt;e=true;
                e-&gt;op-&gt;c=0;
            }
    cout&lt;&lt;cost&lt;&lt;endl;
}
int h[maxn],vh[maxn],v;
int aug(int no,int m)
{
    if(no==vt) return m;
    int l=m;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;e&amp;&amp;i-&gt;c&amp;&amp;h[no]==h[i-&gt;t]+1)
    {
        int d=aug(i-&gt;t,min(l,i-&gt;c));
        i-&gt;c-=d,i-&gt;op-&gt;c+=d,l-=d;
        if(!l||h[vs]&gt;=v) return m-l;
    }
    int minh=v;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;e&amp;&amp;i-&gt;c)
        minh=min(minh,h[i-&gt;t]+1);
    if(!--vh[h[no]]) h[vs]=v;
    vh[h[no]=minh]++;
    return m-l;
}
long long CalFlow()
{
    memset(h,0,sizeof(h));
    memset(vh,0,sizeof(vh));
    v=n;vh[0]=v;long long flow=0;
    while(h[vs]&lt;v) flow+=aug(vs,inf);
    return flow;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    BuildGraph();
    cout&lt;&lt;CalFlow()&lt;&lt;endl;
}

<pre><h2>Problem1267</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
#define FORE(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_N=50000+10;
const int MAX_M=300000+10;
struct Node;
Node*get();
struct Node{
	int v;
	Node*l,*r;	
};
Node*get(int v,Node*l,Node*r){
	const int SIZE=10000;
	static Node*buf=new Node[SIZE],*C=buf;
	if(C==buf+SIZE)
		buf=new Node[SIZE],C=buf;
	C-&gt;v=v;C-&gt;l=l;C-&gt;r=r;
	return C++;
}
Node*merge(Node*a,Node*b){
	if(a==0||b==0)
		return a==0?b:a;
	if(a-&gt;v&lt;b-&gt;v)
		swap(a,b);
	Node*t=get(a-&gt;v,a-&gt;l,merge(a-&gt;r,b));
	if(rand()%2)
		swap(t-&gt;l,t-&gt;r);
	return t;
}
Node*merge2(Node*a,Node*b){
	if(a==0||b==0)
		return a==0?b:a;
	if(a-&gt;v&lt;b-&gt;v)
		swap(a,b);
	a-&gt;r=merge2(a-&gt;r,b);
	if(rand()%2)
		swap(a-&gt;l,a-&gt;r);
	return a;
}
struct Edge{
	int t,c;
	Edge(int t,int c){
		this-&gt;t=t;this-&gt;c=c;
	}
};
vector&lt;Edge&gt; E[MAX_N];
bool del[MAX_N];

int dist[MAX_N],size[MAX_N],opt[MAX_N];
int minOpt;
int seq[MAX_N],cnt;

void dfs(int u,int p){
	size[u]=1;opt[u]=0;
	seq[cnt++]=u;
	FORE(e,E[u])if(e-&gt;t!=p&amp;&amp;!del[e-&gt;t])
		dfs(e-&gt;t,u),size[u]+=size[e-&gt;t],opt[u]=max(opt[u],size[e-&gt;t]);
}

int wih[MAX_N];

void dfs2(int u,int p,int d){
	dist[u]=d;
	seq[cnt++]=u;
	FORE(e,E[u])if(e-&gt;t!=p&amp;&amp;!del[e-&gt;t])
		dfs2(e-&gt;t,u,d+e-&gt;c);
}

struct Vet{
	vector&lt;Node*&gt; nd;
	vector&lt;int&gt; myd;
	
	int mxdist,idx;
	
	void refresh(){
		mxdist=-1;
		REP(i,nd.size()){
			if(nd[i]!=0 &amp;&amp;nd[i]-&gt;v+myd[i] &gt; mxdist){
				mxdist=nd[i]-&gt;v+myd[i];
				idx=i;
			}
		}
	}
	
	void pop(){
		nd[idx]=merge(nd[idx]-&gt;l,nd[idx]-&gt;r);
		refresh();
	}
};

Vet vet[MAX_N];

void splitTree(int rt){
	cnt=0;
	dfs(rt,-1);
	int minOpt=~0U&gt;&gt;1;
	int by=-1;
	REP(i,cnt){
		int u=seq[i];
		opt[u]=max(opt[u],cnt-size[u]);
		if(opt[u]&lt;minOpt){
			minOpt=opt[u];
			by=u;
		}
	}
	
	rt=by;
	//split at rt
	int nCh=0;
	static int ch[MAX_N];
	del[rt]=true;
	static Node*heaps[MAX_N];
	
	cnt=0;
	
	FORE(e,E[rt]){
		if(!del[e-&gt;t]){
			int*cur=seq+cnt;
			int old=cnt;
			dfs2(e-&gt;t,-1,e-&gt;c);
			Node*hp=0;
			
			int myCnt=cnt-old;
			REP(i,myCnt){
				int u=cur[i];
				wih[u]=nCh;
				hp=merge2(hp,get(dist[u],0,0));
			}
			heaps[nCh++]=hp;
		}
	}
	
	heaps[nCh]=get(0,0,0);
	wih[rt]=nCh++;
	seq[cnt++]=rt;
	dist[rt]=0;
	
	static Node*hL[MAX_N],*hR[MAX_N],*myh[MAX_N];
	hL[0]=0;
	for(int i=1;i&lt;nCh;i++)
		hL[i]=merge(hL[i-1],heaps[i-1]);
	hR[nCh-1]=0;
	for(int i=nCh-2;i&gt;=0;--i)
		hR[i]=merge(hR[i+1],heaps[i+1]);
	
	REP(i,nCh){
		myh[i]=merge(hL[i],hR[i]);
	}
	
	REP(i,cnt){
		int u=seq[i];
		vet[u].nd.push_back(myh[wih[u]]);
		vet[u].myd.push_back(dist[u]);
	}
	
	FORE(e,E[rt])
		if(!del[e-&gt;t])
			splitTree(e-&gt;t);
}
struct Cmp{
	bool operator()(int a,int b) const{
		return vet[a].mxdist&lt;vet[b].mxdist;
	}
};

priority_queue&lt;int,vector&lt;int&gt;,Cmp&gt; pque;

int main(){
	int n,m;
	cin&gt;&gt;n&gt;&gt;m;
	REP(i,n-1){
		int a,b,c;
		scanf("%d%d%d",&amp;a,&amp;b,&amp;c);
		--a,--b;
		E[a].push_back(Edge(b,c));
		E[b].push_back(Edge(a,c));
	}
	splitTree(0);
	REP(i,n)vet[i].refresh(),pque.push(i);
	REP(i,m*2){
		int a=pque.top();pque.pop();
		if(i%2==0)printf("%d\n",vet[a].mxdist);
		vet[a].pop();
		pque.push(a);
	}
}
<pre><h2>Problem1269</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

const	int		INSERT	=	0;
const	int		DELETE	=	1;
const	int		ROTATE	=	2;

const	int		limit_op	=    6000 + 10;
const	int		limit_leng	= 2000000 + 10;

char			text	[limit_leng] , *text_p;

int			n;
int			pos	[limit_op];
int			type	[limit_op];
int			leng	[limit_op];
char*			start	[limit_op];

void	printValue( int p )
{
	for(int i = n - 1; i &gt;= 0; i --)
	{
		if( type[i] == INSERT )
		{
			if( pos[i] &lt;= p &amp;&amp; p &lt; pos[i] + leng[i] )
			{
				printf("%c\n" , *(start[i] + (p - pos[i])));
				return;
			}
			if( pos[i] &lt;= p ) p -= leng[i];
		}
		else if( type[i] == DELETE )
		{
			if( pos[i] &lt;= p ) p += leng[i];
		}
		else
		{
			if( pos[i] &lt;= p &amp;&amp; p &lt; pos[i] + leng[i] )
				p = pos[i] + (leng[i] - 1 - (p - pos[i]));
		}
	}

	putchar(0);
	putchar('\n');

	// &amp;#202;&amp;#253;&amp;#190;&amp;#221;&amp;#180;í&amp;#206;ó
}

int	main()
{
	//freopen("editor.in" , "r" , stdin);
	//freopen("editor.out" , "w" , stdout);

	char		command	[20];
	int		p = 0;
	int		k;
	int		i;
	char		ch;

	n = 0;
	text_p = text;

	while( scanf("%s" , command ) &gt; 0 )
	{
		switch ( command[0] )
		{
			case	'M' :		// Move
				scanf("%d" , &amp;k); p = k;
				break;

			case	'I' :		// Insert
				scanf("%d" , &amp;leng[n]);
				start[n] = text_p;
				type[n] = INSERT;
				pos[n] = p;

				for(i = 0; i &lt; leng[n]; i ++)
				{
					do ch = getchar(); while (ch == '\n');
					*text_p ++ = ch;
				}
				n ++;
				break;

			case	'D' :		// Delete
				scanf("%d" , &amp;leng[n]);
				type[n] = DELETE;
				pos[n] = p;
				n ++;
				break;

			case	'R' :		// Rotate
				scanf("%d" , &amp;leng[n]);
				type[n] = ROTATE;
				pos[n] = p;
				n ++;
				break;

			case	'G' :		// Get
				printValue( p );
				break;

			case	'P' :		// Prev
				p --; break;

			case	'N' :		// Next
				p ++; break;
		}
	}

	return 0;
}
<pre><h2>Problem1270</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
const int maxn=2000+10;
int n,h,d;
int N[maxn][maxn]={0};
void Init()
{
    scanf("%d %d %d",&amp;n,&amp;h,&amp;d);
    for(int i=0;i&lt;n;i++)
    {
        int s,x;scanf("%d",&amp;s);
        while(s--)scanf("%d",&amp;x),N[i][x]++;
    }
}
int Best[maxn]={0};
int Dp[maxn]={0};
void Work()
{
    for(int i=1;i&lt;=h;i++)
        for(int j=0;j&lt;n;j++)
        {
            if(i-d&gt;=0)Dp[j]&gt;?=Best[i-d];
            Dp[j]+=N[j][i];
            Best[i]&gt;?=Dp[j];
        }
    printf("%d\n",Best[h]);
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Work();
}
<pre><h2>Problem1283</h2><pre>/*
 * 序列.cpp
 *
 *  Created on: 2011-3-12
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 1000;
const int MAX_M = 100;

const int INF = ~0U &gt;&gt; 2;
struct Network {
	static const int MAX_N_VETS = MAX_N * 2 + 2;
	static const int MAX_N_EDGES = 1000000;
	int head[MAX_N_EDGES], dest[MAX_N_EDGES], next[MAX_N_EDGES],
			cap[MAX_N_EDGES], cost[MAX_N_EDGES];
	int nVets, nEdges;
	int vs, vt;

	void init(int _nVets, int _vs, int _vt) {
		nVets = _nVets;
		nEdges = 0;
		memset(head, -1, sizeof head);
		vs = _vs;
		vt = _vt;
	}

	void makeEdge(int s, int t, int f, int c) {
		int id = nEdges++;
		next[id] = head[s];
		dest[id] = t;
		cap[id] = f;
		cost[id] = c;
		head[s] = id;
	}

	void addEdge(int s, int t, int f, int c) {
		makeEdge(s, t, f, c);
		makeEdge(t, s, 0, -c);
	}

	int que[MAX_N_VETS], qh, qt;
	bool inQ[MAX_N_VETS];
	void inc(int&amp;iter) {
		if (++iter == MAX_N_VETS)
			iter = 0;
	}
	void add(int x) {
		if (inQ[x])
			return;
		inQ[x] = true;
		que[qt] = x;
		inc(qt);
	}

	int get() {
		int t = que[qh];
		inQ[t] = false;
		inc(qh);
		return t;
	}
	int prev[MAX_N_VETS];
	int dist[MAX_N_VETS];
	int minCost;
	int totalFlow;

	bool spfa() {
		fill(dist, dist + nVets, INF);
		dist[vs] = 0;
		add(vs);
		while (qh != qt) {
			int u = get();
			for (int e = head[u]; e != -1; e = next[e])
				if (cap[e] &gt; 0) {
					int v = dest[e];
					int ndist = dist[u] + cost[e];
					if (ndist &lt; dist[v]) {
						prev[v] = e;
						dist[v] = ndist;
						add(v);
					}
				}
		}

		if (dist[vt] == INF)
			return false;

		int minCap = INF;
		{
			int at = vt;
			while (at != vs) {
				minCap = min(minCap, cap[prev[at]]);
				at = dest[prev[at] ^ 1];
			}
		}
		{
			int at = vt;
			while (at != vs) {
				cap[prev[at]] -= minCap;
				cap[prev[at] ^ 1] += minCap;
				at = dest[prev[at] ^ 1];
			}
		}
		minCost += minCap * dist[vt];
		totalFlow += minCap;
		return true;
	}

	int calcMinCostFlow() {
		minCost = 0;
		qh = qt = 0;
		memset(inQ, false, sizeof inQ);
		while (spfa())
			;
		return minCost;
	}
};

Network network;

int n, m, k;
int main() {
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
	int nV = n;
	int vs = nV++, vt = nV++;
	network.init(nV, vs, vt);
	for (int i = 0; i &lt; n; ++i) {
		int c;
		scanf("%d", &amp;c);
		int next = i + 1 == n ? vt : i + 1;
		network.addEdge(i, next, INF, 0);
		int after = i + m;
		if (after &gt;= n)
			after = vt;
		network.addEdge(i, after, 1, -c);
	}
	network.addEdge(vs, 0, k, 0);
	int ans = -network.calcMinCostFlow();
	cout &lt;&lt; ans &lt;&lt; endl;
}
<pre><h2>Problem1293</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#include&lt;ctime&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define all(x) x.begin(),x.end()
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=1000000,maxk=60;
typedef vector&lt;int&gt; vi;
typedef vi::iterator it;
vi A,S[maxk];
int n,k;
void Init()
{
    cin&gt;&gt;n&gt;&gt;k;A.resize(n);it nowA=A.begin();
    rep(i,k)
    {
        int t,x;scanf("%d",&amp;t);S[i].resize(t+1);it nowS=S[i].begin();
        rep(j,t)scanf("%d",&amp;x),(*nowA++)=(*nowS++)=x;
        *nowS++=inf;
    }
}
struct cmp
{
    bool operator()(const it&amp;a,const it&amp;b)const
    {return *a&gt;*b;}
};
void Work()
{
    int s=clock();
    sort(all(A));
    int ans=inf,Max=0;
    priority_queue&lt;it,vector&lt;it&gt;,cmp&gt; Q;
    rep(i,k)Q.push(S[i].begin()),Max=max(Max,*S[i].begin());
    rep(i,n)
    {
        int t=A[i];
        while(*Q.top()&lt;t)
        {
            it j=Q.top();Q.pop();
            Max=max(Max,*++j);
            if(Max==inf)break;
            Q.push(j);
        }
        if(Max==inf)break;
        ans=min(ans,Max-t);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    int s=clock();
    Init();
    Work();
}
<pre><h2>Problem1295</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;deque&gt;
#include&lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define pf push_front
using namespace std;
typedef pair&lt;int,int&gt; ii;
const int inf=~0U&gt;&gt;1,maxn=30;
int n,m,T;
double ans=0;
bool Map[maxn][maxn];
const int di[]={1,0,-1,0},dj[]={0,1,0,-1};
void bfs(int x,int y)
{
    static bool vis[maxn][maxn];
    static int dist[maxn][maxn];
    memset(vis,0,sizeof(vis));
    deque&lt;ii&gt; Q;dist[x][y]=Map[x][y];
    vis[x][y]=true;Q.pb(ii(x,y));
    #define legal(i,j) (i&gt;=x&amp;&amp;i&lt;n&amp;&amp;j&gt;=0&amp;&amp;j&lt;m&amp;&amp;!vis[i][j])
    #define A first
    #define B second
    double tx,ty;
    while(Q.size())
    {
        ii t=Q.front();int cost=dist[t.A][t.B],xx,yy;Q.pop_front();
        if(cost&gt;T)break;
        tx=t.A-x;ty=t.B-y;
        ans=max(ans,tx*tx+ty*ty);
        rep(d,4)
        {
            xx=t.A+di[d];
            yy=t.B+dj[d];
            if(legal(xx,yy))
            {
                if(Map[xx][yy])
                    Q.pb(ii(xx,yy)),dist[xx][yy]=cost+1;
                else
                    Q.pf(ii(xx,yy)),dist[xx][yy]=cost;
                vis[xx][yy]=true;
            }
        }
    }
    #undef legal
    #undef A
    #undef B
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;T;char x;
    rep(i,n)rep(j,m)cin&gt;&gt;x,Map[i][j]=x=='1';
    rep(i,n)rep(j,m)bfs(i,j);
    ans=sqrt(ans);
    printf("%0.6lf",ans);
}
<pre><h2>Problem1297</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int maxt=9,maxv=90,maxn=10,mod=2009;
int n,v;
inline int node(int time,int pos)
{
    return time*n+pos;
}
int tmp[maxv][maxv];
struct Mat
{
    int M[maxv][maxv];
    int&amp;operator()(int i,int j){return M[i][j];}
    Mat(){memset(M,0,sizeof(M));}
    void operator*=(Mat&amp;o)
    {
        memset(tmp,0,sizeof(tmp));
        rep(i,v)rep(j,v)rep(k,v)
            tmp[i][j]+=M[i][k]*o(k,j),tmp[i][j]%=mod;
        memcpy(M,tmp,sizeof(M));
    }
    void operator=(const Mat&amp;o)
    {
        memcpy(M,o.M,sizeof(M));
    }
}orig;
int Map[maxn][maxn];
void Power(int n,Mat&amp;ret)
{
    if(n==1){ret=orig;return;}
    Power(n/2,ret);
    ret*=ret;
    if(n&amp;1)ret*=orig;
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("road.in","r",stdin);
    //freopen("road.out","w",stdout);
    int T;
    scanf("%d %d",&amp;n,&amp;T);char x;v=n*9;
    rep(i,n)
    {
        scanf("\n");
        rep(j,n)scanf("%c",&amp;x),Map[i][j]=x-'0';
    }
    rep(i,n)for(int t=0;t&lt;8;t++)
        orig(node(t,i),node(t+1,i))++;
    rep(i,n)rep(j,n)if(Map[j][i])
        orig(node(8,i),node(9-Map[j][i],j))++;
    Mat Ans;Power(T,Ans);
    int dp[maxn][maxt]={0};
    dp[0][0]=1;
    for(int t=1;t&lt;maxt;t++)
    {
        rep(i,n)rep(j,n)
            if(Map[j][i])
                if(t-Map[j][i]&gt;=0)
                {
                    dp[i][t]+=dp[j][t-Map[j][i]];
                    dp[i][t]%=mod;
                }
    }
    int ans=0;
    rep(i,n)rep(t,maxt)
    {
        ans+=Ans(node(0,n-1),node(t,i))*dp[i][t];
        ans%=mod;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
<pre><h2>Problem1299</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1,maxn=14;
using namespace std;
int A[maxn],n;
int xsum[1&lt;&lt;maxn],sg[1&lt;&lt;maxn],Log[1&lt;&lt;maxn],Count[1&lt;&lt;maxn];
bool Exist[1&lt;&lt;maxn];
void PreCondition()
{
    rep(i,maxn)
        Log[1&lt;&lt;i]=i;
    Count[0]=0;
    for(int i=1;i&lt;(1&lt;&lt;maxn);i++)
    {
        Count[i]=Count[i&gt;&gt;1]+(i&amp;1);
    }
}
void Solve()
{
    cin&gt;&gt;n;
    rep(i,n)cin&gt;&gt;A[i];
    xsum[0]=sg[0]=0;
    for(int now=1;now&lt;(1&lt;&lt;n);now++)
    {
        int last=now&amp;-now;
        xsum[now]=xsum[now-last]^A[Log[last]];
        int num=Count[now];
        memset(Exist,0,sizeof(bool)*((1&lt;&lt;num)+1));
        for(int move=now;move;move=(move-1)&amp;now)
        {
            int New=sg[now-move]^xsum[move];
            if(New&lt;(1&lt;&lt;num))Exist[New]=true;
        }
        int s=0;
        while(Exist[s])s++;
        sg[now]=s;
    }
    if(sg[(1&lt;&lt;n)-1])
        puts("NO");
    else
        puts("YES");
}
int main()
{
    //freopen("in","r",stdin);
    PreCondition();
    rep(t,10)Solve();
}


<pre><h2>Problem1300</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
typedef long long ll;
const int maxn=1000000+10;
bool notP[maxn]={};
int IndexP[maxn],Ps[maxn];
int N,M,numP=0;
const int maxs=100;
struct BigInt
{
    int A[maxs+100],l;
    void clear(){memset(A,0,sizeof A);l=0;}
    void set(int x){A[0]=x;}
    void reset()
    {
        if(l&gt;=maxs)
            memmove(A,A+l-maxs+1,sizeof(int)*maxs),l=maxs-1;
    }
    void operator*=(int x)
    {
        int d=0;
        for(int i=0;i&lt;=l;i++)
        {
            d+=A[i]*x;
            A[i]=d%10;d/=10;
        }
        while(d)A[++l]=d%10,d/=10;
    }
}A;
void getPrime()
{
    for(int x=2;x*x&lt;=N;)
    {
        for(int i=x*x;i&lt;=N;i+=x)
                notP[i]=true;
        x++;while(notP[x]&amp;&amp;x*x&lt;=N)x++;
    }
    for(int i=2;i&lt;=N;i++)
    {
        if(!notP[i])
           IndexP[i]=numP,Ps[numP++]=i;
    }
}
int E[maxn]={};
void Change(int x,int d)
{
    for(int i=0;i&lt;numP;i++)
    {
        int p=Ps[i],t=x;
        while(t)
            E[i]+=(t/p)*d,t/=p;
    }
}
const ll mod=1000000000;
int main()
{
	cin&gt;&gt;N&gt;&gt;M;
	getPrime();
	Change(N,1);
	Change(N-M,-1);
	Change(M,-1);
	A.clear();A.set(1);ll last=1;
	rep(i,numP)
	{
	    int p=Ps[i];
	    rep(j,E[i])
            A*=p,A.reset(),last*=p,last%=mod;
	}
	if(A.l&gt;=12)
	{
	    rep(i,3)cout&lt;&lt;A.A[A.l-i];
	    cout&lt;&lt;"...";
	    cout&lt;&lt;last&lt;&lt;endl;
	}
	else
	{
	    rep(i,A.l+1)cout&lt;&lt;A.A[A.l-i];
	    cout&lt;&lt;endl;
	}
}
<pre><h2>Problem1301</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=112345;
vector&lt;int&gt; E[maxn];
set&lt;int&gt; list;
using namespace std;
int n,m;
void dfs(int x)
{
    for(;;)
    {
        printf("%d\n",x);
        list.erase(list.find(x));
        vector&lt;int&gt;&amp;t=E[x];
        sort(t.begin(),t.end());
        t.pb(n+1);
        int p=0;
        tr(e,t)
        {
            int go=*list.lower_bound(p+1);
            if(go&lt;*e)
            {
                x=go;
                goto next;
            }
            p=*e;
        }
        return;
        next:{}
    }
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d",&amp;n,&amp;m);int a,b;
    for(int i=1;i&lt;=n+1;i++)list.insert(i);
    while(m--)
    {
        scanf("%d%d",&amp;a,&amp;b);
        E[a].pb(b);E[b].pb(a);
    }
    dfs(1);
}


<pre><h2>Problem1303</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1;
const int maxn=1e5+10;
int main()
{
    //freopen("in","r",stdin);
    int n,b;int A[maxn];
    int C[maxn*2]={0};
    cin&gt;&gt;n&gt;&gt;b;int x;
    rep(i,n) scanf("%d",A+i),x=(A[i]==b?i:x);
    int now=0;
    C[now+maxn]++;
    for(int i=x+1;i&lt;n;i++)
    {
        if(A[i]&gt;b) now++;
        else now--;
        C[now+maxn]++;
    }
    long long ans=0;
    now=0;ans+=C[now+maxn];
    for(int i=x-1;i&gt;=0;--i)
    {
        if(A[i]&gt;b) now++;
        else now--;
        ans+=C[maxn-now];
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
<pre><h2>Problem1305</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=300+20;
struct Edge
{
    int t,c;
    Edge(int _t,int _c,Edge* _next):
        t(_t),next(_next),c(_c){}
    Edge*next,*op;
}*E[maxn]={0};
int n,vs,vt;
int h[maxn],vh[maxn],v;
void InsEdge(int s,int t,int c)
{
    //cout&lt;&lt;s&lt;&lt;" "&lt;&lt;t&lt;&lt;" "&lt;&lt;c&lt;&lt;endl;
    E[s]=new Edge(t,c,E[s]);
    E[t]=new Edge(s,0,E[t]);
    E[s]-&gt;op=E[t];E[t]-&gt;op=E[s];
}
const int All=0,Like=1,DontLike=2,inf=1&lt;&lt;20;
inline int Boy(int x,int type){return x*3+type;}
inline int Girl(int x,int type){return (n+x)*3+type;}
void Init()
{
    int k;char x;
    scanf("%d %d\n",&amp;n,&amp;k);
    v=n*6+2;vs=v-1;vt=v-2;
    rep(i,n)rep(j,n)
    {
        scanf("%c\n",&amp;x);
        int t=x=='Y'?Like:DontLike;
        InsEdge(Boy(i,t),Girl(j,t),1);
    }
    rep(i,n)
    {
        InsEdge(vs,Boy(i,All),0);
        InsEdge(Boy(i,All),Boy(i,Like),inf);
        InsEdge(Boy(i,All),Boy(i,DontLike),k);
        InsEdge(Girl(i,All),vt,0);
        InsEdge(Girl(i,Like),Girl(i,All),inf);
        InsEdge(Girl(i,DontLike),Girl(i,All),k);
    }
}
int aug(int no,int m)
{
    if(no==vt) return m;
    int l=m;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;c&amp;&amp;h[no]==h[i-&gt;t]+1)
    {
        int d=aug(i-&gt;t,min(l,i-&gt;c));
        i-&gt;c-=d,i-&gt;op-&gt;c+=d,l-=d;
        if(!l||h[vs]&gt;=v) return m-l;
    }
    int minh=v;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;c)
        minh=min(minh,h[i-&gt;t]+1);
    if(!--vh[h[no]]) h[vs]=v;
    vh[h[no]=minh]++;
    return m-l;
}
int CalFlow()
{
    memset(h,0,sizeof(h));
    memset(vh,0,sizeof(vh));
    vh[0]=v;int flow=0;
    while(h[vs]&lt;v) flow+=aug(vs,inf);
    return flow;
}
void Work()
{
    int Flow=0;
    for(int i=1;;i++)
    {
        for(Edge*e=E[vs];e;e=e-&gt;next)e-&gt;c++;
        for(Edge*e=E[vt];e;e=e-&gt;next)e-&gt;op-&gt;c++;
        Flow+=CalFlow();
        if(Flow!=i*n)
        {
            cout&lt;&lt;i-1&lt;&lt;endl;
            break;
        }
    }
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Work();
}
<pre><h2>Problem1306</h2><pre>/*
 * [CQOI2009]match循环赛.cpp
 *
 *  Created on: 2011-3-11
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
//#define DEBUG
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_TEAMS = 8;
int score[MAX_N_TEAMS];
int nTeams;

void inputData() {
	scanf("%d", &amp;nTeams);
	for (int i = 0; i &lt; nTeams; ++i) {
		scanf("%d", score + i);
	}
}

int ansCnt = 0;

int bitCnt[1 &lt;&lt; MAX_N_TEAMS];

bool possible(int restMatch, int vals) {
	if (vals &lt; 0)
		return false;
	int cnt = vals / 3 + vals % 3;
	if (restMatch &lt; cnt)
		return false;
	return true;
}

bool possible2(int usedSet) {
	return true;
	int sum = 0;
	int cnt = 0;
	for (int who = 0; who &lt; nTeams; ++who) {
		if (~usedSet &gt;&gt; who &amp; 1) {
			sum += score[who];
			++cnt;
		}
	}
	if (sum &gt; (cnt * (cnt - 1) / 2) * 3)
		return false;
	return true;
}

typedef long long int64;
const int MAX_SCORE = MAX_N_TEAMS * 3 + 1;
int64 compress(int usedSet) {
	static int nScore[MAX_N_TEAMS];
	int64 ret = 0;
	int cnt = 0;
	for (int who = 0; who &lt; nTeams; ++who) {
		if (~usedSet &gt;&gt; who &amp; 1) {
			nScore[cnt++] = score[who];
		}
	}
	sort(nScore, nScore + cnt);
	ret = cnt;
	for (int who = 0; who &lt; nTeams; ++who) {
		ret = ret * MAX_SCORE + nScore[who];
	}
	return ret;
}

map&lt;int64, int&gt; memo;

int dfs(int usedSet) {
	if (usedSet == (1 &lt;&lt; nTeams) - 1) {
		return 1;
	}
	int64 code = compress(usedSet);
	if (memo.count(code))
		return memo[code];
	int&amp;ret = memo[code];
	ret = 0;
	int minScoreId = -1;
	for (int nextTeam = 0; nextTeam &lt; nTeams; ++nextTeam) {
		if (usedSet &gt;&gt; nextTeam &amp; 1)
			continue;
		if (minScoreId == -1 || score[nextTeam] &lt; score[minScoreId])
			minScoreId = nextTeam;
	}

	int otherSet = ((1 &lt;&lt; nTeams) - 1 - usedSet) ^ (1 &lt;&lt; minScoreId);
	int nOthers = bitCnt[otherSet];
	for (int drawSet = otherSet;; (--drawSet) &amp;= otherSet) {
		int drawCnt = bitCnt[drawSet];
		int rest = otherSet ^ drawSet;
		int nScore;
		int needWins;
		bool ok;
		if (score[minScoreId] &lt; drawCnt)
			goto endIterDrawSet;
		nScore = score[minScoreId] - drawCnt;
		if (nScore % 3 != 0)
			goto endIterDrawSet;
		needWins = nScore / 3;
		if (needWins &gt; nOthers)
			goto endIterDrawSet;
		ok = true;
		for (int who = 0; who &lt; nTeams; ++who) {
			if (drawSet &gt;&gt; who &amp; 1) {
				if (!possible(nOthers - 1, score[who] - 1)) {
					ok = false;
					break;
				}
			}
		}
		if (!ok)
			goto endIterDrawSet;
		for (int who = 0; who &lt; nTeams; ++who) {
			if (drawSet &gt;&gt; who &amp; 1) {
				score[who] -= 1;
			}
		}
		for (int winSet = rest;; --(winSet) &amp;= rest) {
			if (bitCnt[winSet] != needWins)
				goto endIterWinSet;
			ok = true;
			for (int who = 0; who &lt; nTeams; ++who) {
				if (rest &gt;&gt; who &amp; 1) {
					if (winSet &gt;&gt; who &amp; 1) {
						if (!possible(nOthers - 1, score[who]))
							ok = false;
						break;
					} else {
						if (!possible(nOthers - 1, score[who] - 3))
							ok = false;
						break;
					}
				}
			}
			if (ok) {
				for (int who = 0; who &lt; nTeams; ++who) {
					if (rest &gt;&gt; who &amp; 1) {
						if (winSet &gt;&gt; who &amp; 1)
							;
						else
							score[who] -= 3;
					}
				}
				int nUsedSet = usedSet ^ (1 &lt;&lt; minScoreId);
				if (possible2(nUsedSet)) {
					ret += dfs(nUsedSet);
				}
				for (int who = 0; who &lt; nTeams; ++who) {
					if (rest &gt;&gt; who &amp; 1) {
						if (winSet &gt;&gt; who &amp; 1)
							;
						else
							score[who] += 3;
					}
				}
			}

			endIterWinSet: {
			}
			if (!winSet)
				break;
		}

		for (int who = 0; who &lt; nTeams; ++who) {
			if (drawSet &gt;&gt; who &amp; 1) {
				score[who] += 1;
			}
		}

		endIterDrawSet: {
		}
		if (!drawSet)
			break;
	}

	return ret;
}

void prepareBitCnt() {
	memset(bitCnt, 0, sizeof bitCnt);
	for (int mask = 1; mask &lt; (1 &lt;&lt; nTeams); ++mask) {
		bitCnt[mask] = bitCnt[mask &gt;&gt; 1] + (mask &amp; 1);
	}
}

void work() {
	ansCnt = 0;
	prepareBitCnt();
	cout &lt;&lt; dfs(0) &lt;&lt; endl;
}

void runLargest() {
	nTeams = 8;
	for (int i = 0; i &lt; nTeams; ++i) {
		score[i] = 10;
	}
	work();
}

void solve() {
	inputData();
	work();
}

int main() {
#ifndef DEBUG
	solve();
#endif
#ifdef DEBUG
	runLargest();
#endif
}
<pre><h2>Problem1307</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
typedef long long ll;
const int maxn=1123456;
int n,A[maxn];
int next_ap[maxn],next[maxn];
int R[maxn];
void Init()
{
    scanf("%d",&amp;n);
    rep(i,n)scanf("%d",A+i+1);
}
void PreCondition()
{
    rep(i,maxn)next_ap[i]=n+1;
    for(int i=n;i&gt;=1;i--)
    {
        next[i]=next_ap[A[i]];
        next_ap[A[i]]=i;
    }
    R[n]=n;
    for(int l=n-1;l&gt;=1;l--)
    {
        R[l]=min(R[l+1],next[l]-1);
    }
}
int Doit()
{
    PreCondition();
    static ll Sum[maxn];
    int ret=0;
    Sum[0]=0;
    for(int i=1;i&lt;=n;i++)
        Sum[i]=Sum[i-1]+A[i];
    int p=0;
    for(int i=1;i&lt;=n;i++)
        if(A[i]==1)
        {
            int Max=0;
            for(int l=i;l&gt;p;l--)
            {
                Max=max(Max,A[l]);
                if(R[l]-l+1&lt;Max)break;
                if(Sum[l+Max-1]-Sum[l-1]==ll(Max)*(Max+1)/2)
                    ret=max(ret,Max);
            }
            p=i;
        }
    return ret;
}
void Solve()
{
    int ans=Doit();
    reverse(A+1,A+1+n);
    ans=max(ans,Doit());
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}
<pre><h2>Problem1318</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
typedef long long ll;
const int maxn=112345;
int n,A[maxn];
int next_ap[maxn],next[maxn];
int R[maxn];
void Init()
{
    scanf("%d",&amp;n);
    rep(i,n)scanf("%d",A+i+1);
}
void PreCondition()
{
    rep(i,maxn)next_ap[i]=n+1;
    for(int i=n;i&gt;=1;i--)
    {
        next[i]=next_ap[A[i]];
        next_ap[A[i]]=i;
    }
    R[n]=n;
    for(int l=n-1;l&gt;=1;l--)
    {
        R[l]=min(R[l+1],next[l]-1);
    }
}
int Doit()
{
    PreCondition();
    static ll Sum[maxn];
    int ret=0;
    Sum[0]=0;
    for(int i=1;i&lt;=n;i++)
        Sum[i]=Sum[i-1]+A[i];
    int p=0;
    for(int i=1;i&lt;=n;i++)
        if(A[i]==1)
        {
            int Max=0;
            for(int l=i;l&gt;p;l--)
            {
                Max=max(Max,A[l]);
                if(R[l]-l+1&lt;Max)continue;
                if(Sum[l+Max-1]-Sum[l-1]==ll(Max)*(Max+1)/2)
                    ret=max(ret,Max);
            }
            p=i;
        }
    return ret;
}
void Solve()
{
    int ans=Doit();
    reverse(A+1,A+1+n);
    ans=max(ans,Doit());
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}
<pre><h2>Problem1319</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define tr(e,x) for(vector&lt;ll&gt;::iterator e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1,maxn=20;
using namespace std;
typedef long long ll;
ll P[maxn],m=0,p,g,k,a;
void decompose(ll x)
{
    for(ll i=2;i*i&lt;=x;i++)
        if(x%i==0)
        {
            P[m++]=i;
            while(x%i==0)x/=i;
        }
    if(x&gt;1)P[m++]=x;
}
ll ext_gcd(ll a,ll b,ll&amp;x,ll&amp;y)
{
    if(!b){x=1;y=0;return a;}
    ll tmp=ext_gcd(b,a%b,y,x);y-=x*(a/b);
    return tmp;
}
ll pow(ll x,ll e)
{
    if(!e)return 1;
    ll tmp=pow(x,e/2);tmp*=tmp;tmp%=p;
    if(e&amp;1)tmp*=x,tmp%=p;
    return tmp;
}
ll inv(ll x)
{
    return pow(x,p-2);
}
bool IsRoot(ll a)
{
    rep(i,m)
        if(pow(a,(p-1)/P[i])==1)return false;
    return true;
}
void FindRoot()
{
    decompose(p-1);
    for(ll i=2;i&lt;p;i++)if(IsRoot(i)){g=i;break;}
}
ll discrete_Log(ll a)
{
    map&lt;ll,ll&gt; Map;ll M=sqrt(p)+1;
    ll v=inv(pow(g,M));
    ll e=1;Map[1]=0;
    for(ll i=1;i&lt;M;i++){e=e*g%p;if(!Map.count(e))Map[e]=i;}
    for(ll i=0;i&lt;M;i++)
    {
        if(Map.count(a))return i*M+Map[a];
        a=a*v%p;
    }
    return -1;
}
vector&lt;ll&gt; Solve(ll a,ll b,ll m)
{
    ll x,y,d;
    d=ext_gcd(a,m,x,y);
    vector&lt;ll&gt; A;
    if(b%d)return A;
    ll t=b/d;x%=m;if(x&lt;0)x+=m;x=x*t%m;
    rep(i,d)
    {
        A.pb(x);
        x+=m/d;x%=m;
    }
    return A;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;p&gt;&gt;k&gt;&gt;a;
    if(a==0){cout&lt;&lt;1&lt;&lt;endl&lt;&lt;0&lt;&lt;endl;return 0;}
    FindRoot();
    ll Loga=discrete_Log(a);
    vector&lt;ll&gt; Logx=Solve(k,Loga,p-1);
    cout&lt;&lt;Logx.size()&lt;&lt;endl;
    vector&lt;ll&gt; Ans;
    tr(it,Logx)
    {
        ll tmp=pow(g,*it);
        Ans.pb(tmp);
    }
    sort(Ans.begin(),Ans.end());
    tr(it,Ans)cout&lt;&lt;*it&lt;&lt;endl;
}
<pre><h2>Problem1334</h2><pre>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=300,maxp=100000+10;
int A[maxn],n,L=0;
bool Dp[maxp]={};
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;rep(i,n)cin&gt;&gt;A[i],L+=A[i];sort(A,A+n);reverse(A,A+n);
    Dp[0]=true;L/=2;int Ans=0;
    rep(i,n)
    {
        for(int j=L;j&gt;=0;j--)
        {
            if(Dp[j]&amp;&amp;j+A[i]&gt;L)Ans&gt;?=j+A[i];
            if(j-A[i]&gt;=0)Dp[j]|=Dp[j-A[i]];
        }
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
}
<pre><h2>Problem1334</h2><pre>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
int A[300],n,L=0,Ans=0;
bool Dp[100010]={};
int main()
{
    cin&gt;&gt;n;rep(i,n)cin&gt;&gt;A[i],L+=A[i];sort(A,A+n);reverse(A,A+n);Dp[0]=true;L/=2;
    rep(i,n)for(int j=L;j&gt;=0;j--){if(Dp[j]&amp;&amp;j+A[i]&gt;L)Ans&gt;?=j+A[i];if(j-A[i]&gt;=0)Dp[j]|=Dp[j-A[i]];}
    cout&lt;&lt;Ans&lt;&lt;endl;
}
<pre><h2>Problem1338</h2><pre>/*
 * Pku1981 Circle and Points单位圆覆盖.cpp
 *
 *  Created on: 2011-3-10
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
		x(_x), y(_y) {
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	Point operator*(double d) const {
		return Point(x * d, y * d);
	}
	Point operator/(double d) const {
		return Point(x / d, y / d);
	}
	double det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	double dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	Point rot90() const {
		return Point(-y, x);
	}
	void read() {
		scanf("%lf%lf", &amp;x, &amp;y);
	}
	void write() const {
		printf("%lf %lf", x, y);
	}
	double dist(const Point&amp;p) const {
		return hypot(x - p.x, y - p.y);
	}
};

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))

const double EPS = 1e-8;
inline int sign(double a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}

#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))

Point isSS(Point p1, Point p2, Point q1, Point q2) {
	double a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);
	return (p1 * a2 + p2 * a1) / (a1 + a2);
}

const int MAX_N_CIRCLES = 300 + 10;
Point cs[MAX_N_CIRCLES];
int nCs;
const double R = 1;

typedef pair&lt;double, int&gt; Event;
Event events[MAX_N_CIRCLES * 10];
int nEvents;

void addCover(double l, double r) {
	events[nEvents++] = make_pair(l, 1);
	events[nEvents++] = make_pair(r, -1);
}

const double PI = acos(-1.0);

void normalize(double&amp;alpha) {
	while (alpha &gt;= 2 * PI)
		alpha -= 2 * PI;
	while (alpha &lt; 0)
		alpha += 2 * PI;
}

int ans;

void process(int amId) {
	Point c1 = cs[amId];
	nEvents = 0;

	for (int otherId = 0; otherId &lt; nCs; ++otherId) {
		if (otherId == amId)
			continue;
		Point c2 = cs[otherId];
		double d = c1.dist(c2);
		if (d &gt; R + R)
			continue;
		double alpha = acos(d / (2 * R));
		double am = atan2(c2.y - c1.y, c2.x - c1.x);
		double left = am - alpha, right = am + alpha;
		normalize(left);
		normalize(right);
		if (left &lt; right) {
			addCover(left, right);
		} else {
			addCover(left, 2 * PI);
			addCover(0, right);
		}
	}

	int cnt = 0;
	sort(events, events + nEvents);
	int maxCnt = 0;
	for (int i = 0; i &lt; nEvents; ++i) {
		if (i &gt; 0) {
			double len = events[i].first - events[i - 1].first;
			if (len &gt;= 1e-7)
				maxCnt = max(maxCnt, cnt);
		}
		cnt += events[i].second;
	}

	ans = max(ans, maxCnt);
}

bool inputData() {
	cin &gt;&gt; nCs;
	if (nCs == 0)
		return false;
	for (int i = 0; i &lt; nCs; ++i) {
		cs[i].read();
	}
	return true;
}

void work() {
	ans = 0;
	for (int am = 0; am &lt; nCs; ++am) {
		process(am);
	}
	cout &lt;&lt; ans + 1 &lt;&lt; endl;
}

int main() {
	while (inputData())
		work();
}
<pre><h2>Problem1349</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
typedef unsigned long long ull;
using namespace std;
int main()
{
    ull a,i,l;cin&gt;&gt;a;
    if(!a){cout&lt;&lt;0&lt;&lt;endl;return 0;}
    for(i=0,l=1LL&lt;&lt;31;l;l&gt;&gt;=1)
        if((i+l)*(i+l)&lt;a)i+=l;
    cout&lt;&lt;i+1&lt;&lt;endl;
}


<pre><h2>Problem1355</h2><pre>/*
 *  [Baltic2009]Radio Transmission.cpp
 *
 *  Created on: 2011-5-25
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_L = 1000000 + 10;
char str[MAX_L];
int next[MAX_L];

int n;

int main() {
	cin &gt;&gt; n;
	scanf("%s", str + 1);
	next[1] = 0;
	for (int i = 2; i &lt;= n; ++i) {
		int at = next[i - 1];
		while (at != 0 &amp;&amp; str[at + 1] != str[i])
			at = next[at];
		if (str[at + 1] == str[i])
			++at;
		next[i] = at;
	}

	int ans = n - next[n];
	cout &lt;&lt; ans &lt;&lt; endl;
}
<pre><h2>Problem1362</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=100000;
int A[maxn],ans=0,a,b,n;
inline int abs(int x){return x&gt;0?x:-x;}
int main()
{
    scanf("%d",&amp;n);rep(i,n)scanf("%d%d",&amp;a,&amp;b),ans-=abs(a-b),A[i]=a+b;
    sort(A,A+n);rep(i,n/2)ans+=A[i]-A[n/2+i];
    printf("%d\n",ans/2);
}
<pre><h2>Problem1369</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#define pb push_back
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define RFor(i,l,r) for(int i=l;i&gt;=r;i--)
#define tr(i,x) for(it i=x.begin();i!=x.end();i++)
using namespace std;
const int maxn=10000,maxc=12,c=10,inf=~0U&gt;&gt;2;
int A[2]={},n,ans,L[maxn][maxc],R[maxn][maxc];
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator it;
void AddEdge(int s,int t)
{
    E[s].pb(t);E[t].pb(s);
}
void Dfs(int x,int f)
{
    int A[maxc];
    tr(e,E[x])if(*e!=f)Dfs(*e,x);
    rep(i,maxc)A[i]=L[x][i]=R[x][i]=inf;
    For(i,1,c)
    {
        int ret=i;
        tr(e,E[x])if(*e!=f)
        {
            ret+=min(L[*e][i],R[*e][i]);
        }
        A[i]=ret;
    }
    For(i,2,c)L[x][i]=min(L[x][i-1],A[i-1]);
    RFor(i,c-1,1)R[x][i]=min(R[x][i+1],A[i+1]);
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);int s,t;
    rep(i,n-1)scanf("%d%d",&amp;s,&amp;t),AddEdge(s-1,t-1);
    Dfs(0,-1);printf("%d\n",min(R[0][1],L[0][c]));
}

<pre><h2>Problem1369</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#define pb push_back
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define RFor(i,l,r) for(int i=l;i&gt;=r;i--)
#define tr(i,x) for(it i=x.begin();i!=x.end();i++)
using namespace std;
const int maxn=10000,maxc=9,c=7,inf=~0U&gt;&gt;2;
int A[2]={},n,ans,L[maxn][maxc],R[maxn][maxc];
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator it;
void AddEdge(int s,int t)
{
    E[s].pb(t);E[t].pb(s);
}
void Dfs(int x,int f)
{
    int A[maxc];
    tr(e,E[x])if(*e!=f)Dfs(*e,x);
    rep(i,maxc)A[i]=L[x][i]=R[x][i]=inf;
    For(i,1,c)
    {
        int ret=i;
        tr(e,E[x])if(*e!=f)
        {
            ret+=min(L[*e][i],R[*e][i]);
        }
        A[i]=ret;
    }
    For(i,2,c)L[x][i]=min(L[x][i-1],A[i-1]);
    RFor(i,c-1,1)R[x][i]=min(R[x][i+1],A[i+1]);
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);int s,t;
    rep(i,n-1)scanf("%d%d",&amp;s,&amp;t),AddEdge(s-1,t-1);
    Dfs(0,-1);printf("%d\n",min(R[0][1],L[0][c]));
}

<pre><h2>Problem1369</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#define pb push_back
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define RFor(i,l,r) for(int i=l;i&gt;=r;i--)
#define tr(i,x) for(it i=x.begin();i!=x.end();i++)
using namespace std;
const int maxn=10000,maxc=7,c=5,inf=~0U&gt;&gt;2;
int A[2]={},n,ans,L[maxn][maxc],R[maxn][maxc];
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator it;
void AddEdge(int s,int t)
{
    E[s].pb(t);E[t].pb(s);
}
void Dfs(int x,int f)
{
    int A[maxc];
    tr(e,E[x])if(*e!=f)Dfs(*e,x);
    rep(i,maxc)A[i]=L[x][i]=R[x][i]=inf;
    For(i,1,c)
    {
        int ret=i;
        tr(e,E[x])if(*e!=f)
        {
            ret+=min(L[*e][i],R[*e][i]);
        }
        A[i]=ret;
    }
    For(i,2,c)L[x][i]=min(L[x][i-1],A[i-1]);
    RFor(i,c-1,1)R[x][i]=min(R[x][i+1],A[i+1]);
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);int s,t;
    rep(i,n-1)scanf("%d%d",&amp;s,&amp;t),AddEdge(s-1,t-1);
    Dfs(0,-1);printf("%d\n",min(R[0][1],L[0][c]));
}

<pre><h2>Problem1369</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#define pb push_back
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define RFor(i,l,r) for(int i=l;i&gt;=r;i--)
#define tr(i,x) for(it i=x.begin();i!=x.end();i++)
using namespace std;
const int maxn=10000,maxc=6,c=4,inf=~0U&gt;&gt;2;
int A[2]={},n,ans,L[maxn][maxc],R[maxn][maxc];
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator it;
void AddEdge(int s,int t)
{
    E[s].pb(t);E[t].pb(s);
}
void Dfs(int x,int f)
{
    int A[maxc];
    tr(e,E[x])if(*e!=f)Dfs(*e,x);
    rep(i,maxc)A[i]=L[x][i]=R[x][i]=inf;
    For(i,1,c)
    {
        int ret=i;
        tr(e,E[x])if(*e!=f)
        {
            ret+=min(L[*e][i],R[*e][i]);
        }
        A[i]=ret;
    }
    For(i,2,c)L[x][i]=min(L[x][i-1],A[i-1]);
    RFor(i,c-1,1)R[x][i]=min(R[x][i+1],A[i+1]);
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);int s,t;
    rep(i,n-1)scanf("%d%d",&amp;s,&amp;t),AddEdge(s-1,t-1);
    Dfs(0,-1);printf("%d\n",min(R[0][1],L[0][c]));
}

<pre><h2>Problem1369</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#define pb push_back
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define RFor(i,l,r) for(int i=l;i&gt;=r;i--)
#define tr(i,x) for(it i=x.begin();i!=x.end();i++)
using namespace std;
const int maxn=10000,maxc=5,c=3,inf=~0U&gt;&gt;2;
int A[2]={},n,ans,L[maxn][maxc],R[maxn][maxc];
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator it;
void AddEdge(int s,int t)
{
    E[s].pb(t);E[t].pb(s);
}
void Dfs(int x,int f)
{
    int A[maxc];
    tr(e,E[x])if(*e!=f)Dfs(*e,x);
    rep(i,maxc)A[i]=L[x][i]=R[x][i]=inf;
    For(i,1,c)
    {
        int ret=i;
        tr(e,E[x])if(*e!=f)
        {
            ret+=min(L[*e][i],R[*e][i]);
        }
        A[i]=ret;
    }
    For(i,2,c)L[x][i]=min(L[x][i-1],A[i-1]);
    RFor(i,c-1,1)R[x][i]=min(R[x][i+1],A[i+1]);
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);int s,t;
    rep(i,n-1)scanf("%d%d",&amp;s,&amp;t),AddEdge(s-1,t-1);
    Dfs(0,-1);printf("%d\n",min(R[0][1],L[0][c]));
}

<pre><h2>Problem1372</h2><pre>/*
 *  [Baltic203]Lamps.cpp
 *
 *  Created on: 2011-5-23
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

int N, M;
const int MAX_N = 1000000 + 10;
int a[MAX_N], na[MAX_N];

int main() {
	cin &gt;&gt; N &gt;&gt; M;
	for (int i = 0; i &lt; N; ++i) {
		scanf("%d", a + i);
	}

	int pow = 1;
	for (int i = 0; i &lt; 31; ++i) {
		if (M &gt;&gt; i &amp; 1) {
			for (int j = 0; j &lt; N; ++j) {
				na[j] = a[j] ^ a[(j + pow) % N];
			}
			memcpy(a, na, sizeof(int) * N);
		}
		pow = (pow * 2) % N;
	}

	for (int i = 0; i &lt; N; ++i) {
		printf("%d\n", a[i]);
	}
}
<pre><h2>Problem1379</h2><pre>#include &lt;iostream&gt;
using namespace std;
int n,m,ans;
int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    cout&lt;&lt;m&lt;&lt;endl;
}


<pre><h2>Problem1381</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=200,maxv=maxn*maxn+10;
struct Edge
{
    int t,c;
    Edge*next,*op;
    Edge(int _t,int _c,Edge*_next):t(_t),c(_c),next(_next){}
}*E[maxv]={0};
void AddEdge(int s,int t,int c)
{
    E[s]=new Edge(t,c,E[s]);
    E[t]=new Edge(s,0,E[t]);
    E[s]-&gt;op=E[t];E[t]-&gt;op=E[s];
}
int h[maxv],vh[maxv],vs,vt,v;
int aug(int no,int m)
{
    if(no==vt) return m;
    int l=m;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;c&amp;&amp;h[no]==h[i-&gt;t]+1)
    {
        int d=aug(i-&gt;t,min(i-&gt;c,l));
        l-=d,i-&gt;c-=d,i-&gt;op-&gt;c+=d;
        if(l==0||h[vs]&gt;=v)return m-l;
    }
    int minh=v;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;c&amp;&amp;h[i-&gt;t]+1&lt;minh)
        minh=h[i-&gt;t]+1;
    if(--vh[h[no]]==0) h[vs]=v;vh[h[no]=minh]++;
    return m-l;
}
int CalFlow()
{
    memset(h,0,sizeof(h));
    memset(vh,0,sizeof(vh));
    vh[0]=v;
    int flow=0;while(h[vs]&lt;v)flow+=aug(vs,inf);
    return flow;
}
bool Removed[maxn][maxn]={};
int n,m;
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d",&amp;n,&amp;m);int x,y;
    while(m--)
    {
        scanf("%d%d",&amp;x,&amp;y);
        --x;--y;
        Removed[x][y]=true;
    }
    v=n*n;vs=v++;vt=v++;
    int ret=0;
    rep(i,n)rep(j,n)
    {
        if(Removed[i][j])continue;
        ret++;
        if((i+j)&amp;1)
        {
            AddEdge(vs,i*n+j,1);
            for(int x=-2;x&lt;=2;x++)
                for(int y=-2;y&lt;=2;y++)
                    if(abs(x)+abs(y)==3)
                    {
                        int nx=i+x,ny=j+y;
                        if(nx&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;n)
                            AddEdge(i*n+j,nx*n+ny,1);
                    }
        }
        else
        {
            AddEdge(i*n+j,vt,1);
        }
    }
    ret-=CalFlow();
    cout&lt;&lt;ret&lt;&lt;endl;
}
<pre><h2>Problem1382</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=10000;
int n;
int Y[maxn*2];
struct Event
{
    int x,l,r,d;
    Event(){}
    Event(int _x,int _l,int _r,int _d):x(_x),l(_l),r(_r),d(_d){}
    bool operator&lt;(const Event&amp;o)const
    {
        return x&lt;o.x;
    }
}E[maxn*2];
void Init()
{
    scanf("%d",&amp;n);
    int x[2],y[2],cnt=0;
    rep(i,n)
    {
        rep(j,2)scanf("%d %d",x+j,y+j),Y[cnt++]=y[j];
        E[2*i]=Event(x[0],y[0],y[1],1);
        E[2*i+1]=Event(x[1],y[0],y[1],-1);
    }
}
int Cover[8*maxn]={0},Sum[8*maxn]={0};
void change(int t,int l,int r,int a,int b,int d)
{
    if(a&gt;=r||b&lt;=l) return;
    if(a&lt;=l&amp;&amp;b&gt;=r)Cover[t]+=d;
    else change(t*2,l,(l+r)/2,a,b,d),change(t*2+1,(l+r)/2,r,a,b,d);
    if(Cover[t]&gt;0)
        Sum[t]=Y[r]-Y[l];
    else
        Sum[t]=(l+1==r)?0:(Sum[t*2]+Sum[t*2+1]);
}
void Work()
{
    n&lt;&lt;=1;
    sort(Y,Y+n);
    rep(i,n)
    {
        E[i].l=lower_bound(Y,Y+n,E[i].l)-Y;
        E[i].r=lower_bound(Y,Y+n,E[i].r)-Y;
    }
    sort(E,E+n);int last=E[0].x;long long Ans=0;
    rep(i,n)
    {
        Event now=E[i];
        if(now.x!=last)
        {
            Ans+=(long long)(Sum[1])*(now.x-last);
            last=now.x;
        }
        change(1,0,n-1,now.l,now.r,now.d);
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Work();
}
<pre><h2>Problem1390</h2><pre>/*
 * [Ceoi2008]Fence.cpp
 *
 *  Created on: 2011-6-11
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int BUILDCOST = 20, BADCOST = 111;

struct Point {
	int x, y;
	Point() {
	}
	Point(int _x, int _y) :
		x(_x), y(_y) {
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	int det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	int dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	void read() {
		scanf("%d%d", &amp;x, &amp;y);
	}
	void write() const {
		printf("%d %d", x, y);
	}
	bool operator&lt;(const Point&amp;p) const {
		return x == p.x ? y &lt; p.y : x &lt; p.x;
	}
};

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))

inline int sign(int x) {
	return x &lt; 0 ? -1 : x &gt; 0;
}

#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))

bool crsSS(Point p1, Point p2, Point q1, Point q2) {
	return crossOp(p1,p2,q1) * crossOp(p1,p2,q2) &lt; 0 &amp;&amp; crossOp(q1,q2,p1)
			*crossOp(q1,q2,p2) &lt; 0;
}

const int MAX_N_POINTS = 100 + 10;
const int MAX_N_TREES = 100 + 10;

Point points[MAX_N_POINTS], trees[MAX_N_TREES];
int nPoints, nTrees;

void readInput() {
	cin &gt;&gt; nPoints &gt;&gt; nTrees;
	for (int i = 0; i &lt; nPoints; ++i) {
		points[i].read();
	}
	for (int i = 0; i &lt; nTrees; ++i) {
		trees[i].read();
	}
}

void convexHull(Point ps[], int n, Point qs[], int&amp;k) {
	sort(ps, ps + n);
	k = 0;
	for (int i = 0; i &lt; n; ++i) {
		while (k &gt; 1 &amp;&amp; crossOp(qs[k-2],qs[k-1],ps[i]) &gt;= 0)
			--k;
		qs[k++] = ps[i];
	}
	for (int i = n - 2, t = k; i &gt;= 0; --i) {
		while (k &gt; t &amp;&amp; crossOp(qs[k-2],qs[k-1],ps[i]) &gt;= 0)
			--k;
		qs[k++] = ps[i];
	}
	--k;
}

Point con[MAX_N_POINTS];
bool in[MAX_N_TREES];

bool conPP(Point ps[], int n, Point p) {
	static Point far(22231, 31241);
	int isCnt = 0;
	for (int i = 0; i &lt; n; ++i) {
		isCnt += crsSS(ps[i], ps[(i + 1) % n], p, far);
	}
	return isCnt % 2 == 1;
}

int dist[MAX_N_POINTS][MAX_N_POINTS];

const int INF = INT_MAX / 4;

void work() {
	int cnt;
	convexHull(points, nPoints, con, cnt);

	int inCnt = 0;
	for (int i = 0; i &lt; nTrees; ++i) {
		in[i] = conPP(con, cnt, trees[i]);
		if (in[i])
			inCnt++;
	}

	if (inCnt == 0) {
		printf("%d\n", BADCOST * nTrees);
		return;
	}
	for (int i = 0; i &lt; nPoints; ++i) {
		for (int j = 0; j &lt; nPoints; ++j) {
			if (i == j) {
				dist[i][j] = 0;
			} else {
				bool check = true;
				for (int k = 0; k &lt; nTrees; ++k) {
					if (in[k] &amp;&amp; crossOp(points[i],points[j],trees[k]) &lt;= 0) {
						check = false;
					}
				}
				dist[i][j] = check ? 1 : INF;
			}
		}
	}

	int minCyc = INF;

	for (int k = 0; k &lt; nPoints; ++k) {
		for (int i = 0; i &lt; nPoints; ++i) {
			for (int j = 0; j &lt; nPoints; ++j) {
				dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
			}
		}
	}

	for (int i = 0; i &lt; nPoints; ++i) {
		for (int j = 0; j &lt; nPoints; ++j) {
			if (i != j)
				minCyc = min(minCyc, dist[i][j] + dist[j][i]);
		}
	}

	int ret = minCyc * BUILDCOST + (nTrees - inCnt) * BADCOST;
	printf("%d\n", ret);
}

int main() {
	readInput();
	work();
}
<pre><h2>Problem1391</h2><pre>/*
 * [Ceoi2008]order.cpp
 *
 *  Created on: 2011-4-4
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int INF = ~0U &gt;&gt; 1;
struct Network {
	static const int MAX_N_VETS = 3000;
	static const int MAX_N_EDGES = 3000000;

	int head[MAX_N_VETS];
	int dest[MAX_N_EDGES], cap[MAX_N_EDGES], next[MAX_N_EDGES];

	int nVets, nEdges;
	int vs, vt;

	void init(int _nVets, int _vs, int _vt) {
		nVets = _nVets;
		vs = _vs;
		vt = _vt;
		memset(head, -1, sizeof head);
		nEdges = 0;
	}

	void makeEdge(int s, int t, int c) {
		int id = nEdges++;
		next[id] = head[s];
		dest[id] = t;
		cap[id] = c;
		head[s] = id;
	}

	void addEdge(int s, int t, int c) {
		makeEdge(s, t, c);
		makeEdge(t, s, 0);
	}

	int am[MAX_N_VETS], prev[MAX_N_VETS], h[MAX_N_VETS], cnt[MAX_N_VETS],
			cur[MAX_N_VETS];
	int totalFlow;

	int calcMaxFlow() {
		memset(am, 0, sizeof am);
		memset(cur, -1, sizeof cur);
		memset(h, 0, sizeof h);
		memset(cnt, 0, sizeof cnt);
		cnt[0] = nVets;
		int u = vs, now;
		totalFlow = 0;
		am[u] = INF;
		while (h[vs] &lt; nVets) {
			for (now = cur[u]; now != -1; now = next[now])
				if (cap[now] &gt; 0 &amp;&amp; h[u] == h[dest[now]] + 1)
					break;
			if (now != -1) {
				int v = dest[now];
				cur[u] = prev[v] = now;
				am[v] = min(am[u], cap[now]);
				u = v;
				if (u == vt) {
					int by = am[u];
					while (u != vs) {
						cap[prev[u]] -= by;
						cap[prev[u] ^ 1] += by;
						u = dest[prev[u] ^ 1];
					}
					totalFlow += by;
					am[u] = INF;
				}
			} else {
				if (!--cnt[h[u]])
					break;
				h[u] = nVets;
				for (now = head[u]; now != -1; now = next[now])
					if (cap[now] &gt; 0 &amp;&amp; h[dest[now]] + 1 &lt; h[u]) {
						h[u] = h[dest[now]] + 1;
						cur[u] = now;
					}
				++cnt[h[u]];
				if (u != vs)
					u = dest[prev[u] ^ 1];
			}
		}

		return totalFlow;
	}
};

Network network;

int nOrders, nMachines;

int main() {
	scanf("%d%d", &amp;nOrders, &amp;nMachines);
	int nV = nOrders + nMachines;
	int vs = nV++, vt = nV++;
	network.init(nV, vs, vt);

	int ans = 0;

	for (int me = 0; me &lt; nOrders; ++me) {
		int nNeed, inCome;
		scanf("%d%d", &amp;inCome, &amp;nNeed);
		ans += inCome;
		network.addEdge(vs, me, inCome);
		for (int j = 0; j &lt; nNeed; ++j) {
			int what, rent;
			scanf("%d%d", &amp;what, &amp;rent);
			--what;
			network.addEdge(me, nOrders + what, rent);
		}
	}

	for (int me = 0; me &lt; nMachines; ++me) {
		int cost;
		scanf("%d", &amp;cost);
		network.addEdge(me + nOrders, vt, cost);
	}

	ans -= network.calcMaxFlow();
	printf("%d\n", ans);
}
<pre><h2>Problem1396</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

//suffix array

const int MAX_N=500000+10;
int rank[MAX_N],sa[MAX_N],tmp[MAX_N],m;

void dosort(int x[],int y[],int n){
	static int cnt[MAX_N];
	memset(cnt,0,sizeof(int)*(m));
	REP(i,n)cnt[x[i]]++;
	REP(i,m-1)cnt[i+1]+=cnt[i];
	for(int i=n-1;i&gt;=0;--i)sa[--cnt[x[y[i]]]]=y[i];
}

char str[MAX_N];

bool cmp(int a,int b,int k){
	return rank[a]==rank[b]&amp;&amp;rank[a+k]==rank[b+k];
}

void DA(int n){
	m=300;
	REP(i,n)rank[i]=str[i],tmp[i]=i;
	dosort(rank,tmp,n);
	for(int k=1;k&lt;=n;k&lt;&lt;=1){
		//k-&gt;2k
		int c=0;
		for(int i=n-k;i&lt;n;i++)tmp[c++]=i;
		for(int i=0;i&lt;n;i++)if(sa[i]&gt;=k)tmp[c++]=sa[i]-k;
		dosort(rank,tmp,n);
		m=0;
		REP(i,n)if(!i||!cmp(sa[i],sa[i-1],k))tmp[sa[i]]=m++;else tmp[sa[i]]=m-1;
		REP(i,n)rank[i]=tmp[i];
		if(m==n)	 break;
	}
}

int n;
const int SEED=10007;
int h[MAX_N],pw[MAX_N];
int get(int l,int r){return h[r]-h[l]*pw[r-l];}//SEED
int lcp(int a,int b){
	int l=0,r=min(n-a,n-b)+1;
	while(l+1&lt;r){
		int m=l+r&gt;&gt;1;
		if(get(a,a+m)==get(b,b+m)) l=m; else r=m;
	}
	return l;
}

int mxsame[MAX_N];
const int INF=~0U&gt;&gt;2;

int f[MAX_N];
int fd(int x){return f[x]==x?x:f[x]=fd(f[x]);}

struct Updater{
	int a[MAX_N];
	
	struct Update{
		Update*nxt;
		int l,r;
	};
	
	Update mem[MAX_N],*cur,*first[MAX_N];
	
	void init(int n){
		REP(i,n)a[i]=INF;
		REP(i,n+1)first[i]=0;
		cur=mem;
	}
	
	void add(int l,int r,int v){
		cur-&gt;l=l,cur-&gt;r=r,cur-&gt;nxt=first[v];
		first[v]=cur++;	
	}
	
	void doit(){
		REP(i,n+1)f[i]=i;
		REP(i,n+1){
			for(Update*u=first[i];u;u=u-&gt;nxt)
				for(int x=fd(u-&gt;l);x&lt;=u-&gt;r;x=fd(x))
					a[x]=i,f[x]=x+1;
		}
	}
}UA,UB;

int main(){
	scanf("%s",str);
	n=strlen(str);
	str[n]=0;
	DA(n+1);
	pw[0]=1;REP(i,n)pw[i+1]=pw[i]*SEED,h[i+1]=h[i]*SEED+str[i];
	
	REP(i,n){
		int a=sa[i],b=sa[i+1];
		if(a==n||b==n) continue;
		int com=lcp(a,b);
		mxsame[a]=max(mxsame[a],com);
		mxsame[b]=max(mxsame[b],com);
	}
	
	UA.init(n),UB.init(n);
	
	//REP(i,n)cout&lt;&lt;mxsame[i]&lt;&lt;" ";cout&lt;&lt;endl;
	
	REP(i,n){
		int same=mxsame[i];
		int r=i+same;
		//update [i,r] for r-i+1
		//update (r,n) for i
		if(r&lt;n){
			UA.add(i,r,r-i+1);
			if(r+1&lt;=n-1)
				UB.add(r+1,n-1,n-i);
		}
	}
	
	UA.doit();UB.doit();
	
	REP(i,n)
		printf("%d\n",min(UA.a[i],UB.a[i]+i-n+1));
		
	return 0;
}<pre><h2>Problem1398</h2><pre>/*
 * 1398.cpp
 *
 *  Created on: 2011-8-3
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_LEN = 1000000 + 10;
char a[MAX_LEN], b[MAX_LEN];
int L;

void doit(char a[]) {
	int i = 0, j = 1, k = 0;
	while (i &lt; L &amp;&amp; j &lt; L &amp;&amp; k &lt; L) {
		char p = a[(i + k) % L], q = a[(j + k) % L];
		if (p == q)
			++k;
		else if (p &gt; q) {
			i += k + 1;
			k = 0;
		} else {
			j += k + 1;
			k = 0;
		}
		if (i == j)
			++j;
	}
	rotate(a, a + min(i, j), a + L);
}

int main() {
	scanf("%s%s", a, b);
	L = strlen(a);
	doit(a), doit(b);
	if (strcmp(a, b) == 0) {
		puts("Yes");
		puts(a);
	} else {
		puts("No");
	}
	return 0;
}
<pre><h2>Problem1402</h2><pre>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=30,maxc=8;
using namespace std;
map&lt;string,int&gt; Map;
vector&lt;int&gt; Mark[maxn];
int n,m,Ans=inf;
int E[maxn][maxn];
struct State
{
    int at,mask;
    State(){}
    State(int _at,int _mask):
        at(_at),mask(_mask){}
    void mark(int go)
    {
        rep(i,Mark[go].size())
            mask|=1&lt;&lt;(Mark[go][i]);
    }
    bool full()
    {
        return mask+1==(1&lt;&lt;8);
    }
    bool movefree()
    {
        rep(i,4)
        {
            int t=(mask&gt;&gt;(i*2))&amp;3;
            if(t!=0&amp;&amp;t!=3)return false;
        }
        return true;
    }
    int hash()const{return (at&lt;&lt;8)+mask;}
};
queue&lt;State&gt; Q;
int TDist[maxn&lt;&lt;8];
bool TinQ[maxn&lt;&lt;8];
int&amp;Dist(const State&amp;st){return TDist[st.hash()];}
bool&amp;inQ(const State&amp;st){return TinQ[st.hash()];}
void spfa()
{
    memset(TDist,-1,sizeof TDist);
    memset(TinQ,0,sizeof TinQ);
    rep(at,n)
    {
        State now(at,0);
        now.mark(at);
        Dist(now)=0;inQ(now)=true;
        Q.push(now);
    }
    while(Q.size())
    {
        State now=Q.front();Q.pop();
        int c=Dist(now);inQ(now)=false;
        if(now.full())
        {
            if(c&lt;Ans)Ans=c;
            continue;
        }
        bool free=now.movefree();
        State next;int w;
        //let's go
        rep(go,n)
            if((w=E[now.at][go])!=inf)
            {
                if(free)w=0;
                int nc=c+w;
                next.at=go;next.mask=now.mask;
                next.mark(go);
                if(Dist(next)==-1||Dist(next)&gt;nc)
                {
                    Dist(next)=nc;
                    if(!inQ(next))
                        Q.push(next),inQ(next)=true;
                }
            }
        //or we merge somthing
        rep(j,(1&lt;&lt;8))
        {
            State tmp(now.at,j);
            int tmpc=Dist(tmp);
            if(tmpc!=-1)
            {
                State next(now.at,j|(now.mask));
                int nc=tmpc+c;
                if(Dist(next)==-1||Dist(next)&gt;nc)
                {
                    Dist(next)=nc;
                    if(!inQ(next))
                        Q.push(next),inQ(next)=true;
                }
            }
        }
    }
}
void init()
{
    cin&gt;&gt;n&gt;&gt;m;string a,b;int c;
    rep(i,n)rep(j,n)E[i][j]=inf;
    rep(i,n)cin&gt;&gt;a,Map[a]=i;
    rep(i,m)
    {
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        int s=Map[a],t=Map[b];
        E[s][t]=E[t][s]=min(E[s][t],c);
    }
    memset(Mark,-1,sizeof Mark);
    rep(i,8)
    {
        cin&gt;&gt;a;Mark[Map[a]].push_back(i);
    }
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    init();
    spfa();
    cout&lt;&lt;Ans&lt;&lt;endl;
}


<pre><h2>Problem1403</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1;
using namespace std;
int main()
{
    //freopen("in","r",stdin);
    int b,n,A,B,C;
    rep(i,100)
    {
        cin&gt;&gt;b&gt;&gt;n;A=B=C=-1;
        int now=b%n;
        #define Update(x,c) if(x==-1)x=c
        rep(k,1000)
        {
            if(now==0)Update(A,k+1);
            if(now==1)Update(B,k+1);
            if(now==n-1)Update(C,k+1);
            now*=b;now%=n;
        }
        if(A&gt;=0)printf("Rightmost %d\n",A);
        if(B&gt;=0)printf("Add all %d\n",B);
        if(C&gt;=0)printf("Alternate %d change sign\n",C);
        if(A==-1&amp;&amp;B==-1&amp;&amp;C==-1)puts("condition not found.");
        puts("");
    }
}


<pre><h2>Problem1406</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int main()
{
    //freopen("in","r",stdin);
    ll n;cin&gt;&gt;n;set&lt;int&gt; S;
    for(int a=1;a*a&lt;=n;a++)
        if(n%a==0)
        {
            int b=n/a;
            for(int x=1;x&lt;n;x+=b)
                if((x+1)%a==0)
                    S.insert(x);
            for(int x=b-1;x&lt;n;x+=b)
                if((x-1)%a==0)
                    S.insert(x);
        }
    for(set&lt;int&gt;::iterator i=S.begin();i!=S.end();i++)
        cout&lt;&lt;*i&lt;&lt;endl;
}



<pre><h2>Problem1408</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=1000+10,mod=10000;
using namespace std;
int power(int x,int e)
{
    if(!e)return 1;
    int tmp=power(x,e/2);tmp*=tmp;
    tmp%=mod;
    if(e&amp;1)tmp*=x,tmp%=mod;
    return tmp;
}
int f[maxn],g[maxn];//f:odd g:even
int main()
{
    //freopen("in","r",stdin);
    int k,p,e,all=1,t=0;scanf("%d",&amp;k);
    f[0]=0;g[0]=1;
    rep(i,k)
    {
        scanf("%d%d",&amp;p,&amp;e);
        all*=power(p,e);all%=mod;
        if(p&gt;2)
        {
            ++t;
            for(int i=t;i&gt;=1;i--)
            {
                f[i]+=g[i-1]*(p-1);f[i]%=mod;
                g[i]+=f[i-1]*(p-1);g[i]%=mod;
            }
        }
    }
    int T1=0,T2=0,T3;
    rep(i,t)T1+=g[i+1],T2+=f[i+1],T1%=mod,T2%=mod;
    T3=(all-1)-T1-T2;T3=(T3%mod+mod)%mod;
    cout&lt;&lt;T1&lt;&lt;endl;
    cout&lt;&lt;T2&lt;&lt;endl;
    cout&lt;&lt;T3&lt;&lt;endl;
}


<pre><h2>Problem1410</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x
using namespace std;
typedef long long int64;
const int INF=~0U&gt;&gt;2;

void setIO(){
	string name="mine";
	string inFile=name+".in";
	string outFile=name+".out";
	freopen(inFile.c_str(),"r",stdin);
	freopen(outFile.c_str(),"w",stdout);
}

const int MAX_R=20,MAX_C=20;
const int MAX_MINES=10;
char map[MAX_R][MAX_C];
int H,W;

void inputData(){
	scanf("%d%d",&amp;H,&amp;W);
	rep(r,H){
		scanf(" ");
		scanf("%s",map+r);
	}
}

int rs[MAX_MINES],cs[MAX_MINES];
int dist[MAX_MINES][MAX_MINES];
int dp[1&lt;&lt;MAX_MINES][MAX_MINES];//mask,last
int buildCost[1&lt;&lt;MAX_MINES];
int connectCost[1&lt;&lt;MAX_MINES];
int estimate[1&lt;&lt;MAX_MINES];

int nMines;

inline int Abs(int x){
	return x&gt;0?x:-x;
}

inline void checkmin(int&amp;x,int c){
	if(c&lt;x)x=c;
}

void doDp(){
	rep(mask,(1&lt;&lt;nMines))if(mask){
		rep(last,nMines)if(mask&gt;&gt;last&amp;1){
			if(dp[mask][last]&lt;INF)
				continue;
			rep(prev,nMines)if(prev!=last&amp;&amp;(mask&gt;&gt;prev&amp;1)){
				int nmask=mask^(1&lt;&lt;last);
				int nCost=dp[nmask][prev]+dist[prev][last];
				checkmin(dp[mask][last],nCost);
			}
		}
	}
}

void preCondition(){
	nMines=0;
	rep(r,H)rep(c,W)
		if(map[r][c]=='*'){
			rs[nMines]=r;cs[nMines]=c;
			nMines++;
		}
		
	rep(i,nMines)rep(j,nMines){
		dist[i][j]=Abs(rs[i]-rs[j])+Abs(cs[i]-cs[j]);
	}
	
	rep(mask,(1&lt;&lt;nMines))
		rep(last,nMines){
			dp[mask][last]=INF;
		}
		
	rep(last,nMines){
		int minDist=INF;
		rep(r,H)rep(c,W)
			if(map[r][c]=='#')
				checkmin(minDist,Abs(r-rs[last])+Abs(c-cs[last]));
		dp[1&lt;&lt;last][last]=minDist;
	}
	doDp();
	
	buildCost[0]=0;
	rep(mask,(1&lt;&lt;nMines))if(mask){
		buildCost[mask]=INF;
		rep(last,nMines){
			checkmin(buildCost[mask],dp[mask][last]);
		}
	}
	
	rep(mask,(1&lt;&lt;nMines))
		rep(last,nMines){
			dp[mask][last]=INF;
		}
	
	rep(last,nMines){
		dp[1&lt;&lt;last][last]=0;
	}
	
	doDp();
	connectCost[0]=0;
	rep(mask,(1&lt;&lt;nMines))if(mask){
		connectCost[mask]=INF;
		rep(last,nMines){
			checkmin(connectCost[mask],dp[mask][last]);
		}
	}
	
	estimate[0]=0;
	rep(mask,(1&lt;&lt;nMines))if(mask){
		estimate[mask]=INF;
		for(int set=mask;set&gt;0;set=(set-1)&amp;mask)
			checkmin(estimate[mask],estimate[mask^set]+buildCost[set]);
	}
}

const int dr[]={1,-1,0,0},dc[]={0,0,1,-1};
const int MAX_START=200;
int startR[MAX_START],startC[MAX_START];
int nStart;
bool visited[MAX_R][MAX_C];
int ans;
int idx[MAX_R][MAX_C];

int doEstimate(int cr,int cc,int mask,int cost){
	int minCost=INF;
	for(int set=mask;;set=(set-1)&amp;mask){
		int curCost=connectCost[set];
		
		int minDist=INF;
		rep(i,nMines)
			if(set&gt;&gt;i&amp;1)
				checkmin(minDist,Abs(cr-rs[i])+Abs(cc-cs[i]));
		if(minDist==INF)
			minDist=0;
		curCost+=minDist;
		curCost+=estimate[mask^set];
		checkmin(minCost,curCost);
		if(!set)break;
	}
	
	return minCost+cost;
}

void dfs(int cs,int cr,int cc,int mask,int cost){
	if(doEstimate(cr,cc,mask,cost)&gt;=ans){
		return;
	}
	
	if(!mask){
		ans=cost;
		return;	
	}
	
	if(cr==-1){
		for(int nCs=cs+1;nCs&lt;nStart;nCs++){
			int nr=startR[nCs],nc=startC[nCs];
			int nmask=mask;
			if(!visited[nr][nc]){
				if(idx[nr][nc]!=-1){
					nmask^=(1&lt;&lt;idx[nr][nc]);
				}
				visited[nr][nc]=true;
				dfs(nCs,nr,nc,nmask,cost+1);
				visited[nr][nc]=false;
			}
		}
	} else {
		if(idx[cr][cc]!=-1){
			dfs(cs,-1,-1,mask,cost);
		}
		
		rep(d,4){
			int nr=cr+dr[d],nc=cc+dc[d];
			if(nr&lt;0||nr&gt;=H||nc&lt;0||nc&gt;=W)continue;
			if(!visited[nr][nc]){
				int nmask=mask;
				if(idx[nr][nc]!=-1){
					nmask^=(1&lt;&lt;idx[nr][nc]);
				}
				visited[nr][nc]=true;
				dfs(cs,nr,nc,nmask,cost+1);
				visited[nr][nc]=false;
			}
		}
	}
}
void search(){
	nStart=0;
	rep(r,H)rep(c,W)if(map[r][c]!='#'){
		bool onEdge=false;
		for(int nr=r-1;nr&lt;=r+1;nr++)
			for(int nc=c-1;nc&lt;=c+1;nc++)
				if(nr==r^nc==c){
					if(nr&gt;=0&amp;&amp;nr&lt;H&amp;&amp;nc&gt;=0&amp;&amp;nc&lt;W){
						if(map[nr][nc]=='#'){
							onEdge=true;
						}
					}
				}
		if(onEdge){
			startR[nStart]=r;
			startC[nStart]=c;
			nStart++;
		}
	}
	
	memset(idx,-1,sizeof idx);
	rep(i,nMines){
		idx[rs[i]][cs[i]]=i;
	}
	memset(visited,false,sizeof visited);
	ans=20;
	dfs(-1,-1,-1,(1&lt;&lt;nMines)-1,0);
	cout&lt;&lt;ans&lt;&lt;endl;
}

void solve(){
	inputData();
	preCondition();
	search();
}

int main(){
	solve();
}
<pre><h2>Problem1411</h2><pre>/*
 *  [ZJOI2009]硬币游戏.cpp
 *
 *  Created on: 2011-5-23
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 100000 + 10;
int a[MAX_N], na[MAX_N], n;
typedef long long int64;
int64 T;

int ans[MAX_N * 2];

int main() {
	cin &gt;&gt; n &gt;&gt; T;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", a + i);
		--a[i];
	}
	int64 S = T / 2;
	int pow = 1;
	for (int i = 0; i &lt; 63; ++i) {
		if (S &gt;&gt; i &amp; 1) {
			for (int j = 0; j &lt; n; ++j) {
				na[j] = a[(j - pow + n) % n] ^ a[(j + pow) % n];
			}
			memcpy(a, na, sizeof(int) * n);
		}
		pow = (pow * 2) % n;
	}

	for (int i = 0; i &lt; n; ++i) {
		ans[i * 2] = a[i];
		ans[i * 2 + 1] = -1;
	}

	if (T % 2 == 1) {
		for (int i = 1; i &lt; n * 2; i += 2)
			ans[i] = ans[i - 1] ^ ans[(i + 1) % (2 * n)];
		for (int i = 0; i &lt; n * 2; i += 2)
			ans[i] = -1;
	}

	for (int i = 0; i &lt; n * 2; ++i) {
		printf("%d ", ans[i] + 1);
	}
	printf("\n");
}
<pre><h2>Problem1412</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
typedef pair&lt;int,int&gt; ii;
const int inf=~0U&gt;&gt;1,maxn=100,maxv=maxn*maxn+2;
int n,m;
struct Edge
{
    int t,c;
    Edge*next,*op;
    Edge(int _t,int _c,Edge*_next):t(_t),c(_c),next(_next){}
}*E[maxv]={0};
int h[maxv],vh[maxv],vs,vt,v;
inline int node(int i,int j){return i*m+j;}
void InsEdge(int s,int t,int c)
{
    E[s]=new Edge(t,c,E[s]);
    E[t]=new Edge(s,c,E[t]);
    E[s]-&gt;op=E[t];E[t]-&gt;op=E[s];
}
int aug(int no,int m)
{
    if(no==vt) return m;
    int l=m;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;c&amp;&amp;h[no]==h[i-&gt;t]+1)
    {
        int d=aug(i-&gt;t,min(i-&gt;c,l));
        l-=d,i-&gt;c-=d,i-&gt;op-&gt;c+=d;
        if(l==0||h[vs]&gt;=v)return m-l;
    }
    int minh=v;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;c&amp;&amp;h[i-&gt;t]+1&lt;minh)
        minh=h[i-&gt;t]+1;
    if(--vh[h[no]]==0) h[vs]=v;vh[h[no]=minh]++;
    return m-l;
}
int CalFlow()
{
    memset(h,0,sizeof(h));
    memset(vh,0,sizeof(vh));
    vh[0]=v;
    int flow=0;while(h[vs]&lt;v)flow+=aug(vs,inf);
    return flow;
}
int main()
{
   //freopen("in","r",stdin);
   cin&gt;&gt;n&gt;&gt;m;v=n*m+2;vs=v-1;vt=vs-1;int x;
   rep(i,n)rep(j,m){
      cin&gt;&gt;x;if(x==1)InsEdge(vs,node(i,j),inf);
      if(x==2)InsEdge(node(i,j),vt,inf);
      if(i+1&lt;n) InsEdge(node(i,j),node(i+1,j),1);
      if(j+1&lt;m) InsEdge(node(i,j),node(i,j+1),1);
    }
   cout&lt;&lt;CalFlow()&lt;&lt;endl;
}

<pre><h2>Problem1413</h2><pre>/*
 * [ZJOI2009]取石子游戏.cpp
 *
 *  Created on: 2011-2-16
 *      Author: user
 */

#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;

int smartDoit(int L,int R,int aj){
	if(L&lt;=R){
		if(aj==0)return L;
		if(aj&lt;L)return aj;
		if(aj&gt;=L&amp;&amp;aj&lt;R)return aj+1;
		if(aj==R)return 0;
		if(aj&gt;R)return aj;
	} else {//L&gt;R
		if(aj==0)return L;
		if(aj&lt;R)return aj;
		if(aj==R)return 0;
		if(aj&gt;R&amp;&amp;aj&lt;=L)return aj-1;
		if(aj&gt;L)return aj;
	}
}

const int MAX_N=1000;
int fl[MAX_N][MAX_N],fr[MAX_N][MAX_N];
int n;
int a[MAX_N];
void work(){
	scanf("%d",&amp;n);
	rep(i,n)scanf("%d",a+i);
	for(int l=0;l&lt;n;l++){
		fl[l][l]=a[l];
		fr[l][l]=a[l];
	}
	for(int l=n-1;l&gt;=0;l--)
		for(int r=l+1;r&lt;n;r++){
			fl[l][r]=smartDoit(fl[l][r-1],fr[l][r-1],a[r]);
			fr[l][r]=smartDoit(fr[l+1][r],fl[l+1][r],a[l]);
		}
	if(n==1)
		puts("1");
	else if(fl[1][n-1]==a[0])
		puts("0");
	else
		puts("1");
}
int main(){
	int nT;scanf("%d",&amp;nT);
	while(nT--)
		work();
}
<pre><h2>Problem1414</h2><pre>/*
 * [ZJOI2009]对称的正方形.cpp
 *
 *  Created on: 2011-3-17
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
//using namespace std;
using std::cin;
using std::cout;
using std::endl;
const int MAX_N_ROWS = 2000 + 10, MAX_N_COLS = 2000 + 10;
int map[MAX_N_ROWS][MAX_N_COLS] = { };
int nRows, nCols;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

void inputData() {
	cin &gt;&gt; nRows &gt;&gt; nCols;
	memset(map, -1, sizeof map);
	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			int x;
			scanInt(x);
			map[r * 2][c * 2] = x;
		}
	}
	nRows = nRows * 2 - 1;
	nCols = nCols * 2 - 1;
}

int extendRow[MAX_N_ROWS][MAX_N_COLS];
int extendCol[MAX_N_ROWS][MAX_N_COLS];
//const int SEED = 13331;
//int pow[MAX_N_ROWS];
//void preparePow() {
//	pow[0] = 1;
//	for (int i = 1; i &lt; MAX_N_ROWS; ++i) {
//		pow[i] = pow[i - 1] * SEED;
//	}
//}
//
//struct Hash {
//
//	int hash[MAX_N_ROWS];
//	int n;
//	void init(int a[], int _n) {
//		n = _n;
//		hash[0] = 0;
//		for (int i = 1; i &lt;= n; ++i) {
//			hash[i] = hash[i - 1] * SEED + a[i - 1];
//		}
//	}
//	int ask(int l, int r) {//[l,r]
//		return hash[r + 1] - hash[l] * pow[r - l + 1];
//	}
//};
//
//Hash orig, rev;
//
inline int revPos(int where, int n) {
	return n - 1 - where;
}
//
//int maxPalin(int where, int n) {
//	int l = 0, r = std::min(where, revPos(where, n)) + 1;
//	while (l + 1 &lt; r) {
//		int m = l + r &gt;&gt; 1;
//		int a1 = orig.ask(where - m, where);
//		int a2 = rev.ask(revPos(where + m, n), revPos(where, n));
//		if (a1 == a2)
//			l = m;
//		else
//			r = m;
//	}
//	return l;
//}

void calcExtend(int pat[], int ret[], int n) {
	int maxR = -1, what;
	for (int i = 0; i &lt; n; ++i) {
		int it = 0;
		if (i &lt;= maxR) {
			it = ret[what * 2 - i];
			if (i + it &gt;= maxR)
				it = maxR - i;
		}

		while (i - it &gt;= 0 &amp;&amp; i + it &lt; n &amp;&amp; pat[i - it] == pat[i + it])
			++it;
		--it;
		ret[i] = it;

		if (i + ret[i] &gt; maxR) {
			maxR = ret[i] + i;
			what = i;
		}
	}
}

void prepareExtend() {
	static int pat[MAX_N_ROWS];
	static int ret[MAX_N_ROWS];

	//hor
	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			pat[c] = map[r][c];
		}
		calcExtend(pat, ret, nCols);
		for (int c = 0; c &lt; nCols; ++c) {
			extendRow[r][c] = ret[c];
		}
	}

	//ver
	for (int c = 0; c &lt; nCols; ++c) {
		for (int r = 0; r &lt; nRows; ++r) {
			pat[r] = map[r][c];
		}
		calcExtend(pat, ret, nRows);
		for (int r = 0; r &lt; nRows; ++r) {
			extendCol[r][c] = ret[r];
		}
	}
}

void testCalcExtend() {
	int a[100], n;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; a[i];
	}
	int ret[100];
	calcExtend(a, ret, n);
	for (int i = 0; i &lt; n; ++i) {
		cout &lt;&lt; ret[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
}

typedef long long int64;
const int INF = ~0U &gt;&gt; 1;

//struct SegTree {
//	int min[4096];
//	int n;
//	void init(int pat[], int cap) {
//		n = 1;
//		while (n &lt;= cap + 3)
//			n &lt;&lt;= 1;
//		for (int i = 0; i &lt; n; ++i) {
//			min[n + i] = INF;
//		}
//		for (int i = 0; i &lt; cap; ++i) {
//			min[n + 1 + i] = pat[i];
//		}
//		for (int i = n - 1; i &gt;= 1; --i) {
//			min[i] = std::min(min[i + i], min[i + i + 1]);
//		}
//	}
//
//	int ask(int l, int r) {
//		int ret = INF;
//		for (l += n, r += n + 2; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) {
//			if (~l &amp; 1)
//				ret = std::min(ret, min[l ^ 1]);
//			if (r &amp; 1)
//				ret = std::min(ret, min[r ^ 1]);
//		}
//		return ret;
//	}
//};

//SegTree rmqRow[MAX_N_ROWS];
//SegTree rmqCol[MAX_N_COLS];
//
//void prepareRmq() {
//	static int extend[MAX_N_ROWS];
//	for (int r = 0; r &lt; nRows; ++r) {
//		for (int c = 0; c &lt; nCols; ++c) {
//			extend[c] = extendCol[r][c];
//		}
//		rmqRow[r].init(extend, nCols);
//	}
//
//	for (int c = 0; c &lt; nCols; ++c) {
//		for (int r = 0; r &lt; nRows; ++r) {
//			extend[r] = extendRow[r][c];
//		}
//		rmqCol[c].init(extend, nRows);
//	}
//}
//
//int calcMax(int row, int col) {
//	int l = 0, r = std::min(nRows, nCols) + 1;
//	while (l + 1 &lt; r) {
//		int m = l + r &gt;&gt; 1;
//		if (row - m &lt; 0 || row + m &gt;= nRows || col - m &lt; 0 || col + m &gt;= nCols) {
//			r = m;
//		} else {
//			int it = std::min(rmqRow[row].ask(col - m, col + m),
//					rmqCol[col].ask(row - m, row + m));
//			if (it &gt;= m)
//				l = m;
//			else
//				r = m;
//		}
//	}
//	return l;
//}
//
////int extend[MAX_N_ROWS][MAX_N_COLS];

//int64 work() {
//	preparePow();
//	prepareExtend();
////	prepareRmq();
//	calcMax(1, 1);
//	//
//
//	int64 ans = 0;
//	for (int r = 0; r &lt; nRows; ++r) {
//		for (int c = 0; c &lt; nCols; ++c) {
//			if (r % 2 == 0 &amp;&amp; c % 2 == 0) {
//				int cur = calcMax(r, c);
//				//				extend[r][c] = cur;
//				ans += cur / 2 + 1;
//			}
//			if (r % 2 == 1 &amp;&amp; c % 2 == 1) {
//				int cur = calcMax(r, c);
//				//				extend[r][c] = cur;
//				ans += (cur + 1) / 2;
//			}
//		}
//	}
//
//	return ans;
//}

int maxSquare[MAX_N_ROWS][MAX_N_COLS];

struct UF {
	int F[MAX_N_ROWS];
	int n;
	void makeSet(int i) {
		F[i] = i;
	}
	int find(int x) {
		if (x == F[x])
			return x;
		return F[x] = find(F[x]);
	}
	void unite(int a, int b) {
		b = find(b);
		a = find(a);
		F[b] = a;
	}
};

void doit(int a[], int n, int ret[]) {
	//	static int stack[MAX_N_ROWS];
	//	int top = 0;
	//	static UF U;
	//	for (int i = 0; i &lt; n; i++) {
	//		//		U.makeSet(i);
	//		U.makeSet(i);
	//		while (top &gt; 0 &amp;&amp; a[stack[top - 1]] &gt;= a[i]) {
	//			U.unite(i, stack[--top]);
	//		}
	//		stack[top++] = i;
	//		int l = 0, r = i + 1;
	//		while (l + 1 &lt; r) {
	//			int m = l + r &gt;&gt; 1;
	//			if (a[U.find(i - m)] &gt;= m)
	//				l = m;
	//			else
	//				r = m;
	//		}
	//		ret[i] = l;
	//	}

	static int que[MAX_N_ROWS];
	int qh = 0, qt = 0;
	for (int i = 0; i &lt; n; ++i) {
		while (qh &lt; qt &amp;&amp; a[que[qt - 1]] &gt; a[i])
			--qt;
		que[qt++] = i;
		int where = i ? i - 1 - ret[i - 1] : 0;
		for (;;) {
			int m = i - where;
			if (a[que[qh]] &gt;= m)
				break;
			where++;
			if (que[qh] &lt; where) {
				qh++;
			}
		}
		ret[i] = i - where;
	}
}

int64 work() {
	prepareExtend();

	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			maxSquare[r][c] = INF;
		}
	}

	int extend[MAX_N_ROWS];
	int ret[MAX_N_ROWS];
	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			extend[c] = extendCol[r][c];
		}
		doit(extend, nCols, ret);
		for (int c = 0; c &lt; nCols; ++c) {
			maxSquare[r][c] = std::min(maxSquare[r][c], ret[c]);
		}
		std::reverse(extend, extend + nCols);
		doit(extend, nCols, ret);
		for (int c = 0; c &lt; nCols; ++c) {
			maxSquare[r][c] = std::min(maxSquare[r][c], ret[revPos(c, nCols)]);
		}
	}

	for (int c = 0; c &lt; nCols; ++c) {
		for (int r = 0; r &lt; nRows; ++r) {
			extend[r] = extendRow[r][c];
		}
		doit(extend, nRows, ret);
		for (int r = 0; r &lt; nRows; ++r) {
			maxSquare[r][c] = std::min(maxSquare[r][c], ret[r]);
		}
		std::reverse(extend, extend + nRows);
		doit(extend, nRows, ret);
		for (int r = 0; r &lt; nRows; ++r) {
			maxSquare[r][c] = std::min(maxSquare[r][c], ret[revPos(r, nRows)]);
		}
	}

	int64 ans = 0;
	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			if (r % 2 == 0 &amp;&amp; c % 2 == 0) {
				int cur = maxSquare[r][c];
				ans += cur / 2 + 1;
			}
			if (r % 2 == 1 &amp;&amp; c % 2 == 1) {
				int cur = maxSquare[r][c];
				ans += (cur + 1) / 2;
			}
		}
	}

	//	for (int r = 0; r &lt; nRows; ++r) {
	//		for (int c = 0; c &lt; nCols; ++c) {
	//			cout &lt;&lt; maxSquare[r][c] &lt;&lt; " ";
	//		}
	//		cout &lt;&lt; endl;
	//	}

	return ans;
}

void solve() {
	inputData();
	cout &lt;&lt; work() &lt;&lt; std::endl;
}

void runLargest() {
	nRows = 2000;
	nCols = 2000;
	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			map[r][c] = rand();
		}
	}
	cout &lt;&lt; work() &lt;&lt; endl;
}

int main() {
//	freopen("in", "r", stdin);
	//	testCalcExtend();
	//	inputData();
	solve();
	//	runLargest();
}
<pre><h2>Problem1415</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#define pb push_back
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
using namespace std;
const int maxn=1000,inf=~0U&gt;&gt;1;
vector&lt;int&gt; E[maxn];
int n,m,vs,vt;
void AddEdge(int s,int t)
{
     E[s].pb(t);
     E[t].pb(s);
}
int Dist[maxn][maxn],Next[maxn][maxn];
struct Queue
{
    int Q[maxn],h,t;
    bool inQ[maxn];
    void clear()
    {
         memset(inQ,0,sizeof inQ);
         h=t=0;
    }
    void inc(int&amp;it)
    {
         if(++it==maxn)it=0;
    }
    void add(int x)
    {
         if(inQ[x])return;
         inQ[x]=true;Q[t]=x;inc(t);
    }
    int get()
    {
        int tmp=Q[h];inc(h);
        inQ[tmp]=false;
        return tmp;
    }
    bool empty()
    {
         return h==t;
    }
}Q;
void SPFA(int vs,int Dist[maxn],int Next[maxn])
{
     rep(i,n)Dist[i]=inf;
     Dist[vs]=0;Next[vs]=vs;
     Q.clear();Q.add(vs);
     while(!Q.empty())
     {
        int t=Q.get();
        int c=Dist[t];
        tr(e,E[t])
        {
            int nc=c+1;
            if(Dist[*e]&gt;nc)
            {
                Dist[*e]=nc;
                Next[*e]=t;
            }
            else if(Dist[*e]==nc)
            {
                if(t&lt;Next[*e])
                {
                    Next[*e]=t;
                }
                else
                {
                    continue;
                }
            }
            else
            {
                continue;
            }
            Q.add(*e);
        }        
     }
}
int getNext(int s,int t)
{
    return Next[t][Next[t][s]]
    ;
}
double Mem[maxn][maxn];
void Init()
{
    scanf("%d%d%d%d",&amp;n,&amp;m,&amp;vs,&amp;vt);
    vs--;vt--;int s,t;
    rep(i,m)
    {
        scanf("%d%d",&amp;s,&amp;t);--s;--t;
        AddEdge(s,t);
    }
}
double dp(int a,int b)//a:cat b:morse
{
    double&amp;mem=Mem[a][b];
    if(mem&gt;-0.5)return mem;
    if(a==b)return mem=0;
    //cat move
    a=getNext(a,b);
    if(a==b)return mem=1;
    //morse move
    int P=E[b].size()+1;
    mem=0;
    mem+=dp(a,b);//stay here
    tr(e,E[b])
    {
        mem+=dp(a,*e);//go to *e
    }
    mem/=P;mem+=1;
    return mem;
}
void PreCondition()
{
    rep(i,n)SPFA(i,Dist[i],Next[i]);
}
int main()
{
    //freopen("in.cpp","r",stdin);
    //freopen("out.cpp","w",stdout);
    Init();
    PreCondition();
    rep(i,n)rep(j,n)Mem[i][j]=-1;
    printf("%0.3lf\n",dp(vs,vt));
}
<pre><h2>Problem1416</h2><pre>import java.math.BigInteger;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		new Main().run();
	}

	void debug(Object a) {
		System.out.println(a);
	}

	void run() {
		Scanner scan = new Scanner(System.in);
		int nColors = scan.nextInt();
		int nOperations = scan.nextInt();
		int nAdd = scan.nextInt();
		int[] am = new int[nColors];
		int sum = 0;
		for (int i = 0; i &lt; nColors; ++i) {
			am[i] = scan.nextInt();
		}
		for (int a : am) {
			sum += a;
		}
		BigInteger A = BigInteger.ONE, B = BigInteger.ONE;
		for (int i = 0; i &lt; nOperations; ++i) {
			int x = scan.nextInt(), y = scan.nextInt();
			--y;
			A = A.multiply(BigInteger.valueOf(am[y]));
			B = B.multiply(BigInteger.valueOf(sum));
			am[y] += nAdd;
			sum += nAdd;
		}

		BigInteger g = A.gcd(B);
		A = A.divide(g);
		B = B.divide(g);

		System.out.println(A + "/" + B);
	}
}
<pre><h2>Problem1417</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(VI::iterator e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef vector&lt;int&gt; VI;
map&lt;VI,double&gt; Map;
int n,m;
int total;
double Dp(VI A)
{
    if(Map.count(A))return Map[A];
    double&amp;x=Map[A];
    if(A.size()==1)return x=0;
    double same=0;
    rep(i,A.size())
        rep(j,i+1)
            if(i==j)
                same+=double(A[i]*(A[i]-1)/2)/total;
            else
            {
                VI New=A;
                New[i]+=New[j];swap(New[j],New[New.size()-1]);
                New.pop_back();sort(New.begin(),New.end());
                x+=double(A[i]*A[j])/total*Dp(New);
            }
    x=(x+1)/(1-same);
    return x;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;total=n*(n-1)/2;
    VI comp(n);
    rep(i,n)comp[i]=i;
    int s,t;
    rep(i,m)
    {
        cin&gt;&gt;s&gt;&gt;t;--s;--t;int that=comp[t];
        if(comp[s]!=comp[t])
            rep(j,n)if(comp[j]==that)
                comp[j]=comp[s];
    }
    VI count(n,0),Now;
    rep(i,n)count[comp[i]]++;
    rep(i,n)if(count[i])Now.pb(count[i]);
    sort(Now.begin(),Now.end());
    printf("%0.6lf\n",Dp(Now));
}


<pre><h2>Problem1420</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define tr(e,x) for(vector&lt;ll&gt;::iterator e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1,maxn=20;
using namespace std;
typedef long long ll;
ll P[maxn],m=0,p,g,k,a;
void decompose(ll x)
{
    for(ll i=2;i*i&lt;=x;i++)
        if(x%i==0)
        {
            P[m++]=i;
            while(x%i==0)x/=i;
        }
    if(x&gt;1)P[m++]=x;
}
ll ext_gcd(ll a,ll b,ll&amp;x,ll&amp;y)
{
    if(!b){x=1;y=0;return a;}
    ll tmp=ext_gcd(b,a%b,y,x);y-=x*(a/b);
    return tmp;
}
ll pow(ll x,ll e)
{
    if(!e)return 1;
    ll tmp=pow(x,e/2);tmp*=tmp;tmp%=p;
    if(e&amp;1)tmp*=x,tmp%=p;
    return tmp;
}
ll inv(ll x)
{
    return pow(x,p-2);
}
bool IsRoot(ll a)
{
    rep(i,m)
        if(pow(a,(p-1)/P[i])==1)return false;
    return true;
}
void FindRoot()
{
    decompose(p-1);
    for(ll i=2;i&lt;p;i++)if(IsRoot(i)){g=i;break;}
}
ll discrete_Log(ll a)
{
    map&lt;ll,ll&gt; Map;ll M=sqrt(p)+1;
    ll v=inv(pow(g,M));
    ll e=1;Map[1]=0;
    for(ll i=1;i&lt;M;i++){e=e*g%p;if(!Map.count(e))Map[e]=i;}
    for(ll i=0;i&lt;M;i++)
    {
        if(Map.count(a))return i*M+Map[a];
        a=a*v%p;
    }
    return -1;
}
vector&lt;ll&gt; Solve(ll a,ll b,ll m)
{
    ll x,y,d;
    d=ext_gcd(a,m,x,y);
    vector&lt;ll&gt; A;
    if(b%d)return A;
    ll t=b/d;x%=m;if(x&lt;0)x+=m;x=x*t%m;
    rep(i,d)
    {
        A.pb(x);
        x+=m/d;x%=m;
    }
    return A;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;p&gt;&gt;k&gt;&gt;a;
    if(a==0){cout&lt;&lt;1&lt;&lt;endl&lt;&lt;0&lt;&lt;endl;return 0;}
    FindRoot();
    ll Loga=discrete_Log(a);
    vector&lt;ll&gt; Logx=Solve(k,Loga,p-1);
    cout&lt;&lt;Logx.size()&lt;&lt;endl;
    vector&lt;ll&gt; Ans;
    tr(it,Logx)
    {
        ll tmp=pow(g,*it);
        Ans.pb(tmp);
    }
    sort(Ans.begin(),Ans.end());
    tr(it,Ans)cout&lt;&lt;*it&lt;&lt;endl;
}


<pre><h2>Problem1427</h2><pre>#include &lt;cassert&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;

const long long maxans = 100000000000000001LL;

template &lt;class T&gt; T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }
template &lt;class T&gt; T lcm(T a, T b) { return a / gcd(a, b) * b; }
template &lt;class T&gt; T abs(T a)      { return a &lt; 0 ? -a : a; }

int n, mod, v[10];
long long wtbl[20000][5];

// standard dp solution for small weights
long long ways_brute(int c, int x) {
  if (x &lt; 0) return 0;
  if (c == 0) return x % v[0] == 0;
  if (wtbl[x][c-1] == -1)
    wtbl[x][c-1] = ways_brute(c-1, x) + ways_brute(c, x-v[c]);
  return wtbl[x][c-1];
}

// lagrange interpolation for big weights
long long ways(long long x) {
  int r = x % mod;
  long long k = x / mod, res = 0;
  if (k &lt; n) return ways_brute(n-1, x);
  for (int i = 0; i &lt; n; ++i) {
    long long num = ways_brute(n-1, r + mod*i), den = 1, d;
    for (int j = 0; j &lt; n; ++j) {
      if (i != j) {
	num *= k-j;
	den *= i-j;
	d = gcd(abs(num), abs(den));
	num /= d;
	den /= d;
      }
    }
    if (den &lt; 0) num = -num, den = -den;
    assert(den == 1);
    res += num;
  }
  return res;
}

int main(void) {
  int cse = 0, q;
  //freopen("in","r",stdin);
  scanf("%d", &amp;n);
    mod = 1;
    for (int i = 0; i &lt; n; ++i) {
      scanf("%d", v+i);
      mod = lcm(mod, v[i]);
    }
    memset(wtbl, -1, sizeof(wtbl));

    scanf("%d", &amp;q);
    for (int i = 0; i &lt; q; ++i) {
      long long res = maxans, P;
      cin&gt;&gt;P;

      // ways(n) is not increasing, hence we cannot apply a binary
      // search straight off, but ways(n) is increasing for n with a
      // fixed residue modulo any of the weights, so we do one binary
      // search for each residue mod v[0].
      for (int i = 0; i &lt; *v; ++i) {
	long long lo = -1, hi = 2;
	// first find a range for the binary search
	while ((lo+1) * *v + i &lt; res &amp;&amp; ways(hi * *v + i) &lt; P)
	  lo = hi, hi &lt;&lt;= 1;
	if ((lo+1) * *v + i &gt;= res) continue;

	while (hi - lo &gt; 1) {
	  long long m = (lo + hi)/2, w = ways(m * *v + i);
	  if (w &lt; P) lo = m;
	  else hi = m;
	}
	// don't allow zero, we want positive answers.
	if (hi * *v + i == 0) ++hi;
	res = min(res,hi * *v + i);
      }

      if (res == maxans) printf("no candy for you\n");
      cout&lt;&lt;res&lt;&lt;endl;
    }
  return 0;
}
<pre><h2>Problem1428</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxn=200;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
struct BigInt
{
    int A[maxn],n;
    int&amp;operator[](int i){return A[i];}
    int operator[](int i)const{return A[i];}
    BigInt(int x=0){memset(A,0,sizeof A);A[n=0]=x;}
    bool IsZero()const{return !n&amp;&amp;!A[n];}
    void operator+=(int x)
    {
        A[0]+=x;
        for(int i=0;i&lt;=n;i++)
        {
            if(A[i]&gt;=10)A[i+1]++,A[i]-=10;
        }
        if(A[n+1])n++;
    }
    void operator-=(const BigInt&amp;that)
    {
        int d=0;
        for(int i=0;i&lt;=n;i++)
        {
            if(d)A[i]--,d=0;
            if(A[i]&lt;that[i])d=1,A[i]+=10;
            A[i]-=that[i];
        }
        while(n&amp;&amp;!A[n])n--;
    }
    void operator*=(int x)
    {
        int d=0;
        for(int i=0;i&lt;=n;i++)
        {
            d+=A[i]*x;A[i]=d%10;
            d/=10;
        }
        while(d)A[++n]=d%10,d/=10;
    }
    void operator/=(int x)
    {
        int d=0;
        for(int i=n;i&gt;=0;i--)
        {
            d+=A[i];A[i]=d/x;d%=x;
            d*=10;
        }
        while(n&amp;&amp;!A[n])n--;
    }
    int mod(int x)
    {
        int d=0;
        for(int i=n;i&gt;=0;i--)d*=10,d+=A[i],d%=x;
        return d;
    }
    void operator=(const BigInt&amp;that)
    {
        memcpy(A,that.A,sizeof A);
        n=that.n;
    }
};
istream&amp; operator&gt;&gt;(istream&amp;in,BigInt&amp;x)
{
    string a;in&gt;&gt;a;
    x.n=a.size()-1;
    for(int i=0;i&lt;=x.n;i++)
        x[i]=a[x.n-i]-'0';
    return in;
}
ostream&amp; operator&lt;&lt;(ostream&amp;out,const BigInt&amp;x)
{
    for(int i=x.n;i&gt;=0;i--)
        cout&lt;&lt;x[i];
    return out;
}
int p;
void Solve()
{
    //freopen("in","r",stdin);
    BigInt tmp,n,ret(1);
    cin&gt;&gt;n&gt;&gt;p;tmp=n;
    while(!n.IsZero())ret*=n.mod(p)+1,n/=p;
    tmp+=1;tmp-=ret;
    cout&lt;&lt;tmp&lt;&lt;endl;
}
int main()
{
    int t;cin&gt;&gt;t;while(t--)Solve();
}
<pre><h2>Problem1429</h2><pre>#include &lt;iostream&gt;
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long ll;
ll N;
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;N;N=2*N+1;ll i;
    ll ans=0;
    for(i=1;i*i&lt;N;i++)
        if(N%i==0)ans+=i+N/i;
    if(i*i==N)ans+=i;
    cout&lt;&lt;ans&lt;&lt;endl;
}


<pre><h2>Problem1430</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,mod=9999991;
int main()
{
    int n;long long ans=1;cin&gt;&gt;n;
    rep(i,n-2)ans*=n,ans%=mod;
    rep(i,n-1)ans*=i+1,ans%=mod;
    cout&lt;&lt;ans&lt;&lt;endl;
}
<pre><h2>Problem1430</h2><pre>#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int inf=~0U&gt;&gt;1,mod=9999991;
int main()
{
    int n;long long ans=1;cin&gt;&gt;n;
    rep(i,n-2)ans*=n,ans%=mod;
    rep(i,n-1)ans*=i+1,ans%=mod;
    cout&lt;&lt;ans&lt;&lt;endl;
}
<pre><h2>Problem1432</h2><pre>/*
 * [ZJOI2009]Function.cpp
 *
 *  Created on: 2011-2-16
 *      Author: user
 */

#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;

int main(){
	int n,k;
	cin&gt;&gt;n&gt;&gt;k;
	if(n==1)
		printf("1\n");
	else
		printf("%d\n",2*min(k,n-k+1));
}
<pre><h2>Problem1433</h2><pre>/*
 * [ZJOI2009]假期的宿舍.cpp
 *
 *  Created on: 2011-3-11
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_STUDENTS = 50;

struct BipartiteMatch {
	static const int MAX_N_VETS = MAX_N_STUDENTS;
	bool edge[MAX_N_VETS][MAX_N_VETS];
	int nX, nY;

	void init(int _nX, int _nY) {
		nX = _nX;
		nY = _nY;
		memset(edge, false, sizeof edge);
	}

	void addMatch(int x, int y) {
		edge[x][y] = true;
	}

	int linkY[MAX_N_VETS];
	bool visited[MAX_N_VETS];
	bool dfs(int x) {
		if (visited[x])
			return false;
		visited[x] = true;
		for (int y = 0; y &lt; nY; ++y) {
			if (edge[x][y] &amp;&amp; (linkY[y] == -1 || dfs(linkY[y])))
				return linkY[y] = x, true;
		}
		return false;
	}
	int calcMaxMatch() {
		memset(linkY, -1, sizeof linkY);
		int cnt = 0;
		for (int x = 0; x &lt; nX; ++x) {
			memset(visited, false, sizeof visited);
			if (dfs(x))
				++cnt;
		}

		return cnt;
	}
};

BipartiteMatch match;

int nStudents;
bool hasBed[MAX_N_STUDENTS];
bool atThere[MAX_N_STUDENTS];
int id[MAX_N_STUDENTS];
bool know[MAX_N_STUDENTS][MAX_N_STUDENTS];

void inputData() {
	scanf("%d", &amp;nStudents);
	for (int id = 0; id &lt; nStudents; ++id) {
		int x;
		scanf("%d", &amp;x);
		hasBed[id] = x &gt; 0;
	}
	for (int id = 0; id &lt; nStudents; ++id) {
		int x;
		scanf("%d", &amp;x);
		atThere[id] = x == 0;
		if (!hasBed[id])
			atThere[id] = true;
	}
	for (int a = 0; a &lt; nStudents; ++a) {
		for (int b = 0; b &lt; nStudents; ++b) {
			int x;
			scanf("%d", &amp;x);
			know[a][b] = x &gt; 0;
		}
	}
}

int idBed[MAX_N_STUDENTS];
int idMan[MAX_N_STUDENTS];
void buildGraph() {
	int nMans = 0, nBeds = 0;
	match.init(nMans, nBeds);
	for (int i = 0; i &lt; nStudents; ++i) {
		if (hasBed[i])
			idBed[i] = nBeds++;
		if (atThere[i])
			idMan[i] = nMans++;
	}

	match.init(nMans, nBeds);
	for (int man = 0; man &lt; nStudents; ++man) {
		for (int bed = 0; bed &lt; nStudents; ++bed) {
			if (atThere[man] &amp;&amp; hasBed[bed] &amp;&amp; (man == bed || know[man][bed]))
				match.addMatch(idMan[man], idBed[bed]);
		}
	}
}

void work() {
	buildGraph();
	if (match.calcMaxMatch() == match.nX) {
		puts("^_^");
	} else {
		puts("T_T");
	}
}

void solve() {
	int nCase;
	cin &gt;&gt; nCase;
	while (nCase--) {
		inputData();
		work();
	}
}

int main() {
	solve();
}
<pre><h2>Problem1434</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=105;
using namespace std;
inline int lowbit(int x){return x&amp;-x;}
int log(int x){return x==1?0:(log(x/2)+1);}
int n,m;
int sg(int x,int y)
{
    if(x==0||y==0)return log(lowbit(x+y+1));
    return x+y;
}
bool E[maxn*2]={};
int main()
{
    //freopen("in","r",stdin);
    int T;scanf("%d",&amp;T);
    rep(t,T)
    {
        scanf("%d%d",&amp;n,&amp;m);
        memset(E,0,sizeof E);
        rep(i,n)
        {
            scanf(" ");
            rep(j,m)
            {
                char c=getchar();
                if(c=='T')
                    E[sg(i,j)]^=1;
            }
        }
        bool ok=true;
        rep(i,n+m)if(E[i]){ok=false;break;}
        if(ok)puts("=_=");
        else puts("-_-");
    }
}


<pre><h2>Problem1438</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#include &lt;cassert&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long ll;
ll ext_gcd(ll a,ll b,ll&amp;x,ll&amp;y)
{
    if(!b){x=1;y=0;return a;}
    ll tmp=ext_gcd(b,a%b,y,x);
    y-=x*(a/b);return tmp;
}
bool check(ll a,ll b,ll c)
{
    ll x,y;
    ll d=ext_gcd(a,b,x,y);
    if(c%d)return false;
    x*=c/d;y*=c/d;
    if(x&gt;=0&amp;&amp;y&gt;=0)return true;
    if(x&lt;0)
    {
        ll t=(-x-1)/(b/d)+1;
        x+=t*b/d;y-=t*a/d;
        if(y&lt;0)return false;
        return true;
    }
    if(y&lt;0)
    {
        ll t=(-y-1)/(a/d)+1;
        x-=t*b/d;y+=t*a/d;
        if(x&lt;0)return false;
        return true;
    }
    return false;
}
void solve()
{
    ll a,b,c,d;
    #define Exit(s) {puts(s);return;}
    scanf("%I64d%I64d%I64d%I64d",&amp;a,&amp;b,&amp;c,&amp;d);
    if((c%a)&amp;&amp;(d%a))Exit("NO");
    if((c%b)&amp;&amp;(d%b))Exit("NO");
    if((c*d)%(a*b))Exit("NO");
    if(!check(a,b,c))Exit("NO");
    if(!check(a,b,d))Exit("NO");
    Exit("YES");
}
int main()
{
    //freopen("in","r",stdin);
    int t;cin&gt;&gt;t;rep(i,t)solve();
}


</pre><pre></pre><h2>Problem1441</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1;
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int main()
{
    //freopen("in","r",stdin);
    int n,a,x;cin&gt;&gt;n;cin&gt;&gt;a;
    rep(i,n-1)cin&gt;&gt;x,a=gcd(a,x);
    cout&lt;&lt;(a&gt;0?a:-a)&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1441</h2><pre>#include&lt;iostream&gt;
using namespace std;
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int main()
{
    int n,a,x;cin&gt;&gt;n;cin&gt;&gt;a;
    while(--n)cin&gt;&gt;x,a=gcd(a,x);
    cout&lt;&lt;(a&gt;0?a:-a)&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1443</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1,maxn=100,maxv=maxn*maxn+10;
using namespace std;
struct Edge
{
    int t,c;
    Edge*next,*op;
    Edge(int _t,int _c,Edge*_n):
        t(_t),c(_c),next(_n){}
}*E[maxv]={};
void AddEdge(int s,int t,int c)
{
    E[s]=new Edge(t,c,E[s]);
    E[t]=new Edge(s,0,E[t]);
    E[s]-&gt;op=E[t];E[t]-&gt;op=E[s];
}
int n,m,v,vs,vt;
bool M[maxn][maxn];
void BuildGraph()
{
    v=n*m;vs=v++;vt=v++;
    rep(i,n)rep(j,m)
        if(M[i][j])
            if((i+j)&amp;1)
            {
                #define A(i,j) ((i)*m+(j))
                #define build(ii,jj)\
                    if(M[ii][jj])\
                        AddEdge(A(i,j),A(ii,jj),1)
                AddEdge(vs,A(i,j),1);
                if(i)build(i-1,j);
                if(j)build(i,j-1);
                if(i+1&lt;n)build(i+1,j);
                if(j+1&lt;m)build(i,j+1);
                #undef build
            }
            else
            {
                AddEdge(A(i,j),vt,1);
                #undef A
            }
}
int Vis[maxv]={},flag=0;
int dfs(int x,int m)
{
    if(x==vt)return m;
    Vis[x]=flag;
    for(Edge*e=E[x];e;e=e-&gt;next)if(e-&gt;c&amp;&amp;Vis[e-&gt;t]!=flag)
    {
        int d=dfs(e-&gt;t,min(m,e-&gt;c));
        if(d) return e-&gt;c-=d,e-&gt;op-&gt;c+=d,d;
    }
    return 0;
}
void Init()
{
    scanf("%d%d",&amp;n,&amp;m);char c;
    rep(i,n)
    {
        scanf(" ");
        rep(j,m)
            c=getchar(),M[i][j]=c=='.';
    }
}
bool dead[maxv]={},type;
bool Type(int v)
{
    return (v%m+v/m)&amp;1;
}
int C;
void dfs(int x)
{
    Vis[x]=flag;
    if(Type(x)==type)
        dead[x]=true;
    for(Edge*e=E[x];e;e=e-&gt;next)
        if(e-&gt;c==type&amp;&amp;Vis[e-&gt;t]!=flag)
            dfs(e-&gt;t);
}
void Solve()
{
    ++flag;int Max=0;
    while(int d=dfs(vs,inf))++flag,Max+=d;
    ++flag;
    type=1;
    dfs(vs);dead[vs]=false;
    ++flag;
    type=0;
    dfs(vt);dead[vt]=false;
    bool has=false;
    rep(i,v)if(dead[i]){has=true;break;}
    if(has)
    {
        puts("WIN");
        rep(i,v)if(dead[i])
        {
            int x=i/m,y=i%m;
            printf("%d %d\n",x+1,y+1);
        }
    }
    else
    {
        puts("LOSE");
    }
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    BuildGraph();
    Solve();
}
</pre><pre></pre><h2>Problem1449</h2><pre>/*
 * [JSOI2009]球队收益.cpp
 *
 *  Created on: 2011-3-11
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_TEAMS = 5000;
const int MAX_N_MATCHS = 1000;
const int INF = INT_MAX / 2;

struct Network {
	static const int MAX_N_VETS = MAX_N_TEAMS + MAX_N_MATCHS + 2;
	static const int MAX_N_EDGES = 1000000;

	int head[MAX_N_EDGES], dest[MAX_N_EDGES], next[MAX_N_EDGES],
			cap[MAX_N_EDGES], cost[MAX_N_EDGES];
	int nVets, nEdges;
	int vs, vt;

	void init(int _nVets, int _vs, int _vt) {
		nVets = _nVets;
		nEdges = 0;
		memset(head, -1, sizeof head);
		vs = _vs;
		vt = _vt;
	}

	void makeEdge(int s, int t, int f, int c) {
		int id = nEdges++;
		next[id] = head[s];
		dest[id] = t;
		cap[id] = f;
		cost[id] = c;
		head[s] = id;
	}

	void addEdge(int s, int t, int f, int c) {
		makeEdge(s, t, f, c);
		makeEdge(t, s, 0, -c);
	}

	int que[MAX_N_VETS], qh, qt;
	bool inQ[MAX_N_VETS];
	void inc(int&amp;iter) {
		if (++iter == MAX_N_VETS)
			iter = 0;
	}
	void add(int x) {
		if (inQ[x])
			return;
		inQ[x] = true;
		que[qt] = x;
		inc(qt);
	}

	int get() {
		int t = que[qh];
		inQ[t] = false;
		inc(qh);
		return t;
	}
	int prev[MAX_N_VETS];
	int dist[MAX_N_VETS];
	int minCost;
	int totalFlow;

	bool spfa() {
		fill(dist, dist + nVets, INF);
		dist[vs] = 0;
		add(vs);
		while (qh != qt) {
			int u = get();
			for (int e = head[u]; e != -1; e = next[e])
				if (cap[e] &gt; 0) {
					int v = dest[e];
					int ndist = dist[u] + cost[e];
					if (ndist &lt; dist[v]) {
						prev[v] = e;
						dist[v] = ndist;
						add(v);
					}
				}
		}

		if (dist[vt] == INF)
			return false;

		int minCap = INF;
		{
			int at = vt;
			while (at != vs) {
				minCap = min(minCap, cap[prev[at]]);
				at = dest[prev[at] ^ 1];
			}
		}
		{
			int at = vt;
			while (at != vs) {
				cap[prev[at]] -= minCap;
				cap[prev[at] ^ 1] += minCap;
				at = dest[prev[at] ^ 1];
			}
		}
		minCost += minCap * dist[vt];
		totalFlow += minCap;
		return true;
	}

	int calcMinCostFlow() {
		minCost = 0;
		qh = qt = 0;
		memset(inQ, false, sizeof inQ);
		while (spfa())
			;
		return minCost;
	}
};

Network network;

int nTeams, nMatchs;
int nWin[MAX_N_TEAMS], nLose[MAX_N_TEAMS];
int winFactors[MAX_N_TEAMS], loseFactors[MAX_N_TEAMS];
int matchCounts[MAX_N_TEAMS];

int matchCompetitors[MAX_N_MATCHS][2];

void inputData() {
	scanf("%d%d", &amp;nTeams, &amp;nMatchs);
	for (int id = 0; id &lt; nTeams; ++id) {
		scanf("%d%d%d%d", nWin + id, nLose + id, winFactors + id, loseFactors
				+ id);
	}
	for (int matchId = 0; matchId &lt; nMatchs; ++matchId) {
		int teamA, teamB;
		scanf("%d%d", &amp;teamA, &amp;teamB);
		--teamA;
		--teamB;
		matchCompetitors[matchId][0] = teamA;
		matchCompetitors[matchId][1] = teamB;
		matchCounts[teamA]++;
		matchCounts[teamB]++;
	}
}

int vs, vt;
int cost[MAX_N_MATCHS];

int matchId[MAX_N_MATCHS];
int teamId[MAX_N_TEAMS];

int inCome;

void buildTeamSubGraph(int team) {
	int winFactor = winFactors[team];
	int loseFactor = loseFactors[team];
	int matchCount = matchCounts[team];
	int win = nWin[team], lose = nLose[team];
	for (int myWin = 0; myWin &lt;= matchCount; myWin++) {
		int myLose = matchCount - myWin;
		cost[myWin] = (win + myWin) * (win + myWin) * winFactor + (lose
				+ myLose) * (lose + myLose) * loseFactor;
	}
	inCome += cost[0];
	for (int cWin = 1; cWin &lt;= matchCount; cWin++) {
		//cWin-1 -&gt; cWin
		int delta = cost[cWin] - cost[cWin - 1];
		network.addEdge(teamId[team], vt, 1, delta);
	}
}

void buildGraph() {
	inCome = 0;
	int nId = 0;
	vs = nId++;
	vt = nId++;
	for (int team = 0; team &lt; nTeams; ++team) {
		teamId[team] = nId++;
	}
	for (int match = 0; match &lt; nMatchs; ++match) {
		matchId[match] = nId++;
	}
	network.init(nId, vs, vt);
	for (int match = 0; match &lt; nMatchs; ++match) {
		network.addEdge(vs, matchId[match], 1, 0);
		for (int who = 0; who &lt; 2; ++who) {
			network.addEdge(matchId[match],
					teamId[matchCompetitors[match][who]], 1, 0);
		}
	}
	for (int team = 0; team &lt; nTeams; ++team) {
		buildTeamSubGraph(team);
	}
}

void work() {
	buildGraph();
	inCome += network.calcMinCostFlow();
	cout &lt;&lt; inCome &lt;&lt; endl;
}

void solve() {
	inputData();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem1452</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=301,maxc=100;
int n,m;
struct Board
{
    int C[maxn][maxn];
    Board(){memset(C,0,sizeof(C));}
    void change(int i,int j,int d)
    {
        for(int x=i;x&lt;=n;x+=x&amp;-x)
            for(int y=j;y&lt;=n;y+=y&amp;-y)
                C[x][y]+=d;
    }
    int sum(int i,int j)
    {
        int Ans=0;
        for(int x=i;x&gt;0;x-=x&amp;-x)
            for(int y=j;y&gt;0;y-=y&amp;-y)
                Ans+=C[x][y];
        return Ans;
    }
    int sum(int x0,int y0,int x1,int y1)
    {
        return sum(x1,y1)-sum(x1,y0-1)-sum(x0-1,y1)+sum(x0-1,y0-1);
    }
}C[maxc];
int M[maxn][maxn];
void Change(int x,int y,int c)
{
    int o=M[x][y];
    C[o].change(x,y,-1);
    C[c].change(x,y,1);
    M[x][y]=c;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;int c;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            scanf("%d",&amp;c);--c;
            C[c].change(i,j,1);
            M[i][j]=c;
        }
    int p,t,x,y,x0,y0,x1,y1;cin&gt;&gt;p;
    while(p--)
    {
        scanf("%d",&amp;t);
        if(t==1)
            scanf("%d %d %d",&amp;x,&amp;y,&amp;c),Change(x,y,c-1);
        else
            scanf("%d %d %d %d %d",&amp;x0,&amp;x1,&amp;y0,&amp;y1,&amp;c),printf("%d\n",C[c-1].sum(x0,y0,x1,y1));
    }
}
</pre><pre></pre><h2>Problem1455</h2><pre>#include &lt;cstdio&gt;
#include &lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=1000000+10;
using namespace std;
int A[maxn],n,m;
int dist[maxn],l[maxn],r[maxn];
int R[maxn];
void make_it(int x)
{
    dist[x]=0;l[x]=r[x]=0;
}
int merge(int a,int b)
{
    if(!a||!b)return a+b;
    if(A[a]&gt;A[b])a^=b^=a^=b;
    r[a]=merge(r[a],b);
    if(dist[r[a]]&gt;dist[l[a]])
        swap(l[a],r[a]);
    dist[a]=dist[r[a]]+1;
    return a;
}
struct UF
{
    int F[maxn];
    void Set()
    {
        rep(i,n+1)F[i]=i,R[i]=i;
    }
    int Find(int x)
    {
        if(F[x]==x)return x;
        return F[x]=Find(F[x]);
    }
    void Union(int i,int j)
    {
        F[j]=i;
    }
}U;
bool Dead[maxn]={};
int Kill(int x)
{
    if(Dead[x])return 0;
    int o=U.Find(x);int&amp;a=R[o];
    Dead[a]=true;
    int tmp=A[a];
    a=merge(l[a],r[a]);
    return tmp;
}
void Merge(int a,int b)
{
    if(Dead[a]||Dead[b])return;
    a=U.Find(a);b=U.Find(b);
    if(a==b)return;
    U.Union(a,b);
    R[a]=merge(R[a],R[b]);
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);
    dist[0]=0;
    rep(i,n)scanf("%d",A+i+1),make_it(i+1);
    U.Set();
    scanf("%d",&amp;m);
    char c;int a,b;
    rep(i,m)
    {
        scanf(" ");
        scanf("%c",&amp;c);
        if(c=='M')scanf("%d%d",&amp;a,&amp;b),Merge(a,b);
        else scanf("%d",&amp;a),printf("%d\n",Kill(a));
    }

}
</pre><pre></pre><h2>Problem1457</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxn=100;
using namespace std;
int Dp[maxn][maxn];
bool Set[maxn*3];
void Insert(int a,int b)
{
    if(a&gt;0&amp;&amp;b&gt;0&amp;&amp;a!=b)Set[Dp[a][b]]=true;
}
void PreDo()
{
    for(int i=1;i&lt;maxn;i++)
        for(int j=1;j&lt;maxn;j++)
        {
            memset(Set,0,sizeof Set);
            if(i!=j)
            {
                for(int k=1;k&lt;maxn;k++)
                {
                    Insert(i-k,j);
                    Insert(i,j-k);
                    Insert(i-k,j-k);
                }
            }
            int&amp;t=Dp[i][j]=0;
            while(Set[t])t++;
        }
}
void Solve()
{
    int n,x,y,s=0;bool win=false;
    scanf("%d",&amp;n);
    rep(i,n)
    {
        scanf("%d%d",&amp;x,&amp;y);
        if(x==0||y==0||x==y)win=true;
        else s^=Dp[x][y];
    }
    if(win||s)puts("^o^");
    else puts("T_T");
}
int main()
{
    //freopen("in","r",stdin);
    PreDo();
    int t;cin&gt;&gt;t;rep(i,t)Solve();
}


</pre><pre></pre><h2>Problem1458</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxv=200+10,maxn=100;
using namespace std;
int vs,vt,n,m,k,v,ans=0;
struct Edge
{
    int t,c;
    Edge*next,*op;
    Edge(int _t,int _c,Edge*_n):t(_t),c(_c),next(_n){}
}*E[maxv]={};
void AddEdge(int s,int t,int c)
{
    E[s]=new Edge(t,c,E[s]);
    E[t]=new Edge(s,0,E[t]);
    E[s]-&gt;op=E[t];E[t]-&gt;op=E[s];
}
bool M[maxn][maxn]={};
int L[maxn],C[maxn];
void Fail()
{
    puts("JIONG!");
    exit(0);
}
void Init()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;v=n+m;vs=v++;vt=v++;
    rep(i,n)cin&gt;&gt;L[i];
    rep(i,m)cin&gt;&gt;C[i];
    int x,y;
    rep(i,k)
    {
        scanf("%d%d",&amp;x,&amp;y);--x;--y;
        M[x][y]=true;
    }
    rep(i,n)rep(j,m)if(!M[i][j])L[i]--,C[j]--,ans++;
    rep(i,n)if(L[i]&gt;0)Fail();
    rep(i,m)if(C[i]&gt;0)Fail();
}
void BuildGraph()
{
    rep(i,n)AddEdge(vs,i,-L[i]);
    rep(j,m)AddEdge(j+n,vt,-C[j]);
    rep(i,n)rep(j,m)if(!M[i][j])
        AddEdge(i,j+n,1);
}
bool vis[maxv]={};
int dfs(int no,int m)
{
    if(no==vt)return m;
    vis[no]=true;
    for(Edge*e=E[no];e;e=e-&gt;next)if(!vis[e-&gt;t]&amp;&amp;e-&gt;c)
        if(int d=dfs(e-&gt;t,min(m,e-&gt;c)))
            return e-&gt;c-=d,e-&gt;op-&gt;c+=d,d;
    return 0;
}
int CalFlow()
{
    int flow=0;
    do
    {
        memset(vis,0,sizeof vis);
        int d=dfs(vs,inf);
        if(d)flow+=d;
        else break;
    }while(1);
    return flow;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    BuildGraph();
    cout&lt;&lt;ans-CalFlow()&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1465</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
int n,A[1000000];
inline void scan(int&amp;t)
{
    char c;while(c=getchar(),c&lt;'0'||c&gt;'9');t=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
}
int main()
{
    scan(n);
    long long avg=0,ans=0;
    rep(i,n)scan(A[i]),avg+=A[i];
    avg/=n;A[0]-=avg;
    rep(i,n-1)A[i+1]+=A[i]-avg;
    sort(A,A+n);
    rep(i,n)ans+=abs(A[n/2]-A[i]);
    printf("%I64d\n",ans);
}
</pre><pre></pre><h2>Problem1468</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(Edge*e=H[x]-&gt;R;e!=E[x];e=e-&gt;R)
const int inf=~0U&gt;&gt;1,maxn=40000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int ans=0,n,K;
struct Edge
{
    int t,c;
    Edge*op,*L,*R;
    Edge(){}
    Edge(int _t,int _c):t(_t),c(_c){}
}*H[maxn],*E[maxn];
Edge* AddEdge(int s,int t,int c)
{
    Edge*e=new Edge(t,c);
    e-&gt;L=H[s];e-&gt;R=H[s]-&gt;R;
    H[s]-&gt;R-&gt;L=e;H[s]-&gt;R=e;
    return e;
}
void InsEdge(int s,int t,int c)
{
    //cout&lt;&lt;s&lt;&lt;" "&lt;&lt;t&lt;&lt;" "&lt;&lt;c&lt;&lt;endl;
    Edge*e1=AddEdge(s,t,c),*e2=AddEdge(t,s,c);
    e1-&gt;op=e2;e2-&gt;op=e1;
}
void DelEdge(Edge*e)
{
    e-&gt;L-&gt;R=e-&gt;R;e-&gt;R-&gt;L=e-&gt;L;
}
struct Array
{
    int A[maxn+2],n;
    void clear(){n=0;}
    void Add(int x){A[n++]=x;}
    void Sort(){sort(A,A+n);}
    void Show(){rep(i,n)cout&lt;&lt;A[i]&lt;&lt;",";cout&lt;&lt;endl;}
    int operator[](int i)const{return A[i];}
}A,B;
int Cal(const Array&amp;L,const Array&amp;R)
{
    int j=R.n-1,ret=0;
    for(int i=0;i&lt;L.n;i++)
    {
        while(j&gt;=0&amp;&amp;L[i]+R[j]&gt;K)j--;
        ret+=j+1;
    }
    return ret;
}
int Vis[maxn],Size[maxn],Len[maxn],Max[maxn],cnt;
int Search(int x,int f,int d)
{
    int now=cnt++;Vis[now]=x;Size[now]=1;
    Len[now]=d;Max[now]=0;
    tr(e,x)if(e-&gt;t!=f)
    {
        int tmp=Search(e-&gt;t,x,d+e-&gt;c);
        Size[now]+=Size[tmp];
        Max[now]=max(Max[now],Size[tmp]);
    }
    return now;
}
void Solve(int root)
{
    //cout&lt;&lt;root&lt;&lt;endl;
    cnt=0;
    Search(root,-1,0);
    if(cnt==1)return;
    int x=-1;
    rep(i,cnt)
    {
        Max[i]=max(Max[i],cnt-Size[i]);
        if(x==-1||Max[i]&lt;Max[x])x=i;
    }
    //cout&lt;&lt;Max[x]&lt;&lt;endl;
    x=Vis[x];
    //cout&lt;&lt;"Split at:"&lt;&lt;x+1&lt;&lt;endl;
    A.clear();B.clear();
    tr(e,x)
    {
        cnt=0;
        Search(e-&gt;t,x,e-&gt;c);
        rep(i,cnt)A.Add(Len[i]);
    }
    A.Add(0);A.Add(0);A.Sort();
    //A.Show();
    int ret=0;
    tr(e,x)
    {
        cnt=0;
        Search(e-&gt;t,x,e-&gt;c);
        B.clear();rep(i,cnt)B.Add(Len[i]);
        B.Sort();//B.Show();
        ret+=Cal(B,A)-Cal(B,B);
    }
    ret/=2;ans+=ret;
    A.clear();B.clear();
    tr(e,x)
    {
        DelEdge(e-&gt;op);
        //cout&lt;&lt;x&lt;&lt;"-&gt;"&lt;&lt;e-&gt;t&lt;&lt;endl;
        Solve(e-&gt;t);
    }
    H[x]-&gt;R=E[x];E[x]-&gt;L=H[x];
};
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);int s,t,c;
    rep(i,n)
    {
        H[i]=new Edge;E[i]=new Edge;
        H[i]-&gt;R=E[i];E[i]-&gt;L=H[i];
    }
    rep(i,n-1)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);--s;--t;
        InsEdge(s,t,c);
    }
    scanf("%d",&amp;K);
    Solve(0);
    printf("%d\n",ans);
}


</pre><pre></pre><h2>Problem1468</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(Edge*e=H[x]-&gt;R;e!=E[x];e=e-&gt;R)
const int inf=~0U&gt;&gt;1,maxn=40000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int ans=0,n,K;
struct Edge
{
    int t,c;
    Edge*op,*L,*R;
    Edge(){}
    Edge(int _t,int _c):t(_t),c(_c){}
}*H[maxn],*E[maxn];
Edge* AddEdge(int s,int t,int c)
{
    Edge*e=new Edge(t,c);
    e-&gt;L=H[s];e-&gt;R=H[s]-&gt;R;
    H[s]-&gt;R-&gt;L=e;H[s]-&gt;R=e;
    return e;
}
void InsEdge(int s,int t,int c)
{
    //cout&lt;&lt;s&lt;&lt;" "&lt;&lt;t&lt;&lt;" "&lt;&lt;c&lt;&lt;endl;
    Edge*e1=AddEdge(s,t,c),*e2=AddEdge(t,s,c);
    e1-&gt;op=e2;e2-&gt;op=e1;
}
void DelEdge(Edge*e)
{
    e-&gt;L-&gt;R=e-&gt;R;e-&gt;R-&gt;L=e-&gt;L;
}
struct Array
{
    int A[maxn+2],n;
    void clear(){n=0;}
    void Add(int x){A[n++]=x;}
    void Sort(){sort(A,A+n);}
    void Show(){rep(i,n)cout&lt;&lt;A[i]&lt;&lt;",";cout&lt;&lt;endl;}
    int operator[](int i)const{return A[i];}
}A,B;
int Cal(const Array&amp;L,const Array&amp;R)
{
    int j=R.n-1,ret=0;
    for(int i=0;i&lt;L.n;i++)
    {
        while(j&gt;=0&amp;&amp;L[i]+R[j]&gt;K)j--;
        ret+=j+1;
    }
    return ret;
}
int Vis[maxn],Size[maxn],Len[maxn],Max[maxn],cnt;
int Search(int x,int f,int d)
{
    int now=cnt++;Vis[now]=x;Size[now]=1;
    Len[now]=d;Max[now]=0;
    tr(e,x)if(e-&gt;t!=f)
    {
        int tmp=Search(e-&gt;t,x,d+e-&gt;c);
        Size[now]+=Size[tmp];
        Max[now]=max(Max[now],Size[tmp]);
    }
    return now;
}
void Solve(int root)
{
    //cout&lt;&lt;root&lt;&lt;endl;
    cnt=0;
    Search(root,-1,0);
    if(cnt==2)
    {
        ans+=H[root]-&gt;R-&gt;c&lt;=K;
        return;
    }
    if(cnt==1)return;
    int x=-1;
    rep(i,cnt)
    {
        Max[i]=max(Max[i],cnt-Size[i]);
        if(x==-1||Max[i]&lt;Max[x])x=i;
    }
    //cout&lt;&lt;Max[x]&lt;&lt;endl;
    x=Vis[x];
    //cout&lt;&lt;"Split at:"&lt;&lt;x+1&lt;&lt;endl;
    A.clear();B.clear();
    tr(e,x)
    {
        cnt=0;
        Search(e-&gt;t,x,e-&gt;c);
        rep(i,cnt)A.Add(Len[i]);
    }
    A.Add(0);A.Add(0);A.Sort();
    //A.Show();
    int ret=0;
    tr(e,x)
    {
        cnt=0;
        Search(e-&gt;t,x,e-&gt;c);
        B.clear();rep(i,cnt)B.Add(Len[i]);
        B.Sort();//B.Show();
        ret+=Cal(B,A)-Cal(B,B);
    }
    ret/=2;ans+=ret;
    A.clear();B.clear();
    tr(e,x)
    {
        DelEdge(e-&gt;op);
        //cout&lt;&lt;x&lt;&lt;"-&gt;"&lt;&lt;e-&gt;t&lt;&lt;endl;
        Solve(e-&gt;t);
    }
    H[x]-&gt;R=E[x];E[x]-&gt;L=H[x];
};
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);int s,t,c;
    rep(i,n)
    {
        H[i]=new Edge;E[i]=new Edge;
        H[i]-&gt;R=E[i];E[i]-&gt;L=H[i];
    }
    rep(i,n-1)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);--s;--t;
        InsEdge(s,t,c);
    }
    scanf("%d",&amp;K);
    Solve(0);
    printf("%d\n",ans);
}


</pre><pre></pre><h2>Problem1471</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxl=300,maxn=150;
using namespace std;
int Tmp[maxl];
struct BigInt
{
    int A[maxl],l;
    BigInt(){memset(A,0,sizeof A);l=0;}
    void set(int x){A[0]=x;}
    int operator[](int v)const{return A[v];}
    int&amp;operator[](int v){return A[v];}
    BigInt&amp;operator=(const BigInt&amp;that)
    {
        memcpy(A,that.A,sizeof A);
        l=that.l;
        return *this;
    }
    BigInt&amp;operator+=(const BigInt&amp;that)
    {
        l=max(l,that.l);int d=0;
        rep(i,l+1)
        {
            d+=A[i]+that[i];
            A[i]=d%10;
            d/=10;
        }
        if(d)A[++l]=d;
        return *this;
    }
    BigInt&amp;operator-=(const BigInt&amp;that)
    {
        int d=0;
        rep(i,l+1)
        {
            if(d)A[i]--,d=0;
            A[i]-=that[i];
            if(A[i]&lt;0)A[i]+=10,d=1;
        }
        while(!A[l])l--;
        return *this;
    }
    BigInt&amp;operator*=(const BigInt&amp;that)
    {
        int d=0;
        memset(Tmp,0,sizeof Tmp);
        rep(i,l+1)rep(j,that.l+1)Tmp[i+j]+=A[i]*that[j];
        l+=that.l;
        rep(i,l+1)
        {
            d+=Tmp[i];A[i]=d%10;d/=10;
        }
        while(d)A[++l]=d%10,d/=10;
        return *this;
    }
    BigInt operator*(const BigInt&amp;that)
    {
        BigInt ret=*this;
        return ret*=that;
    }
    BigInt operator+(const BigInt&amp;that)
    {
        BigInt ret=*this;
        return ret+=that;
    }
    BigInt operator-(const BigInt&amp;that)
    {
        BigInt ret=*this;
        return ret-=that;
    }
};
ostream&amp;operator&lt;&lt;(ostream&amp;out,BigInt&amp;that)
{
    for(int i=that.l;i&gt;=0;i--)out&lt;&lt;that[i];
    return out;
}
BigInt G[maxn][maxn];
BigInt F[maxn];
bool E2[maxn][maxn]={},E[maxn][maxn]={};
int Q[maxn],Ord[maxn],h,t,n,m,In[maxn];
int s1,t1,s2,t2;
void init()
{
    cin&gt;&gt;n&gt;&gt;m;int s,t;
    rep(i,m)cin&gt;&gt;s&gt;&gt;t,--s,--t,E2[s][t]=true,In[t]++;
    cin&gt;&gt;s1&gt;&gt;t1&gt;&gt;s2&gt;&gt;t2;--s1;--t1;--s2;--t2;
}
void TopoSort()
{
    h=t=0;rep(i,n)if(!In[i])Q[t++]=i;
    for(;h&lt;t;h++)
    {
        int x=Q[h];
        rep(i,n)if(E2[x][i])
            if(!--In[i])
                Q[t++]=i;
    }
    rep(i,n)Ord[Q[i]]=i;
    rep(i,n)rep(j,n)if(E2[i][j])
        E[Ord[i]][Ord[j]]=true;
}
void Solve()
{
    s1=Ord[s1];s2=Ord[s2];
    t1=Ord[t1];t2=Ord[t2];
    for(int s=0;s&lt;n;s++)
        for(int t=s;t&lt;n;t++)
        {
            if(s==t)
            {
                G[s][t].set(1);
            }
            else
            {
                rep(k,n)if(E[k][t])
                    G[s][t]+=G[s][k];
            }
        }
    for(int t=0;t&lt;n;t++)
    {
        F[t]=G[s1][t]*G[s2][t];
        rep(k,t)
            F[t]-=F[k]*G[k][t]*G[k][t];
    }
    BigInt Ans=G[s1][t1]*G[s2][t2];
    rep(k,n)Ans-=F[k]*G[k][t1]*G[k][t2];
    cout&lt;&lt;Ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    init();
    TopoSort();
    Solve();
}


</pre><pre></pre><h2>Problem1471</h2><pre>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=150;
using namespace std;
typedef long long ll;
ll G[maxn][maxn],F[maxn];
bool E2[maxn][maxn]={},E[maxn][maxn]={};
int Q[maxn],Ord[maxn],h,t,n,m,In[maxn];
int s1,t1,s2,t2;
void init()
{
    cin&gt;&gt;n&gt;&gt;m;int s,t;
    rep(i,m)cin&gt;&gt;s&gt;&gt;t,--s,--t,E2[s][t]=true,In[t]++;
    cin&gt;&gt;s1&gt;&gt;t1&gt;&gt;s2&gt;&gt;t2;--s1;--t1;--s2;--t2;
}
void TopoSort()
{
    h=t=0;rep(i,n)if(!In[i])Q[t++]=i;
    for(;h&lt;t;h++)
    {
        int x=Q[h];
        rep(i,n)if(E2[x][i])
            if(!--In[i])
                Q[t++]=i;
    }
    rep(i,n)Ord[Q[i]]=i;
    rep(i,n)rep(j,n)if(E2[i][j])
        E[Ord[i]][Ord[j]]=true;
}
void Solve()
{
    s1=Ord[s1];s2=Ord[s2];
    t1=Ord[t1];t2=Ord[t2];
    for(int s=0;s&lt;n;s++)
        for(int t=s;t&lt;n;t++)
        {
            if(s==t)G[s][t]=1;
            else
                rep(k,n)if(E[k][t])
                    G[s][t]+=G[s][k];
        }
    for(int t=0;t&lt;n;t++)
    {
        F[t]=G[s1][t]*G[s2][t];
        rep(k,t)
            F[t]-=F[k]*G[k][t]*G[k][t];
    }
    ll Ans=G[s1][t1]*G[s2][t2];
    rep(k,n)Ans-=F[k]*G[k][t1]*G[k][t2];
    cout&lt;&lt;Ans&lt;&lt;endl;
}
int main()
{
    init();
    TopoSort();
    Solve();
}


</pre><pre></pre><h2>Problem1471</h2><pre>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=150;
using namespace std;
typedef long long ll;
ll G[maxn][maxn],F[maxn];
bool E2[maxn][maxn]={},E[maxn][maxn]={};
int Q[maxn],Ord[maxn],h,t,n,m,In[maxn];
int s1,t1,s2,t2;
int nextInt()
{
    int ret;char c;
    while(c=getchar(),c&lt;'0'||c&gt;'9');
    ret=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')ret=ret*10+c-'0';
    return ret;
}
void init()
{
    cin&gt;&gt;n&gt;&gt;m;int s,t;
    rep(i,m)s=nextInt(),t=nextInt(),--s,--t,E2[s][t]=true,In[t]++;
    cin&gt;&gt;s1&gt;&gt;t1&gt;&gt;s2&gt;&gt;t2;--s1;--t1;--s2;--t2;
}
void TopoSort()
{
    h=t=0;rep(i,n)if(!In[i])Q[t++]=i;
    for(;h&lt;t;h++)
    {
        int x=Q[h];
        rep(i,n)if(E2[x][i])
            if(!--In[i])
                Q[t++]=i;
    }
    rep(i,n)Ord[Q[i]]=i;
    rep(i,n)rep(j,n)if(E2[i][j])
        E[Ord[i]][Ord[j]]=true;
}
void Solve()
{
    s1=Ord[s1];s2=Ord[s2];
    t1=Ord[t1];t2=Ord[t2];
    for(int s=0;s&lt;n;s++)
        for(int t=s;t&lt;n;t++)
        {
            if(s==t)G[s][t]=1;
            else
                rep(k,n)if(E[k][t])
                    G[s][t]+=G[s][k];
        }
    for(int t=0;t&lt;n;t++)
    {
        F[t]=G[s1][t]*G[s2][t];
        rep(k,t)
            F[t]-=F[k]*G[k][t]*G[k][t];
    }
    ll Ans=G[s1][t1]*G[s2][t2];
    rep(k,n)Ans-=F[k]*G[k][t1]*G[k][t2];
    cout&lt;&lt;Ans&lt;&lt;endl;
}
int main()
{
    init();
    TopoSort();
    Solve();
}


</pre><pre></pre><h2>Problem1475</h2><pre>/*
 * 1475.cpp
 *
 *  Created on: 2011-8-3
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

struct Maxflow {
	struct Edge {
		int t, c;
		Edge*n, *r;
		Edge(int _t, int _c, Edge*_n) :
				t(_t), c(_c), n(_n) {
		}
	};
	vector&lt;Edge*&gt; E;

	int addV() {
		E.push_back(NULL);
		return E.size() - 1;
	}

	void clear() {
		E.clear();
	}

	Edge* makeEdge(int s, int t, int c) {
		return E[s] = new Edge(t, c, E[s]);
	}

	void addEdge(int s, int t, int c) {
		Edge*e1 = makeEdge(s, t, c), *e2 = makeEdge(t, s, 0);
		e1-&gt;r = e2, e2-&gt;r = e1;
	}

	int calcMaxFlow(int vs, int vt, int INF = ~0U &gt;&gt; 2) {
		int nV = E.size();
		int totalFlow = 0;

		vector&lt;int&gt; am(nV, 0), h(nV, 0), cnt(nV, 0);
		vector&lt;Edge*&gt; prev(nV, (Edge*) (0)), cur(nV, (Edge*) (0));
		cnt[0] = nV;

		int u = vs;
		Edge*e;
		am[u] = INF;
		while (h[vs] &lt; nV) {
			for (e = cur[u]; e; e = e-&gt;n)
				if (e-&gt;c &gt; 0 &amp;&amp; h[u] == h[e-&gt;t] + 1)
					break;
			if (e) {
				int v = e-&gt;t;
				cur[u] = prev[v] = e;
				am[v] = min(am[u], e-&gt;c);
				u = v;
				if (u == vt) {
					int by = am[u];
					while (u != vs) {
						prev[u]-&gt;c -= by;
						prev[u]-&gt;r-&gt;c += by;
						u = prev[u]-&gt;r-&gt;t;
					}
					totalFlow += by;
					am[u] = INF;
				}
			} else {
				if (!--cnt[h[u]])
					break;
				h[u] = nV;
				for (e = E[u]; e; e = e-&gt;n)
					if (e-&gt;c &gt; 0 &amp;&amp; h[e-&gt;t] + 1 &lt; h[u]) {
						h[u] = h[e-&gt;t] + 1;
						cur[u] = e;
					}
				++cnt[h[u]];
				if (u != vs)
					u = prev[u]-&gt;r-&gt;t;
			}
		}

		return totalFlow;
	}
};

int main() {
	int n, a[30][30], id[30][30];
	cin &gt;&gt; n;
	Maxflow m;
	int ans = 0;
	REP(i,n)
		REP(j,n)
			cin &gt;&gt; a[i][j], id[i][j] = m.addV(), ans += a[i][j];
	int vs = m.addV(), vt = m.addV();
	REP(i,n)
		REP(j,n)
			if ((i + j) &amp; 1)
				m.addEdge(vs, id[i][j], a[i][j]);
			else
				m.addEdge(id[i][j], vt, a[i][j]);
	REP(i,n)
		REP(j,n)
			REP(ii,n)
				REP(jj,n)
					if (abs(i - ii) + abs(j - jj) == 1 &amp;&amp; (i + j) &amp; 1)
						m.addEdge(id[i][j], id[ii][jj], ~0U &gt;&gt; 1);
	cout &lt;&lt; ans - m.calcMaxFlow(vs, vt, ~0U &gt;&gt; 1) &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem1486</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define tr(i,x) for(eit i=x.begin();i!=x.end();i++)
const int inf=~0U&gt;&gt;1,maxn=3000;
using namespace std;
int n,m;
struct Edge
{
    int t;
    double c,oc;
    Edge(int _t,double _c):t(_t),oc(_c){}
};
typedef vector&lt;Edge&gt;::iterator eit;
vector&lt;Edge&gt; E[maxn];
double D;
bool vis[maxn]={0},Find;
double Dist[maxn];
void dfs(int x)
{
    vis[x]=true;double cost=Dist[x],ncost;
    tr(e,E[x])if((ncost=cost+e-&gt;c)&gt;Dist[e-&gt;t])
    {
        if(!vis[e-&gt;t]){Dist[e-&gt;t]=ncost;dfs(e-&gt;t);}
        else Find=true;
        if(Find)break;
    }
    vis[x]=false;
}
bool Check(double _D)
{
    D=_D;
    rep(i,n)tr(e,E[i])e-&gt;c=D-e-&gt;oc;
    Find=false;
    rep(i,n)Dist[i]=0;
    rep(i,n){dfs(i);if(Find)return true;}
    return false;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;
    int s,t;double c;
    rep(i,m)scanf("%d %d %lf",&amp;s,&amp;t,&amp;c),--s,--t,E[s].pb(Edge(t,c));
    double r=1e7,l=-r;
    while(r-l&gt;1e-9)
    {
        double m=(l+r)/2;
        if(Check(m))r=m;
        else l=m;
    }
    printf("%0.8lf\n",l);
}


</pre><pre></pre><h2>Problem1486</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define tr(i,x) for(eit i=x.begin();i!=x.end();i++)
const int inf=~0U&gt;&gt;1,maxn=3000;
using namespace std;
int n,m;
struct Edge
{
    int t;
    double c,oc;
    Edge(int _t,double _c):t(_t),oc(_c){}
};
typedef vector&lt;Edge&gt;::iterator eit;
vector&lt;Edge&gt; E[maxn];
double D;
bool vis[maxn]={0},Find;
double Dist[maxn];
void dfs(int x)
{
    vis[x]=true;double cost=Dist[x],ncost;
    tr(e,E[x])if((ncost=cost+e-&gt;c)&gt;Dist[e-&gt;t])
    {
        if(!vis[e-&gt;t]){Dist[e-&gt;t]=ncost;dfs(e-&gt;t);}
        else Find=true;
        if(Find)break;
    }
    vis[x]=false;
}
bool Check(double _D)
{
    D=_D;
    rep(i,n)tr(e,E[i])e-&gt;c=D-e-&gt;oc;
    Find=false;
    rep(i,n)Dist[i]=0;
    rep(i,n){dfs(i);if(Find)return true;}
    return false;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;
    int s,t;double c,l=inf,r=-inf;
    rep(i,m)scanf("%d %d %lf",&amp;s,&amp;t,&amp;c),--s,--t,E[s].pb(Edge(t,c)),l&lt;?=c,r&gt;?=c;
    while(r-l&gt;1e-9)
    {
        double m=(l+r)/2;
        if(Check(m))r=m;
        else l=m;
    }
    printf("%0.8lf\n",l);
}


</pre><pre></pre><h2>Problem1491</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,a,b) for(int i=a;i&lt;=b;i++)
#define tr(i,x) for(typeof(x.begin()) i=x.begin();i!=x.end();i++)
#define all(x) x.begin(),x.end()
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;3;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef pair&lt;int,int&gt; ii;
typedef long long ll;
const int maxn=100;
int n,m;
struct State
{
    int dist;
    ll Num;
    State()
    {
        dist=inf;
        Num=0;
    }
    void Set(int d)
    {
        dist=d;
        Num=1;
    }
    void Renew(const State&amp;a,const State&amp;b)
    {
        int ncost=a.dist+b.dist;
        if(ncost&gt;dist) return;
        if(ncost==dist){Num+=a.Num*b.Num;return;}
        dist=ncost;
        Num=a.Num*b.Num;
    }
};
State d[maxn][maxn];
void Init()
{
    cin&gt;&gt;n&gt;&gt;m;int s,t,c;
    while(m--)
    {
        cin&gt;&gt;s&gt;&gt;t&gt;&gt;c;--s;--t;
        d[s][t].Set(c);
        d[t][s].Set(c);
    }
}
inline bool inPath(int pos,int a,int b)
{
    return d[a][pos].dist+d[pos][b].dist==d[a][b].dist;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    rep(k,n)rep(i,n)rep(j,n)
        d[i][j].Renew(d[i][k],d[k][j]);
    double Ans[maxn]={0};
    rep(i,n)rep(j,n)if(i!=j)
    {
        double cost=d[i][j].Num;
        rep(k,n)if(inPath(k,i,j))
        {
            double num=d[i][k].Num*d[k][j].Num;
            Ans[k]+=num/cost;
        }
    }
    rep(i,n)printf("%0.3lf\n",Ans[i]);
}
</pre><pre></pre><h2>Problem1492</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=100000+10,inf=~0U&gt;&gt;1;
double dp[maxn];
struct pnt
{
    double x,y;
    pnt(){}
    pnt(double _x,double _y):
        x(_x),y(_y){}
}P[maxn];
pnt operator-(pnt a,pnt b)
{
    return pnt(a.x-b.x,a.y-b.y);
}
double operator*(pnt a,pnt b)
{
    return a.x*b.y-a.y*b.x;
}
double Cal_K(pnt a,pnt b)
{
    return (a.y-b.y)/(a.x-b.x);
}
int compare(double a,double b)
{
    if(abs(a-b)&gt;1e-8)return a&gt;b?1:-1;
    return 0;
}
bool check(pnt a,pnt b,pnt c)
{
    return compare((b-c)*(a-c),0)&gt;0;
}
int n,s=0,sq;
int id[maxn],pre[maxn],next[maxn];
inline double get(int idx)
{
    return Cal_K(P[id[idx]],P[id[next[idx]]]);
}
double Cal_Value(pnt p,double a,double b)
{
    return a*p.x+b*p.y;
}
int Rands[maxn],p=0;
void BuildRand()
{
    rep(i,n)Rands[i]=rand();
}
int Rand()
{
    if(++p==n)p=0;
    return Rands[p];
}
double FindMax(double a,double b)
{
    double d=-a/b;int t=0;
    if(s==2)return 0;
    double now=get(t);
    rep(i,sq)
    {
        int to=Rand()%s;
        if(next[to]!=1)
        {
            double tmp=get(to);
            if(tmp&gt;d&amp;&amp;tmp&lt;now)
                t=to,now=tmp;
        }
    }
    while(next[t]!=1&amp;&amp;get(t)&gt;d)t=next[t];
    return Cal_Value(P[id[t]],a,b);
}
void remove(int t)
{
    next[pre[t]]=next[t];
    pre[next[t]]=pre[t];
    id[t]=id[s-1];
    pre[t]=pre[s-1];
    next[t]=next[s-1];
    next[pre[t]]=t;
    pre[next[t]]=t;
    s--;
}
void InitList()
{
    id[0]=n+1;P[n+1]=pnt(-inf,-inf);
    id[1]=n+2;P[n+2]=pnt(inf,inf);
    pre[0]=0;next[0]=1;
    pre[1]=0;next[1]=1;
    s=2;
}
void insert(int i)
{
    pnt x=P[i];int t=0;double sx=P[id[t]].x;
    rep(i,sq)
    {
        int to=Rand()%s;
        double nx=P[id[to]].x;
        if(compare(nx,x.x)&lt;=0&amp;&amp;nx&gt;sx)
        {
            t=to;
            sx=nx;
        }
    }
    while(compare(P[id[t]].x,x.x)&lt;=0)t=next[t];
    t=pre[t];
    #define C(a,b,c) check(P[id[a]],P[id[b]],P[id[c]])
    int nx=s;id[nx]=i;
    int l=t,r=next[t],ll,rr;
    if(l!=0&amp;&amp;r!=1&amp;&amp;!C(l,nx,r))return;
    #define Check(x) {if(l==s)l=x;if(r==s)r=x;}
    for(;;)
    {
        ll=pre[l];if(ll==0)break;
        if(!C(ll,l,nx))
        {
            swap(l,ll),remove(ll);
            Check(ll);
        }
        else break;
    }
    for(;;)
    {
        rr=next[r];if(rr==1)break;
        if(!C(nx,r,rr))
        {
            swap(r,rr),remove(rr);
            Check(rr);
        }
        else break;
    }
    nx=s;id[nx]=i;
    next[l]=nx;pre[r]=nx;
    next[nx]=r;pre[nx]=l;
    s++;
}
void reset()
{
    if(sq*sq&lt;n)
        while(sq*sq&lt;s)sq++;
    else
    {
        while(sq*sq&gt;=s)sq--;
        sq++;
    }
}
double getreal()
  {
    double res = 0, t = 1;
    char ch;
    for (ch = getchar(); '0' &lt;= ch &amp;&amp; ch &lt;= '9'; ch = getchar())
      res = res * 10 + int(ch) - 48;
    for (ch = getchar(); '0' &lt;= ch &amp;&amp; ch &lt;= '9'; ch = getchar())
      t /= 10, res += t * (int(ch) - 48);
    return res;
  }
int main()
{
    double a,b,r;
    scanf("%d%lf",&amp;n,dp);getchar();
    BuildRand();
    sq=0;reset();
    InitList();
    for(int i=1;i&lt;=n;i++)
    {
        a=getreal();b=getreal();r=getreal();
        dp[i]=max(dp[i-1],FindMax(a,b));
        P[i].y=dp[i]/(a*r+b);
        P[i].x=P[i].y*r;
        insert(i);reset();
    }
    printf("%0.3lf\n",dp[n]);
}
</pre><pre></pre><h2>Problem1493</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=500000+10;
using namespace std;
int n,c;
struct Func
{
    int a,b;
    Func(){}
    Func(int _a,int _b):
        a(_a),b(_b){a%=n;b%=n;}
    int val(int x)
    {
        return (a*x+b+n*3)%n;
    }
};
Func now;
void Rotate(int k)
{
    now.b-=now.a*k;
    now.b%=n;
}
void Flip()
{
    now.a*=-1;
}
struct info
{
    int Lc,Rc,Count;
    bool e;
    info(bool _e=true):e(_e){}
    void set(int t)
    {
        Lc=Rc=t;
        Count=1;
    }
};
const int maxt=maxn*4;
int A[maxn];
int Mark[maxt];
info I[maxt];
info operator+(const info&amp;L,const info&amp;R)
{
    if(!L.e)return R;
    if(!R.e)return L;
    info F;
    F.Lc=L.Lc;
    F.Rc=R.Rc;
    F.Count=L.Count+R.Count-(L.Rc==R.Lc?1:0);
    return F;
}
void Update(int t)
{
    I[t]=I[t*2]+I[t*2+1];
}
void MarkIt(int t,int col)
{
    Mark[t]=col;
    I[t].set(col);
}
void PushDown(int t)
{
    if(Mark[t]!=-1)
    {
        MarkIt(t*2,Mark[t]);
        MarkIt(t*2+1,Mark[t]);
        Mark[t]=-1;
    }
}
struct seg
{
    int l,r;
    seg(){}
    seg(int _l,int _r):
        l(_l),r(_r){}
    seg left(){return seg(l,l+r&gt;&gt;1);}
    seg right(){return seg(l+r&gt;&gt;1,r);}
    bool contain(seg a)const
    {
        return l&lt;=a.l&amp;&amp;a.r&lt;=r;
    }
    bool inter(seg a)const
    {
        return !(l&gt;=a.r||a.l&gt;=r);
    }
}root;
void change(int t,seg a,seg s,int col)
{
    if(!a.inter(s))return;
    if(s.contain(a)){MarkIt(t,col);return;}
    PushDown(t);
    change(t*2,a.left(),s,col);
    change(t*2+1,a.right(),s,col);
    Update(t);
}
info Ask(int t,seg a,seg s)
{
    if(!a.inter(s))return info(false);
    if(s.contain(a))return I[t];
    PushDown(t);
    return Ask(t*2,a.left(),s)+Ask(t*2+1,a.right(),s);
}
void Build(int t,seg s)
{
    Mark[t]=-1;
    if(s.l+1==s.r)
    {
        I[t].set(A[s.l]);
        return;
    }
    Build(t*2,s.left());
    Build(t*2+1,s.right());
    Update(t);
}
void Swap(int i,int j)
{
    i=now.val(i);j=now.val(j);
    seg si(i,i+1),sj(j,j+1);
    int ci=Ask(1,root,si).Lc,cj=Ask(1,root,sj).Lc;
    change(1,root,si,cj);
    change(1,root,sj,ci);
}
void Paint(int i,int j,int col)
{
    i=now.val(i);j=now.val(j);
    if(now.a==-1)swap(i,j);
    if(i&gt;j)change(1,root,seg(i,n),col),change(1,root,seg(0,j+1),col);
    else change(1,root,seg(i,j+1),col);
}
void CountS(int i,int j)
{
    i=now.val(i);j=now.val(j);
    if(now.a==-1)swap(i,j);
    info ans;
    if(i&gt;j)ans=Ask(1,root,seg(i,n))+Ask(1,root,seg(0,j+1));
    else ans=Ask(1,root,seg(i,j+1));
    printf("%d\n",ans.Count);
}
void Count()
{
    info ans=I[1];
    if(ans.Count&gt;1&amp;&amp;ans.Lc==ans.Rc)
        ans.Count--;
    printf("%d\n",ans.Count);
}
void Init()
{
    int c;
    scanf("%d%d",&amp;n,&amp;c);
    rep(i,n)scanf("%d",A+i);
    root=seg(0,n);
    now=Func(1,0);
}
void Solve()
{
    Build(1,root);
    int q,l,r,k,c;scanf("%d",&amp;q);
    char cmd[100];
    while(q--)
    {
        scanf(" ");
        scanf("%s",cmd);
        if(cmd[0]=='R')
        {
            scanf("%d",&amp;k);
            Rotate(k);
        }
        else if(cmd[0]=='F')
        {
            Flip();
        }
        else if(cmd[0]=='S')
        {
            scanf("%d%d",&amp;l,&amp;r);
            --l;--r;
            Swap(l,r);
        }
        else if(cmd[0]=='P')
        {
            scanf("%d%d%d",&amp;l,&amp;r,&amp;c);
            --l;--r;
            Paint(l,r,c);
        }
        else if(cmd[1]=='S')
        {
            scanf("%d%d",&amp;l,&amp;r);
            --l;--r;
            CountS(l,r);
        }
        else
        {
            Count();
        }
    }
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


</pre><pre></pre><h2>Problem1494</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
const int maxk=5;
typedef long long ll;
ll n;int k;
struct Con
{
    int A[maxk+1],n;
    void Set(int _n)
    {
        n=_n;rep(i,n)A[i]=i;
    }
    void ReMark()
    {
        int F[maxk+1],cnt=0;
        memset(F,-1,sizeof F);
        rep(i,n)
        {
            if(F[A[i]]==-1)
                F[A[i]]=cnt++;
            A[i]=F[A[i]];
        }
    }
    bool Connect(int u,int v)
    {
        if(A[u]==A[v])return false;
        int a=A[u];
        rep(i,n)if(A[i]==a)A[i]=A[v];
        ReMark();
        return true;
    }
    bool Seperate(int u)
    {
        rep(i,n)if(i!=u&amp;&amp;A[i]==A[u])
            return false;
        return true;
    }
    bool operator&lt;(const Con&amp;a)const
    {
        rep(i,n)
        {
            if(A[i]&lt;a.A[i])return true;
            if(A[i]&gt;a.A[i])return false;
        }
        return false;
    }
    void operator=(const Con&amp;a)
    {
        memcpy(A,a.A,sizeof A);
        n=a.n;
    }
    void add()
    {
        A[n++]=n;
    }
    void move()
    {
        n--;
        rep(i,n)A[i]=A[i+1];
        ReMark();
    }
    bool Single()
    {
        rep(i,n)if(A[i]!=A[0])return false;
        return true;
    }
};
map&lt;Con,int&gt; Map;
vector&lt;Con&gt; Cons;
vector&lt;int&gt; Num;
int id(Con x)
{
    return lower_bound(All(Cons),x)-Cons.begin();
}
void Dfs(Con now,int ent)
{
    if(ent==k*k)
    {
        Map[now]++;
        return;
    }
    int u=ent/k,v=ent%k;
    if(u&gt;=v)
    {
        Dfs(now,ent+1);
        return;
    }
    Con nxt=now;
    if(nxt.Connect(u,v))
        Dfs(nxt,ent+1);
    Dfs(now,ent+1);
}
void FindAllSet()
{
    Con now;
    now.Set(k);
    Dfs(now,0);
    for(map&lt;Con,int&gt;::iterator it=Map.begin();it!=Map.end();it++)
        Cons.pb(it-&gt;first),Num.pb(it-&gt;second);
}
const int maxs=52,mod=65521;
ll tmp[maxs][maxs];
struct Mat
{
    ll A[maxs][maxs];
    int n;
    Mat(){}
    Mat(int _n)
    {
        n=_n;
        memset(A,0,sizeof A);
    }
    void operator*=(const Mat&amp;that)
    {
        memset(tmp,0,sizeof tmp);
        rep(i,n)rep(j,n)rep(k,n)
            tmp[i][j]+=A[i][k]*that.A[k][j];
        rep(i,n)rep(j,n)tmp[i][j]%=mod;
        memcpy(A,tmp,sizeof A);
    }
}Orig;
Mat UnitMat(int _n)
{
    Mat t(_n);
    rep(i,t.n)
        t.A[i][i]=1;
    return t;
}
void Power(Mat&amp;ret,ll e)
{
    if(e==0){ret=UnitMat(Orig.n);return;}
    Power(ret,e/2);ret*=ret;
    if(e&amp;1)ret*=Orig;
}
void BuildMat()
{
    Orig=Mat(Cons.size());
    rep(i,Cons.size())
    {
        Con now=Cons[i];
        rep(con,(1&lt;&lt;k))
        {
            Con nxt=now;
            nxt.add();
            bool ok=true;
            rep(j,k)if(con&amp;(1&lt;&lt;j))
            {
                if(!nxt.Connect(j,k))
                    ok=false;
            }
            if(nxt.Seperate(0)||(!ok))continue;
            nxt.move();
            Orig.A[i][id(nxt)]++;
        }
    }
}
void Init()
{
    cin&gt;&gt;k&gt;&gt;n;
}
void Solve()
{
    Mat ret;
    Power(ret,n-k);
    int ansid;
    rep(i,Cons.size())
        if(Cons[i].Single())
            ansid=i;
    ll ans=0;
    rep(i,Cons.size())
        ans+=ll(Num[i])*ret.A[i][ansid],ans%=mod;
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    Init();
    FindAllSet();
    BuildMat();
    Solve();
}
</pre><pre></pre><h2>Problem1495</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;3,maxn=10,maxs=1&lt;&lt;maxn;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int A[maxs],C[maxs],F[maxs][maxs],n,s;
void Input_Data()
{
    scanf("%d",&amp;n);s=1&lt;&lt;n;
    rep(i,s)scanf("%d",A+i);
    rep(i,s)scanf("%d",C+i);
    rep(i,s)
        for(int j=i+1;j&lt;s;j++)
            scanf("%d",&amp;F[i][j]);
}
int S[maxs][maxn]={};
void Calc_S(int i,int j)
{
    int a=i+s,b=j+s;
    for(int d=1;d&lt;=n;d++)
        if((a&gt;&gt;d)==(b&gt;&gt;d))
        {
            S[i][n-d]+=F[i][j];
            S[j][n-d]+=F[i][j];
            return;
        }
}
void Pre_Calc()
{
    rep(i,s)
        for(int j=i+1;j&lt;s;j++)
            Calc_S(i,j);
}
struct State
{
    int Dep;
    int Set,numA;
    State(int _Dep,int _Set,int _numA):
        Dep(_Dep),Set(_Set),numA(_numA){}
    State(){}
    bool Legal()
    {
        return (s&gt;&gt;(Dep))&gt;=numA;
    }
    int Hash()
    {
        return (numA&lt;&lt;Dep)+Set;
    }
};
int Mem[maxs*2][maxs*2];
int Dp(int at,State st)
{
    if(!st.Legal())return inf;
    int&amp;mem=Mem[at][st.Hash()];
    if(mem!=-1)return mem;
    if(at&gt;=s)
    {
        int i=at-s;int rA=0,rB=0;
        if(A[i])rA=C[i];else rB=C[i];
        rep(j,n)
            if(st.Set&amp;(1&lt;&lt;j))
                rB+=S[i][j];
            else
                rA+=S[i][j];
        if(st.numA)
            return mem=rA;
        else
            return mem=rB;
    }
    else
    {
        int nA=st.numA,ret;
        int L=at*2,R=L+1;
        int type=st.numA&gt;=(s&gt;&gt;(st.Dep+1));
        int NewSet=st.Set|(type&lt;&lt;(st.Dep));
        mem=inf;
        rep(La,nA+1)
        {
            ret=Dp(L,State(st.Dep+1,NewSet,La))+
                Dp(R,State(st.Dep+1,NewSet,nA-La));
            if(ret&lt;mem)mem=ret;
        }
    }
    return mem;
}
void Solve()
{
    int Ans=inf;
    rep(A,s+1)
    {
        int ret=Dp(1,State(0,0,A));
        if(ret&lt;Ans)Ans=ret;
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Input_Data();
    Pre_Calc();
    memset(Mem,-1,sizeof Mem);
    Solve();
}


</pre><pre></pre><h2>Problem1497</h2><pre>#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;

int h[55002], hn[55003] = {}, n, res = 0;
struct node
{
    int v, c, rev;
};
vector&lt;node&gt; a[55002];

int ShortestAugmentingPath(int u, int delta)
{
    if (u == n-1) return delta;
    int old_delta = delta, min_h = n-1, new_delta;
    for (vector&lt;node&gt;::iterator it = a[u].begin(); it != a[u].end(); ++it)
    {
        if (it-&gt;c &lt;= 0) continue;
        if (h[it-&gt;v]+1 == h[u])
        {
            new_delta = min(delta, it-&gt;c);
            new_delta = ShortestAugmentingPath(it-&gt;v, new_delta);
            it-&gt;c -= new_delta;
            a[it-&gt;v][it-&gt;rev].c += new_delta;
            delta -= new_delta;
            if (h[0] &gt;= n || !delta) return old_delta-delta;
        }
        if (h[it-&gt;v] &lt; min_h) min_h = h[it-&gt;v];
    }
    if (!--hn[h[u]]) h[0] = n;
    h[u] = min_h+1;
    ++hn[h[u]];
    return old_delta-delta;
}

int main()
{
    //freopen("in","r",stdin);
    int m, t, u, v, w;
    scanf("%d%d", &amp;n, &amp;m);
    t = m+n+1;
    for (int i = 1; i &lt;= n; ++i)
    {
        scanf("%d", &amp;w);
        a[m+i].push_back((node){t, w, a[t].size()});
        a[t].push_back((node){m+i, 0, a[m+i].size()-1});
    }
    for (int i = 1; i &lt;= m; ++i)
    {
        scanf("%d%d%d", &amp;u, &amp;v, &amp;w);
        res += w;
        a[0].push_back((node){i, w, a[i].size()});
        a[i].push_back((node){0, 0, a[0].size()-1});
        a[i].push_back((node){m+u, INT_MAX, a[m+u].size()});
        a[m+u].push_back((node){i, 0, a[i].size()-2});
        a[i].push_back((node){m+v, INT_MAX, a[m+v].size()});
        a[m+v].push_back((node){i, 0, a[i].size()-3});
    }
    n += m+2;
    hn[0] = n;
    while (h[0] &lt; n)
        res -= ShortestAugmentingPath(0, INT_MAX);
    printf("%d\n", res);
}
</pre><pre></pre><h2>Problem1497</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=60000,inf=~0U&gt;&gt;1;
struct Edge
{
    int t,c;
    Edge(int _t,int _c,Edge* _next):
        t(_t),next(_next),c(_c){}
    Edge*next,*op;
}*E[maxn]={0};
int n,m,vs,vt,v,Ans=0;
void InsEdge(int s,int t,int c)
{
    E[s]=new Edge(t,c,E[s]);
    E[t]=new Edge(s,0,E[t]);
    E[s]-&gt;op=E[t];E[t]-&gt;op=E[s];
}
inline int T(int i){return i;}
inline int C(int i){return n+i;}
void Init()
{
    scanf("%d%d",&amp;n,&amp;m);int s,t,c;
    v=n+m+2;vs=v-1;vt=v-2;
    rep(i,n)scanf("%d",&amp;c),InsEdge(T(i),vt,c);
    rep(i,m)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);--s;--t;
        InsEdge(C(i),T(s),inf);
        InsEdge(C(i),T(t),inf);
        InsEdge(vs,C(i),c);
        Ans+=c;
    }
}
int h[maxn],vh[maxn];
int aug(int no,int m)
{
    if(no==vt) return m;
    int l=m,minh=v;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;c)
    {
        if(h[no]==h[i-&gt;t]+1)
        {
            int d=aug(i-&gt;t,min(l,i-&gt;c));
            i-&gt;c-=d,i-&gt;op-&gt;c+=d,l-=d;
            if(!l||h[vs]&gt;=v) return m-l;
        }
        minh=min(minh,h[i-&gt;t]+1);
    }
    if(!--vh[h[no]]) h[vs]=v;
    vh[h[no]=minh]++;
    return m-l;
}
int CalFlow()
{
    memset(h,0,sizeof(h));
    memset(vh,0,sizeof(vh));
    vh[0]=v;int flow=0;
    while(h[vs]&lt;v) flow+=aug(vs,inf);
    return flow;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    cout&lt;&lt;Ans-CalFlow()&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1498</h2><pre>import java.math.BigInteger;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		new Main().run();
	}

	void debug(Object a) {
		System.out.println(a);
	}

	void run() {
		Scanner scan = new Scanner(System.in);
		int nColors = scan.nextInt();
		int nOperations = scan.nextInt();
		int nAdd = scan.nextInt();
		int[] am = new int[nColors];
		int sum = 0;
		for (int i = 0; i &lt; nColors; ++i) {
			am[i] = scan.nextInt();
		}
		for (int a : am) {
			sum += a;
		}
		BigInteger A = BigInteger.ONE, B = BigInteger.ONE;
		for (int i = 0; i &lt; nOperations; ++i) {
			int x = scan.nextInt(), y = scan.nextInt();
			--y;
			A = A.multiply(BigInteger.valueOf(am[y]));
			B = B.multiply(BigInteger.valueOf(sum));
			am[y] += nAdd;
			sum += nAdd;
		}

		BigInteger g = A.gcd(B);
		A = A.divide(g);
		B = B.divide(g);

		System.out.println(A + "/" + B);
	}
}
</pre><pre></pre><h2>Problem1500</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#define OK puts("OK")
using namespace std;
namespace Solve
{
    namespace Constant
    {
        const int ND_MAX=500000+10;
        const int inf=~0U&gt;&gt;2;
        const int CM_MAX=100;
    }
    namespace Function
    {
        inline int Max(int x,int y)
        {
            int m=(x-y)&gt;&gt;31;
            return y&amp;m|x&amp;~m;
        }
        template&lt;class T&gt;
        inline void Swap(T&amp;a,T&amp;b)
        {
            T c=a;a=b;b=c;
        }
    }
    namespace Scanner
    {
        inline void scan_str(char*s)
        {
            char c;while(c=getchar(),c==' '||c=='\n');*s++=c;
            while(c=getchar(),c!=' '&amp;&amp;c!='\n')*s++=c;*s++='\0';
        }
        inline void scan(int&amp;t)
        {
            int sign=1;char c;
            while(c=getchar(),c&lt;'0'||c&gt;'9')
                if(c=='-')break;
            if(c=='-')t=0,sign=-1;
            else t=c-'0';
            while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
            t*=sign;
        }
    }
    namespace Splay_Data
    {
        using namespace Solve::Function;
        using namespace Solve::Constant;
        struct Info
        {
            int L_Max,R_Max,Sum,M_Max,Val;
            int Size;
            void Mark_Same(int Same)
            {
                Sum=Same*Size;Val=Same;
                L_Max=R_Max=M_Max=Max(Sum,Same);
            }
            void Mark_Rev()
            {
                Swap(L_Max,R_Max);
            }
            void Set_Single(int _Val)
            {
                Size=1;
                Mark_Same(_Val);
            }
        }None;
        void Update_Info(Info&amp;F,const Info&amp;L,const Info&amp;R)
        {
            F.Size=L.Size+R.Size+1;
            F.Sum=L.Sum+R.Sum+F.Val;
            int L_ch=Max(0,L.R_Max);
            int R_ch=Max(0,R.L_Max);
            F.L_Max=Max(L.L_Max,L.Sum+F.Val+R_ch);
            F.R_Max=Max(R.R_Max,R.Sum+F.Val+L_ch);
            F.M_Max=Max(L.M_Max,R.M_Max);
            F.M_Max=Max(F.M_Max,L_ch+F.Val+R_ch);
        }
        struct Mark
        {
            bool Rev;
            bool is_Same;
            int Same;
            void Mark_Same(int _Same)
            {
                Same=_Same;
                is_Same=true;
            }
            void Mark_Rev()
            {
                Rev^=1;
            }
            void Clear()
            {
                Rev=is_Same=false;
            }
        };
        struct Node
        {
            Node*p,*c[2];
            bool d()
            {
                return p-&gt;c[1]==this;
            }
            void sc(Node*_c,bool _d)
            {
                c[_d]=_c;
                _c-&gt;p=this;
            }
            Info I;
            Mark M;
        }*Null,*root;
        namespace Memory
        {
            Node Mem[ND_MAX];
            Node*Stack[ND_MAX];
            int top;
            void init_Memory()
            {
                for(int i=0;i&lt;ND_MAX;i++)
                    Stack[i]=Mem+i;
                top=ND_MAX;
            }
            inline Node*get_New_Node()
            {
                return Stack[--top];
            }
            inline void Delete_Node(Node*t)
            {
                Stack[top++]=t;
            }
        }
        void Mark_Same(Node*t,int Same)
        {
            if(t==Null)return;
            t-&gt;M.Mark_Same(Same);
            t-&gt;I.Mark_Same(Same);
        }
        void Mark_Rev(Node*t)
        {
            if(t==Null)return;
            t-&gt;I.Mark_Rev();
            t-&gt;M.Mark_Rev();
            Swap(t-&gt;c[0],t-&gt;c[1]);
        }
        void Push_Down(Node*t)
        {
            if(t==Null)return;
            Mark&amp;m=t-&gt;M;
            if(m.is_Same)
            {
                Mark_Same(t-&gt;c[0],m.Same);
                Mark_Same(t-&gt;c[1],m.Same);
                m.is_Same=false;
            }
            if(m.Rev)
            {
                Mark_Rev(t-&gt;c[0]);
                Mark_Rev(t-&gt;c[1]);
                m.Rev=false;
            }
        }
        void Update_Node(Node*t)
        {
            if(t==Null)return;
            Update_Info(t-&gt;I,t-&gt;c[0]-&gt;I,t-&gt;c[1]-&gt;I);
        }
        Node*New_Node(int val)
        {
            Node*ret=Memory::get_New_Node();
            ret-&gt;I.Set_Single(val);
            ret-&gt;c[0]=ret-&gt;c[1]=ret-&gt;p=Null;
            ret-&gt;M.Clear();
            return ret;
        }
        void Rotate(Node*t)
        {
            Node*p=t-&gt;p;bool d=t-&gt;d();
            Push_Down(p);Push_Down(t);
            p-&gt;sc(t-&gt;c[!d],d);
            if(p-p==Null)t-&gt;p=Null;
            else p-&gt;p-&gt;sc(t,p-&gt;d());
            t-&gt;sc(p,!d);
            Update_Node(p);
            if(p==root)root=t;
        }
        void Splay(Node*t,Node*f)
        {
            for(Push_Down(t);t-&gt;p!=f;)
            {
                if(t-&gt;p-&gt;p==f)Rotate(t);
                else t-&gt;d()==t-&gt;p-&gt;d()?
                    (Rotate(t-&gt;p),Rotate(t)):(Rotate(t),Rotate(t));
            }
            Update_Node(t);
        }
        Node*Select(int k)
        {
            for(Node*t=root;;)
            {
                Push_Down(t);
                int cnt=t-&gt;c[0]-&gt;I.Size;
                if(cnt==k)return t;
                t=t-&gt;c[k&gt;cnt];
                if(k&gt;cnt)k-=cnt+1;
            }
        }
        Node*&amp;get_Seq(int l,int r)
        {
            Node*L=Select(l);//OK;
            Splay(L,Null);//OK;
            Node*R=Select(r);//OK;
            Splay(R,root);//OK;
            return root-&gt;c[1]-&gt;c[0];
        }
        void init_Null()
        {
            Null=New_Node(-inf);
            Null-&gt;I.Size=Null-&gt;I.Sum=0;
            Null-&gt;c[0]=Null-&gt;c[1]=Null-&gt;p=Null;
        }
        void init_Splay()
        {
            Memory::init_Memory();
            init_Null();
            root=New_Node(-inf+1);
            Node*End=New_Node(-inf+1);
            root-&gt;sc(End,1);
            Splay(End,Null);
        }
        Node*Make_Tree(int*l,int*r)
        {
            if(l&gt;=r)return Null;
            if(l+1==r)
            {
                return New_Node(*l);
            }
            int*m=l+(r-l)/2;
            Node*t=New_Node(*m);
            t-&gt;sc(Make_Tree(l,m),0);
            t-&gt;sc(Make_Tree(m+1,r),1);
            Update_Node(t);
            return t;
        }
    }
    namespace Work
    {
        using namespace Solve::Splay_Data;
        using namespace Solve::Scanner;
        using namespace Solve::Constant;
        char cmd[CM_MAX];
        int N,M,A[ND_MAX];
        void Insert_Num(int tot,int pos)
        {
            for(int i=0;i&lt;tot;i++)
                scan(A[i]);
            Node*t_root=Make_Tree(A,A+tot);
            get_Seq(pos,pos+1);
            root-&gt;c[1]-&gt;sc(t_root,0);
            Splay(t_root,Null);
        }
        void Delete_All(Node*t_root)
        {
            static Node*Q[ND_MAX];
            static int h,t;
            for(h=t=0,Q[t++]=t_root;h&lt;t;h++)
            {
                Node*x=Q[h];
                if(x-&gt;c[0]!=Null)Q[t++]=x-&gt;c[0];
                if(x-&gt;c[1]!=Null)Q[t++]=x-&gt;c[1];
                Memory::Delete_Node(x);
            }
        }
        void Delete_Num(int tot,int pos)
        {
            Node*t_root=get_Seq(pos-1,pos+tot);
            //cout&lt;&lt;pos&lt;&lt;" "&lt;&lt;pos+tot&lt;&lt;endl;
            //cout&lt;&lt;t_root-&gt;I.Size&lt;&lt;endl;
            t_root-&gt;p-&gt;sc(Null,0);
            Splay(root-&gt;c[1],Null);
            Delete_All(t_root);
        }
        void Make_Same(int tot,int pos,int same)
        {
            Node*t_root=get_Seq(pos-1,pos+tot);
            Mark_Same(t_root,same);
            Splay(t_root,Null);
        }
        void Make_Rev(int tot,int pos)
        {
            Node*t_root=get_Seq(pos-1,pos+tot);
            Mark_Rev(t_root);
            Splay(t_root,Null);
        }
        void Calc_Sum(int tot,int pos)
        {
            Node*t_root=get_Seq(pos-1,pos+tot);
            printf("%d\n",t_root-&gt;I.Sum);
        }
        void Calc_Max()
        {
            printf("%d\n",root-&gt;I.M_Max);
        }
        void Show_Tree()
        {
            static Node*Q[ND_MAX];
            static int h,t;
            cout&lt;&lt;"Let's See"&lt;&lt;endl;
            for(h=t=0,Q[t++]=root;h&lt;t;h++)
            {
                Node*x=Q[h];
                cout&lt;&lt;x-&gt;I.Val&lt;&lt;" "&lt;&lt;x-&gt;I.Size&lt;&lt;endl;
                cout&lt;&lt;x-&gt;c[0]-&gt;I.Val&lt;&lt;"/"&lt;&lt;x-&gt;c[1]-&gt;I.Val&lt;&lt;endl;
                if(x-&gt;c[0]!=Null)Q[t++]=x-&gt;c[0];
                if(x-&gt;c[1]!=Null)Q[t++]=x-&gt;c[1];
            }
            cout&lt;&lt;"End"&lt;&lt;endl;
        }
        void Solve()
        {
            scan(N);scan(M);
            //cout&lt;&lt;N&lt;&lt;" "&lt;&lt;M&lt;&lt;endl;
            init_Splay();
            Insert_Num(N,0);int tot,pos,val;
            //Show_Tree();
            while(M--)
            {
                scan_str(cmd);
                //cout&lt;&lt;cmd&lt;&lt;endl;
                switch(cmd[0])
                {
                    case 'I':
                        scan(pos);scan(tot);
                        Insert_Num(tot,pos);
                        break;
                    case 'D':
                        scan(pos);scan(tot);
                        Delete_Num(tot,pos);
                        break;
                    case 'R':
                        scan(pos);scan(tot);
                        Make_Rev(tot,pos);
                        break;
                    case 'G':
                        scan(pos);scan(tot);
                        Calc_Sum(tot,pos);
                        break;
                    case 'M':
                        if(cmd[2]=='X')
                            Calc_Max();
                        else
                        {
                            scan(pos);scan(tot);scan(val);
                            Make_Same(tot,pos,val);
                        }
                        break;
                }
                //Show_Tree();
            }
        }
    }
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    Solve::Work::Solve();
}
</pre><pre></pre><h2>Problem1500</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#define OK puts("OK")
using namespace std;
namespace Solve
{
    namespace Constant
    {
        const int ND_MAX=500000+10;
        const int inf=~0U&gt;&gt;2;
        const int CM_MAX=100;
    }
    namespace Function
    {
        inline int Max(int x,int y)
        {
            int m=(x-y)&gt;&gt;31;
            return y&amp;m|x&amp;~m;
        }
        template&lt;class T&gt;
        inline void Swap(T&amp;a,T&amp;b)
        {
            T c=a;a=b;b=c;
        }
    }
    namespace IO
    {
        namespace Scanner
        {
            inline void scan_str(char*s)
            {
                char c;while(c=getchar(),c==' '||c=='\n');*s++=c;
                while(c=getchar(),c!=' '&amp;&amp;c!='\n')*s++=c;*s++='\0';
            }
            inline void scan(int&amp;t)
            {
                int sign=1;char c;
                while(c=getchar(),c&lt;'0'||c&gt;'9')
                    if(c=='-')break;
                if(c=='-')t=0,sign=-1;
                else t=c-'0';
                while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
                t*=sign;
            }
        }
        namespace Printer
        {
            inline void print_int(int t)
            {
                static int a[20];int p=0;
                if(!t){puts("0");return;}
                if(t&lt;0)
                {
                    putchar('-');
                    t=-t;
                }
                while(t)a[p++]=t%10,t/=10;
                for(int i=p-1;i&gt;=0;i--)
                    putchar('0'+a[i]);
                putchar('\n');
            }
        }
    }
    namespace Splay_Data
    {
        using namespace Solve::Function;
        using namespace Solve::Constant;
        struct Info
        {
            int L_Max,R_Max,Sum,M_Max,Val;
            int Size;
            void Mark_Same(int Same)
            {
                Sum=Same*Size;Val=Same;
                L_Max=R_Max=M_Max=Max(Sum,Same);
            }
            void Mark_Rev()
            {
                Swap(L_Max,R_Max);
            }
            void Set_Single(int _Val)
            {
                Size=1;
                Mark_Same(_Val);
            }
        }None;
        void Update_Info(Info&amp;F,const Info&amp;L,const Info&amp;R)
        {
            F.Size=L.Size+R.Size+1;
            F.Sum=L.Sum+R.Sum+F.Val;
            int L_ch=Max(0,L.R_Max);
            int R_ch=Max(0,R.L_Max);
            F.L_Max=Max(L.L_Max,L.Sum+F.Val+R_ch);
            F.R_Max=Max(R.R_Max,R.Sum+F.Val+L_ch);
            F.M_Max=Max(L.M_Max,R.M_Max);
            F.M_Max=Max(F.M_Max,L_ch+F.Val+R_ch);
        }
        struct Mark
        {
            bool Rev;
            bool is_Same;
            int Same;
            void Mark_Same(int _Same)
            {
                Same=_Same;
                is_Same=true;
            }
            void Mark_Rev()
            {
                Rev^=1;
            }
            void Clear()
            {
                Rev=is_Same=false;
            }
        };
        struct Node
        {
            Node*p,*c[2];
            bool d()
            {
                return p-&gt;c[1]==this;
            }
            void sc(Node*_c,bool _d)
            {
                c[_d]=_c;
                _c-&gt;p=this;
            }
            Info I;
            Mark M;
        }*Null,*root;
        namespace Memory
        {
            Node Mem[ND_MAX];
            Node*Stack[ND_MAX];
            int top;
            void init_Memory()
            {
                for(int i=0;i&lt;ND_MAX;i++)
                    Stack[i]=Mem+i;
                top=ND_MAX;
            }
            inline Node*get_New_Node()
            {
                return Stack[--top];
            }
            inline void Delete_Node(Node*t)
            {
                Stack[top++]=t;
            }
        }
        void Mark_Same(Node*t,int Same)
        {
            if(t==Null)return;
            t-&gt;M.Mark_Same(Same);
            t-&gt;I.Mark_Same(Same);
        }
        void Mark_Rev(Node*t)
        {
            if(t==Null)return;
            t-&gt;I.Mark_Rev();
            t-&gt;M.Mark_Rev();
            Swap(t-&gt;c[0],t-&gt;c[1]);
        }
        void Push_Down(Node*t)
        {
            if(t==Null)return;
            Mark&amp;m=t-&gt;M;
            if(m.is_Same)
            {
                Mark_Same(t-&gt;c[0],m.Same);
                Mark_Same(t-&gt;c[1],m.Same);
                m.is_Same=false;
            }
            if(m.Rev)
            {
                Mark_Rev(t-&gt;c[0]);
                Mark_Rev(t-&gt;c[1]);
                m.Rev=false;
            }
        }
        void Update_Node(Node*t)
        {
            if(t==Null)return;
            Update_Info(t-&gt;I,t-&gt;c[0]-&gt;I,t-&gt;c[1]-&gt;I);
        }
        Node*New_Node(int val)
        {
            Node*ret=Memory::get_New_Node();
            ret-&gt;I.Set_Single(val);
            ret-&gt;c[0]=ret-&gt;c[1]=ret-&gt;p=Null;
            ret-&gt;M.Clear();
            return ret;
        }
        void Rotate(Node*t)
        {
            Node*p=t-&gt;p;bool d=t-&gt;d();
            Push_Down(p);Push_Down(t);
            p-&gt;sc(t-&gt;c[!d],d);
            if(p-p==Null)t-&gt;p=Null;
            else p-&gt;p-&gt;sc(t,p-&gt;d());
            t-&gt;sc(p,!d);
            Update_Node(p);
            if(p==root)root=t;
        }
        void Splay(Node*t,Node*f)
        {
            for(Push_Down(t);t-&gt;p!=f;)
            {
                if(t-&gt;p-&gt;p==f)Rotate(t);
                else t-&gt;d()==t-&gt;p-&gt;d()?
                    (Rotate(t-&gt;p),Rotate(t)):(Rotate(t),Rotate(t));
            }
            Update_Node(t);
        }
        Node*Select(int k)
        {
            for(Node*t=root;;)
            {
                Push_Down(t);
                int cnt=t-&gt;c[0]-&gt;I.Size;
                if(cnt==k)return t;
                t=t-&gt;c[k&gt;cnt];
                if(k&gt;cnt)k-=cnt+1;
            }
        }
        Node*&amp;get_Seq(int l,int r)
        {
            Node*L=Select(l);//OK;
            Splay(L,Null);//OK;
            Node*R=Select(r);//OK;
            Splay(R,root);//OK;
            return root-&gt;c[1]-&gt;c[0];
        }
        void init_Null()
        {
            Null=New_Node(-inf);
            Null-&gt;I.Size=Null-&gt;I.Sum=0;
            Null-&gt;c[0]=Null-&gt;c[1]=Null-&gt;p=Null;
        }
        void init_Splay()
        {
            Memory::init_Memory();
            init_Null();
            root=New_Node(-inf+1);
            Node*End=New_Node(-inf+1);
            root-&gt;sc(End,1);
            Splay(End,Null);
        }
        Node*Make_Tree(int*l,int*r)
        {
            if(l&gt;=r)return Null;
            if(l+1==r)
            {
                return New_Node(*l);
            }
            int*m=l+(r-l)/2;
            Node*t=New_Node(*m);
            t-&gt;sc(Make_Tree(l,m),0);
            t-&gt;sc(Make_Tree(m+1,r),1);
            Update_Node(t);
            return t;
        }
    }
    namespace Work
    {
        using namespace Solve::Splay_Data;
        using namespace Solve::IO::Scanner;
        using namespace Solve::IO::Printer;
        char cmd[CM_MAX];
        int N,M,A[ND_MAX];
        void Insert_Num(int tot,int pos)
        {
            for(int i=0;i&lt;tot;i++)
                scan(A[i]);
            Node*t_root=Make_Tree(A,A+tot);
            get_Seq(pos,pos+1);
            root-&gt;c[1]-&gt;sc(t_root,0);
            Splay(t_root,Null);
        }
        void Delete_All(Node*t_root)
        {
            static Node*Q[ND_MAX];
            static int h,t;
            for(h=t=0,Q[t++]=t_root;h&lt;t;h++)
            {
                Node*x=Q[h];
                if(x-&gt;c[0]!=Null)Q[t++]=x-&gt;c[0];
                if(x-&gt;c[1]!=Null)Q[t++]=x-&gt;c[1];
                Memory::Delete_Node(x);
            }
        }
        void Delete_Num(int tot,int pos)
        {
            Node*t_root=get_Seq(pos-1,pos+tot);
            //cout&lt;&lt;pos&lt;&lt;" "&lt;&lt;pos+tot&lt;&lt;endl;
            //cout&lt;&lt;t_root-&gt;I.Size&lt;&lt;endl;
            t_root-&gt;p-&gt;sc(Null,0);
            Splay(root-&gt;c[1],Null);
            Delete_All(t_root);
        }
        void Make_Same(int tot,int pos,int same)
        {
            Node*t_root=get_Seq(pos-1,pos+tot);
            Mark_Same(t_root,same);
            Splay(t_root,Null);
        }
        void Make_Rev(int tot,int pos)
        {
            Node*t_root=get_Seq(pos-1,pos+tot);
            Mark_Rev(t_root);
            Splay(t_root,Null);
        }
        void Calc_Sum(int tot,int pos)
        {
            Node*t_root=get_Seq(pos-1,pos+tot);
            print_int(t_root-&gt;I.Sum);
        }
        void Calc_Max()
        {
            print_int(root-&gt;I.M_Max);
        }
        void Show_Tree()
        {
            static Node*Q[ND_MAX];
            static int h,t;
            cout&lt;&lt;"Let's See"&lt;&lt;endl;
            for(h=t=0,Q[t++]=root;h&lt;t;h++)
            {
                Node*x=Q[h];
                cout&lt;&lt;x-&gt;I.Val&lt;&lt;" "&lt;&lt;x-&gt;I.Size&lt;&lt;endl;
                cout&lt;&lt;x-&gt;c[0]-&gt;I.Val&lt;&lt;"/"&lt;&lt;x-&gt;c[1]-&gt;I.Val&lt;&lt;endl;
                if(x-&gt;c[0]!=Null)Q[t++]=x-&gt;c[0];
                if(x-&gt;c[1]!=Null)Q[t++]=x-&gt;c[1];
            }
            cout&lt;&lt;"End"&lt;&lt;endl;
        }
        void Solve()
        {
            scan(N);scan(M);
            //cout&lt;&lt;N&lt;&lt;" "&lt;&lt;M&lt;&lt;endl;
            init_Splay();
            Insert_Num(N,0);int tot,pos,val;
            //Show_Tree();
            while(M--)
            {
                scan_str(cmd);
                //cout&lt;&lt;cmd&lt;&lt;endl;
                switch(cmd[0])
                {
                    case 'I':
                        scan(pos);scan(tot);
                        Insert_Num(tot,pos);
                        break;
                    case 'D':
                        scan(pos);scan(tot);
                        Delete_Num(tot,pos);
                        break;
                    case 'R':
                        scan(pos);scan(tot);
                        Make_Rev(tot,pos);
                        break;
                    case 'G':
                        scan(pos);scan(tot);
                        Calc_Sum(tot,pos);
                        break;
                    case 'M':
                        if(cmd[2]=='X')
                            Calc_Max();
                        else
                        {
                            scan(pos);scan(tot);scan(val);
                            Make_Same(tot,pos,val);
                        }
                        break;
                }
                //Show_Tree();
            }
        }
    }
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    Solve::Work::Solve();
}
</pre><pre></pre><h2>Problem1501</h2><pre>/*
 * [NOI2005]智慧珠游戏.cpp
 *
 *  Created on: 2011-3-4
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;cstdlib&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
typedef vector&lt;vector&lt;bool&gt; &gt; Board;

#define DEBUG

Board get(string*rows, int nRow) {
	int nCol = rows-&gt;size();
	Board board(nRow, vector&lt;bool&gt; (nCol));
	for (int r = 0; r &lt; nRow; ++r) {
		for (int c = 0; c &lt; nCol; ++c) {
			board[r][c] = rows[r][c] == '*';
		}
	}
	return board;
}

struct Shape {
	char name;
	vector&lt;int&gt; rs, cs;
	void init(Board board) {
		rs.clear();
		cs.clear();
		for (int r = 0; r &lt; board.size(); ++r) {
			for (int c = 0; c &lt; board[r].size(); ++c) {
				if (board[r][c])
					rs.push_back(r), cs.push_back(c);
			}
		}
		normallize();
	}

	void normallize() {
		int minR = INT_MAX, minC = INT_MAX;
		for (int it = 0; it &lt; rs.size(); ++it) {
			minR = min(minR, rs[it]);
			minC = min(minC, cs[it]);
		}
		for (int it = 0; it &lt; rs.size(); ++it) {
			rs[it] -= minR;
			cs[it] -= minC;
		}
	}

	//	void write() {
	//		cout &lt;&lt; name &lt;&lt; ":" &lt;&lt; endl;
	//		for (int r = 0; r &lt; board.size(); ++r) {
	//			foreach(iter,board[r])
	//				cout &lt;&lt; *iter;
	//			cout &lt;&lt; endl;
	//		}
	//		cout &lt;&lt; endl;
	//	}

	void reflectHor() {
		for (int it = 0; it &lt; rs.size(); ++it) {
			cs[it] = -cs[it];
		}
		normallize();
	}

	void reflectVer() {
		for (int it = 0; it &lt; rs.size(); ++it) {
			rs[it] = -rs[it];
		}
		normallize();
	}

	void rot90() {
		for (int it = 0; it &lt; rs.size(); ++it) {
			int r = rs[it], c = cs[it];
			int nr = c, nc = -r;
			rs[it] = nr;
			cs[it] = nc;
		}
		normallize();
	}
};

vector&lt;Shape&gt; shapes;

void initShapes() {
	shapes.clear();
	{
		Shape shape;
		shape.name = 'A';
		string rows[] = { "**", "*." };
		shape.init(get(rows, 2));
		shapes.push_back(shape);
	}
	{
		Shape shape;
		shape .name = 'B';
		string rows[] = { "****" };
		shape.init(get(rows, 1));
		shapes.push_back(shape);
	}
	{
		Shape shape;
		shape .name = 'C';
		string rows[] = { "***", "*.." };
		shape.init(get(rows, 2));
		shapes.push_back(shape);
	}
	{
		Shape shape;
		shape .name = 'D';
		string rows[] = { "**", "**" };
		shape.init(get(rows, 2));
		shapes.push_back(shape);
	}
	{
		Shape shape;
		shape .name = 'E';
		string rows[] = { "*..", "*..", "***" };
		shape.init(get(rows, 3));
		shapes.push_back(shape);
	}
	{
		Shape shape;
		shape .name = 'F';
		string rows[] = { "****", ".*.." };
		shape.init(get(rows, 2));
		shapes.push_back(shape);
	}
	{
		Shape shape;
		shape .name = 'G';
		string rows[] = { "***", "*.*" };
		shape.init(get(rows, 2));
		shapes.push_back(shape);
	}
	{
		Shape shape;
		shape .name = 'H';
		string rows[] = { "***", "**." };
		shape.init(get(rows, 2));
		shapes.push_back(shape);
	}
	{
		Shape shape;
		shape .name = 'I';
		string rows[] = { "***.", "..**" };
		shape.init(get(rows, 2));
		shapes.push_back(shape);
	}
	{
		Shape shape;
		shape .name = 'J';
		string rows[] = { ".*.", "***", ".*." };
		shape.init(get(rows, 3));
		shapes.push_back(shape);
	}
	{
		Shape shape;
		shape .name = 'K';
		string rows[] = { "*..", "**.", ".**" };
		shape.init(get(rows, 3));
		shapes.push_back(shape);
	}
	{
		Shape shape;
		shape .name = 'L';
		string rows[] = { "****", "*..." };
		shape.init(get(rows, 2));
		shapes.push_back(shape);
	}
}

typedef long long int64;
const int NROW = 10, NCELL = NROW * (NROW + 1) / 2;

int id[NROW][NROW + 1];
int64 initCovered;
char initBoard[NROW][NROW + 1]={};

inline bool inRange(int r, int c) {
	return r &gt;= 0 &amp;&amp; r &lt; NROW &amp;&amp; c &gt;= 0 &amp;&amp; c &lt;= r;
}

struct MarkSet {
	char name;
	vector&lt;int64&gt; marks;

	void doit(Shape shape) {
		vector&lt;int&gt;&amp;rs = shape.rs;
		vector&lt;int&gt;&amp;cs = shape.cs;
		for (int dr = 0; dr &lt; NROW; ++dr) {
			for (int dc = 0; dc &lt; NROW; ++dc) {
				bool ok = true;
				for (int am = 0; am &lt; rs.size(); ++am) {
					int nr = rs[am] + dr, nc = cs[am] + dc;
					if (!inRange(nr, nc)) {
						ok = false;
						break;
					}
					if (initCovered &amp; (1LL &lt;&lt; id[nr][nc])) {
						ok = false;
						break;
					}
				}
				if (!ok)
					continue;
				int64 coverSet = 0;
				for (int am = 0; am &lt; rs.size(); ++am) {
					int nr = rs[am] + dr, nc = cs[am] + dc;
					coverSet |= 1LL &lt;&lt; id[nr][nc];
				}
				marks.push_back(coverSet);
			}
		}
	}

	void init(Shape shape) {
		name=shape.name;
		marks.clear();
		for (int ifHor = 0; ifHor &lt; 2; ++ifHor) {
			for (int ifVer = 0; ifVer &lt; 2; ++ifVer) {
				for (int rotCnt = 0; rotCnt &lt; 4; ++rotCnt) {
					Shape cur = shape;
					if (ifHor)
						cur.reflectHor();
					if (ifVer)
						cur.reflectVer();
					for (int step = 0; step &lt; rotCnt; ++step) {
						cur.rot90();
					}
					doit(cur);
				}
			}
		}
		sort(marks.begin(), marks.end());
		marks.resize(unique(marks.begin(), marks.end()) - marks.begin());
	}
};
vector&lt;MarkSet&gt; markSets;

void inputData() {
	initCovered = 0;
	int curId = 0;
	for (int r = 0; r &lt; NROW; ++r) {
		for (int c = 0; c &lt; r + 1; ++c) {
			char ch;
			scanf(" ");
			scanf("%c", &amp;ch);
			initBoard[r][c] = ch;
			id[r][c] = curId++;
			if (ch != '.')
				initCovered |= 1LL &lt;&lt; (id[r][c]);
		}
	}
}

void initMarkSets() {
	bool hasName[256]={};
	for (int r = 0; r &lt; NROW; ++r) {
		for (int c = 0; c &lt; r+1; ++c) {
			hasName[initBoard[r][c]] = true;
		}
	}
	for (int cur = 0; cur &lt; shapes.size(); ++cur) {
		if(hasName[shapes[cur].name])
			continue;
		MarkSet markSet;
		markSet.init(shapes[cur]);
		markSets.push_back(markSet);
//		cout &lt;&lt; cur &lt;&lt; ":" &lt;&lt; markSet.marks.size() &lt;&lt; endl;
	}
}

struct Mark{
	int64 coverSet;
	char name;
	Mark(){}
	Mark(char _name,int64 _coverSet):
		name(_name),coverSet(_coverSet){}
};

vector&lt;Mark&gt; canCoverIt[NCELL]['L'-'A'+1];

void initCanCoverIt(){
	for (int me = 0; me &lt; NCELL; ++me) {
		for (int what = 0; what &lt; markSets.size(); ++what) {
			MarkSet&amp;markSet=markSets[what];
			char name=markSet.name;
			for (int am = 0; am &lt; markSet.marks.size(); ++am) {
				int64 mark=markSet.marks[am];
				if(mark &amp; (1LL&lt;&lt;me))
					canCoverIt[me][what].push_back(Mark(name,mark));
			}
		}
	}
}

Mark path[NCELL];
int curSearchTime=0;

void outputSol() {
	char out[NROW][NROW + 1] = { };
//	cout&lt;&lt;markSets.size()&lt;&lt;endl;
	for (int which = 0; which &lt; markSets.size(); ++which) {
		char name = path[which].name;
		int64 mark = path[which].coverSet;
//		cout&lt;&lt;name&lt;&lt;endl;
		for (int r = 0; r &lt; NROW; ++r) {
			for (int c = 0; c &lt; r + 1; ++c) {
				if ((1LL &lt;&lt; id[r][c]) &amp; mark)
					out[r][c] = name;
			}
		}
	}
	for (int r = 0; r &lt; NROW; ++r) {
		for (int c = 0; c &lt; r + 1; ++c) {
			if (out[r][c] == 0)
				out[r][c] = initBoard[r][c];
			printf("%c", out[r][c]);
		}
		printf("\n");
	}
//	cout&lt;&lt;curSearchTime&lt;&lt;endl;
	exit(0);
}

const int MAX_SEARCH_TIME=1000000;

bool used[256]={};

bool impossible(int where,int64 curCoverSet){
	for (int after = where; after &lt; NCELL; ++after) {
		if((1LL&lt;&lt;after) &amp; curCoverSet)
			continue;
		bool ok=false;
		for (int what = 0; what &lt; markSets.size(); ++what) {
			if(used[what])continue;
			vector&lt;Mark&gt;&amp;tmp=canCoverIt[after][what];
			for (int am = 0; am &lt; tmp.size(); ++am) {
				if(tmp[am].coverSet &amp; curCoverSet)
					continue;
				ok=true;
				break;
			}
			if(ok)break;
		}
		if(!ok)
			return true;
	}
	return false;
}

int ord[NCELL];
void dfs(int where,int64 curCoverSet,int nUsed){
	++curSearchTime;
	if(impossible(where,curCoverSet))
		return;
	if(curCoverSet == (1LL&lt;&lt;NCELL)-1){
		outputSol();
		return;
	}
	if(where == NCELL)
		return;
	int at=ord[where];
	if((1LL&lt;&lt;at) &amp; curCoverSet){
		dfs(where+1,curCoverSet,nUsed);
	}
	for (int what = 0; what &lt; markSets.size(); ++what) {
		if(used[what])
			continue;
		used[what]=true;
		vector&lt;Mark&gt;&amp;tmp=canCoverIt[at][what];
		for (int am = 0; am &lt; tmp.size(); ++am) {
			Mark mark=tmp[am];
			if(mark.coverSet &amp; curCoverSet)
				continue;
			path[nUsed]=mark;
			dfs(where+1,curCoverSet | mark.coverSet,nUsed+1);
		}
		used[what]=false;
	}
}

int main() {
//	freopen("in", "r", stdin);
	initShapes();
	inputData();
	initMarkSets();
	initCanCoverIt();
	for (int i = 0; i &lt; NCELL; ++i) {
		ord[i]=i;
	}
	int cntUp=0,cntDown=0;
	for (int r = 0; r &lt; NROW; ++r) {
		for (int c = 0; c &lt; r+1; ++c) {
			int distLeft=c;
			int distDown=NROW-1-r;
			if(distLeft &lt; distDown)
				cntUp++;
			else
				cntDown++;
		}
	}
	if(cntDown &gt; cntUp)
		reverse(ord,ord+NCELL);
	dfs(0,initCovered,0);
	puts("No solution");
}
</pre><pre></pre><h2>Problem1502</h2><pre>/*
 * [NOI2005]月下柠檬树.cpp
 *
 *  Created on: 2011-6-20
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
		x(_x), y(_y) {
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	Point operator*(double d) const {
		return Point(x * d, y * d);
	}
	Point operator/(double d) const {
		return Point(x / d, y / d);
	}
	double det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	double dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	double alpha() const {
		return atan2(y, x);
	}
	Point rot90() const {
		return Point(-y, x);
	}
	void read() {
		scanf("%lf%lf", &amp;x, &amp;y);
	}
	void write() const {
		printf("(%lf,%lf)", x, y);
	}
	double abs() {
		return hypot(x, y);
	}
	double abs2() {
		return x * x + y * y;
	}
	Point unit() {
		return *this / abs();
	}
	double distTo(const Point&amp;p) const {
		return hypot(x - p.x, y - p.y);
	}
};

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))

const double EPS = 1e-8;
inline int sign(double a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}

#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))

Point isSS(Point p1, Point p2, Point q1, Point q2) {
	double a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);
	return (p1 * a2 + p2 * a1) / (a1 + a2);
}

typedef pair&lt;double, double&gt; dpair;

vector&lt;Point&gt; make(Point a, Point b) {
	vector&lt;Point&gt; ret;
	ret.push_back(a);
	ret.push_back(b);
	return ret;
}

vector&lt;Point&gt; tanCP(Point c, double r, Point p) {
	double x2 = (p - c).abs2();
	double d2 = x2 - r * r;
	vector&lt;Point&gt; ret;
	if (d2 &lt; -EPS)
		return ret;
	if (r &lt;= EPS) {
		ret.push_back(c);
		ret.push_back(c);
		return ret;
	}
	d2 = max(d2, 0.);
	Point q1 = c + (p - c) * (r * r / x2);
	Point q2 = (p - c).rot90() * (-r * sqrt(d2) / x2);
	ret.push_back(q1 - q2);
	ret.push_back(q1 + q2);
	return ret;
}

vector&lt;vector&lt;Point&gt; &gt; tanCC(Point c1, double r1, Point c2, double r2) {
	vector&lt;vector&lt;Point&gt; &gt; ret;
	if (fabs(r1 - r2) &lt;= EPS) {
		Point dir = (c2 - c1).unit().rot90() * r1;
		ret.push_back(make(c1 + dir, c2 + dir));
		ret.push_back(make(c1 - dir, c2 - dir));
	} else {
		Point p = (c2 * r1 - c1 * r2) / (r1 - r2);
		vector&lt;Point&gt; ps = tanCP(c1, r1, p);
		vector&lt;Point&gt; qs = tanCP(c2, r2, p);
		for (int i = 0; i &lt; ps.size() &amp;&amp; i &lt; qs.size(); ++i) {
			ret.push_back(make(ps[i], qs[i]));
		}
	}
	return ret;
}

const int MAX_N_CIRCLES = 500 + 10;
int n;
double alpha;
double h[MAX_N_CIRCLES];
double r[MAX_N_CIRCLES];

typedef vector&lt;Point&gt; Poly;
vector&lt;Point&gt; cs;
vector&lt;double&gt; rs;
vector&lt;Poly&gt; ps;

void addPoly(Point c1, double r1, Point c2, double r2) {
	if (c1.distTo(c2) &lt;= fabs(r1 - r2))
		return;
	vector&lt;vector&lt;Point&gt; &gt; tans = tanCC(c1, r1, c2, r2);
	Poly ps;
	ps.push_back(tans[0][0]);
	ps.push_back(tans[0][1]);
	ps.push_back(tans[1][1]);
	ps.push_back(tans[1][0]);
	::ps.push_back(ps);
}

const dpair none(0, 0);

dpair cutCX(Point c, double r, double x) {
	double dx = fabs(x - c.x);
	if (dx &gt;= r)
		return none;
	double dy = sqrt(r * r - dx * dx);
	return dpair(c.y - dy, c.y + dy);
}

dpair cutPX(Poly ps, double x) {
	double mn = 1e100, mx = -1e100;
	Point q1(x, 0), q2(x, 100);
	for (int i = 0; i &lt; ps.size(); ++i) {
		Point p1 = ps[i], p2 = ps[(i + 1) % ps.size()];
		int d1 = sign(p1.x - x), d2 = sign(p2.x - x);
		if (d1 == 0) {
			mn = min(mn, p1.y);
			mx = max(mx, p1.y);
		}
		if (d1 * d2 &lt; 0) {
			Point is = isSS(p1, p2, q1, q2);
			mn = min(mn, is.y);
			mx = max(mx, is.y);
		}
	}
	if (mn &lt; mx)
		return dpair(mn, mx);
	else
		return none;
}

double calcCutLength(double x) {
	static dpair segs[10000];
	int cur = 0;
	for (int i = 0; i &lt; cs.size(); ++i) {
		dpair cut = cutCX(cs[i], rs[i], x);
		if (cut != none)
			segs[cur++] = cut;
	}
	for (int i = 0; i &lt; ps.size(); ++i) {
		dpair cut = cutPX(ps[i], x);
		if (cut != none)
			segs[cur++] = cut;
	}

	sort(segs, segs + cur);
	double L = -1e100, R = -1e100;
	double ans = 0;
	for (int i = 0; i &lt; cur; ++i) {
		dpair s = segs[i];
		if (s.first &lt;= R) {
			R = max(R, s.second);
		} else {
			ans += R - L;
			L = s.first;
			R = s.second;
		}
	}
	ans += R - L;
	return ans;
}

const double PRECISON = 1e-4;
double combine(double l, double r, double L, double M, double R) {
	return (L + 4 * M + R) / 6 * (r - l);
}

double simpson(double l, double r, double L, double M, double R) {
	double a1 = combine(l, r, L, M, R);
	double m = (l + r) / 2;
	double m1 = (l + m) / 2, M1 = calcCutLength(m1);
	double m2 = (m + r) / 2, M2 = calcCutLength(m2);
	double a2 = combine(l, m, L, M1, M) + combine(m, r, M, M2, R);
	if (fabs(a1 - a2) &lt;= PRECISON)
		return a2;
	return simpson(l, m, L, M1, M) + simpson(m, r, M, M2, R);
}

int main() {
	cin &gt;&gt; n &gt;&gt; alpha;
	for (int i = 0; i &lt;= n; ++i) {
		cin &gt;&gt; h[i];
		h[i] += i &gt; 0 ? h[i - 1] : 0;
	}
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; r[i];
	}
	r[n] = 0;

	double delta = 1 / tan(alpha);
	for (int i = 0; i &lt;= n; ++i) {
		cs.push_back( { h[i] * delta, 0 });
		rs.push_back(r[i]);
		if (i &gt; 0) {
			addPoly(cs[i], rs[i], cs[i - 1], rs[i - 1]);
		}
	}

	vector&lt;double&gt; ixs;
	for (int i = 0; i &lt; cs.size(); ++i) {
		ixs.push_back(cs[i].x);
		ixs.push_back(cs[i].x - rs[i]);
		ixs.push_back(cs[i].x + rs[i]);
	}

	//	for (int i = 0; i &lt; ps.size(); ++i) {
	//		foreach(e,ps[i])
	//			ixs.push_back(e-&gt;x);
	//		cout &lt;&lt; ps[i].size() &lt;&lt; ":" &lt;&lt; endl;
	//		foreach(e,ps[i]) {
	//			e-&gt;write();
	//			cout &lt;&lt; " ";
	//		}
	//		cout &lt;&lt; endl;
	//	}

	sort(ixs.begin(), ixs.end());
	double ans = 0;
	for (int i = 0; i &lt; ixs.size() - 1; ++i) {
		double l = ixs[i], r = ixs[i + 1];
		if (r - l &gt;= EPS)
			ans += simpson(l, r, calcCutLength(l), calcCutLength((l + r) / 2),
					calcCutLength(r));
	}
	printf("%.2lf\n", ans);
}
</pre><pre></pre><h2>Problem1503</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,a,b) for(int i=a;i&lt;=b;i++)
#define tr(i,x) for(typeof(x.begin()) i=x.begin();i!=x.end();i++)
#define all(x) x.begin(),x.end()
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef pair&lt;int,int&gt; ii;
struct Treap
{
    struct Node
    {
        int key,val,size;
        Node*c[2];
        Node(int _val,Node*C):val(_val),size(1),key(rand())
        {
            c[0]=c[1]=C;
        }
        void rz(){size=c[0]-&gt;size+c[1]-&gt;size+1;}
    };
    Node*root,*Null;
    Treap()
    {
        Null=new Node(0,0);Null-&gt;size=0;Null-&gt;key=inf;
        Null-&gt;c[0]=Null-&gt;c[1]=Null;
        root=Null;
    }
    void rot(Node*&amp;t,bool d)
    {
        Node*p=t-&gt;c[d];
        t-&gt;c[d]=p-&gt;c[!d];
        p-&gt;c[!d]=t;
        t-&gt;rz();p-&gt;rz();
        t=p;
    }
    void insert(Node*&amp;t,int x)
    {
        if(t==Null){t=new Node(x,Null);return;}
        bool d=x&gt;t-&gt;val;
        insert(t-&gt;c[d],x);
        if(t-&gt;c[d]-&gt;key&lt;t-&gt;key)
            rot(t,d);
        else
            t-&gt;rz();
    }
    int select(Node*t,int x)
    {
        int r=t-&gt;c[0]-&gt;size;
        if(x==r)return t-&gt;val;
        if(x&lt;r) return select(t-&gt;c[0],x);
        return select(t-&gt;c[1],x-r-1);
    }
    int Min()
    {
        Node*p=root;
        while(p-&gt;c[0]!=Null)p=p-&gt;c[0];
        return p-&gt;val;
    }
    void Delete(Node*&amp;t,int x)
    {
        if(t==Null)return;
        if(t-&gt;val==x)
        {
            bool d=t-&gt;c[1]-&gt;key&lt;t-&gt;c[0]-&gt;key;
            if(t-&gt;c[d]==Null)
                {delete t;t=Null;return;}
            rot(t,d);
            Delete(t-&gt;c[!d],x);
        }
        else
        {
            bool d=x&gt;t-&gt;val;
            Delete(t-&gt;c[d],x);
        }
        t-&gt;rz();
    }
    void del(int x)
    {
        Delete(root,x);
    }
    int sel(int x)
    {
        return select(root,x);
    }
    void ins(int x)
    {
        insert(root,x);
    }
    int size()
    {
        return root-&gt;size;
    }
}T;
int n,Min,Add=0,leave=0;
void Check()
{
    while(T.size())
    {
        int m=T.Min();
        if(m+Add&lt;Min)
        {
            leave++;
            T.del(m);
        }
        else break;
    }
}
void ins(int x)
{
    if(x&gt;=Min) T.ins(x-Add);
}
void add(int t)
{
    Add+=t;
}
void sub(int t)
{
    Add-=t;
    Check();
}
void find(int k)
{
    if(k&gt;T.size())
        printf("-1\n");
    else
        printf("%d\n",T.sel(T.size()-k)+Add);
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d %d",&amp;n,&amp;Min);char cmd;int x;
    rep(i,n)
    {
        scanf("\n%c%d",&amp;cmd,&amp;x);
        switch(cmd)
        {
            case 'I':ins(x);break;
            case 'A':add(x);break;
            case 'S':sub(x);break;
            case 'F':find(x);break;
        }
    }
    printf("%d\n",leave);
}
</pre><pre></pre><h2>Problem1507</h2><pre>/*
 * [NOI2003]Editor.cpp
 *
 *  Created on: 2011-3-3
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_LEN = 1024 * 1024 + 100;

struct Node {
	Node*ch[2], *p;
	char var;
	int size;
	bool dir() {
		return this == p-&gt;ch[1];
	}
	void set(Node*_c, bool _d) {
		ch[_d] = _c;
		_c-&gt;p = this;
	}
	void update() {
		size = ch[0]-&gt;size + ch[1]-&gt;size + 1;
	}
}*null;

void initNull() {
	null = new Node;
	null-&gt;size = 0;
}

struct Splay {
	Node*root;

	Node*newNode(char var) {
		Node*t = new Node;
		t-&gt;var = var;
		t-&gt;size = 1;
		t-&gt;ch[0] = t-&gt;ch[1] = null;
		return t;
	}

	void rotate(Node*t) {
		Node*p = t-&gt;p;
		bool d = t-&gt;dir();
		p-&gt;p-&gt;set(t, p-&gt;dir());
		p-&gt;set(t-&gt;ch[!d], d);
		t-&gt;set(p, !d);
		p-&gt;update();
		if (root == p)
			root = t;
	}

	void splay(Node*t, Node*f = null) {
		while (t-&gt;p != f) {
			if (t-&gt;p-&gt;p == f)
				rotate(t);
			else
				(t-&gt;dir() == t-&gt;p-&gt;dir()) ? (rotate(t-&gt;p), rotate(t))
						: (rotate(t), rotate(t));
		}
		t-&gt;update();
	}

	Node*getKth(int kth) {
		for (Node*t = root;;) {
			int cnt = t-&gt;ch[0]-&gt;size;
			if (kth == cnt)
				return t;
			t = t-&gt;ch[kth &gt; cnt];
			if (kth &gt; cnt)
				kth -= cnt + 1;
		}
	}

	Node* getRange(int l, int r) {//(l,r)
		Node*Left = getKth(l);
		splay(Left);
		Node*Right = getKth(r);
		splay(Right, Left);
		return Right;
	}

	void insert(int at, Node*t) {
		Node*p = getRange(at, at + 1);
		p-&gt;set(t, 0);
		splay(t);
	}

	void insert(int at, char ch) {
		insert(at, newNode(ch));
	}

	void erase(int at, int num) {
		Node*p = getRange(at, at + num + 1);
		p-&gt;set(null, 0);
		p-&gt;update();
		splay(p);
	}

	void write(Node*rt) {
		static Node* stack[MAX_LEN];
		bool leftDone[MAX_LEN];
		int top = 0;
		stack[top] = rt;
		leftDone[top] = false;
		++top;
		while (top &gt; 0) {
			int am = top - 1;
			Node*t = stack[am];
			if (t == null) {
				--top;
				continue;
			}
			if (!leftDone[am]) {
				stack[top] = t-&gt;ch[0];
				leftDone[top] = false;
				++top;
				leftDone[am] = true;
				continue;
			} else {
				putchar( t-&gt;var);
				--top;
				stack[top] = t-&gt;ch[1];
				leftDone[top] = false;
				++top;
			}
		}
	}

	void get(int at, int num) {
		Node*p = getRange(at, at + num + 1)-&gt;ch[0];
		write(p);
	}

	Splay() {
		Node*begin = newNode(0);
		Node*end = newNode(0);
		begin-&gt;set(end, 1);
		root = begin;
		root-&gt;p = null;
		rotate(end);
	}

	Node*build(char*l,char*r){//[l,r)
		if(l&gt;=r) return null;
		char*m=l+(r-l)/2;
		Node*t=newNode(*m);
		t-&gt;set(build(l,m),0);
		t-&gt;set(build(m+1,r),1);
		t-&gt;update();
		return t;
	}

	void insert(int at,char*l,char*r){
		Node*t=build(l,r);
		insert(at,t);
	}
};

char input[MAX_LEN];

int main() {
	initNull();
	Splay splay;
	int at = 0;
	int nOpt;
	scanf("%d", &amp;nOpt);
	while (nOpt--) {
		char ch;
		while (ch = getchar(), ch == ' ' || ch == '\n')
			;
		//		cout&lt;&lt;ch&lt;&lt;endl;
		switch (ch) {
		case 'I':
			scanf("nsert");
			int nIns;
			scanf("%d", &amp;nIns);
			int cur;cur=0;
			while (nIns--) {
				while (ch = getchar(), ch == '\n')
					;
				input[cur++]=ch;
			}
			splay.insert(at,input,input+cur);
			break;
		case 'M':
			scanf("ove");
			scanf("%d", &amp;at);
			break;
		case 'D':
			scanf("elete");
			int nDel;
			scanf("%d", &amp;nDel);
			splay.erase(at, nDel);
			break;
		case 'G':
			scanf("et");
			int nGet;
			scanf("%d", &amp;nGet);
			splay.get(at, nGet);
			putchar('\n');
			break;
		case 'P':
			scanf("rev");
			--at;
			break;
		case 'N':
			scanf("ext");
			++at;
			break;
		default:
			break;
		}
	}
}
</pre><pre></pre><h2>Problem1507</h2><pre>#include &lt;cstdio&gt;
#include &lt;ext/rope&gt;

__gnu_cxx::crope s;
int t,cur,k,i;
char op[10],buf[1&lt;&lt;21],c;

int main()
{
	scanf("%d",&amp;t);
	for(;t&gt;0;t--)
	{
		scanf("%s",op);
		switch(op[0])
		{
			case 'M':
				scanf("%d",&amp;cur);
				break;
			case 'I':
				scanf("%d",&amp;k);i=0;
				while(k)
				{
					c=getc(stdin);
					if(c&gt;=32&amp;&amp;c&lt;=126)
					{
						buf[i++]=c;
						k--;
					}
				}
				buf[i]=0;
				s.insert(cur,buf);
				break;
			case 'D':
				scanf("%d",&amp;k);
				s.erase(cur,k);
				break;
			case 'G':
				scanf("%d",&amp;k);
				puts(s.substr(cur,k).c_str());
				break;
			case 'P':
				cur--;
				break;
			case 'N':
				cur++;
				break;
		}
	}
	return 0;
}
</pre><pre></pre><h2>Problem1507</h2><pre>#include &lt;cstdio&gt;
#include &lt;ext/rope&gt;
#define S scanf
#define W break
__gnu_cxx::crope s;
int t,C,k,i;
char O[10],B[1&lt;&lt;21],c;
int main(){S("%d",&amp;t);for(;t&gt;0;t--){S("%s",O);switch(O[0]){case 'M':S("%d",&amp;C);W;case 'I':S("%d",&amp;k);i=0;while(k){c=getc(stdin);if(c&gt;=32&amp;&amp;c&lt;=126){B[i++]=c;k--;}}B[i]=0;s.insert(C,B);W;case 'D':S("%d",&amp;k);s.erase(C,k);W;case 'G':S("%d",&amp;k);puts(s.substr(C,k).c_str());W;case 'P':C--;W;case 'N':C++;W;}}}
</pre><pre></pre><h2>Problem1509</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
typedef long long ll;
const int maxn=200000,maxm=maxn*2;
const ll inf=1LL&lt;&lt;60;
int n,m;
int head[maxn],nxt[maxm],to[maxm],c[maxm],mnt;
void ClearList()
{
    memset(head,-1,sizeof head);
    mnt=0;
}
void AddEdge(int s,int _t,int _c)
{
    to[mnt]=_t;c[mnt]=_c;
    nxt[mnt]=head[s];head[s]=mnt++;
}
void InsEdge(int s,int t,int c)
{
    AddEdge(s,t,c);
    AddEdge(t,s,c);
}
struct Data
{
    ll A[3];
    Data()
    {
        rep(i,3)A[i]=-inf;
    }
    void Update(ll c)
    {
        if(c&gt;A[2])A[2]=c;
        if(A[2]&gt;A[1])swap(A[1],A[2]);
        if(A[1]&gt;A[0])swap(A[1],A[0]);
    }
    ll get(ll c)
    {
        if(A[0]==c)return A[1];
        return A[0];
    }
    ll ret()
    {
        return A[0]+A[1]*2+A[2];
    }
}S[maxn];
ll Up[maxn];
int Q[maxn],F[maxn],C[maxn],h,t;
void BFS(int vs)
{
    for(h=t=0,Q[t++]=vs,F[vs]=-1,C[vs]=0;h&lt;t;h++)
    {
        int x=Q[h];
        for(int e=head[x];e!=-1;e=nxt[e])if(to[e]!=F[x])
        {
            Q[t++]=to[e];
            F[to[e]]=x;
            C[to[e]]=c[e];
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];S[x].Update(0);
        for(int e=head[x];e!=-1;e=nxt[e])if(to[e]!=F[x])
            S[x].Update(S[to[e]].get(-inf)+c[e]);
    }
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i],f=F[x];
        Up[x]=0;
        if(f&gt;=0)
            Up[x]=max(Up[f],S[f].get(S[x].A[0]+C[x]))+C[x];
    }
    rep(i,n)if(F[i]&gt;=0)S[i].Update(Up[i]);
}
void Solve()
{
    ll ans=0;
    rep(i,n)
    {
        ll ret=S[i].ret();
        if(ret&gt;ans)ans=ret;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
void scan(int&amp;t)
{
    static char c;
    while(c=getchar(),c&lt;'0'||c&gt;'9');t=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
}
void Init()
{
    ClearList();
    scan(n);scan(m);int s,t,c;
    rep(i,m)
    {
        scan(s);scan(t);scan(c);
        --s;--t;
        InsEdge(s,t,c);
    }
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    BFS(0);
    Solve();
}
</pre><pre></pre><h2>Problem1514</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define OK cout&lt;&lt;"OK"&lt;&lt;endl
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=1000,maxv=maxn*maxn;
int n,m,num;
struct pnt
{
    int x,y;
    int hash()
    {
        return x*m+y;
    }
    pnt(){}
    pnt(int _x,int _y):
        x(_x),y(_y){}
    void read()
    {
        scanf("%d%d",&amp;x,&amp;y);
        --x;--y;
    }
    bool operator==(const pnt&amp;p)const
    {
        return x==p.x&amp;&amp;y==p.y;
    }
}S,T,H[maxv];
int MinD[maxv],to[maxv];
inline int sqr(int x){return x*x;}
inline int dist(pnt a,pnt b)
{
    return sqr(a.x-b.x)+sqr(a.y-b.y);
}
struct Queue
{
    bool inQ[maxv];
    int h,t,Q[maxv];
    void clear()
    {
        memset(inQ,0,sizeof inQ);
        h=t=0;
    }
    void inc(int&amp;i)
    {
        if(++i==maxv)i=0;
    }
    void dec(int&amp;i)
    {
        if(!i--)i=maxv-1;
    }
    void push_back(int x)
    {
        if(inQ[x])return;
        Q[t]=x;inc(t);
    }
    void push_front(int x)
    {
        if(inQ[x])return;
        dec(h);Q[h]=x;
    }
    int front()
    {
        return Q[h];
    }
    void pop_front()
    {
        inQ[Q[h]]=false;
        inc(h);
    }
    bool empty()
    {
        return h==t;
    }
}Q;
#define Dist(a,b,c,d) (a-c)*(a-c)+(b-d)*(b-d)
void CalMinD()
{
    memset(MinD,0x7F,sizeof MinD);
    Q.clear();
    rep(i,num)
    {
        pnt a=H[i];int id=a.hash();
        MinD[id]=0;
        to[id]=i;
        Q.push_back(id);
    }
    while(!Q.empty())
    {
        int id=Q.front();Q.pop_front();
        int a=id/m,b=id%m,tx=H[to[id]].x,ty=H[to[id]].y;;
        for(int x=a-1;x&lt;=a+1;x++)
            for(int y=b-1;y&lt;=b+1;y++)
                if(x&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&gt;=0&amp;&amp;y&lt;m)
                {
                    int nid=x*m+y;
                    int nc=Dist(x,y,tx,ty);
                    if(MinD[nid]&gt;nc)
                    {
                        MinD[nid]=nc;
                        to[nid]=to[id];
                        if(MinD[nid]&lt;=MinD[Q.empty()?0:Q.front()])
                            Q.push_front(nid);
                        else
                            Q.push_back(nid);
                    }
                }
    }
}
int Dist[maxv];
void Dijstra()
{
    memset(Dist,-1,sizeof Dist);
    Dist[S.hash()]=MinD[S.hash()];
    Q.push_back(S.hash());
    while(!Q.empty())
    {
        int id=Q.front();Q.pop_front();
        int x=id/m,y=id%m;
        #define go(x,y)\
        {\
            int nid=(x)*m+y;\
            int nval=min(Dist[id],MinD[nid]);\
            if(nval&gt;Dist[nid])\
            {\
                Dist[nid]=nval;\
                if(Dist[nid]&gt;=Dist[Q.empty()?0:Q.front()])\
                    Q.push_front(nid);\
                else\
                    Q.push_back(nid);\
            }\
        }
        if(x)go(x-1,y);if(x+1&lt;n)go(x+1,y);
        if(y)go(x,y-1);if(y+1&lt;m)go(x,y+1);
    }
}
void Init()
{
    scanf("%d%d",&amp;n,&amp;m);
    S.read();T.read();
    scanf("%d",&amp;num);
    rep(i,num)
    {
        H[i].read();
    }
}
int main()
{
    Init();
    CalMinD();
    Dijstra();
    cout&lt;&lt;Dist[T.hash()]&lt;&lt;endl;
    Dijstra();
}
</pre><pre></pre><h2>Problem1517</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=1000000+10,maxm=maxn*2;
int head[maxn],nxt[maxm],to[maxm],mnt=0;
int n,L;
void clearList()
{
    memset(head,-1,sizeof head);
    mnt=0;
}
void AddEdge(int s,int t)
{
    to[mnt]=t;nxt[mnt]=head[s];
    head[s]=mnt++;
}
void InsEdge(int s,int t)
{
    AddEdge(s,t);
    AddEdge(t,s);
}
void scan(int&amp;t)
{
    char c;t=0;
    while(c=getchar(),c&lt;'0'||c&gt;'9');t=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
}
void Init()
{
    scan(n);scan(L);int s,t;
    rep(i,n-1)
    {
        scan(s);scan(t);
        s--;t--;
        InsEdge(s,t);
    }
}
int Q[maxn],h,t,F[maxn];
void BFS(int vs)
{
    for(h=t=0,Q[t++]=vs,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        for(int e=head[x];e!=-1;e=nxt[e])
            if(to[e]!=F[x])
            {
                F[to[e]]=x;
                Q[t++]=to[e];
            }
    }
}
bool Mark[maxn]={};
struct state
{
    int d,id;
    state(int _d=-1,int _id=0):
        d(_d),id(_id){}
    void Update(state a,int c)
    {
        if(a.d+c&gt;d)
            *this=a,d+=c;
    }
}S[maxn];
void Solve()
{
    BFS(0);
    BFS(Q[n-1]);
    for(int i=n-1;i&gt;=0;i--)
    {
        int x=Q[i];
        S[x].Update(state(0,x),0);
        int fa=F[x];
        if(fa&gt;=0)
        {
            S[fa].Update(S[x],1);
        }
    }
    clearList();
    rep(i,n)AddEdge(S[i].d,i);
    int cnt=2*L-1,ans=0;
    for(int i=n-1;i&gt;=0;i--)
    {
        if(cnt&lt;=0)break;
        for(int e=head[i];e!=-1;e=nxt[e])
        {
            if(cnt&lt;=0)break;
            int x=to[e];
            if(Mark[x])continue;
            cnt--;
            int tmp=S[x].id;ans+=S[x].d+1;
            while(tmp&gt;=0&amp;&amp;!Mark[tmp])
            {
                Mark[tmp]=true;
                tmp=F[tmp];
            }
        }
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    clearList();
    Init();
    Solve();
}

</pre><pre></pre><h2>Problem1520</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;2,maxn=200;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int Lx[maxn],Ly[maxn],w[maxn][maxn],Link[maxn],Slack[maxn],n;
bool VisX[maxn],VisY[maxn];
bool Find(int x)
{
    VisX[x]=true;
    rep(y,n)if(!VisY[y])
    {
        int t=Lx[x]+Ly[y]-w[x][y];
        if(!t)
        {
            VisY[y]=true;
            if(Link[y]==-1||Find(Link[y]))
                return Link[y]=x,true;
        }
        else Slack[y]=min(Slack[y],t);
    }
    return false;
}
void KM()
{
    memset(Link,-1,sizeof Link);
    rep(i,n)Lx[i]=-inf;
    memset(Ly,0,sizeof Ly);
    rep(i,n)rep(j,n)Lx[i]=max(Lx[i],w[i][j]);
    rep(x,n)
    {
        rep(y,n)Slack[y]=inf;
        for(;;)
        {
            memset(VisX,0,sizeof VisX);
            memset(VisY,0,sizeof VisY);
            if(Find(x))break;
            int d=inf;
            rep(y,n)if(!VisY[y])d=min(d,Slack[y]);
            rep(x,n)if(VisX[x])Lx[x]-=d;
            rep(y,n)if(VisY[y])Ly[y]+=d;else Slack[y]-=d;
        }
    }
}
void InIt()
{
    cin&gt;&gt;n;int m,a,b,k;
    rep(x,n)rep(y,n)w[x][y]=-inf;
    rep(x,n)
    {
        cin&gt;&gt;m&gt;&gt;a&gt;&gt;b&gt;&gt;k;--a;--b;--m;
        for(int y=a;y&lt;=b;y++)
            w[x][y]=-abs(y-m)*k;
    }
}
int main()
{
    //freopen("in","r",stdin);
    InIt();KM();int ans=0;
    rep(i,n)
    {
        int tmp;
        if((tmp=w[Link[i]][i])==-inf){cout&lt;&lt;"NIE"&lt;&lt;endl;return 0;}
        ans-=tmp;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1520</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;2,maxn=200;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int Lx[maxn],Ly[maxn],w[maxn][maxn],Link[maxn],Slack[maxn],n;
bool VisX[maxn],VisY[maxn];
bool Find(int x)
{
    VisX[x]=true;
    rep(y,n)if(!VisY[y])
    {
        int t=Lx[x]+Ly[y]-w[x][y];
        if(!t)
        {
            VisY[y]=true;
            if(Link[y]==-1||Find(Link[y]))
                return Link[y]=x,true;
        }
        else Slack[y]=min(Slack[y],t);
    }
    return false;
}
void KM()
{
    memset(Link,-1,sizeof Link);
    rep(i,n)Lx[i]=-inf;
    memset(Ly,0,sizeof Ly);
    rep(i,n)rep(j,n)Lx[i]=max(Lx[i],w[i][j]);
    rep(x,n)
    {
        rep(y,n)Slack[y]=inf;
        for(;;)
        {
            memset(VisX,0,sizeof VisX);
            memset(VisY,0,sizeof VisY);
            if(Find(x))break;
            int d=inf;
            rep(y,n)if(!VisY[y])d=min(d,Slack[y]);
            rep(x,n)if(VisX[x])Lx[x]-=d;
            rep(y,n)if(VisY[y])Ly[y]+=d;else Slack[y]-=d;
        }
    }
}
void InIt()
{
    cin&gt;&gt;n;int m,a,b,k;
    rep(x,n)rep(y,n)w[x][y]=-inf;
    rep(x,n)
    {
        scanf("%d%d%d%d",&amp;m,&amp;a,&amp;b,&amp;k);--a;--b;--m;
        for(int y=a;y&lt;=b;y++)
            w[x][y]=-abs(y-m)*k;
    }
}
int main()
{
    //freopen("in","r",stdin);
    InIt();KM();int ans=0;
    rep(i,n)
    {
        int tmp;
        if((tmp=w[Link[i]][i])==-inf){cout&lt;&lt;"NIE"&lt;&lt;endl;return 0;}
        ans-=tmp;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1524</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
typedef long long ll;
const int seed=13331,maxs=2000000+10;
int n,l,cnt=0;
char A[maxs];
ll Hash[maxs],P[maxs],Ret[maxs];
void Doit()
{
    Hash[0]=A[0];
    for(int i=1;i&lt;l;i++)Hash[i]=Hash[i-1]*seed+A[i];
    for(int i=1;i&lt;=l;i++)if(l%i==0)
    {
        ll now=0;rep(j,(l/i))now=now*P[i]+Hash[i-1];
        if(now==Hash[l-1])
        {
            Ret[cnt++]=Hash[i-1];
            return;
        }
    }
}
int main()
{
    cin&gt;&gt;n;
    P[0]=1;rep(i,maxs-1)P[i+1]=P[i]*seed;
    rep(i,n)
    {
        scanf("%d %s",&amp;l,A);
        Doit();
    }
    sort(Ret,Ret+cnt);ll last=1LL&lt;&lt;60,ans=0;
    int c=0;
    rep(i,cnt)
    if(Ret[i]!=last)ans+=c*c,last=Ret[i],c=1;
    else c++;
    ans+=c*c;
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1526</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=10000+10;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,t;
int A[maxn];
int first[maxn][10];
int Dp[maxn]={};
void dfs(int t,int f)
{
    if(f==-1)return;
    if(t&gt;=10000)
    {
        Dp[t-10000]++;
        return;
    }
    rep(i,10)
        dfs(t*10+i,first[f][i]);
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;
    rep(i,n)
    {
        cin&gt;&gt;t;char c;scanf(" ");
        rep(i,t)scanf("%c",&amp;c),A[i]=c-'0';
        memset(first[t],-1,sizeof first[t]);
        for(int i=t-1;i&gt;=0;i--)
        {
            memcpy(first[i],first[i+1],sizeof first[i]);
            first[i][A[i]]=i;
        }
        dfs(1,0);
    }
    int cnt=0;
    rep(i,maxn)if(Dp[i]==n)cnt++;
    cout&lt;&lt;cnt&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1526</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=10000,digit=10;
using namespace std;
int n,t;
int A[maxn];
int next_same[maxn];
int first[digit];
int Count[maxn];
vector&lt;int&gt; First[maxn];
void doit()
{
    scanf("%d",&amp;t);getchar();
    rep(i,t)A[i]=getchar()-'0',First[i].clear();
    memset(first,-1,sizeof first);
    for(int i=t-1;i&gt;=0;i--)
    {
        next_same[i]=first[A[i]];
        first[A[i]]=i;
    }
    rep(i,digit)if(first[i]&gt;=0)
        First[first[i]].pb(10+i);
    for(int i=0;i&lt;t;i++)
    {
        rep(j,First[i].size())
        {
            int x=First[i][j];
            if(x&lt;maxn)
            {
                rep(j,digit)
                    if(first[j]&gt;=0)
                        First[first[j]].pb(x*10+j);
            }
            else
                Count[x-maxn]++;
        }
        first[A[i]]=next_same[i];
    }
}
int main()
{
    //freopen("in","r",stdin);
    int n;cin&gt;&gt;n;
    rep(i,n)doit();
    int cnt=0;
    rep(i,maxn)if(Count[i]==n)cnt++;
    cout&lt;&lt;cnt&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1527</h2><pre>/*
 * [POI2005]Pun-point.cpp
 *
 *  Created on: 2011-6-27
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;utility&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

typedef long long int64;

struct Point {
	int64 x, y;
	Point() {
	}
	Point(int64 _x, int64 _y) :
		x(_x), y(_y) {
	}
	int64 abs2() {
		return x * x + y * y;
	}
	int64 det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	bool operator==(const Point&amp;p) const {
		return x == p.x &amp;&amp; y == p.y;
	}
	void read() {
		scanf("%lld%lld", &amp;x, &amp;y);
	}
	int64 distTo(const Point&amp;p) const {
		int64 dx = x - p.x, dy = y - p.y;
		return dx * dx + dy * dy;
	}
};

const Point ZERO(0, 0);

bool isLower(Point p) {
	return p.y &lt; 0 || (p.y == 0 &amp;&amp; p.x &lt; 0);
}

bool cmpByAngel(Point a, Point b) {
	int64 d = a.det(b);
	if (d != 0)
		return d &lt; 0;
	return a.abs2() &gt; b.abs2();
}

const int MAX_N_POINTS = 25000 + 10;

typedef pair&lt;int64, int64&gt; i64pair;

int64 doGcd(int64 a, int64 b) {
	return b ? doGcd(b, a % b) : a;
}

int64 gcd(int64 a, int64 b) {
	return llabs(doGcd(a, b));
}

struct PointSet;

struct PointString {
	i64pair ps[MAX_N_POINTS];
	int nPs;
	bool hasZero;
	void init(const PointSet&amp;set);
	void write() {
		cout &lt;&lt; (hasZero ? "has zero" : "hasn't zero") &lt;&lt; endl;
		for (int i = 0; i &lt; nPs; ++i) {
			cout &lt;&lt; ps[i].first &lt;&lt; " " &lt;&lt; ps[i].second &lt;&lt; endl;
		}
		cout &lt;&lt; "End." &lt;&lt; endl;
	}
};

struct PointSet {
	Point ps[MAX_N_POINTS];
	int nPs;
	bool hasZero;

	void doit() {
		Point*mid = partition(ps, ps + nPs, isLower);
		sort(ps, mid, cmpByAngel);
		sort(mid, ps + nPs, cmpByAngel);
		ps[nPs] = ps[0];
	}

	void read() {
		scanf("%d", &amp;nPs);
		int64 sx = 0, sy = 0;
		for (int i = 0; i &lt; nPs; ++i) {
			ps[i].read();
			sx += ps[i].x, sy += ps[i].y;
		}
		for (int i = 0; i &lt; nPs; ++i) {
			ps[i].x = ps[i].x * nPs - sx;
			ps[i].y = ps[i].y * nPs - sy;
		}
		Point*at = find(ps, ps + nPs, ZERO);
		if (at != ps + nPs) {
			hasZero = true;
			swap(*at, *(ps + nPs - 1));
			nPs--;
		} else {
			hasZero = false;
		}
		doit();
	}

	void makeRef() {
		for (int i = 0; i &lt; nPs; ++i) {
			ps[i].y *= -1;
		}
		doit();
	}
};

void PointString::init(const PointSet&amp;set) {
	nPs = set.nPs;
	hasZero = set.hasZero;
	int64 g = -1;
	for (int i = 0; i &lt; nPs; ++i) {
		Point a = set.ps[i], b = set.ps[i + 1];
		ps[i] = make_pair(a.abs2(), a.distTo(b));
		int64 cg = gcd(ps[i].first, ps[i].second);
		if (!i)
			g = cg;
		else
			g = gcd(g, cg);
	}

	if (g &gt; 1) {
		for (int i = 0; i &lt; nPs; ++i) {
			ps[i].first /= g;
			ps[i].second /= g;
		}
	}

	int i = 0, j = 1, t = 0;
	while (i &lt; nPs &amp;&amp; j &lt; nPs &amp;&amp; t &lt; nPs) {
		i64pair a = ps[(i + t) % nPs], b = ps[(j + t) % nPs];
		if (a == b)
			++t;
		else {
			if (a &lt; b)
				i += t + 1, t = 0;
			else
				j += t + 1, t = 0;
			if (i == j)
				++j;
		}
	}

	rotate(ps, ps + min(i, j), ps + nPs);
}

bool operator==(const PointString&amp;a, const PointString&amp;b) {
	if (a.nPs != b.nPs || a.hasZero != b.hasZero)
		return false;
	for (int i = 0; i &lt; a.nPs; ++i) {
		if (a.ps[i] != b.ps[i])
			return false;
	}
	return true;
}

PointString nor, rev, tmp;
PointSet me, toTest;

int main() {
	me.read();
	nor.init(me);
	me.makeRef();
	rev.init(me);

	int nTest;
	cin &gt;&gt; nTest;
	while (nTest--) {
		toTest.read();
		tmp.init(toTest);
		if (nor == tmp || rev == tmp) {
			printf("TAK\n");
		} else {
			printf("NIE\n");
		}
	}
}
</pre><pre></pre><h2>Problem1528</h2><pre>/*
 *  [POI2005]sam-Toy Cars.cpp
 *
 *  Created on: 2011-6-27
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

int n, k, nQ;
const int MAX_N = 100000 + 10;
const int MAX_N_Q = 500000 + 10;
int prev[MAX_N_Q], next[MAX_N_Q], what[MAX_N_Q];
int app[MAX_N];

struct Comparator {
	bool operator()(int a, int b) const {
		return next[a] != next[b] ? next[a] &lt; next[b] : a &lt; b;
	}
};

set&lt;int, Comparator&gt; Set;
bool inTable[MAX_N] = { };

int main() {
	cin &gt;&gt; n &gt;&gt; k &gt;&gt; nQ;
	for (int i = 0; i &lt; nQ; ++i) {
		scanf("%d", what + i);
	}

	fill(app, app + MAX_N, MAX_N_Q);
	for (int i = nQ - 1; i &gt;= 0; --i) {
		int w = what[i];
		next[i] = app[w];
		app[w] = i;
	}

	fill(app, app + MAX_N, -1);
	for (int i = 0; i &lt; nQ; ++i) {
		int w = what[i];
		prev[i] = app[w];
		app[w] = i;
	}

	int ans = 0;
	for (int i = 0; i &lt; nQ; ++i) {
		int w = what[i];
		if (inTable[w]) {
			int at = prev[i];
			Set.erase(at);
			Set.insert(i);
		} else {
			ans++;
			if (Set.size() &lt; k) {
				inTable[w] = true;
				Set.insert(i);
			} else {
				int it = *Set.rbegin();
				inTable[what[it]] = false;
				Set.erase(--Set.end());
				Set.insert(i);
				inTable[w] = true;
			}
		}
	}
	printf("%d\n", ans);
}
</pre><pre></pre><h2>Problem1529</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=1000000;
using namespace std;
int Q[maxn],h,t,F[maxn],n,In[maxn]={};
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);
    rep(i,n)scanf("%d",F+i),In[--F[i]]++;
    h=t=0;
    rep(i,n)if(!In[i])Q[t++]=i;
    for(;h&lt;t;h++)
    {
        int x=Q[h];if(!--In[F[x]])Q[t++]=F[x];
    }
    int ans=0;
    rep(i,n)
        if(In[i])
        {
            ans++;
            int x=i;
            while(In[x])In[x]=0,x=F[x];
        }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1529</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=1000000;
using namespace std;
int Q[maxn],h,t,F[maxn],n,In[maxn]={};
int nextInt()
{
    int ret;char c;
    while(c=getchar(),c&lt;'0'||c&gt;'9');
    ret=c-'0';while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')ret=ret*10+c-'0';
    return ret;
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);
    rep(i,n)F[i]=nextInt(),In[--F[i]]++;
    h=t=0;
    rep(i,n)if(!In[i])Q[t++]=i;
    for(;h&lt;t;h++)
    {
        int x=Q[h];if(!--In[F[x]])Q[t++]=F[x];
    }
    int ans=0;
    rep(i,n)
        if(In[i])
        {
            ans++;
            int x=i;
            while(In[x])In[x]=0,x=F[x];
        }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1531</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;2,maxn=200,maxw=20000+10;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,w,v[maxn],c[maxn];
int F[maxw]={};
void Update(int x,int c)
{
    for(int j=w;j&gt;=x;j--)
        F[j]=min(F[j],F[j-x]+c);
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;rep(i,n)cin&gt;&gt;v[i];
    rep(i,n)cin&gt;&gt;c[i];cin&gt;&gt;w;
    rep(i,maxw)F[i]=inf;F[0]=0;
    rep(i,n)
    {
        int t=1,x=c[i];
        while(t&lt;=x)
        {
            Update(t*v[i],t);
            x-=t;
            t&lt;&lt;=1;
        }
        Update(x*v[i],x);
    }
    cout&lt;&lt;F[w]&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1531</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;2,maxn=200,maxw=20000+10;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,w,v[maxn],c[maxn];
int F[maxw]={};
void Update(int x,int c)
{
    for(int j=w;j&gt;=x;j--)
        F[j]=min(F[j],F[j-x]+c);
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);rep(i,n)scanf("%d",v+i);
    rep(i,n)scanf("%d",c+i);scanf("%d",&amp;w);
    rep(i,maxw)F[i]=inf;F[0]=0;
    rep(i,n)
    {
        int t=1,x=c[i];
        while(t&lt;=x)
        {
            Update(t*v[i],t);
            x-=t;
            t&lt;&lt;=1;
        }
        Update(x*v[i],x);
    }
    printf("%d\n",F[w]);
}


</pre><pre></pre><h2>Problem1531</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;2,maxn=200,maxw=20000+10;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,w,v[maxn],c[maxn];
int F[maxw]={};
inline int Min(int a,int b)
{
    int m=(a-b)&gt;&gt;31;
    return a&amp;m|b&amp;~m;
}
void Update(int x,int c)
{
    for(int j=w;j&gt;=x;j--)
        F[j]=Min(F[j],F[j-x]+c);
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;rep(i,n)cin&gt;&gt;v[i];
    rep(i,n)cin&gt;&gt;c[i];cin&gt;&gt;w;
    rep(i,maxw)F[i]=inf;F[0]=0;
    rep(i,n)
    {
        int t=1,x=c[i];
        while(t&lt;=x)
        {
            Update(t*v[i],t);
            x-=t;
            t&lt;&lt;=1;
        }
        Update(x*v[i],x);
    }
    cout&lt;&lt;F[w]&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1531</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;2,maxn=200,maxw=20000+10;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,w,v[maxn],c[maxn];
int F[maxw]={};
inline int Min(int a,int b)
{
    int m=(a-b)&gt;&gt;31;
    return a&amp;m|b&amp;~m;
}
void Update(int x,int c)
{
    for(int j=w;j&gt;=x;j--)
        F[j]=Min(F[j],F[j-x]+c);
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;rep(i,n)cin&gt;&gt;v[i];
    rep(i,n)cin&gt;&gt;c[i];cin&gt;&gt;w;
    rep(i,maxw)F[i]=inf;F[0]=0;
    rep(i,n)
    {
        int t=1,x=c[i];
        while(t&lt;=x)
        {
            Update(t*v[i],t);
            x-=t;
            t&lt;&lt;=1;
        }
        if(x)Update(x*v[i],x);
    }
    cout&lt;&lt;F[w]&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1532</h2><pre>/*
 *  [POI2005]Kos-Dicing.cpp
 *
 *  Created on: 2011-6-27
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_COMPETITORS = 10000 + 10;
const int MAX_N_MATCHS = 10000 + 10;

const int INF = ~0U &gt;&gt; 1;
struct Network {
	static const int MAX_N_VETS = MAX_N_COMPETITORS + MAX_N_MATCHS;
	static const int MAX_N_EDGES = 300000;

	int head[MAX_N_VETS];
	int dest[MAX_N_EDGES], cap[MAX_N_EDGES], next[MAX_N_EDGES];

	int nVets, nEdges;
	int vs, vt;

	void init(int _nVets, int _vs, int _vt) {
		nVets = _nVets;
		vs = _vs;
		vt = _vt;
		memset(head, -1, sizeof head);
		nEdges = 0;
	}

	void makeEdge(int s, int t, int c) {
		int id = nEdges++;
		next[id] = head[s];
		dest[id] = t;
		cap[id] = c;
		head[s] = id;
	}

	void addEdge(int s, int t, int c1, int c2) {
		makeEdge(s, t, c1);
		makeEdge(t, s, c2);
	}

	int am[MAX_N_VETS], prev[MAX_N_VETS], h[MAX_N_VETS], cnt[MAX_N_VETS],
			cur[MAX_N_VETS];
	int totalFlow;

	int calcMaxFlow() {
		memset(am, 0, sizeof am);
		memset(cur, -1, sizeof cur);
		memset(h, 0, sizeof h);
		memset(cnt, 0, sizeof cnt);
		cnt[0] = nVets;
		int u = vs, now;
		totalFlow = 0;
		am[u] = INF;
		while (h[vs] &lt; nVets &amp;&amp; h[vs] &lt; 100) {
			for (now = cur[u]; now != -1; now = next[now])
				if (cap[now] &gt; 0 &amp;&amp; h[u] == h[dest[now]] + 1)
					break;
			if (now != -1) {
				int v = dest[now];
				cur[u] = prev[v] = now;
				am[v] = min(am[u], cap[now]);
				u = v;
				if (u == vt) {
					int by = am[u];
					while (u != vs) {
						cap[prev[u]] -= by;
						cap[prev[u] ^ 1] += by;
						u = dest[prev[u] ^ 1];
					}
					totalFlow += by;
					am[u] = INF;
				}
			} else {
				if (!--cnt[h[u]])
					break;
				h[u] = nVets;
				for (now = head[u]; now != -1; now = next[now])
					if (cap[now] &gt; 0 &amp;&amp; h[dest[now]] + 1 &lt; h[u]) {
						h[u] = h[dest[now]] + 1;
						cur[u] = now;
					}
				++cnt[h[u]];
				if (u != vs)
					u = dest[prev[u] ^ 1];
			}
		}

		return totalFlow;
	}
};

int nCompetitors, nMatches;
int match[MAX_N_MATCHS][2];

void readInput() {
	cin &gt;&gt; nCompetitors &gt;&gt; nMatches;
	for (int i = 0; i &lt; nMatches; ++i) {
		for (int j = 0; j &lt; 2; ++j) {
			scanf("%d", match[i] + j);
			--match[i][j];
		}
	}
}

int greedyWork() {
	static int win[MAX_N_COMPETITORS];
	memset(win, 0, sizeof win);
	for (int i = 0; i &lt; nMatches; ++i) {
		int a = match[i][0], b = match[i][1];
		if (win[a] &gt; win[b]) {
			swap(a, b);
		}
		win[a]++;
	}
	return *max_element(win, win + nCompetitors);
}

bool check(int maxWin) {
	static Network network;
	static int restWin[MAX_N_COMPETITORS];
	static int which[MAX_N_MATCHS];
	int nV = nCompetitors + nMatches;
	int vs = nV++, vt = nV++;
	fill(restWin, restWin + nCompetitors, maxWin);

	int needFlow = 0;
	for (int i = 0; i &lt; nMatches; ++i) {
		int a = match[i][0], b = match[i][1];
		if (restWin[a] &lt; restWin[b])
			swap(a, b);
		if (!restWin[a]) {
			which[i] = -1;
			++needFlow;
		} else {
			--restWin[a];
			which[i] = a;
		}
	}

	if (!needFlow)
		return true;

	network.init(nV, vs, vt);
	for (int i = 0; i &lt; nMatches; ++i) {
		if (which[i] == -1) {
			network.addEdge(vs, nCompetitors + i, 1, 0);
			for (int j = 0; j &lt; 2; ++j) {
				network.addEdge(nCompetitors + i, match[i][j], 1, 0);
			}
		} else {
			int a = which[i];
			network.addEdge(vs, nCompetitors + i, 0, 1);
			for (int j = 0; j &lt; 2; ++j) {
				if (match[i][j] == a)
					network.addEdge(nCompetitors + i, match[i][j], 0, 1);
				else
					network.addEdge(nCompetitors + i, match[i][j], 1, 0);
			}
		}
	}

	for (int i = 0; i &lt; nCompetitors; ++i) {
		network.addEdge(i, vt, restWin[i], maxWin - restWin[i]);
	}

	return network.calcMaxFlow() == needFlow;
}

void work() {
	int left = 0, right = greedyWork();
	while (left + 1 &lt; right) {
		int mid = left + right &gt;&gt; 1;
		if (check(mid))
			right = mid;
		else
			left = mid;
	}
	printf("%d\n", right);
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem1536</h2><pre>/*
 * [POI2005]Akc- Special Forces Manoeuvres.cpp
 *
 *  Created on: 2011-6-27
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;math.h&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
//using namespace std;
using std::vector;
using std::min;
using std::cout;
using std::endl;

struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
		x(_x), y(_y) {
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	Point operator*(double d) const {
		return Point(x * d, y * d);
	}
	Point operator/(double d) const {
		return Point(x / d, y / d);
	}
	double det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	double dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	double alpha() const {
		return atan2(y, x);
	}
	Point rot90() const {
		return Point(-y, x);
	}
	void read() {
		scanf("%lf%lf", &amp;x, &amp;y);
	}
	void write() const {
		printf("%lf %lf", x, y);
	}
	double abs() {
		return hypot(x, y);
	}
	Point unit() {
		return *this / abs();
	}
	double distTo(const Point&amp;p) const {
		return hypot(x - p.x, y - p.y);
	}
};

const double EPS = 1e-8;
inline int compare(double a, double b) {
	return a &lt; b - EPS ? -1 : a &gt; b + EPS;
}

vector&lt;Point&gt; isCC(Point c1, double r1, Point c2, double r2) {
	double d = c1.distTo(c2);
	vector&lt;Point&gt; ret;
	if (compare(d, r1 + r2) == 1)
		return ret;
	d = min(d, r1 + r2);
	double y = (r1 * r1 + d * d - r2 * r2) / (2 * d);
	double x = sqrt(r1 * r1 - y * y);
	Point dir = (c2 - c1).unit();
	Point q1 = c1 + dir * y;
	Point q2 = dir.rot90() * x;
	ret.push_back(q1 - q2);
	ret.push_back(q1 + q2);
	return ret;
}

const int MAX_N_CIRLCES = 2000 + 10;
Point cs[MAX_N_CIRLCES];
double rs[MAX_N_CIRLCES];
int nCircles;

double mid, left, right;
double minR, maxL;
int minRId, maxLId;
bool has;

void addCircle(int i) {
	double dx = cs[i].x - mid;
	if (compare(fabs(dx), rs[i]) == 1) {
		has = true;
		return;
	}
	dx = min(dx, rs[i]);
	double dy = sqrt(rs[i] * rs[i] - dx * dx);
	double iL = cs[i].y - dy, iR = cs[i].y + dy;
	if (iL &gt; maxL) {
		maxL = iL;
		maxLId = i;
	}
	if (iR &lt; minR) {
		minR = iR;
		minRId = i;
	}
}

void resetMid(int cur) {
	mid = (left + right) / 2;
	minR = 1e100, maxL = -1e100;
	has = false;
	for (int i = 0; i &lt;= cur; ++i) {
		addCircle(i);
	}
}

bool check() {
	return !has &amp;&amp; compare(maxL, minR) &lt;= 0;
}

int main() {
	scanf("%d", &amp;nCircles);
	for (int i = 0; i &lt; nCircles; ++i) {
		cs[i].read();
		scanf("%lf", rs + i);
	}

	left = cs[0].x - rs[0], right = cs[0].x + rs[0];
	resetMid(0);
	for (int i = 1; i &lt; nCircles; ++i) {
		addCircle(i);
		while (right - left &gt; EPS) {
			if (check())
				break;
			bool has[3] = { };
			for (int j = 0; j &lt;= i; ++j) {
				double cL = cs[i].x - rs[i], cR = cs[i].x + rs[i];
				if (compare(cL, mid) == 1)
					has[2] = true;
				else if (compare(cR, mid) == -1)
					has[0] = true;
				else
					has[1] = true;
			}
			if (has[0] &amp;&amp; has[2])
				break;
			if (has[0]) {
				right = mid;
				resetMid(i);
				continue;
			}
			if (has[2]) {
				left = mid;
				resetMid(i);
				continue;
			}

			vector&lt;Point&gt; is = isCC(cs[minRId], rs[minRId], cs[maxLId],
					rs[maxLId]);
			if (is.empty())
				break;

			if (is[0].x &gt; mid) {
				left = mid;
				resetMid(i);
			} else {
				right = mid;
				resetMid(i);
			}
		}
		if (!check()) {
			printf("%d\n", i + 1);
			return 0;
		}
	}
	puts("NIE");
}
</pre><pre></pre><h2>Problem1550</h2><pre>/*
 * 打电话(tel).cpp
 *
 *  Created on: 2011-3-1
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_NPEOPLE = 100000;
const int MAX_PHONE = 1000000;
const int MAX_NDIGIT = 6;
const int BASE = 10;
const int pow[] = { 1, 10, 100, 1000, 10000, 100000, 1000000 };

bool exist[MAX_PHONE] = { };
int nPeople;

int prob[BASE][BASE];

void inputData() {
	scanf("%d", &amp;nPeople);
	for (int i = 0; i &lt; nPeople; ++i) {
		int phone;
		scanf("%d", &amp;phone);
		exist[phone] = true;
	}

	for (int i = 0; i &lt; BASE; ++i) {
		for (int j = 0; j &lt; BASE; ++j) {
			scanf("%d", &amp;prob[i][j]);
		}
	}
}

int sum[MAX_PHONE][MAX_NDIGIT] = { };

void calcSum() {
	for (int i = 0; i &lt; MAX_PHONE; ++i) {
		int am = i % 10;
		int last = i / 10;
		int res = 0;
		for (int first = 0; first &lt; BASE; ++first) {
			if (exist[first + last * 10])
				res += prob[am][first];
		}
		sum[i][0] = res;
	}

	for (int known = 1; known &lt;= 5; ++known) {
		for (int i = 0; i &lt; MAX_PHONE; ++i) {
			int am = (i / pow[known]) % 10;
			int res = 0;
			for (int that = 0; that &lt; BASE; ++that) {
				res += prob[am][that] * sum[i + (that - am) * pow[known]][known
						- 1];
			}
			sum[i][known] = res;
		}
	}
}

int probToSelf(int call) {
	int res = 1;
	for (int digit = 0; digit &lt; MAX_NDIGIT; ++digit) {
		int am = call % 10;
		res *= prob[am][am];
		call /= 10;
	}
	return res;
}

void work() {
	calcSum();

	int nAsk;
	scanf("%d", &amp;nAsk);
	while (nAsk--) {
		int call;
		scanf("%d", &amp;call);
		int ans = sum[call][5] - probToSelf(call);
		printf("%d\n", ans);
	}
}

void solve() {
	inputData();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem1559</h2><pre>/*
 * [JSOI2009]密码.cpp
 *
 *  Created on: 2011-3-15
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_L_BIG_WORD = 25 + 10;
const int MAX_N_WORD = 10;
const int MAX_N_ALPHABET = 26;
const int MAX_L_WORD = 10;

struct Trie {
	Trie* ch[MAX_N_ALPHABET];
	Trie* jump[MAX_N_ALPHABET];
	Trie* sufLink;
	int id;
	int wordSet;
	static int numId;

	Trie() {
		memset(ch, 0, sizeof ch);
		sufLink = 0;
		memset(jump, 0, sizeof jump);
		id = numId++;
		wordSet = 0;
	}

	Trie* getCh(char what) {
		Trie*&amp;which = ch[what - 'a'];
		if (which == 0) {
			which = new Trie;
		}
		return which;
	}
};

int Trie::numId = 0;

int bigWordLen, nWords;
Trie*root;

void inputData() {
	cin &gt;&gt; bigWordLen &gt;&gt; nWords;
	root = new Trie;
	for (int i = 0; i &lt; nWords; ++i) {
		string s;
		cin &gt;&gt; s;
		Trie* t = root;
		for (int j = 0; j &lt; s.length(); ++j) {
			t = t-&gt;getCh(s[j]);
		}
		t-&gt;wordSet |= 1 &lt;&lt; i;
	}
}

const int MAX_N_NODES = MAX_L_WORD * MAX_N_WORD + 10;

Trie* que[MAX_N_NODES];
int qh, qt;

void build() {
	qh = qt = 0;
	que[qt++] = root;
	for (; qh &lt; qt;) {
		Trie*u = que[qh++];
		for (int what = 0; what &lt; MAX_N_ALPHABET; ++what) {
			if (u-&gt;ch[what] != 0) {
				Trie *v = u-&gt;ch[what];
				Trie *p = u-&gt;sufLink;
				while (p &amp;&amp; p-&gt;ch[what] == 0)
					p = p-&gt;sufLink;
				if (p == 0)
					v-&gt;sufLink = root;
				else
					v-&gt;sufLink = p-&gt;ch[what];
				que[qt++] = v;
				v-&gt;wordSet |= v-&gt;sufLink-&gt;wordSet;
			}
		}
	}

	for (int i = 0; i &lt; qt; ++i) {
		Trie*u = que[i];
		for (int what = 0; what &lt; MAX_N_ALPHABET; ++what) {
			Trie* t = u;
			while (t &amp;&amp; t-&gt;ch[what] == 0)
				t = t-&gt;sufLink;
			if (t == 0)
				u-&gt;jump[what] = root;
			else
				u-&gt;jump[what] = t-&gt;ch[what];
		}
	}
}

typedef long long int64;
int64 memo[MAX_N_NODES][MAX_L_BIG_WORD][1 &lt;&lt; MAX_N_WORD];//state,len,wordSet

int64 rec(Trie* u, int len, int wordSet) {//we need all word
	if (len == 0) {
		return wordSet == (1 &lt;&lt; nWords) - 1 ? 1 : 0;
	}
	int64&amp;ret = memo[u-&gt;id][len][wordSet];
	if (ret != -1)
		return ret;
	ret = 0;
	for (int what = 0; what &lt; MAX_N_ALPHABET; ++what) {
		Trie*v = u-&gt;jump[what];
		ret += rec(v, len - 1, wordSet | v-&gt;wordSet);
	}

	return ret;
}

int64 doDp() {
	memset(memo, -1, sizeof memo);
	return rec(root, bigWordLen, 0);
}

vector&lt;string&gt; ans;
string path;

void construct(Trie*u, int len, int wordSet) {
	int64 ret = rec(u, len, wordSet);
	if (ret == 0)
		return;
	if (len == 0) {
		ans.push_back(path);
		return;
	}
	for (int what = 0; what &lt; MAX_N_ALPHABET; ++what) {
		Trie*v = u-&gt;jump[what];
		path[bigWordLen - len] = 'a' + what;
		construct(v, len - 1, wordSet | v-&gt;wordSet);
	}
}

void solve() {
	inputData();
	build();
	int64 ansCnt = doDp();
	cout &lt;&lt; ansCnt &lt;&lt; endl;
	if (ansCnt &lt;= 42) {
		path.resize(bigWordLen);
		construct(root, bigWordLen, 0);
		sort(ans.begin(), ans.end());
		foreach(e,ans)
			cout &lt;&lt; *e &lt;&lt; endl;
	}
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem1560</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=1000,maxm=200000,inf=~0U&gt;&gt;2;
int M[maxn],X[maxn]={},n,m;
struct Land
{
    int i,j,v;
    Land(){}
    Land(int _i,int _j,int _v):i(_i),j(_j),v(_v){}
    bool operator&lt;(const Land&amp;o)const
    {
        if(i!=o.i)return i&lt;o.i;
        return j&lt;o.j;
    }
}A[maxm];
inline int Dist(int a,int b,int i,int j)
{
    return (a-i)*(a-i)+(b-j)*(b-j);
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d",&amp;n,&amp;m);int x,y,v;
    rep(i,m)M[i]=-inf;
    rep(i,n)
    {
        scanf("%d%d%d",&amp;x,&amp;y,&amp;v);--x;--y;
        A[i]=Land(x,y,v);
    }
    sort(A,A+n);int ret;
    M[0]=A[0].v;
    for(int i=1;i&lt;n;i++)
    {
        x=A[i].i;y=A[i].j;v=A[i].v;
        ret=-inf;
        rep(j,y+1)
            ret&gt;?=M[j]-Dist(x,y,X[j],j);
        ret+=v;
        M[y]=ret;X[y]=x;
    }
    printf("%d\n",ret);
}
</pre><pre></pre><h2>Problem1561</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include &lt;sstream&gt;
using namespace std;

class Expr{
public:
	virtual void write(ostringstream&amp;oss,bool inTerm,bool inv) = 0;
};

class Op:public Expr{
public:
	Op(char _op,Expr*_l,Expr*_r):
		op(_op),l(_l),r(_r){}

	void write(ostringstream&amp;oss,bool inFactor,bool inv){
		bool factorOp=op=='*'||op=='/';
		if(inFactor&amp;&amp;!factorOp){
			oss&lt;&lt;"(";
			write(oss,false,false);
			oss&lt;&lt;")";
			return;
		}
		if(inFactor!=factorOp)
			inv=false;
		l-&gt;write(oss,factorOp,inv);
		if(inv)
			oss&lt;&lt;(factorOp?(op=='*'?'/':'*') : (op=='+'?'-':'+'));
		else
			oss&lt;&lt;op;
		bool invOp=op=='-'||op=='/';
		r-&gt;write(oss,factorOp,inv^invOp);
	}
private:
	char op;
	Expr*l,*r;
};

class Var:public Expr{
public:
	Var(char _name):
		name(_name){}
	void write(ostringstream&amp;oss,bool inTerm,bool inv){
		oss&lt;&lt;name;
	}
private:
	char name;
};

string input;
int at;

bool hasNextChar(){
	return at&lt;input.size();
}

char nextChar(){
	return input[at];
}

void skip(){
	++at;
}

Expr* parseExpression();
Expr* parseTerm();
Expr* parseFactor();

Expr* parseExpression(){
	Expr* e=parseTerm();
	while(hasNextChar() &amp;&amp; (nextChar()=='+'||nextChar()=='-')){
		char op=nextChar();
		skip();
		e=new Op(op,e,parseTerm());
	}
	return e;
}

Expr* parseTerm(){
	Expr* e=parseFactor();
	while(hasNextChar() &amp;&amp; (nextChar()=='*'||nextChar()=='/')){
		char op=nextChar();
		skip();
		e=new Op(op,e,parseFactor());
	}
	return e;
}

Expr* parseFactor(){
	if(nextChar()=='('){
		skip();//(
		Expr*e=parseExpression();
		skip();//)
		return e;
	} else {
		char name=nextChar();
		skip();
		return new Var(name);
	}
}

void solve(){
	cin&gt;&gt;input;
	at=0;
	Expr*e=parseExpression();
	ostringstream oss;
	e-&gt;write(oss,false,false);
	cout&lt;&lt;oss.str()&lt;&lt;endl;
}

int main(){
	int nTests;cin&gt;&gt;nTests;
	while(nTests--)
		solve();
}
</pre><pre></pre><h2>Problem1562</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=10000;
int LinkX[maxn],LinkY[maxn],D[maxn],TmpLink[maxn],n;
bool Vis[maxn],Fixed[maxn]={};
int ex,ey;
bool Find(int x)
{
     if(Vis[x]||Fixed[x])return false;
     Vis[x]=true;
     #define go(y)\
     if(x!=ex||y!=ey)\
     if(LinkY[y]==-1||Find(LinkY[y]))\
          return LinkY[y]=x,LinkX[x]=y,true;
     int y=(x+D[x])%n;go(y);
     y=(x-D[x]+n)%n;go(y);
     return false;
}
int MaxMatch()
{
     memset(LinkY,-1,sizeof LinkY);
     int ans=0;
     ex=ey=-1;
     rep(i,n)
     {
          memset(Vis,0,sizeof Vis);
          if(Find(i))ans++;
          else return ans;
     }
     return ans;
}
void Init()
{
     scanf("%d",&amp;n);
     rep(i,n)scanf("%d",D+i);
}
void Solve()
{
     for(int i=0;i&lt;n;i++)
     {
          int a=(i+D[i])%n,b=(i-D[i]+n)%n;
          if(a&gt;b)swap(a,b);
          if(LinkX[i]==a){Fixed[i]=true;continue;}
          LinkY[b]=-1;
          ex=i;ey=b;
          memset(Vis,0,sizeof Vis);
          if(!Find(i))
          {
               LinkY[b]=i;
               LinkX[i]=b;
          }
          Fixed[i]=true;
     }
     rep(i,n){if(i)cout&lt;&lt;" ";cout&lt;&lt;LinkX[i];}
     cout&lt;&lt;endl;
}
int main()
{
     //freopen("in.cpp","r",stdin);
     //freopen("out.cpp","w",stdout);
     Init();
     int match=MaxMatch();
     if(match!=n)
     {
          cout&lt;&lt;"No Answer"&lt;&lt;endl;
          return 0;
     }
     Solve();
}
</pre><pre></pre><h2>Problem1563</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
const int maxn=100000+10;
typedef long long ll;
const ll MaxRet=1e18,Lim=MaxRet+100;
int NumCase,N,L,P;
int Sum[maxn];
inline int EatLine()
{
    char c;int cnt=0;
    while(c=getchar(),c!='\n')cnt++;
    return cnt;
}
void Input_Data()
{
    scanf("%d%d%d",&amp;N,&amp;L,&amp;P);
    EatLine();
    Sum[0]=0;
    rep(i,N)
        Sum[i+1]=Sum[i]+EatLine();
}
double D_Power(double x,int e)
{
    if(!e)return 1;
    double tmp=D_Power(x,e&gt;&gt;1);
    tmp*=tmp;if(e&amp;1)tmp*=x;
    return tmp;
}
ll L_Power(ll x,int e)
{
    if(!e)return 1;
    ll tmp=L_Power(x,e&gt;&gt;1);
    tmp*=tmp;if(e&amp;1)tmp*=x;
    return tmp;
}
ll Dp[maxn];
inline double D_abs(double a){return a&gt;0?a:-a;}
inline ll L_abs(ll a){return a&gt;0?a:-a;}
double D_Calc_State(int prev,int now)
{
    return Dp[prev]+D_Power(D_abs(double(Sum[now]-Sum[prev]+now-prev-1-L)),P);
}
ll L_Calc_State(int prev,int now)
{
    return Dp[prev]+L_Power(L_abs(Sum[now]-Sum[prev]+now-prev-1-L),P);
}
bool Better(int ch1,int ch2,int pos)//is ch1 better than ch2 at pos?
{
    return D_Calc_State(ch1,pos)&lt;=D_Calc_State(ch2,pos);
}
struct Strategy
{
    int l,r,ch;
    Strategy(){}
    Strategy(int _l,int _r,int _ch):
        l(_l),r(_r),ch(_ch){}
}Q[maxn];
int h,t;
int Binary_Search(Strategy st,int x)
{
    if(Better(st.ch,x,st.r))return st.r;
    int l=st.l,r=st.r;
    while(l+1&lt;r)
    {
        int m=l+r&gt;&gt;1;
        if(Better(st.ch,x,m))
            l=m;
        else
            r=m;
    }
    return l;
}
void Solve()
{
    Dp[0]=0;h=t=0;Q[t++]=Strategy(0,N,0);
    for(int i=1;i&lt;=N;i++)
    {
        if(Q[h].l&lt;i)Q[h].l=i;
        if(Q[h].l&gt;Q[h].r)h++;
        double Dret=D_Calc_State(Q[h].ch,i);
        if(Dret&lt;Lim)
            Dp[i]=L_Calc_State(Q[h].ch,i);
        else
            Dp[i]=Lim;
        while(h&lt;t)
        {
            if(Better(i,Q[t-1].ch,Q[t-1].l))
                t--;
            else
                break;
        }
        if(h==t)
            Q[t++]=Strategy(i,N,i);
        else
        {
            int split=Binary_Search(Q[t-1],i);
            Q[t-1].r=split;
            if(split&lt;N)
                Q[t++]=Strategy(split+1,N,i);
        }
    }
    if(Dp[N]&gt;MaxRet)
        puts("Too hard to arrange");
    else
        cout&lt;&lt;Dp[N]&lt;&lt;endl;
    puts("--------------------");
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    scanf("%d",&amp;NumCase);
    while(NumCase--)
    {
        Input_Data();
        Solve();
    }
}
</pre><pre></pre><h2>Problem1564</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
const int maxn=100,inf=~0U&gt;&gt;1;
struct node
{
    int val,key,s;
    bool operator&lt;(const node&amp;that)const
    {
        return val&lt;that.val;
    }
}A[maxn];
struct Index
{
    int A[maxn],n;
    void Clear()
    {
        n=0;
    }
    void add(int x)
    {
        A[n++]=x;
    }
    void Doit()
    {
        sort(A,A+n);
        n=unique(A,A+n)-A;
    }
    int operator[](int x)
    {
        return lower_bound(A,A+n,x)-A;
    }
}I;
int N,K;
int Sum[maxn][maxn]={};
void PrePare_Sum()
{
    for(int l=0;l&lt;N;l++)
        for(int r=l;r&lt;N;r++)
            if(l==r)Sum[l][r]=A[l].s;
            else Sum[l][r]=Sum[l][r-1]+A[r].s;
}
int Mem[maxn][maxn][maxn];
int Dp(int l,int r,int x)
{
    if(l&gt;r)return 0;
    if(l==r)return Sum[l][r];
    int id=I[x];
    int&amp;mem=Mem[l][r][id];
    if(mem!=-1)return mem;
    mem=inf;
    int nxt=inf,ret,pos;
    for(int i=l;i&lt;=r;i++)
    {
        if(A[i].key&lt;=x)
        {
            ret=Dp(l,i-1,x)+Dp(i+1,r,x)+Sum[l][r];
            if(ret&lt;mem)mem=ret;
        }
        else
        {
            if(A[i].key&lt;nxt)nxt=A[i].key,pos=i;
            ret=Dp(l,i-1,x)+Dp(i+1,r,x)+Sum[l][r]+K;
            if(ret&lt;mem)mem=ret;
        }
    }
    if(nxt!=inf)
    {
        ret=Dp(l,r,nxt)+K;
        if(ret&lt;mem)mem=ret;
        ret=Dp(l,pos-1,x)+Dp(pos+1,r,x)+Sum[l][r];
        if(ret&lt;mem)mem=ret;
    }
    return mem;
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d",&amp;N,&amp;K);
    I.Clear();
    rep(i,N)cin&gt;&gt;A[i].val;
    rep(i,N)cin&gt;&gt;A[i].key,I.add(A[i].key);
    rep(i,N)cin&gt;&gt;A[i].s;
    I.add(-1);I.Doit();
    sort(A,A+N);
    PrePare_Sum();
    memset(Mem,-1,sizeof Mem);
    cout&lt;&lt;Dp(0,N-1,-1)&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1565</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
const int maxn=20+1,maxm=30+1,maxv=maxn*maxm,maxe=maxv*maxv*2,inf=~0U&gt;&gt;1;
int head[maxv],mnt;
int nxt[maxe],to[maxe],c[maxe];
int n,m,v,vs,vt;
int S[maxv];
void ClearList()
{
    memset(head,-1,sizeof head);
    mnt=0;
}
void AddEdge(int s,int t,int _c)
{
    to[mnt]=t;nxt[mnt]=head[s];c[mnt]=_c;
    head[s]=mnt++;
}
void InsEdge(int s,int t,int c)
{
    AddEdge(s,t,c);
    AddEdge(t,s,0);
}
void Init()
{
    scanf("%d%d",&amp;n,&amp;m);
    v=n*m;
    ClearList();
    int u,w,x,y,t;
    rep(i,n)rep(j,m)
    {
        u=i*m+j;
        scanf("%d",&amp;S[u]);
        scanf("%d",&amp;w);
        while(w--)
        {
            scanf("%d%d",&amp;x,&amp;y);
            t=x*m+y;
            InsEdge(t,u,inf);
        }
        if(j)InsEdge(u-1,u,inf);
    }
}
#define tr(e,x)for(int e=head[x];e!=-1;e=nxt[e])
int Q[maxv],in[maxv]={},h,t;
bool Mark[maxv]={};
void FindCycle()
{
    rep(i,v)tr(e,i)if(!c[e])
        in[to[e]]++;
    h=t=0;
    rep(i,v)if(!in[i])
        Q[t++]=i;
    for(;h&lt;t;h++)
    {
        int x=Q[h];Mark[x]=true;
        tr(e,x)if(!c[e])if(!--in[to[e]])
            Q[t++]=to[e];
    }
}
int Sum=0;
void BuildGraph()
{
    vs=v++;vt=v++;
    rep(i,n*m)if(Mark[i])
    {
        if(S[i]&gt;0)Sum+=S[i],InsEdge(vs,i,S[i]);
        else InsEdge(i,vt,-S[i]);
    }
    Mark[vs]=Mark[vt]=true;
}
int Vis[maxv]={},flag=0,Flow=0;
int D[maxv]={};
bool ReLabel()
{
    memset(D,-1,sizeof D);
    D[vs]=0;int h,t;
    for(h=t=0,Q[t++]=vs;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,x)if(c[e]&amp;&amp;D[to[e]]==-1)
        {
            D[to[e]]=D[x]+1;
            Q[t++]=to[e];
            if(to[e]==vt)return true;
        }
    }
    return false;
}
void Aug()
{
    static int Stack[maxv],top;top=0;
    static int P[maxv],E[maxv];
    memcpy(E,head,sizeof(int)*v);
    Stack[top++]=vs;
    while(top&gt;0)
    {
        int x=Stack[top-1];
        if(x==vt)
        {
            int dt=inf;
            for(int i=top-1;i&gt;=1;i--)
                dt=min(dt,c[P[i]]);
            Flow+=dt;
            for(int i=top-1;i&gt;=1;i--)
            {
                c[P[i]]-=dt;
                c[P[i]^1]+=dt;
                if(!c[P[i]])top=i;
            }
        }
        else
        {
            int&amp;e=E[x];
            for(;e!=-1;e=nxt[e])
                if(c[e]&amp;&amp;D[x]+1==D[to[e]])break;
            if(e==-1)D[x]=-1,top--;
            else Stack[top]=to[e],P[top++]=e;
        }
    }
}
int CalFlow()
{
    while(ReLabel())
        Aug();
    return Flow;
}
void Solve()
{
    Sum-=CalFlow();
    printf("%d\n",Sum);
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    FindCycle();
    BuildGraph();
    Solve();
}
</pre><pre></pre><h2>Problem1566</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=500+10;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int mod=1024523;
int Dp[2][maxn][maxn]={},A[maxn],B[maxn],n,m;
inline void Update(int&amp;x,int c){x+=c;x%=mod;}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;char c;
    rep(i,n)cin&gt;&gt;c,A[n-i]=c-'A';
    rep(i,m)cin&gt;&gt;c,B[m-i]=c-'A';
    int now=0,next=1;Dp[next][0][0]=1;
    for(int i=0;i&lt;=n;i++)
    {
        swap(now,next);memset(Dp[next],0,sizeof(Dp[next]));
        for(int j=0;j&lt;=m;j++)
            for(int k=0;k&lt;=n;k++)
            if(int x=Dp[now][j][k])
            {
                int d=i+j-k;
                if(A[i+1]==A[k+1])Update(Dp[next][j][k+1],x);
                if(A[i+1]==B[d+1])Update(Dp[next][j][k],x);
                if(B[j+1]==A[k+1])Update(Dp[now][j+1][k+1],x);
                if(B[j+1]==B[d+1])Update(Dp[now][j+1][k],x);
            }
    }
    cout&lt;&lt;Dp[now][m][n]&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1566</h2><pre>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int maxn=500+10,mod=1024523;
using namespace std;
int Dp[2][maxn][maxn]={},A[maxn],B[maxn],n,m;
inline void Update(int&amp;x,int c){x+=c;x%=mod;}
int main()
{
    cin&gt;&gt;n&gt;&gt;m;char c;
    rep(i,n)cin&gt;&gt;c,A[n-i]=c-'A';
    rep(i,m)cin&gt;&gt;c,B[m-i]=c-'A';
    int now=0,next=1;Dp[next][0][0]=1;
    rep(i,n+1)
    {
        swap(now,next);memset(Dp[next],0,sizeof(Dp[next]));
        rep(j,m+1)rep(k,n+1)
            if(int x=Dp[now][j][k])
            {
                int d=i+j-k;
                if(A[i+1]==A[k+1])Update(Dp[next][j][k+1],x);
                if(A[i+1]==B[d+1])Update(Dp[next][j][k],x);
                if(B[j+1]==A[k+1])Update(Dp[now][j+1][k+1],x);
                if(B[j+1]==B[d+1])Update(Dp[now][j+1][k],x);
            }
    }
    cout&lt;&lt;Dp[now][m][n]&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1567</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=50,seed[2]={1771,17773},size=17771;
typedef unsigned long long ull;
int n;
ull Power[2][maxn];
struct Hash
{
    struct node
    {
        ull key;
        node*next;
        node(ull _key,node*_next):key(_key),next(_next){}
    }*H[size];
    void clear(){memset(H,0,sizeof(H));}
    Hash(){clear();}
    void insert(ull key)
    {
        int h=key%size;
        H[h]=new node(key,H[h]);
    }
    bool find(ull key)
    {
        int h=key%size;
        for(node*i=H[h];i;i=i-&gt;next)if(i-&gt;key==key)return true;
        return false;
    }
}H;
struct Mat
{
    int M[maxn][maxn];
    void ReadIn()
    {
        for(int i=0;i&lt;n;i++)
            for(int j=0;j&lt;n;j++)
                scanf("%d",&amp;M[i][j]);
    }
    int operator()(int i,int j)const{return M[i][j];}
}A,B;
int s;
ull L[maxn][maxn];
void CalLeft(const Mat&amp;M)
{
    for(int i=0;i&lt;n;i++)
    {
        ull ret=0;
        for(int j=0;j&lt;s;j++)
            ret*=seed[0],ret+=M(i,j);
        L[i][0]=ret;
        for(int j=1;j+s&lt;=n;j++)
            ret-=Power[0][s-1]*M(i,j-1),ret*=seed[0],ret+=M(i,j+s-1),L[i][j]=ret;
    }
}
void InsertToHash(const Mat&amp;M)
{
    CalLeft(M);H.clear();
    for(int l=0;l+s&lt;=n;l++)
    {
        int r=l+s-1;
        ull ret=0;
        for(int j=0;j&lt;s;j++)
            ret*=seed[1],ret+=L[j][l];
        H.insert(ret);
        for(int j=1;j+s&lt;=n;j++)
            ret-=Power[1][s-1]*L[j-1][l],ret*=seed[1],ret+=L[j+s-1][l],H.insert(ret);
    }
}
bool CheckHash(const Mat&amp;M)
{
    CalLeft(M);
    for(int l=0;l+s&lt;=n;l++)
    {
        int r=l+s-1;
        ull ret=0;
        for(int j=0;j&lt;s;j++)
            ret*=seed[1],ret+=L[j][l];
        if(H.find(ret)) return true;
        for(int j=1;j+s&lt;=n;j++)
        {
            ret-=Power[1][s-1]*L[j-1][l],ret*=seed[1],ret+=L[j+s-1][l];
            if(H.find(ret)) return true;
        }
    }
    return false;
}
bool Check(int size)
{
    s=size;
    InsertToHash(A);
    return CheckHash(B);
}
void init()
{
    scanf("%d",&amp;n);
    Power[0][0]=Power[1][0]=1;
    for(int j=0;j&lt;2;j++)for(int i=1;i&lt;n;i++) Power[j][i]=Power[j][i-1]*seed[j];
    A.ReadIn();B.ReadIn();
}
void work()
{
    int l=0,r=n;
    if(Check(r)){printf("%d\n",r);return;}
    while(l+1&lt;r)
    {
        int m=(l+r)/2;
        if(Check(m)) l=m;
        else r=m;
    }
    printf("%d\n",l);
}
int main()
{
    //freopen("in","r",stdin);
    init();
    work();
}
</pre><pre></pre><h2>Problem1571</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int TM_MAX=10000+10,SK_MAX=100+10,inf=~0U&gt;&gt;3;
int T,S,N;
struct Lesson
{
    int end,A;
    Lesson(int _end,int _A):
        end(_end),A(_A){}
};
vector&lt;Lesson&gt; start[TM_MAX];
void add_lesson(int st,int last,int A)
{
    start[st].push_back(Lesson(st+last,A));
}
int Min[SK_MAX];
void input_data()
{
    rep(i,SK_MAX)Min[i]=inf;
    scanf("%d%d%d",&amp;T,&amp;S,&amp;N);
    int st,last,A;
    rep(i,S)
    {
        scanf("%d%d%d",&amp;st,&amp;last,&amp;A);
        add_lesson(st,last,A);
    }
    int C,D;
    rep(i,N)
    {
        scanf("%d%d",&amp;C,&amp;D);
        Min[C]=min(Min[C],D);
    }
    rep(i,SK_MAX-1)
    {
        Min[i+1]=min(Min[i+1],Min[i]);
    }
}
typedef vector&lt;Lesson&gt;::iterator vit;
#define tr(e,x) for(vit e=x.begin();e!=x.end();e++)
int Mem[TM_MAX][SK_MAX];
int dp(int cur_t,int cur_sk)
{
    if(cur_t&gt;T)return -inf;
    if(cur_t==T)return 0;
    int&amp;ret=Mem[cur_t][cur_sk];
    if(ret!=-1)return ret;
    ret=0;
    tr(e,start[cur_t])
    {
        ret=max(ret,dp(e-&gt;end,e-&gt;A));
    }
    ret=max(ret,dp(cur_t+Min[cur_sk],cur_sk)+1);
    ret=max(ret,dp(cur_t+1,cur_sk));
    return ret;
}
void solve()
{
    input_data();
    memset(Mem,-1,sizeof Mem);
    printf("%d\n",dp(0,1));
}
int main()
{
    //freopen("in.cpp","r",stdin);
    //freopen("out.cpp","w",stdout);
    solve();
}
</pre><pre></pre><h2>Problem1572</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#include &lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(VI::iterator e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
#define All(x) x.begin(),x.end()
const int inf=~0U&gt;&gt;1,maxn=1000000000;
using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;int&gt; VI;
int main()
{
    //freopen("in","r",stdin);
    int n,d,p;
    cin&gt;&gt;n;
    map&lt;int,VI&gt; M;
    rep(i,n)
    {
        scanf("%d%d",&amp;d,&amp;p);
        M[d].pb(p);
    }
    vector&lt;pair&lt;int,VI&gt; &gt; A(All(M));
    priority_queue&lt;int&gt; PQ;
    int j=A.size()-1;
    ll ans=0;
    for(int i=maxn;i&gt;=1;)
    {
        if(i==A[j].first)
        {
            VI&amp;tmp=A[j].second;
            tr(e,tmp)PQ.push(*e);
            j--;
        }
        if(PQ.size())
        {
            ans+=PQ.top();
            PQ.pop();
            i--;
        }
        else
        {
            if(j&gt;=0)i=A[j].first;
            else break;
        }
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1576</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;utility&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_V = 100000 + 10;
const int MAX_E = 200000 + 10;
struct Edge {
	int t, c;
};

vector&lt;Edge&gt; E[MAX_V];

struct WEdge {
	int a, b, w;
	bool operator&lt;(const WEdge&amp;e) const {
		return w &lt; e.w;
	}
};
WEdge es[MAX_E];
int nV, nE;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

void readInput() {
	scanInt(nV);
	scanInt(nE);

	for (int i = 0; i &lt; nE; ++i) {
		int a, b, c;
		scanInt(a);
		scanInt(b);
		scanInt(c);
		--a;
		--b;
		E[a].push_back( { b, c });
		E[b].push_back( { a, c });
		es[i] = {a,b,c};
	}
}

int D[MAX_V];
int Ans[MAX_V];
int F[MAX_V];
bool used[MAX_V] = { };

void dijstra() {
	fill(D, D + nV, INT_MAX);
	D[0] = 0;
	priority_queue&lt;pair&lt;int, int&gt; &gt; que;
	que.push(make_pair(-D[0], 0));
	while (!que.empty()) {
		int u = que.top().second;
		que.pop();
		if (used[u])
			continue;
		used[u] = true;
		foreach(e,E[u])
			if (D[u] + e-&gt;c &lt; D[e-&gt;t]) {
				F[e-&gt;t] = u;
				D[e-&gt;t] = D[u] + e-&gt;c;
				que.push(make_pair(-D[e-&gt;t], e-&gt;t));
			}
	}
}

int Fa[MAX_V];
int find(int x) {
	if (Fa[x] == x)
		return x;
	return Fa[x] = find(Fa[x]);
}

void mark(int u, int v, int c) {
	if (F[u] == v || F[v] == u)
		return;
	u = find(u);
	v = find(v);
	while (true) {
		if (u == v)
			break;
		if (D[u] &lt; D[v])
			swap(u, v);
		Ans[u] = c;
		Fa[u] = F[u];
		u = find(u);
	}
}

void work() {
	dijstra();
	memset(Ans, -1, sizeof Ans);
	for (int i = 0; i &lt; nE; ++i) {
		es[i].w += D[es[i].a] + D[es[i].b];
	}
	sort(es, es + nE);
	for (int i = 0; i &lt; nV; ++i) {
		Fa[i] = i;
	}
	for (int i = 0; i &lt; nE; ++i) {
		mark(es[i].a, es[i].b, es[i].w);
	}
	for (int i = 1; i &lt; nV; ++i) {
		if (Ans[i] != -1) {
			Ans[i] -= D[i];
		}
		printf("%d\n", Ans[i]);
	}
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem1579</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int maxn=10000+10;
typedef long long ll;
const ll inf=ll(1)&lt;&lt;60;
struct Edge
{
    int t,c;
    bool operator&lt;(const Edge&amp;o) const
    {return c&lt;o.c;}
    Edge(int _t,int _c):t(_t),c(_c){}
};
vector&lt;Edge&gt; E[maxn];
typedef vector&lt;Edge&gt;::iterator eit;
void InsEdge(int s,int t,int c){E[s].pb(Edge(t,c));E[t].pb(Edge(s,c));}
int n,m,k;
ll Dp[2][maxn];
struct State
{
    int p;ll c;
    State(int _p,ll _c):p(_p),c(_c){}
    bool operator&lt;(const State&amp;o)const
    {return c&gt;o.c;}
};
priority_queue&lt;State&gt; Q;
int main()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;int s,t,c;
    rep(i,m)scanf("%d %d %d",&amp;s,&amp;t,&amp;c),InsEdge(s-1,t-1,c);
    rep(i,n)sort(E[i].begin(),E[i].end());
    int now=0,next=1;rep(i,n)Dp[next][i]=inf;Dp[next][0]=0;
    rep(o,k+1)
    {
        swap(now,next);
        rep(i,n)if(Dp[now][i]!=inf) Q.push(State(i,Dp[now][i]));
        //Update now
        while(Q.size())
        {
            State t=Q.top();Q.pop();if(Dp[now][t.p]!=t.c)continue;
            Dp[now][t.p]=t.c;int ncost;
            for(eit e=E[t.p].begin();e!=E[t.p].end();++e)
                if((ncost=t.c+e-&gt;c)&lt;Dp[now][e-&gt;t])
                    Dp[now][e-&gt;t]=ncost,Q.push(State(e-&gt;t,ncost));
        }
        //Update next
        rep(i,n) Dp[next][i]=Dp[now][i];
        rep(i,n) for(eit e=E[i].begin();e!=E[i].end();e++)
            Dp[next][e-&gt;t]&lt;?=Dp[now][i];
    }
    cout&lt;&lt;Dp[now][n-1]&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1579</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int maxn=10000+10;
typedef long long ll;
const ll inf=ll(1)&lt;&lt;60;
struct Edge
{
    int t,c;
    Edge(int _t,int _c):t(_t),c(_c){}
};
vector&lt;Edge&gt; E[maxn];
typedef vector&lt;Edge&gt;::iterator eit;
void InsEdge(int s,int t,int c){E[s].pb(Edge(t,c));E[t].pb(Edge(s,c));}
int n,m,k;
ll Dp[2][maxn];
struct State
{
    int p;ll c;
    State(int _p,ll _c):p(_p),c(_c){}
    bool operator&lt;(const State&amp;o)const
    {return c&gt;o.c;}
};
priority_queue&lt;State&gt; Q;
int main()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;int s,t,c;
    rep(i,m)scanf("%d %d %d",&amp;s,&amp;t,&amp;c),InsEdge(s-1,t-1,c);
    int now=0,next=1;rep(i,n)Dp[next][i]=inf;Dp[next][0]=0;
    rep(o,k+1)
    {
        swap(now,next);
        rep(i,n)if(Dp[now][i]!=inf) Q.push(State(i,Dp[now][i]));
        //Update now
        while(Q.size())
        {
            State t=Q.top();Q.pop();if(Dp[now][t.p]!=t.c)continue;
            Dp[now][t.p]=t.c;int ncost;
            for(eit e=E[t.p].begin();e!=E[t.p].end();++e)
                if((ncost=t.c+e-&gt;c)&lt;Dp[now][e-&gt;t])
                    Dp[now][e-&gt;t]=ncost,Q.push(State(e-&gt;t,ncost));
        }
        //Update next
        rep(i,n) Dp[next][i]=Dp[now][i];
        rep(i,n) for(eit e=E[i].begin();e!=E[i].end();e++)
            Dp[next][e-&gt;t]&lt;?=Dp[now][i];
    }
    cout&lt;&lt;Dp[now][n-1]&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1583</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=4000000+10;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int a[2],b[2],d[2];
ll S[maxn];
ll next[2];
int pos[maxn];
int main()
{
    //freopen("in","r",stdin);
    int N,s;cin&gt;&gt;S[1]&gt;&gt;N;
    rep(i,2)cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;d[i],next[i]=a[i]*S[1]/d[i]+b[i],pos[i]=1;
    s=1;
    while(s&lt;N)
    {
        int c=next[1]&lt;next[0];
        if(next[c]!=S[s])S[++s]=next[c];
        next[c]=a[c]*S[++pos[c]]/d[c]+b[c];
    }
    cout&lt;&lt;S[N]&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1584</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=40000+10,maxs=200+10;
using namespace std;
int last[maxn];
int Min_Index[maxs];
int Dp[maxn];
int n,m;
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;
    memset(last,-1,sizeof last);
    int sqrtN=sqrt(n)+1;
    Min_Index[0]=1;int x;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;x;
        int p=last[x],j;last[x]=i;
        for(j=0;j&lt;=sqrtN&amp;&amp;Min_Index[j]-1!=p;j++);
        for(j--;j&gt;=0;j--)Min_Index[j+1]=Min_Index[j];
        Min_Index[0]=i+1;
        Dp[i]=inf;
        for(j=1;j&lt;=sqrtN;j++)
            Dp[i]=min(Dp[i],Dp[Min_Index[j]-1]+j*j);
    }
    cout&lt;&lt;Dp[n]&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1585</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
typedef pair&lt;int,int&gt; ii;
const int inf=~0U&gt;&gt;1,maxn=3000+10,maxv=maxn*2;
int n,m,d;
struct Edge
{
    int t,c;
    Edge*next,*op;
    Edge(int _t,int _c,Edge*_next):t(_t),c(_c),next(_next){}
}*E[maxv]={0};
int h[maxv],vh[maxv],vs,vt,v;
inline int In(int i){return i*2;}
inline int Out(int i){return i*2+1;}
void InsEdge(int s,int t,int c)
{
    E[s]=new Edge(t,c,E[s]);
    E[t]=new Edge(s,0,E[t]);
    E[s]-&gt;op=E[t];E[t]-&gt;op=E[s];
}
int aug(int no,int m)
{
    if(no==vt) return m;
    int l=m;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;c&amp;&amp;h[no]==h[i-&gt;t]+1)
    {
        int d=aug(i-&gt;t,min(i-&gt;c,l));
        l-=d,i-&gt;c-=d,i-&gt;op-&gt;c+=d;
        if(l==0||h[vs]&gt;=v)return m-l;
    }
    int minh=v;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;c&amp;&amp;h[i-&gt;t]+1&lt;minh)
        minh=h[i-&gt;t]+1;
    if(--vh[h[no]]==0) h[vs]=v;vh[h[no]=minh]++;
    return m-l;
}
int CalFlow()
{
    memset(h,0,sizeof(h));
    memset(vh,0,sizeof(vh));
    vh[0]=v;
    int flow=0;while(h[vs]&lt;v)flow+=aug(vs,inf);
    return flow;
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d %d %d",&amp;n,&amp;m,&amp;d);int s,t;vs=Out(0);v=n*2+1;vt=v-1;
    while(m--)scanf("%d %d",&amp;s,&amp;t),--s,--t,InsEdge(Out(s),In(t),inf),InsEdge(Out(t),In(s),inf);
    rep(i,n)InsEdge(In(i),Out(i),1);
    while(d--)scanf("%d",&amp;s),--s,InsEdge(In(s),vt,inf);
    cout&lt;&lt;CalFlow()&lt;&lt;endl;
}

</pre><pre></pre><h2>Problem1589</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=100000;
using namespace std;
int C[maxn],n,In[maxn],Q[maxn];
int Mem[maxn];
int Dp(int x)
{
    if(Mem[x]!=-1)return Mem[x];
    return Mem[x]=1+Dp(C[x]);
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);
    rep(i,n)scanf("%d",C+i),C[i]--,In[C[i]]++;
    int h,t;h=t=0;
    rep(i,n)if(!In[i])Q[t++]=i;
    for(;h&lt;t;h++)
    {
        int x=Q[h];
        if(!--In[C[x]])Q[t++]=C[x];
    }
    memset(Mem,-1,sizeof Mem);
    rep(i,n)
    {
        if(Mem[i]&gt;=0)continue;
        if(In[i])
        {
            int x,s;
            for(x=i,s=0;;)
            {
                s++;x=C[x];
                if(x==i)break;
            }
            for(x=i;;)
            {
                Mem[x]=s;x=C[x];
                if(x==i)break;
            }
        }
    }
    rep(i,n)printf("%d\n",Dp(i));
}


</pre><pre></pre><h2>Problem1590</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=50000;
using namespace std;
struct Trie
{
    Trie*ch[2];
    int part,end;
    Trie(){memset(ch,0,sizeof ch);part=end=0;}
}*root;
int n,m;
int main()
{
    //freopen("in","r",stdin);
    root=new Trie;
    scanf("%d%d",&amp;m,&amp;n);
    rep(i,m)
    {
        int t,x;scanf("%d",&amp;t);
        Trie*p=root;
        rep(i,t)
        {
            scanf("%d",&amp;x);
            if(!p-&gt;ch[x])
                p-&gt;ch[x]=new Trie;
            p=p-&gt;ch[x];p-&gt;part++;
        }
        p-&gt;end++;
    }
    rep(i,n)
    {
        int t,x;scanf("%d",&amp;t);
        bool ok=true;Trie*p=root;
        int ans=0;
        rep(i,t)
        {
            scanf("%d",&amp;x);
            if(!ok)continue;
            ans+=p-&gt;end;
            if(!p-&gt;ch[x])
            {
                ok=false;
                continue;
            }
            p=p-&gt;ch[x];
        }
        if(ok)ans+=p-&gt;part;
        printf("%d\n",ans);
    }
}


</pre><pre></pre><h2>Problem1592</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
using namespace std;
const int maxn=2010,inf=~0U&gt;&gt;1;
int A[maxn],B[maxn],DP[maxn],n;
inline int cost(int i,int j){return i&gt;j?(i-j):(j-i);}
int solve()
{
	for(int i=0;i&lt;n;i++)
		DP[i]=cost(B[i],A[0]);
	int tmp;
	for(int i=1;i&lt;n;i++)
	{
		tmp=inf;
		for(int j=0;j&lt;n;j++)
		{
			tmp=min(tmp,DP[j]);
			DP[j]=tmp+cost(B[j],A[i]);
		}
	}
	return *min_element(DP,DP+n);
}
int main()
{
	cin&gt;&gt;n;for(int i=0;i&lt;n;i++) scanf("%d",A+i),B[i]=A[i];
	sort(B,B+n);int ans=solve();
	for(int l=0,r=n-1;l&lt;r;l++,r--)		
		swap(A[l],A[r]);
	ans=min(ans,solve());
	cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem1593</h2><pre>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;utility&gt;
#include&lt;cstdio&gt;
#define Renew(x,c) x=max(x,c)
using namespace std;
struct Tree
{
	bool sign,e;
	int max,Lmax,Rmax,size,l,r;
	Tree*Lch,*Rch;
}A[150000],*now,*root;
Tree* NewNode(int l,int r)
{
	now-&gt;sign=false;
	now-&gt;max=now-&gt;Lmax=now-&gt;Rmax=r-l+1;
	now-&gt;size=r-l+1;
	now-&gt;l=l;
	now-&gt;r=r;
	return now++;
}
void Update(Tree*Fa)
{
	if(Fa-&gt;Lch-&gt;max==Fa-&gt;Lch-&gt;size)
		Fa-&gt;Lmax=Fa-&gt;Lch-&gt;size+Fa-&gt;Rch-&gt;Lmax;
	else
		Fa-&gt;Lmax=Fa-&gt;Lch-&gt;Lmax;
	if(Fa-&gt;Rch-&gt;max==Fa-&gt;Rch-&gt;size)
		Fa-&gt;Rmax=Fa-&gt;Rch-&gt;size+Fa-&gt;Lch-&gt;Rmax;
	else
		Fa-&gt;Rmax=Fa-&gt;Rch-&gt;Rmax;	
	Fa-&gt;max=Fa-&gt;Lch-&gt;Rmax+Fa-&gt;Rch-&gt;Lmax;
	Renew(Fa-&gt;max,max(Fa-&gt;Lch-&gt;max,Fa-&gt;Rch-&gt;max));
}
Tree* Build(int l,int r)
{
	if(l==r)return NewNode(l,r);
	int mid=(l+r)/2;
	Tree* T=NewNode(l,r);
	T-&gt;Lch=Build(l,mid);
	T-&gt;Rch=Build(mid+1,r);
	return T;	
}
void Set(Tree*T,bool e)
{
	T-&gt;sign=true;
	T-&gt;e=e;
	T-&gt;Lmax=T-&gt;Rmax=T-&gt;max=e?T-&gt;size:0;
}
void Push(Tree*T)
{
	if(T-&gt;sign)
	{	
		if(T-&gt;size&gt;1)
		{
			Set(T-&gt;Lch,T-&gt;e);
			Set(T-&gt;Rch,T-&gt;e);
		}
		T-&gt;sign=false;
	}
}
int l,r;
void set(Tree*T,bool e)
{
	if(T-&gt;l&gt;=l and T-&gt;r&lt;=r)
	{
		Set(T,e);
		return;
	}
	int mid=T-&gt;Lch-&gt;r;
	Push(T);
	if(mid&gt;=l)
		set(T-&gt;Lch,e);
	if(r&gt;mid)
		set(T-&gt;Rch,e);	
	Update(T);
}
int len;
int Put(Tree*T)
{	
	Push(T);
	if(T-&gt;Lch-&gt;max&gt;=len)
		return Put(T-&gt;Lch);
	if(T-&gt;Lch-&gt;Rmax+T-&gt;Rch-&gt;Lmax&gt;=len)	
		return T-&gt;Lch-&gt;r-T-&gt;Lch-&gt;Rmax+1;
	if(T-&gt;Rch-&gt;max&gt;=len)
		return Put(T-&gt;Rch);
	return 0;		
}
void In(int D)
{
	len=D;
	int a=Put(root);
	printf("%d\n",a);
	if(a)
		l=a,r=a+D-1,set(root,false);
}
void Out(int l,int r)
{
	::l=l;::r=r;
	set(root,true);
}
int n,m;
void init()
{
	cin&gt;&gt;n&gt;&gt;m;
	now=A;
	root=Build(1,n);
}
void work()
{
	int k,l,d;
	while(m--)
	{
		scanf("%d",&amp;k);
		if(k==1)
			scanf("%d",&amp;d),In(d);
		else
			scanf("%d %d",&amp;l,&amp;d),Out(l,l+d-1);
	}
}
int main()
{
	init();
	work();
}</pre><pre></pre><h2>Problem1594</h2><pre>/*
 *  [Usaco2008 Jan]猜数游戏.cpp
 *
 *  Created on: 2011-6-6
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 1000000 + 10;
const int MAX_Q = 25000 + 10;

struct Query {
	int l, r, a, id;
	void read(int _id) {
		id = _id;
		scanf("%d%d%d", &amp;l, &amp;r, &amp;a);
	}
};

int n, nQ;
Query queries[MAX_Q];
vector&lt;Query*&gt; byL[MAX_N], byR[MAX_N];
map&lt;int, vector&lt;Query*&gt; &gt; byA;

void readInput() {
	scanf("%d%d", &amp;n, &amp;nQ);
	for (int i = 0; i &lt; nQ; ++i) {
		Query*q = queries + i;
		q-&gt;read(i);
		byL[q-&gt;l].push_back(q);
		byR[q-&gt;r].push_back(q);
		byA[q-&gt;a].push_back(q);
	}
}

int what[MAX_N];
int F[MAX_N];
int stack[MAX_N], top;

int find(int x) {
	if (F[x] == x)
		return x;
	return F[x] = find(F[x]);
}

bool check(int when) {
	multiset&lt;int&gt; con;
	map&lt;int, vector&lt;int&gt; &gt; pos;
	con.insert(0);
	for (int i = 1; i &lt;= n; ++i) {
		foreach(iter,byL[i]) {
			Query*q = *iter;
			if (q-&gt;id &lt; when)
				con.insert(q-&gt;a);
		}
		what[i] = *con.rbegin();
		pos[what[i]].push_back(i);
		foreach(iter,byR[i]) {
			Query*q = *iter;
			if (q-&gt;id &lt; when)
				con.erase(con.find(q-&gt;a));
		}
	}

	foreach(iter,byA) {
		int x = iter-&gt;first;
		vector&lt;Query*&gt;&amp;qs = iter-&gt;second;
		int L = INT_MIN, R = INT_MAX;
		foreach(iter2,qs) {
			Query*q = *iter2;
			if (q-&gt;id &lt; when) {
				L = max(L, q-&gt;l);
				R = min(R, q-&gt;r);
			}
		}
		if (L == INT_MIN)
			continue;
		if (L &gt; R)
			return false;
		if (pos.count(x) == 0)
			return false;
		vector&lt;int&gt;&amp;p = pos[x];
		vector&lt;int&gt;::iterator it = lower_bound(p.begin(), p.end(), L);
		if (it == p.end())
			return false;
		if (*it &gt; R)
			return false;
	}

	return true;
}

void work() {
	int L = 0, R = nQ + 1;
	while (L + 1 &lt; R) {
		int M = L + R &gt;&gt; 1;
		if (check(M))
			L = M;
		else
			R = M;
	}
	if (L == nQ) {
		printf("0\n");
	} else {
		printf("%d\n", L + 1);
	}
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem1595</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=100000+10;
using namespace std;
typedef long long ll;
int h[maxn],w[maxn],pre[maxn],next[maxn],n;
ll ans[maxn];
int main()
{
    //freopen("in","r",stdin);
    int now=0;
    scanf("%d",&amp;n);
    ll time=0;
    h[0]=h[n+1]=inf;
    for(int i=1;i&lt;=n;i++)
    {
        scanf("%d%d",w+i,h+i);
        pre[i]=i-1;next[i]=i+1;
        if(h[i]&lt;h[now])now=i;
    }
    for(;h[now]!=inf;)
    {
        ans[now]=time+w[now];
        next[pre[now]]=next[now];
        pre[next[now]]=pre[now];
        if(h[pre[now]]&lt;h[next[now]])
        {
            time+=ll(h[pre[now]]-h[now])*w[now];
            w[pre[now]]+=w[now];
            now=pre[now];
            while(now&gt;0&amp;&amp;h[pre[now]]&lt;h[now])now=pre[now];
        }
        else
        {
            time+=ll(h[next[now]]-h[now])*w[now];
            w[next[now]]+=w[now];
            now=next[now];
            while(now&lt;=n&amp;&amp;h[next[now]]&lt;h[now])now=next[now];
        }
    }
    for(int i=1;i&lt;=n;i++)printf("%I64d\n",ans[i]);
}


</pre><pre></pre><h2>Problem1596</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
using namespace std;
const int maxn=10000;
int n,dp[3][maxn]={0};
vector&lt;int&gt; E[maxn];
void add(int s,int t)
{
	E[s].push_back(t);
	E[t].push_back(s);
}
bool vis[maxn]={0};
int ord[maxn],r[maxn],cnt=0;
void dfs(int n)
{
	vis[n]=true;
	for(int t,i=0;i&lt;E[n].size();i++)
	{
		t=E[n][i];if(!vis[t])
			dfs(t);
	}
	ord[cnt]=n;
	r[n]=cnt++;
}
int main()
{
	scanf("%d",&amp;n);
	for(int i=0;i&lt;n-1;i++)
	{
		int a,b;scanf("%d %d",&amp;a,&amp;b);a--;b--;
		add(a,b);
	}
	dfs(0);
	for(int i=0;i&lt;cnt;i++)
	{
		int t=ord[i];int m=maxn;bool find=false;
		for(int p,j=0;j&lt;E[t].size();j++)
		{
			p=E[t][j];if(r[p]&lt;i)
			{
				dp[0][t]+=dp[2][p];
				dp[1][t]+=min(min(dp[0][p],dp[1][p]),dp[2][p]);
				dp[2][t]+=min(dp[2][p],dp[1][p]);
				if(dp[1][p]&lt;=dp[2][p]) find=true;
				m=min(m,dp[1][p]-dp[2][p]);				
			}
		}
		dp[1][t]++;
		if(!find) dp[2][t]+=m;
	}
	int ans=min(dp[1][0],dp[2][0]);
	cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem1597</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
const int maxn=50000+10;
typedef long long ll;
struct State
{
    int l,r,ch;
    State(){}
    State(int _l,int _r,int _ch):
        l(_l),r(_r),ch(_ch){}
};
struct Land
{
    ll w,h;
    bool operator&lt;(const Land&amp;x)const
    {
        return w!=x.w?w&gt;x.w:h&gt;x.h;
    }
    bool Contain(const Land&amp;x)const
    {
        return w&gt;=x.w&amp;&amp;h&gt;=x.h;
    }
}L[maxn];
int N;
void Init()
{
    scanf("%d",&amp;N);
    for(int i=1;i&lt;=N;i++)
    {
        scanf("%d %d",&amp;L[i].w,&amp;L[i].h);
    }
}
void PreCondition()
{
    sort(L+1,L+N+1);int n=1;
    for(int i=1;i&lt;=N;i++)
    {
        if((n==1)||!L[n-1].Contain(L[i]))
            L[n++]=L[i];
    }
    N=n-1;
}
ll Dp[maxn];
ll getValue(int ch,int now)
{
    return Dp[ch]+L[ch+1].w*L[now].h;
}
int Binary(State st,int i)
{
    if(getValue(st.ch,st.r)&lt;getValue(i,st.r))
        return st.r+1;
    int l=st.l,r=st.r;
    while(l+1&lt;r)
    {
        int m=l+r&gt;&gt;1;
        if(getValue(st.ch,m)&gt;getValue(i,m))
            r=m;
        else
            l=m;
    }
    return r;
}
State Q[maxn];
int h,t;
void Show()
{
    for(int i=h;i&lt;t;i++)
    {
        cout&lt;&lt;Q[i].l&lt;&lt;" "&lt;&lt;Q[i].r&lt;&lt;" "&lt;&lt;Q[i].ch&lt;&lt;endl;
    }
}
void Solve()
{
    h=t=0;Dp[0]=0;
    Q[t++]=State(0,N,0);
    for(int i=1;i&lt;=N;i++)
    {
        if(Q[h].l&lt;i)Q[h].l=i;
        if(Q[h].l&gt;Q[h].r)h++;
        Dp[i]=getValue(Q[h].ch,i);
        while(h&lt;t&amp;&amp;getValue(Q[t-1].ch,Q[t-1].l)&gt;=getValue(i,Q[t-1].l))
        {
            t--;
        }
        if(h==t)Q[t++]=State(i,N,i);
        else
        {
            int split=Binary(Q[t-1],i);
            if(split&lt;=N)
            {
                Q[t-1].r=split-1;
                Q[t++]=State(split,N,i);
            }
        }
        //cout&lt;&lt;"After "&lt;&lt;i&lt;&lt;endl;
        //Show();
    }
    cout&lt;&lt;Dp[N]&lt;&lt;endl;
}
int main()
{
    //freopen("in.cpp","r",stdin);
    //freopen("out.cpp","w",stdout);
    Init();
    PreCondition();
    Solve();
}
</pre><pre></pre><h2>Problem1598</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(vector&lt;Edge&gt;::iterator e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;3,maxn=1000,maxk=101;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,m,k;
struct Edge
{
    int t,c;
    Edge(int _t,int _c):t(_t),c(_c){}
};
vector&lt;Edge&gt; E[maxn];
void AddEdge(int s,int t,int c)
{
    E[s].pb(Edge(t,c));
}
int Tmp[maxk];
struct Data
{
    int A[maxk],n;
    Data(){n=0;}
    void add(int x){A[n++]=x;}
    int&amp;operator[](int v){return A[v];}
    void Update(Data&amp;that,int c)
    {
        A[n]=that[that.n]=inf;
        #define B(x) (that[x]+c)
        n+=that.n;if(n&gt;k)n=k;
        int i=0,j=0;
        rep(o,n)
        {
            if(A[i]&lt;B(j))Tmp[o]=A[i++];
            else Tmp[o]=B(j),j++;
        }
        memcpy(A,Tmp,sizeof A);
    }
}Dp[maxn];
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d%d",&amp;n,&amp;m,&amp;k);int s,t,c;
    rep(i,m)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);--s;--t;
        AddEdge(s,t,c);
    }
    Dp[0].add(0);
    rep(i,n)
        tr(e,E[i])Dp[i].Update(Dp[e-&gt;t],e-&gt;c);
    Data&amp;Ans=Dp[n-1];
    rep(i,Ans.n)printf("%d\n",Ans[i]);
    for(int i=Ans.n;i&lt;k;i++)printf("-1\n");
}


</pre><pre></pre><h2>Problem1599</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,a,b) for(int i=a;i&lt;=b;i++)
#define tr(i,x) for(typeof(x.begin()) i=x.begin();i!=x.end();i++)
#define all(x) x.begin(),x.end()
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=300;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef pair&lt;int,int&gt; ii;
int Sum[maxn]={0},a,b,c,ans=0;
int main()
{
  //freopen("in","r",stdin);
  cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
  rep(i,a)rep(j,b)rep(k,c) Sum[i+j+k+3]++;
  rep(i,maxn)if(Sum[i]&gt;Sum[ans])ans=i;
  cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1600</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,a,b) for(int i=a;i&lt;=b;i++)
#define tr(i,x) for(typeof(x.begin()) i=x.begin();i!=x.end();i++)
#define all(x) x.begin(),x.end()
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=2600;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef pair&lt;int,int&gt; ii;
int n,dp[5][maxn]={0};
typedef long long ll;
ll WaySumTo(int a,int b)
{
    if(a&lt;0)return 0;
    ll ret=1;a+=--b;
    rep(i,b) ret*=a-i;
    rep(i,b) ret/=i+1;
    return ret;
}
int main()
{
  //freopen("in","r",stdin);
  cin&gt;&gt;n;int a=n/2;if(a*2==n)--a;
  n-=4;
  cout&lt;&lt;WaySumTo(n,4)-4*WaySumTo(n-a,4)+6*WaySumTo(n-2*a,4)-4*WaySumTo(n-3*a,4)+WaySumTo(n-4*a,4)&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1601</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,a,b) for(int i=a;i&lt;=b;i++)
#define tr(i,x) for(typeof(x.begin()) i=x.begin();i!=x.end();i++)
#define all(x) x.begin(),x.end()
#define pb push_back
#define fi first
#define se second
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=300+10;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef pair&lt;int,int&gt; ii;
typedef pair&lt;int,ii&gt; Edge;
vector&lt;Edge&gt; Es;
int F[maxn],n,c,ans;
int find(int x){return F[x]==x?x:(F[x]=find(F[x]));}
void dealEdge(const Edge&amp;e)
{
    int a=find(e.se.fi),b=find(e.se.se);
    if(a!=b) F[a]=b,ans+=e.fi;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;rep(i,n)cin&gt;&gt;c,Es.pb(Edge(c,ii(0,i+1))),F[i]=i;F[n]=n;
    rep(i,n)rep(j,n)cin&gt;&gt;c,Es.pb(Edge(c,ii(i+1,j+1)));
    sort(all(Es));
    for_each(all(Es),dealEdge);
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1601</h2><pre>#include &lt;stdio.h&gt;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=300+10;
using namespace std;
int C[maxn][maxn],n,P[maxn];
bool Vis[maxn]={};
int main()
{
    scanf("%d",&amp;n);
    For(i,1,n)
    {
        scanf("%d",&amp;C[0][i]);
        C[i][0]=C[0][i];
    }
    For(i,1,n)For(j,1,n)
        scanf("%d",&amp;C[i][j]),C[j][i]=C[i][j];
    n++;
    Vis[0]=true;rep(i,n)P[i]=C[i][0];
    int ret=0;
    rep(i,n-1)
    {
        int Min=-1;
        rep(j,n)if(!Vis[j]&amp;&amp;(Min==-1||P[j]&lt;P[Min]))Min=j;
        ret+=P[Min];
        rep(j,n)if(P[j]&gt;C[Min][j])P[j]=C[Min][j];
        Vis[Min]=true;
    }
    printf("%d\n",ret);
}


</pre><pre></pre><h2>Problem1602</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,a,b) for(int i=a;i&lt;=b;i++)
#define tr(i,x) for(typeof(x.begin()) i=x.begin();i!=x.end();i++)
#define all(x) x.begin(),x.end()
#define pb push_back
#define fi first
#define se second
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=1000;
typedef pair&lt;int,int&gt; ii;
typedef vector&lt;ii&gt;::iterator vit;
vector&lt;ii&gt; E[maxn];
int n,q;
void InsEdge(int s,int t,int c)
{
    E[s].pb(ii(t,c));
    E[t].pb(ii(s,c));
}
int Dist[maxn];
void init()
{
    cin&gt;&gt;n&gt;&gt;q;int s,t,c;
    rep(i,n-1)cin&gt;&gt;s&gt;&gt;t&gt;&gt;c,InsEdge(s-1,t-1,c);
}
void dfs(int x,int f,int d)
{
    Dist[x]=d;
    for(vit i=E[x].begin();i!=E[x].end();i++)
        if(i-&gt;fi!=f) dfs(i-&gt;fi,x,d+i-&gt;se);
}
int Cal(int a,int b)
{
    dfs(a,-1,0);
    return Dist[b];
}
int main()
{
  //freopen("in","r",stdin);
  init();int s,t;
  while(q--)cin&gt;&gt;s&gt;&gt;t,cout&lt;&lt;Cal(s-1,t-1)&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1603</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,a,b) for(int i=a;i&lt;=b;i++)
#define tr(i,x) for(vector&lt;ii&gt;::iterator i=x.begin();i!=x.end();i++)
#define all(x) x.begin(),x.end()
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=1000+10;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef pair&lt;int,int&gt; ii;
vector&lt;ii&gt; E[maxn];
int dist[maxn];
void dfs(int x,int f,int d)
{
    dist[x]=d;
    tr(e,E[x]) if(e-&gt;first!=f) dfs(e-&gt;first,x,d+e-&gt;second);
}
int main()
{
  //freopen("in","r",stdin);
  int n,s,t,c;cin&gt;&gt;n;rep(i,n-1) cin&gt;&gt;s&gt;&gt;t&gt;&gt;c,--s,--t,E[s].pb(ii(t,c)),E[t].pb(ii(s,c));
  dfs(0,-1,0);
  cout&lt;&lt;(dist[n-1]&amp;1)&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1604</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
namespace Solve
{
    const int PT_MAX=100000+10;
    const ll inf=1LL&lt;&lt;58,off=1LL&lt;&lt;30;
    int n,C;
    namespace Point
    {
        struct Point
        {
            ll x,y;
            Point(){}
            Point(ll _x,ll _y):
                x(_x),y(_y){}
            bool operator&lt;(const Point&amp;pnt)const
            {
                if(x!=pnt.x)return x&lt;pnt.x;
                return y&lt;pnt.y;
            }
            Point up()
            {
                return Point(x,y+1);
            }
            Point left()
            {
                return Point(x-1,y);
            }
            Point left_up()
            {
                return Point(x-1,y+1);
            }
            Point right_up()
            {
                return Point(x+1,y+1);
            }
        };
    }
    namespace Hash
    {
        using Point::Point;
        map&lt;Point,int&gt; id;
        vector&lt;vector&lt;Point&gt; &gt; data;
        inline int add(Point x)
        {
            if(id.count(x))
                return id[x];
            int n=id.size();
            data.push_back(vector&lt;Point&gt;());
            return id[x]=n;
        }
        inline int find(Point x)
        {
            if(id.count(x))
                return id[x];
            return -1;
        }
        inline Point get_loc(Point p)
        {
            return Point(p.x/C,p.y/C);
        }
        void add_point(Point x)
        {
            int t=add(get_loc(x));
            data[t].push_back(x);
        }
        void sort_point()
        {
            for(int i=0;i&lt;data.size();i++)
                sort(data[i].begin(),data[i].end());
        }
    }
    namespace Union_Find_Set
    {
        struct UF
        {
            int n,F[PT_MAX],S[PT_MAX];
            void init_size(int _n)
            {
                n=_n;
            }
            void make_set(int id,int size)
            {
                F[id]=id;
                S[id]=size;
            }
            int Find(int x)
            {
                if(F[x]==x)return x;
                return F[x]=Find(F[x]);
            }
            bool Union(int i,int j)
            {
                i=Find(i);j=Find(j);
                if(i==j)return false;
                F[j]=i;S[i]+=S[j];S[j]=0;
                return true;
            }
        };
    }
    namespace Check
    {
        using Point::Point;
        typedef vector&lt;Point&gt;::iterator vit;
        #define tr(it,a) for(vit it=a.begin();it!=a.end();it++)
        bool check_up(vector&lt;Point&gt;&amp;a,vector&lt;Point&gt;&amp;b)
        {
            ll top=-inf;
            tr(it,a)top=max(top,it-&gt;y);
            ll bot=inf;
            tr(it,b)bot=min(bot,it-&gt;y);
            return bot-top&lt;C;
        }
        bool check_left(vector&lt;Point&gt;&amp;a,vector&lt;Point&gt;&amp;b)
        {
            ll leftest=inf;
            tr(it,a)leftest=min(leftest,it-&gt;x);
            ll rightest=-inf;
            tr(it,b)rightest=max(rightest,it-&gt;x);
            return leftest-rightest&lt;C;
        }
        ll top[PT_MAX];
        bool check_left_up(vector&lt;Point&gt;&amp;a,vector&lt;Point&gt;&amp;b)
        {
            //sort(a.begin(),a.end()); //let us doit beforehand
            ll ret=-inf;
            for(int i=0;i&lt;a.size();i++)
            {
                ret=max(ret,a[i].y);
                top[i]=ret;
            }
            ll bot=inf;int j=b.size()-1;
            for(int i=a.size()-1;i&gt;=0;i--)
            {
                while(j&gt;=0&amp;&amp;a[i].x-b[j].x&lt;C)
                    bot=min(bot,b[j].y),j--;
                if(bot-top[i]&lt;C)return true;
            }
            return false;
        }
        bool check_right_up(vector&lt;Point&gt;&amp;a,vector&lt;Point&gt;&amp;b)
        {
            //sort(a.begin(),a.end()); //let us doit beforehand
            ll ret=-inf;
            for(int i=a.size()-1;i&gt;=0;i--)
            {
                ret=max(ret,a[i].y);
                top[i]=ret;
            }
            ll bot=inf;int j=0;
            for(int i=0;i&lt;a.size();i++)
            {
                while(j&lt;b.size()&amp;&amp;b[j].x-a[i].x&lt;C)
                    bot=min(bot,b[j].y),j++;
                if(bot-top[i]&lt;C)return true;
            }
            return false;
        }
    }
    Point::Point P[PT_MAX];
    void input_data()
    {
        int x,y;
        scanf("%d%d",&amp;n,&amp;C);C++;
        for(int i=0;i&lt;n;i++)
        {
            scanf("%d%d",&amp;x,&amp;y);
            P[i].x=ll(x)+y+off;P[i].y=ll(x)-y+off;
            Hash::add_point(P[i]);
        }
        Hash::sort_point();
    }
    typedef map&lt;Point::Point,int&gt;::iterator mit;
    void calc_ans()
    {
        Union_Find_Set::UF U;
        using Hash::id;
        using Hash::data;
        using Point::Point;
        int cnt=id.size();
        U.init_size(cnt);
        for(int i=0;i&lt;cnt;i++)
            U.make_set(i,data[i].size());
        for(mit it=id.begin();it!=id.end();it++)
        {
            int u=it-&gt;second,v;
            Point now=it-&gt;first;
            //try to Link up
            v=Hash::find(now.up());
            if(v!=-1&amp;&amp;Check::check_up(data[u],data[v]))
                if(U.Union(u,v))
                    cnt--;
            //try to Link left
            v=Hash::find(now.left());
            if(v!=-1&amp;&amp;Check::check_left(data[u],data[v]))
                if(U.Union(u,v))
                    cnt--;
            //try to link left_up
            v=Hash::find(now.left_up());
            if(v!=-1&amp;&amp;Check::check_left_up(data[u],data[v]))
                if(U.Union(u,v))
                    cnt--;
            //try to link right_up
            v=Hash::find(now.right_up());
            if(v!=-1&amp;&amp;Check::check_right_up(data[u],data[v]))
                if(U.Union(u,v))
                    cnt--;
        }
        printf("%d ",cnt);
        int ans=0;
        for(int i=0;i&lt;U.n;i++)
            ans=max(ans,U.S[i]);
        printf("%d\n",ans);
    }
    void solve()
    {
        //freopen("in.cpp","r",stdin);
        //freopen("out.cpp","w",stdout);
        input_data();
        calc_ans();
    }
}
int main()
{
    Solve::solve();
}

</pre><pre></pre><h2>Problem1606</h2><pre>#include&lt;iostream&gt;
using namespace std;
const int maxn=50000+10;
bool D[maxn]={1};
int main()
{
    int C,H,x;cin&gt;&gt;C&gt;&gt;H;
    while(H--)
    {
        cin&gt;&gt;x;
        for(int i=C;i&gt;=x;i--)
            if(D[i-x]) D[i]=true;
    }
    for(int i=C;;i--)if(D[i]){cout&lt;&lt;i&lt;&lt;endl;return 0;}
}
</pre><pre></pre><h2>Problem1607</h2><pre>#include&lt;cstdio&gt;
using namespace std;
const int maxn=100000,maxc=1000000+1;
int A[maxn],N[maxc]={0},Ans[maxc]={0},n;
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);for(int i=0;i&lt;n;i++)scanf("%d",A+i),N[A[i]]++;
    int t;
    for(int i=1;i&lt;maxc;i++)if(t=N[i])
        for(int j=i;j&lt;maxc;j+=i)
            Ans[j]+=t;
    for(int i=0;i&lt;n;i++)printf("%d\n",Ans[A[i]]-1);
}
</pre><pre></pre><h2>Problem1609</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,D[40000];
int cal()
{
	int DP[3]={0},tmp;
	for(int i=0;i&lt;n;i++)
	{
		tmp=40000;
		for(int j=0;j&lt;3;j++)
		{
			tmp=min(tmp,DP[j]);
			DP[j]=tmp+(D[i]==j?0:1);
		}
	}
	return *min_element(DP,DP+3);
}
int main()
{
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++)
		scanf("%d",D+i),D[i]--;
	int ans=cal();
	for(int l=0,r=n-1;l&lt;r;l++,r--)
		swap(D[l],D[r]);
	ans=min(ans,cal());
	cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1610</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;utility&gt;
#include&lt;set&gt;
using namespace std;
typedef pair&lt;int,int&gt; pi;
int n;
pi A[300];
int gcd(int a,int b)
{return b?gcd(b,a%b):a;}
pi operator-(pi x,pi y)
{
	return pi(x.first-y.first,x.second-y.second);
}
int main()
{
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++)
		cin&gt;&gt;A[i].first&gt;&gt;A[i].second;		
	set&lt;pi&gt; S;pi get;
	for(int i=0;i&lt;n;i++)
		for(int j=i+1;j&lt;n;j++)
		{
			get=A[j]-A[i];
			int d=gcd(get.first,get.second);
			get.first/=d;
			get.second/=d;
			S.insert(get);
		}
	cout&lt;&lt;S.size()&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1611</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#define Renew(x,c) x=min(x,c)
using namespace std;
typedef pair&lt;int,int&gt; pi;
const int maxn=310,inf=~0U&gt;&gt;1;
int T[maxn][maxn],D[maxn][maxn];
queue&lt;pi&gt; Q;
inline bool inarea(int x,int y)
{return x&gt;=0 and y&gt;=0 and x&lt;maxn and y&lt;maxn;}
int main()
{
	int m,x,y,t;cin&gt;&gt;m;
	for(int i=0;i&lt;maxn;i++)
		for(int j=0;j&lt;maxn;j++)
			T[i][j]=D[i][j]=inf;	
	const int di[]={-1,0,1,0},dj[]={0,1,0,-1};
	while(m--)
	{
		scanf("%d %d %d",&amp;x,&amp;y,&amp;t);
		Renew(T[x][y],t);
		for(int ii,jj,d=0;d&lt;4;d++)		
		{
			ii=x+di[d];jj=y+dj[d];
			if(inarea(ii,jj))
				Renew(T[ii][jj],t);
		}
	}
	D[0][0]=0;Q.push(pi(0,0));int c;
	while(Q.size())
	{
		pi t=Q.front();Q.pop();c=D[t.first][t.second];
		if(T[t.first][t.second]==inf)
		{
			cout&lt;&lt;c&lt;&lt;endl;
			return 0;
		}
		for(int ii,jj,d=0;d&lt;4;d++)		
		{
			ii=t.first+di[d];jj=t.second+dj[d];
			if(inarea(ii,jj) and  D[ii][jj]==inf and T[ii][jj]&gt;c+1)
				D[ii][jj]=c+1,Q.push(pi(ii,jj));
		}
	}
	cout&lt;&lt;-1&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1612</h2><pre>#include&lt;iostream&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=100;
int n,m;
bool d[maxn][maxn]={0};
int main()
{
	cin&gt;&gt;n&gt;&gt;m;int s,t;
	while(m--)
	{
		cin&gt;&gt;s&gt;&gt;t;s--;t--;
		d[s][t]=true;
	}
	REP(k,n) REP(i,n) REP(j,n) d[i][j]=d[i][j] or (d[i][k] and d[k][j]);
	int ans=0;
	REP(i,n)
	{
		int a=0,b=0;
		REP(j,n) if(d[j][i]) a++;
		REP(j,n) if(d[i][j]) b++;
		if(a+b==n-1) ans++;			
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1613</h2><pre>#include&lt;iostream&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=10000,maxm=500+10,inf=~0U&gt;&gt;1;
int n,m;
int D[maxn],S[maxn];
void init()
{
	cin&gt;&gt;n&gt;&gt;m;
	REP(i,n) cin&gt;&gt;D[i];	
	REP(i,n) S[i]=0;
}
inline void Renew(int&amp;x,int c)
{
	x=max(x,c);
}
void solve()
{
	S[0]=0;
	REP(i,n)	
	{
		int cost=S[i];
		Renew(S[i+1],cost);
		int pos=i,sum=S[i];
		for(int j=0;j&lt;m&amp;&amp;pos&lt;n;j++)
		{
			pos+=2;
			sum+=D[i+j];
			Renew(S[pos],sum);
		}
	}
	cout&lt;&lt;S[n]&lt;&lt;endl;
}
int main()
{
	init();
	solve();
}
</pre><pre></pre><h2>Problem1614</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=1000,inf=~0U&gt;&gt;1;
struct edge
{
 int t,c;
 edge*next;
 edge(int t,int c,edge*n):t(t),c(c),next(n){}
}*E[maxn];
void add(int s,int t,int c)
{
 E[s]=new edge(t,c,E[s]);
 E[t]=new edge(s,c,E[t]);
}
int N,P,K;
void init()
{
 cin&gt;&gt;N&gt;&gt;P&gt;&gt;K;
 while(P--)
 {
  int s,t,c;scanf("%d %d %d",&amp;s,&amp;t,&amp;c);s--;t--;
  add(s,t,c);
 }
}
struct node
{
 int pos,cost;
 node(int p,int c):pos(p),cost(c){}
};
bool inQ[maxn][maxn]={0};
int cost[maxn][maxn];
queue&lt;node&gt; Q;
inline void Renew(int p,int u,int c)
{
 if(u&gt;K) return;
 if(cost[p][u]&gt;c)
 {
  cost[p][u]=c;
  if(!inQ[p][u])
   Q.push(node(p,u)),inQ[p][u]=true;
 }
}
void solve()
{
 REP(i,N) REP(j,K+1) cost[i][j]=inf;
 Q.push(node(0,0));cost[0][0]=0;inQ[0][0]=true;
 int p,u;
 while(Q.size()) 
 {  
  node c=Q.front();Q.pop();inQ[p=c.pos][u=c.cost]=false;
  int get=cost[p][u];
  Renew(p,u+1,get);
  for(edge*i=E[p];i;i=i-&gt;next)  
  {
   Renew(i-&gt;t,u,max(get,i-&gt;c));
   Renew(i-&gt;t,u+1,get);
  }
 }
 if(cost[N-1][K]==inf) cout&lt;&lt;-1&lt;&lt;endl;  
 else cout&lt;&lt;cost[N-1][K]&lt;&lt;endl;
}
int main()
{
 init();
 solve();
}</pre><pre></pre><h2>Problem1616</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int di[]={1,0,-1,0},dj[]={0,1,0,-1},maxn=100;
int n,m,t;
typedef long long ll;
ll Dp[2][maxn][maxn]={0};
char Map[maxn][maxn];
inline bool Legal(int i,int j){return i&gt;=0&amp;&amp;i&lt;n&amp;&amp;j&gt;=0&amp;&amp;j&lt;m&amp;&amp;Map[i][j]=='.';}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;
    rep(i,n)rep(j,m)cin&gt;&gt;Map[i][j];
    int xs,ys,xt,yt;cin&gt;&gt;xs&gt;&gt;ys&gt;&gt;xt&gt;&gt;yt;xs--;ys--;xt--;yt--;
    int now=0,next=1;ll cost;Dp[next][xs][ys]=1;
    rep(i,t)
    {
        swap(next,now);
        memset(Dp[next],0,sizeof(Dp[next]));
        rep(x,n)rep(y,m)if(cost=Dp[now][x][y])rep(d,4)
        {
            int xx=x+di[d],yy=y+dj[d];
            if(Legal(xx,yy))
                Dp[next][xx][yy]+=cost;
        }
    }
    cout&lt;&lt;Dp[next][xt][yt]&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1617</h2><pre>#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=2600,inf=~0U&gt;&gt;1;
typedef long long ll;
ll Dp[maxn],M[maxn];
int n;
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;cin&gt;&gt;M[0];
    rep(i,n)cin&gt;&gt;M[i+1],M[i+1]+=M[i];
    Dp[0]=0;
    for(int i=1;i&lt;=n;i++)
    {
        ll&amp;x=Dp[i]=inf;
        for(int j=1;j&lt;=i;j++)
            x&lt;?=Dp[i-j]+M[j]+M[0];
    }
    cout&lt;&lt;Dp[n]-M[0]&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1618</h2><pre>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=60000+10,inf=~0U&gt;&gt;2;
int D[maxn];
int main()
{
    //freopen("in","r",stdin);
    fill(D,D+maxn,inf);D[0]=0;
    int N,H,p,c;cin&gt;&gt;N&gt;&gt;H;
    for(int i=0;i&lt;N;i++)
    {
        cin&gt;&gt;p&gt;&gt;c;
        for(int j=p;j&lt;maxn;j++)
            D[j]&lt;?=D[j-p]+c;
    }
    int ans=inf;
    for(int j=maxn-1;j&gt;=H;j--)
        ans&lt;?=D[j];
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1619</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=700,di[]={1,1,1,0,-1,-1,-1,0},dj[]={-1,0,1,1,1,0,-1,-1};
bool Vis[maxn][maxn]={0};
int H[maxn][maxn],n,m,now;
inline bool Legal(int i,int j){return i&gt;=0&amp;&amp;i&lt;n&amp;&amp;j&gt;=0&amp;&amp;j&lt;m;}
int dfs(int i,int j)
{
    Vis[i][j]=true;int ret=-1,ii,jj;
    rep(d,8)
    {
        ii=di[d]+i;jj=dj[d]+j;
        if(Legal(ii,jj))
        {
            if(H[ii][jj]!=now) ret&gt;?=H[ii][jj];
            else if(!Vis[ii][jj]) ret&gt;?=dfs(ii,jj);
        }
    }
    return ret;
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    rep(i,n)rep(j,m)scanf("%d",&amp;H[i][j]);int ans=0;
    rep(i,n)rep(j,m)if(!Vis[i][j])now=H[i][j],ans+=dfs(i,j)&lt;now;
    printf("%d\n",ans);
}


</pre><pre></pre><h2>Problem1620</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
const int maxn=1000+10;
struct Task
{
    int T,S;
    bool operator&lt;(const Task&amp;t)const
    {
        return S&lt;t.S;
    }
}T[maxn];
int N;
void Input_Data()
{
    cin&gt;&gt;N;
    rep(i,N)cin&gt;&gt;T[i].T&gt;&gt;T[i].S;
    sort(T,T+N);
}
bool Check(int Start)
{
    rep(i,N)
    {
        if(Start+T[i].T&gt;T[i].S)return false;
        Start+=T[i].T;
    }
    return true;
}
void Solve()
{
    int l=-1,r=~0U&gt;&gt;3;
    while(l+1&lt;r)
    {
        int m=l+r&gt;&gt;1;
        if(Check(m))l=m;else r=m;
    }
    cout&lt;&lt;l&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Input_Data();
    Solve();
}
</pre><pre></pre><h2>Problem1621</h2><pre>#include &lt;map&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef pair&lt;int,int&gt; ii;
int n,k;
map&lt;ii,int&gt; M;
int dfs(int n,int a,int b)
{
    int&amp;x=M[ii(a,b)];if(x)return x;
    if(n&lt;=k) return x=1;
    if((n-k)%2!=0) return x=1;
    return x=dfs((n+k)/2,a+(k&lt;&lt;b),b+1)+dfs((n-k)/2,a-(k&lt;&lt;b),b+1);
}
int main()
{
    cin&gt;&gt;n&gt;&gt;k;
    cout&lt;&lt;dfs(n,0,0)&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1621</h2><pre>#include &lt;map&gt;
#include &lt;iostream&gt;
using namespace std;
int n,k;
map&lt;int,int&gt; M;
int dfs(int n)
{
    int&amp;x=M[n];if(x)return x;
    if(n&lt;=k||(n-k)%2!=0)return x=1;
    return x=dfs((n-k)/2)+dfs((n+k)/2);
}
int main()
{
    cin&gt;&gt;n&gt;&gt;k;
    cout&lt;&lt;dfs(n)&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1621</h2><pre>#include &lt;iostream&gt;
using namespace std;
int n,k;
int dfs(int n)
{
    if(n&lt;=k||(n-k)%2!=0)return 1;
    return dfs((n-k)/2)+dfs((n+k)/2);
}
int main()
{
    cin&gt;&gt;n&gt;&gt;k;
    cout&lt;&lt;dfs(n)&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1625</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#include&lt;string&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxw=13000;
inline void Renew(int&amp;x,int c)
{
	if(x==-1 or x&lt;c)
		x=c;
}
int main()
{
	int F[maxw],w,d,n,m;
	REP(i,maxw) F[i]=-1;
	F[0]=0;
	cin&gt;&gt;n&gt;&gt;m;
	while(n--)
	{
		cin&gt;&gt;w&gt;&gt;d;
		for(int i=m;i&gt;=w;i--)
			if(F[i-w]!=-1)
				Renew(F[i],F[i-w]+d);
	}
	cout&lt;&lt;*max_element(F,F+m+1)&lt;&lt;endl;
}</pre><pre></pre><h2>Problem1626</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
#define Renew(x,c) x=min(x,c)
using namespace std;
typedef long double ld;
typedef pair&lt;ld,ld&gt; pi;
inline ld squ(ld x)
{
	return x*x;
}
ld dist(pi x,pi y)
{
	return sqrt(squ(x.first-y.first)+squ(x.second-y.second));
}
const int maxn=1000,inf=~0U&gt;&gt;1;
pi ps[maxn];
ld d[maxn][maxn];
int n,m;
void init()
{
	cin&gt;&gt;n&gt;&gt;m;
	REP(i,n) cin&gt;&gt;ps[i].first&gt;&gt;ps[i].second;
	for(int i=0;i&lt;n;i++)
		for(int j=0;j&lt;n;j++)
			d[i][j]=dist(ps[i],ps[j]);
	int s,t;
	REP(i,m)
		cin&gt;&gt;s&gt;&gt;t,d[--s][--t]=d[t][s]=0;
}
ld D[maxn];
bool intree[maxn]={0};
void solve()
{
	intree[0]=true;
	REP(i,n) D[i]=d[0][i];ld ans=0;
	REP(t,n-1)
	{
		ld m=inf;int j=-1;
		REP(i,n) if(!intree[i]&amp;&amp;D[i]&lt;m) m=D[i],j=i;
		ans+=D[j];intree[j]=true;
		REP(i,n) if(!intree[i]) Renew(D[i],d[j][i]);
	}
	cout.setf(ios::fixed);	
	cout.precision(2);
	cout&lt;&lt;ans&lt;&lt;endl;
}			
int main()
{
	init();
	solve();
}</pre><pre></pre><h2>Problem1627</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
#define Renew(x,c) x=min(x,c)
using namespace std;
const int maxn=1200,de=600;
int dist[maxn][maxn];
typedef pair&lt;int,int&gt; pi;
int main()
{
	REP(i,maxn) REP(j,maxn) dist[i][j]=-1;
	REP(i,maxn)
		dist[0][i]=dist[maxn-1][i]=dist[i][0]=dist[i][maxn-1]=-2;
	pi tar;
	int n,s,t;cin&gt;&gt;tar.first&gt;&gt;tar.second&gt;&gt;n;
	tar.first+=de;tar.second+=de;
	while(n--)
	{
		cin&gt;&gt;s&gt;&gt;t;s+=de;t+=de;
		dist[s][t]=-2;
	}
	dist[de][de]=0;
	queue&lt;pi&gt; Q;Q.push(pi(de,de));
	const int di[]={-1,0,1,0},dj[]={0,1,0,-1};int ii,jj,tt;
	while(Q.size())
	{
		pi c=Q.front();Q.pop();tt=dist[c.first][c.second];
		if(c==tar)
		{
			cout&lt;&lt;tt&lt;&lt;endl;
			return 0;
		}
		REP(d,4)
		{
			ii=c.first+di[d];jj=c.second+dj[d];
			if(dist[ii][jj]==-1)
			{
				dist[ii][jj]=tt+1;
				Q.push(pi(ii,jj));
			}
		}
	}	
}</pre><pre></pre><h2>Problem1628</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxy=500000,maxn=50000;
int w,n;
int H[maxn];
int cal(int i,int j)
{
	if(i&gt;j) return 0;
	if(i==j) return H[i]&gt;0;
	int c=maxy;
	for(int o=i;o&lt;=j;o++)
		c=min(H[o],c);
	int a=i,ans=0;
	for(int o=i;o&lt;=j;o++)
		if(H[o]==c)
			ans+=cal(a,o-1),a=o+1;
	ans+=cal(a,j);
	if(c) ans++;
	return ans;
}
int main()
{	
	cin&gt;&gt;n&gt;&gt;w;int x;
	for(int i=0;i&lt;n;i++)
	{
		scanf("%d %d",&amp;x,H+i);
	}
	cout&lt;&lt;cal(0,n-1)&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1629</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=50000,inf=~0U&gt;&gt;1;
int n;
struct node
{
	int w,s;
	bool operator&lt;(const node&amp;x) const
	{
		int a=w+s,b=x.w+x.s;
		if(a!=b) return a&lt;b;
		return w&lt;x.w;
	}
}Q[maxn];
int main()
{
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++)
	{
		scanf("%d %d",&amp;Q[i].w,&amp;Q[i].s);
	}
	sort(Q,Q+n);
	int Sum=0,ans=-inf;
	for(int i=0;i&lt;n;i++)
	{
		ans=max(ans,Sum-Q[i].s);
		Sum+=Q[i].w;
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem1630</h2><pre>#include&lt;iostream&gt;
using namespace std;
const int maxn=1000,maxl=100000,Mod=1000000;
struct P
{
	int *C;
	int n;
	P(int n):n(n)
	{
		C=new int[n+1];		
		for(int i=0;i&lt;=n;i++)
			C[i]=1;
	}
	int&amp; operator[](int v){return C[v];}	
	void operator*=(P&amp;x)
	{
		int*now=new int[n+x.n+1];
		for(int i=0;i&lt;=n+x.n;i++) now[i]=0;
		for(int i=0;i&lt;=n;i++)
			for(int j=0;j&lt;=x.n;j++)
			{
				now[i+j]+=C[i]*x[j];
				now[i+j]%=Mod;
			}
		delete[] C;
		C=now;n+=x.n;
	}
};
int C[maxn]={0};
int T,A,S,B;
int main()
{
	cin&gt;&gt;T&gt;&gt;A&gt;&gt;S&gt;&gt;B;	
	while(A--)
	{
		int t;cin&gt;&gt;t;
		C[t-1]++;
	}
	P ans(0);
	for(int i=0;i&lt;T;i++)
	{
		P now(C[i]);
		ans*=now;
	}
	int sum=0;
	for(int i=S;i&lt;=B;i++)
		sum+=ans[i],sum%=Mod;
	cout&lt;&lt;sum&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1631</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=1000+10;
struct Edge
{
    int t,c;
    Edge*next;
    Edge(int _t,int _c,Edge*_next):
        t(_t),c(_c),next(_next){}
}*E[maxn]={0},*R[maxn]={0};
int n,m,vs;
void InsEdge(int s,int t,int c)
{
    E[s]=new Edge(t,c,E[s]);
    R[t]=new Edge(s,c,R[t]);
}
void Init()
{
    scanf("%d %d %d",&amp;n,&amp;m,&amp;vs);int s,t,c;--vs;
    while(m--)
    {
        scanf("%d %d %d",&amp;s,&amp;t,&amp;c);
        InsEdge(s-1,t-1,c);
    }
}
const int inf=~0U&gt;&gt;2;
int DistF[maxn],DistR[maxn];
void Spfa(int Dist[maxn],int vs,Edge*E[maxn])
{
    queue&lt;int&gt; Q;
    bool inQ[maxn]={0};
    for(int i=0;i&lt;n;i++) Dist[i]=inf;
    Dist[vs]=0;inQ[vs]=true;Q.push(vs);
    while(Q.size())
    {
        int t=Q.front();Q.pop();inQ[t]=false;int cost=Dist[t];
        for(Edge*i=E[t];i;i=i-&gt;next)
        {
            int ncost=cost+i-&gt;c;
            if(ncost&lt;Dist[i-&gt;t])
            {
                Dist[i-&gt;t]=ncost;
                if(!inQ[i-&gt;t])
                    inQ[i-&gt;t]=true,Q.push(i-&gt;t);
            }
        }
    }
}
void Work()
{
    Spfa(DistF,vs,E);
    Spfa(DistR,vs,R);
    int ans=0;
    rep(i,n)ans=max(ans,DistF[i]+DistR[i]);
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Work();
}
</pre><pre></pre><h2>Problem1633</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;2,maxw=600,maxn=300,maxl=26;
using namespace std;
string S[maxw],A;
int w,l;
int Dp[maxw][maxl]={0};
struct state
{
    int s,p;
    state(int _s,int _p):s(_s),p(_p){}
    bool operator&lt;(const state&amp;o)const
    {return p&gt;o.p;}
};
vector&lt;state&gt; P[maxl];
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;w&gt;&gt;l;
    cin&gt;&gt;A;
    rep(i,w)
    {
        cin&gt;&gt;S[i];
        rep(j,S[i].size())
        {
            P[S[i][j]-'a'].pb(state(i,j));
            Dp[i][j]=-inf;
        }
    }
    rep(i,26)sort(P[i].begin(),P[i].end());
    int MaxEnd=0;
    rep(t,l)
    {
        int c=A[t]-'a';int nextMaxEnd=MaxEnd;
        for(vector&lt;state&gt;::iterator i=P[c].begin();i!=P[c].end();i++)
        {
            if(!i-&gt;p)Dp[i-&gt;s][i-&gt;p]=MaxEnd+1;
            else Dp[i-&gt;s][i-&gt;p]&gt;?=Dp[i-&gt;s][i-&gt;p-1]+1;
            if(i-&gt;p==S[i-&gt;s].size()-1)nextMaxEnd&gt;?=Dp[i-&gt;s][i-&gt;p];
        }
        MaxEnd=nextMaxEnd;
    }
    cout&lt;&lt;l-MaxEnd&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1634</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
typedef pair&lt;int,int&gt; pi;
typedef pair&lt;double,pi&gt; item;
const int maxn=100100;
item A[maxn];
int main()
{
	int n;cin&gt;&gt;n;scanf("\n");
	for(int i=0;i&lt;n;i++)
	{
		scanf("%d %d",&amp;A[i].second.first,&amp;A[i].second.second);
		A[i].first=double(A[i].second.first)/A[i].second.second;
	}
	sort(A,A+n);long long ans=0,time=0;
	for(int i=0;i&lt;n;i++)
	{
		ans+=time*A[i].second.second;
		time+=A[i].second.first*2;
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem1635</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
typedef pair&lt;int,int&gt; pi;
const int maxn=10010;
int D[maxn]={0},N,R,I,H;
int main()
{
	scanf("%d %d %d %d",&amp;N,&amp;I,&amp;H,&amp;R);
	int a,b;set&lt;pi&gt; E;
	for(int i=1;i&lt;=R;i++)
	{
		scanf("%d %d",&amp;a,&amp;b);
		if(a&gt;b) swap(a,b);
		if(E.find(pi(a,b))!=E.end()) continue;
		D[a+1]-=1,D[b]+=1;
		E.insert(pi(a,b));
	}
	int now=H;		
	for(int i=1;i&lt;=N;i++)
		now+=D[i],now=min(now,H),printf("%d\n",now);	
}
</pre><pre></pre><h2>Problem1636</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=50000;
struct info
{
    int Max,Min;
    info(int x=0,int y=0):Max(x),Min(y){}
};
info T[maxn*3],none(-inf,inf);
info operator+(const info&amp;l,const info&amp;r)
{
    return info(max(l.Max,r.Max),min(l.Min,r.Min));
}
int A[maxn],n,q;
void build(int t,int l,int r)
{
    if(l+1==r){T[t]=info(A[l],A[l]);return;}
    build(t*2,l,(l+r)/2);
    build(t*2+1,(l+r)/2,r);
    T[t]=T[t*2]+T[t*2+1];
}
info ask(int t,int l,int r,int a,int b)
{
    if(a&gt;=r||b&lt;=l)return none;
    if(l&gt;=a&amp;&amp;r&lt;=b)return T[t];
    return ask(t*2,l,(l+r)/2,a,b)+ask(t*2+1,(l+r)/2,r,a,b);
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d %d",&amp;n,&amp;q);
    rep(i,n) scanf("%d",A+i);
    build(1,0,n);int l,r;info a;
    rep(i,q)scanf("%d %d",&amp;l,&amp;r),a=ask(1,0,n,l-1,r),printf("%d\n",a.Max-a.Min);
}
</pre><pre></pre><h2>Problem1637</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1;
using namespace std;
const int maxn=50000+10;
int Dp[maxn*2]={},n;
typedef pair&lt;int,int&gt; ii;
ii A[maxn];
int main()
{
    //freopen("in","r",stdin);
    int a,b,t=maxn,ans=0;
    scanf("%d",&amp;n);rep(i,n)scanf("%d%d",&amp;A[i].second,&amp;A[i].first);
    sort(A,A+n);rep(i,maxn*2)Dp[i]=-1;
    rep(i,n)
    {
        int a=A[i].second,b=A[i].first;t+=a?1:-1;
        if(Dp[t]==-1)Dp[t]=i;
        else ans&gt;?=b-A[Dp[t]+1].first;
    }
    printf("%d\n",ans);
}


</pre><pre></pre><h2>Problem1638</h2><pre>#include&lt;cstdio&gt;
#include&lt;utility&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define Renew(x,c) x=max(x,c)
using namespace std;
typedef vector&lt;int&gt;::iterator it;
const int maxn=5000+10,maxm=50000+10;
vector&lt;int&gt; E[maxn];
int main()
{
	int n,m,s,t;
	int from[maxm],to[maxm];
	int front[maxn]={0},back[maxn]={0};
	scanf("%d %d",&amp;n,&amp;m);	
	for(int i=0;i&lt;m;i++)
		scanf("%d %d",from+i,to+i);
	for(int i=0;i&lt;m;i++)
		E[from[i]].push_back(to[i]);
	for(int i=1;i&lt;=n;i++)
	{
		if(front[i]==0) front[i]++;
		for(it j=E[i].begin();j!=E[i].end();j++)
			front[*j]+=front[i];
	}
	for(int i=1;i&lt;=n;i++)
		E[i].clear();
	for(int i=0;i&lt;m;i++)		
		E[to[i]].push_back(from[i]);
	back[n]=1;
	for(int i=n;i&gt;=1;i--)
	if(back[i])
	{
		for(it j=E[i].begin();j!=E[i].end();j++)
			back[*j]+=back[i];
	}
	int ans=0;
	for(int i=0;i&lt;m;i++)	
	{
		Renew(ans,front[from[i]]*back[to[i]]);
	}
	printf("%d\n",ans);
}
</pre><pre></pre><h2>Problem1639</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=100000;
using namespace std;
int A[maxn],n,m;
int Check(int L)
{
    int t=0,ret=0;
    rep(i,n)
    {
        if(t+A[i]&gt;L)ret++,t=0;
        t+=A[i];
    }
    return ++ret;
}
int main()
{
    //freopen("in","r",stdin);
    int l=0,r=0;
    scanf("%d%d",&amp;n,&amp;m);rep(i,n)scanf("%d",A+i),l&gt;?=A[i],r+=A[i];l--;
    while(l+1&lt;r)
    {
        int t=l+r&gt;&gt;1;
        if(Check(t)&lt;=m)r=t;else l=t;
    }
    cout&lt;&lt;r&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1640</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;utility&gt;
#include&lt;cstdlib&gt;
#include&lt;string&gt;
using namespace std;
typedef string::iterator it;
typedef string::reverse_iterator rit;
const int maxn=2000;
int n,limit=5000000;
string a,ans;
bool cmp(it a,it b,rit c,rit d)
{
	for(;a!=b;a++,c++)
	{
		if(*a&lt;*c) return true;
		if(*a&gt;*c) return false;
	}
	return false;
}
int main()
{
	scanf("%d",&amp;n);char c;
	for(int i=0;i&lt;n;i++)
		scanf("\n%c",&amp;c),a+=c;
	it l=a.begin(),r=a.end();
	rit rl=a.rbegin(),rr=a.rend();	
	while(l!=r)
	{
		if(cmp(l,r,rl,rr))
		{
			ans+=*l;
			l++;rr--;
		}
		else
		{		
			r--;rl++;
			ans+=*r;
		}
	}
	int now=0;
	for(int i=0;i&lt;n;i++)
	{
		now++;
		printf("%c",ans[i]);
		if(now==80) printf("\n"),now=0;
	}
	if(now) printf("\n");
}
</pre><pre></pre><h2>Problem1641</h2><pre>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {
	public static void main(String[] args) {
		new Main().run();
	}

	BufferedReader reader;
	StringTokenizer tokenizer;
	PrintWriter writer;

	private void solve() throws IOException {
		int n = nextInt(), m = nextInt(), nQ = nextInt();
		int[][] dist = new int[n][n];
		for (int[] a : dist)
			Arrays.fill(a, Integer.MAX_VALUE);
		for (int i = 0; i &lt; n; ++i) {
			dist[i][i] = 0;
		}
		for (int i = 0; i &lt; m; ++i) {
			int a = nextInt() - 1, b = nextInt() - 1, c = nextInt();
			dist[a][b] = Math.min(dist[a][b], c);
		}
		for (int k = 0; k &lt; n; ++k) {
			for (int i = 0; i &lt; n; ++i) {
				for (int j = 0; j &lt; n; ++j) {
					dist[i][j] = Math.min(dist[i][j],
							Math.max(dist[i][k], dist[k][j]));
				}
			}
		}

		for (int i = 0; i &lt; nQ; ++i) {
			int a = nextInt() - 1, b = nextInt() - 1;
			writer.println(dist[a][b] == Integer.MAX_VALUE ? -1 : dist[a][b]);
		}
	}

	public void run() {
		try {
			reader = new BufferedReader(new InputStreamReader(System.in));
			tokenizer = null;
			writer = new PrintWriter(System.out);
			solve();
			reader.close();
			writer.close();

		} catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	String nextToken() throws IOException {
		while (tokenizer == null || !tokenizer.hasMoreTokens())
			tokenizer = new StringTokenizer(reader.readLine());
		return tokenizer.nextToken();
	}
}
</pre><pre></pre><h2>Problem1642</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;utility&gt;
#define low(x) (x&amp;(-x))
#define Renew(x,c) x=max(x,c)
using namespace std;
typedef pair&lt;int,int&gt; pi;
typedef pair&lt;pi,int&gt; inter;
const int maxn=1000000+100,maxm=1000+100,inf=~0U&gt;&gt;2;
int N,M,R,A[maxn];
int Max(int l)
{
	int ans=0;
	for(;l&gt;0;l-=low(l))		
		Renew(ans,A[l]);
	return ans;
}
void Change(int l,int d)
{
	for(;l&lt;=N;l+=low(l))
		Renew(A[l],d);
}
inter I[maxm];
void init()
{
	cin&gt;&gt;N&gt;&gt;M&gt;&gt;R;N++;
	for(int i=1;i&lt;=N;i++) A[i]=-inf;
	int s,t,e;
	for(int i=0;i&lt;M;i++)
	{
		scanf("%d %d %d",&amp;s,&amp;t,&amp;e);
		I[i]=inter(pi(s,t),e);
	}
	sort(I,I+M);
}
void solve()
{
	int ans=-inf,get;
	for(inter*i=I;i!=I+M;i++)
	{
		get=Max(i-&gt;first.first-R);
		get+=i-&gt;second;				
		Change(i-&gt;first.second,get);
	}
	ans=Max(N);
	cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
	init();
	solve();
}</pre><pre></pre><h2>Problem1643</h2><pre>#include &lt;iostream&gt;
const int maxn=10010;
using namespace std;
int Dp[maxn]={},N;
int main()
{
    cin&gt;&gt;N;int t=4;
    Dp[0]=1;
    while(t--)
        for(int j=N;j&gt;=0;j--)
            for(int i=1;i*i&lt;=j;i++)
                Dp[j]+=Dp[j-i*i];
    cout&lt;&lt;Dp[N]&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1644</h2><pre>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxd=4,maxn=100+1;
const int dx[]={-1,0,1,0},dy[]={0,1,0,-1};
using namespace std;
int Dist[maxn][maxn][maxd],n,vsx,vsy;
bool inQ[maxn][maxn][maxd]={};
char Map[maxn][maxn];
struct State
{
    int x,y,d;
    State(int _x,int _y,int _d):
        x(_x),y(_y),d(_d){}
};
queue&lt;State&gt; Q;
void BFS()
{
    rep(d,4)
    {
        Dist[vsx][vsy][d]=0;
        inQ[vsx][vsy][d]=true;
        Q.push(State(vsx,vsy,d));
    }
    while(Q.size())
    {
        State t=Q.front();Q.pop();
        int c=Dist[t.x][t.y][t.d];
        inQ[t.x][t.y][t.d]=false;
        rep(nd,4)
        {
            int nx=t.x+dx[nd],ny=t.y+dy[nd];
            if(nx&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;n&amp;&amp;Map[nx][ny]!='x')
            {
                int&amp;tmp=Dist[nx][ny][nd];
                int nc=c+(nd!=t.d);
                if(tmp==-1||tmp&gt;nc)
                {
                    tmp=nc;
                    if(!inQ[nx][ny][nd])
                    {
                        inQ[nx][ny][nd]=true;
                        Q.push(State(nx,ny,nd));
                    }
                }
            }
        }
    }
}
int main()
{
    //freopen("in","r",stdin);
    memset(Dist,-1,sizeof Dist);
    cin&gt;&gt;n;scanf(" ");rep(i,n)gets(Map[i]);
    rep(i,n)rep(j,n)
        if(Map[i][j]=='A')
            vsx=i,vsy=j;
    BFS();
    int ans=inf;
    rep(i,n)rep(j,n)
        if(Map[i][j]=='B')
        {
            rep(d,4)
            {
                int c=Dist[i][j][d];
                if(c!=-1&amp;&amp;c&lt;ans)ans=c;
            }
        }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1646</h2><pre>#include&lt;iostream&gt;
#include&lt;queue&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=200000+100,inf=~0U&gt;&gt;1;
int Dist[maxn];
int N,K;
queue&lt;int&gt; Q;
void Renew(int n,int c)
{
	if(Dist[n]&gt;c)
		Dist[n]=c,Q.push(n);
}
int main()
{
	cin&gt;&gt;N&gt;&gt;K;
	REP(i,maxn) Dist[i]=inf;
	Dist[N]=0;Q.push(N);
	while(Q.size())
	{
		int t=Q.front(),c=Dist[t];Q.pop();
		if(t==K) cout&lt;&lt;Dist[t]&lt;&lt;endl;
		if(t*2&lt;maxn) Renew(t*2,c+1);
		if(t&gt;0) Renew(t-1,c+1);
		if(t+1&lt;maxn) Renew(t+1,c+1);
	}
}
</pre><pre></pre><h2>Problem1647</h2><pre>Program P1647;
var
  m,n:longint;
  i,j,k:longint;
  matrix:array[1..15,1..15] of longint;
  state:longint;
  check:longint;
  now,all:string;
  temp:array[1..15,1..15] of longint;
  answer:string;
  answernow:longint;
  answerbeing:boolean;
  kkkkk:longint;
  Procedure Print;
  var
    i,j:longint;
  begin
    For i:=1 to m do
    begin
      For j:=1 to n-1 do
      begin
        Write(answer[(i-1) * n + j],' ');
      end;
      Writeln(answer[i*n]);
    end;
  end;

  Function Change(t:longint):string;
  var
    i:longint;
    res:string;
  begin
    res:='';
    i:=t;
    While i&lt;&gt;0 do
    begin
      res:=chr(ord('0') + i mod 2)+res;
      i:=i div 2;
    end;
    While length(res)&lt;n do
    res:='0'+res;
    change:=res;
  end;

begin
  answernow:=maxlongint;
  answerbeing:=false;
  Read(m,n);
  For i:=1 to m do
    For j:=1 to n do
    begin
      Read(matrix[i,j]);
    end;
  state:=1;
  For i:=1 to n do
  begin
    inc(state,state);
  end;
  For i:=0 to state-1 do
  begin
    if i=24 then
    begin
      temp:=matrix;
    end;
    temp:=matrix;
    all:='';
    now:=change(i);
    all:=now;
    For j:=2 to m+1 do
    begin
      For k:=1 to n do
      begin
        if now[k] = '0' then continue;
        temp[j-1,k]:=1-temp[j-1,k];
        if j&gt;2 then
        begin
          temp[j-2,k]:=1-temp[j-2,k];
        end;
        if j&lt;=m then
          temp[j,k]:=1-temp[j,k];
        if k&gt;1 then
        begin
          temp[j-1,k-1]:=1-temp[j-1,k-1];
        end;
        if k&lt;n then
        begin
          temp[j-1,k+1]:=1-temp[j-1,k+1];
        end;
      end;
      For k:=1 to n do
      begin
        now[k]:=chr(ord('0')+temp[j-1,k]);
      end;
      all:=all+now;
    end;
    check:=0;
    For k:=1 to n do
    begin
      inc(check,temp[m,k]);
    end;

    if check=0 then
    begin
      answerbeing:=true;
      kkkkk:=0;
      For k:=1 to n*m do
      begin
        if all[k]&lt;&gt;'0' then inc(kkkkk);
      end;
      if kkkkk&lt;answernow then
      begin
        answernow:=kkkkk;
        answer:=all;
      end;
    end;
  end;
  if answerbeing then Print else Writeln('IMPOSSIBLE');
end.

</pre><pre></pre><h2>Problem1648</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
using namespace std;
const int maxk=120,maxn=1100;
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator it;
inline int add(int a,int b){E[a].push_back(b);}
int k,n,m;
bool vis[maxn];
int ts[maxn]={0};
void dfs(int x)
{
	vis[x]=true;ts[x]++;
	for(it i=E[x].begin();i!=E[x].end();i++)
		if(!vis[*i]) dfs(*i);
}
int main()
{
	scanf("%d %d %d",&amp;k,&amp;n,&amp;m);
	int C[maxk],s,t;
	for(int i=0;i&lt;k;i++) scanf("%d",C+i);
	while(m--)
	{
		scanf("%d %d",&amp;s,&amp;t);
		add(s,t);
	}
	for(int i=0;i&lt;k;i++)
		memset(vis,0,sizeof(vis)),dfs(C[i]);
	int ans=0;
	for(int i=1;i&lt;=n;i++)		
		if(ts[i]==k) ans++;
	printf("%d\n",ans);
}</pre><pre></pre><h2>Problem1649</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#define Renew(x,c) x=max(x,c)
using namespace std;
typedef pair&lt;int,int&gt; pi;
const int maxl=1100,maxn=11000,maxb=1001;
int L,N,B;
struct node
{
	int l,r,f,c;
	node(int _l,int _r,int _f,int _c)
	{l=_l;r=_r;f=_f;c=_c;}
};
vector&lt;node&gt; C[maxl];
typedef vector&lt;node&gt;::iterator it;
const int inf=~0U&gt;&gt;1;
int DP[maxl][maxb];
int main()
{
	scanf("%d %d %d",&amp;L,&amp;N,&amp;B);
	int l,r,f,c;
	for(int i=0;i&lt;N;i++)
	{
		scanf("%d %d %d %d",&amp;l,&amp;r,&amp;f,&amp;c);
		r+=l;C[l].push_back(node(l,r,f,c));
	}
	for(int i=0;i&lt;=L;i++)
		for(int j=0;j&lt;=B;j++)
			DP[i][j]=-inf;
	DP[0][0]=0;int cost;
	for(int i=0;i&lt;L;i++)
		for(int j=0;j&lt;=B;j++)
			if((cost=DP[i][j])!=-inf)
			{
				for(it e=C[i].begin();e!=C[i].end();e++)
					if(e-&gt;c+j&lt;=B)
						Renew(DP[e-&gt;r][e-&gt;c+j],e-&gt;f+cost);
			}
	int ans=-inf;
	for(int i=0;i&lt;=B;i++) Renew(ans,DP[L][i]);
	if(ans==-inf) puts("-1");
	else printf("%d\n",ans);
}

</pre><pre></pre><h2>Problem1650</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
int N,M;
LL L;
const int maxn=50010;
LL D[maxn];
int check(int maxs)
{
	int last=0,ans=1;
	for(int i=1;i&lt;=N;i++)
	{
		if(D[i]-D[last]&gt;=maxs)
			ans++,last=i;
	}
	if(D[N+1]-D[last]&gt;=maxs) ans++;
	return ans;
}
int main()
{
	scanf("%lld %d %d",&amp;L,&amp;N,&amp;M);
	D[0]=0;D[N+1]=L;
	for(int i=1;i&lt;=N;i++)	
		scanf("%lld",D+i);
	sort(D,D+N+1);
	M=N-M+2;
	LL l=0,r=L+1,mid;
	while(l+1&lt;r)
	{
		mid=(l+r)/2;
		if(check(mid)&gt;=M)
			l=mid;
		else
			r=mid;
	}
	printf("%lld\n",l);
}</pre><pre></pre><h2>Problem1651</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=50000;
int n;
struct Event
{
    int p,d;
    Event(){}
    Event(int _p,int _d):p(_p),d(_d){}
    bool operator&lt;(const Event&amp;o)const
    {
        if(p!=o.p)return p&lt;o.p;
        return d&lt;o.d;
    }
}E[maxn*2];
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);int s,t,p=0;
    for(int i=0;i&lt;n;i++)
    {
        scanf("%d%d",&amp;s,&amp;t);
        E[p++]=Event(s,1);
        E[p++]=Event(t+1,-1);
    }
    sort(E,E+p);
    int now=0,ans=0;
    for(int i=0;i&lt;p;i++)
    {
        now+=E[i].d;
        ans&gt;?=now;
    }
    printf("%d\n",ans);
}
</pre><pre></pre><h2>Problem1651</h2><pre>#include&lt;cstdio&gt;
#include&lt;utility&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=50000;
int n;
typedef pair&lt;int,int&gt; ii;
ii E[maxn*2];
int main()
{
    scanf("%d",&amp;n);int s,t,p=0;
    for(int i=0;i&lt;n;i++)scanf("%d%d",&amp;s,&amp;t),E[p++]=ii(s,1),E[p++]=ii(t+1,-1);
    sort(E,E+p);
    int now=0,ans=0;
    for(int i=0;i&lt;p;i++)now+=E[i].second,ans&gt;?=now;
    printf("%d\n",ans);
}
</pre><pre></pre><h2>Problem1651</h2><pre>#include&lt;cstdio&gt;
#include&lt;utility&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=50000;
typedef pair&lt;int,int&gt; T;
T E[maxn*2];
int main(){int n,s,t,p=0,now=0,ans=0;scanf("%d",&amp;n);for(int i=0;i&lt;n;i++)scanf("%d%d",&amp;s,&amp;t),E[p++]=T(s,1),E[p++]=T(t+1,-1);sort(E,E+p);for(int i=0;i&lt;p;i++)now+=E[i].second,ans&gt;?=now;printf("%d\n",ans);}
</pre><pre></pre><h2>Problem1651</h2><pre>#include&lt;cstdio&gt;
#include&lt;utility&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
typedef pair&lt;int,int&gt; T;
T E[100000];
int main(){int n,s,t,p=0,now=0,ans=0;scanf("%d",&amp;n);rep(i,n)scanf("%d%d",&amp;s,&amp;t),E[p++]=T(s,1),E[p++]=T(t+1,-1);sort(E,E+p);rep(i,p)now+=E[i].second,ans&gt;?=now;printf("%d\n",ans);}
</pre><pre></pre><h2>Problem1652</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
const int maxn=2000+10;
int n,v[maxn];
int dp[maxn][maxn];
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;rep(i,n)cin&gt;&gt;v[i];
    rep(l,n)
        rep(i,n-l)
        {
            int j=i+l,a=n-l;
            if(i==j)dp[i][j]=v[i]*a;
            else
                dp[i][j]=max(dp[i+1][j]+a*v[i],dp[i][j-1]+a*v[j]);
        }
    cout&lt;&lt;dp[0][n-1]&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1653</h2><pre>#include&lt;iostream&gt;
using namespace std;
const int maxn=10+1;
int C[maxn][maxn],n,sum,A[maxn];
bool used[maxn]={},Find=false;
void Print()
{
    for(int i=0;i&lt;n;i++)cout&lt;&lt;A[i]&lt;&lt;" ";
    cout&lt;&lt;endl;
}
void Dfs(int p,int now)
{
    if(Find)return;
    if(now&gt;sum)return;
    if(p==n)
    {
        if(now==sum){Print();Find=true;}
        return;
    }
    for(int i=1;i&lt;=n;i++)if(!used[i])
    {
        used[i]=true;A[p]=i;
        Dfs(p+1,C[n-1][p]*i+now);
        used[i]=false;
    }
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;sum;C[0][0]=1;
    for(int i=1;i&lt;=n;i++)
    {
        C[i][0]=C[i][i]=1;
        for(int j=1;j&lt;n;j++)
            C[i][j]=C[i-1][j]+C[i-1][j-1];
    }
    Dfs(0,0);
}
</pre><pre></pre><h2>Problem1657</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=50000+10;
int H[maxn],V[maxn],L[maxn],R[maxn],n,P[maxn],A[maxn]={};
bool cmp(int i,int j)
{
    return H[i]&lt;H[j];
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);rep(i,n)scanf("%d%d",H+i,V+i),P[i]=i;
    rep(i,n+1)R[i]=i+1,L[i+1]=i;sort(P,P+n,cmp);
    rep(i,n)
    {
        int t=P[i]+1;A[L[t]]+=V[t-1];A[R[t]]+=V[t-1];
        R[L[t]]=R[t];L[R[t]]=L[t];
    }
    int ans=0;
    rep(i,n)ans&gt;?=A[i+1];
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1657</h2><pre>#include&lt;stdio.h&gt;
#define rep(i,n) for(int i=1;i&lt;=n;i++)
int h[1&lt;&lt;18],v[1&lt;&lt;18],next[1&lt;&lt;18],ans[1&lt;&lt;18]={},n;
int main()
{
    scanf("%d",&amp;n);
    rep(i,n)scanf("%d%d",h+i,v+i);h[0]=h[n+1]=~0U&gt;&gt;1;
    rep(i,n)
    {
        for(next[i]=i-1;h[next[i]]&lt;h[i];next[i]=next[next[i]]);
        ans[next[i]]+=v[i];
    }
    for(int i=n;i&gt;=1;i--)
    {
        for(next[i]=i+1;h[next[i]]&lt;h[i];next[i]=next[next[i]]);
        ans[next[i]]+=v[i];
    }
    int Ans=0;
    rep(i,n)if(ans[i]&gt;Ans)Ans=ans[i];
    printf("%d\n",Ans);
}
</pre><pre></pre><h2>Problem1657</h2><pre>#include&lt;stdio.h&gt;
#define rep(i,n) for(int i=1;i&lt;=n;i++)
int h[1&lt;&lt;18],v[1&lt;&lt;18],n[1&lt;&lt;18],a[1&lt;&lt;18]={},N;
int main()
{
    scanf("%d",&amp;N);
    rep(i,N)scanf("%d%d",h+i,v+i);h[0]=h[N+1]=~0U&gt;&gt;1;
    rep(i,N)
    {
        for(n[i]=i-1;h[n[i]]&lt;h[i];n[i]=n[n[i]]);
        a[n[i]]+=v[i];
    }
    for(int i=N;i&gt;=1;i--)
    {
        for(n[i]=i+1;h[n[i]]&lt;h[i];n[i]=n[n[i]]);
        a[n[i]]+=v[i];
    }
    int Ans=0;
    rep(i,N)if(a[i]&gt;Ans)Ans=a[i];
    printf("%d\n",Ans);
}
</pre><pre></pre><h2>Problem1657</h2><pre>#include&lt;stdio.h&gt;
#define rep(i,n) for(int i=1;i&lt;=n;i++)
int h[1&lt;&lt;18],v[1&lt;&lt;18],n[1&lt;&lt;18],a[1&lt;&lt;18]={},N,A=0;
int main()
{
    scanf("%d",&amp;N);
    rep(i,N)scanf("%d%d",h+i,v+i);h[0]=h[N+1]=~0U&gt;&gt;1;
    #define it for(;h[n[i]]&lt;h[i];n[i]=n[n[i]]);a[n[i]]+=v[i];
    rep(i,N)
    {n[i]=i-1;it}
    for(int i=N;i&gt;=1;i--)
    {n[i]=i+1;it}
    rep(i,N)if(a[i]&gt;A)A=a[i];
    printf("%d\n",A);
}
</pre><pre></pre><h2>Problem1657</h2><pre>#include&lt;stdio.h&gt;
#define rep(i,n) for(i=1;i&lt;=n;i++)
int h[1&lt;&lt;18],v[1&lt;&lt;18],n[1&lt;&lt;18],a[1&lt;&lt;18]={},N,A=0,i;
int main()
{
    scanf("%d",&amp;N);rep(i,N)scanf("%d%d",h+i,v+i);h[0]=h[N+1]=~0U&gt;&gt;1;
    #define it for(;h[n[i]]&lt;h[i];n[i]=n[n[i]]);a[n[i]]+=v[i];
    rep(i,N){n[i]=i-1;it}i=N+1;while(--i&gt;=1){n[i]=i+1;it}
    rep(i,N)if(a[i]&gt;A)A=a[i];
    printf("%d\n",A);
}
</pre><pre></pre><h2>Problem1657</h2><pre>#define rep(i,n) for(i=1;i&lt;=n;i++)
h[1&lt;&lt;18],v[1&lt;&lt;18],n[1&lt;&lt;18],a[1&lt;&lt;18]={},N,A=0,i;
main(){scanf("%d",&amp;N);rep(i,N)scanf("%d%d",h+i,v+i);h[0]=h[N+1]=~0U&gt;&gt;1;
#define it for(;h[n[i]]&lt;h[i];n[i]=n[n[i]]);a[n[i]]+=v[i];
rep(i,N){n[i]=i-1;it}i=N+1;while(--i&gt;=1){n[i]=i+1;it}rep(i,N)if(a[i]&gt;A)A=a[i];printf("%d\n",A);}
</pre><pre></pre><h2>Problem1657</h2><pre>#define R(i,n) for(i=1;i&lt;=n;i++)
h[1&lt;&lt;18],v[1&lt;&lt;18],n[1&lt;&lt;18],a[1&lt;&lt;18]={},N,A=0,i;
main(){scanf("%d",&amp;N);R(i,N)scanf("%d%d",h+i,v+i);h[0]=h[N+1]=~0U&gt;&gt;1;
#define T for(;h[n[i]]&lt;h[i];n[i]=n[n[i]]);a[n[i]]+=v[i];
R(i,N){n[i]=i-1;T}for(i=N;i&gt;=1;i--){n[i]=i+1;T}R(i,N)A=A&gt;a[i]?A:a[i];printf("%d\n",A);}
</pre><pre></pre><h2>Problem1657</h2><pre>#define R for(i=1;i&lt;=N;i++)
#define M 1&lt;&lt;18
h[M],v[M],n[M],a[M]={},N,A=0,i;
main(){scanf("%d",&amp;N);R scanf("%d%d",h+i,v+i);h[0]=h[N+1]=~0U&gt;&gt;1;
#define T for(;h[n[i]]&lt;h[i];n[i]=n[n[i]]);a[n[i]]+=v[i];
R {n[i]=i-1;T}for(i=N;i&gt;=1;i--){n[i]=i+1;T}R A=A&gt;a[i]?A:a[i];printf("%d",A);}
</pre><pre></pre><h2>Problem1658</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=10000;
using namespace std;
typedef long long ll;
int A[maxn],B[maxn],X[maxn];
int Deg[maxn]={},N,M;
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;N&gt;&gt;M;int a,b;
    rep(i,N)cin&gt;&gt;X[i];
    rep(i,M)cin&gt;&gt;a&gt;&gt;b,--a,--b,Deg[a]++,Deg[b]--;
    int pa=0,pb=0;
    rep(i,N)
    {
        if(Deg[i]&gt;0)rep(j,Deg[i])A[pa++]=X[i];
        else rep(j,-Deg[i])B[pb++]=X[i];
    }
    sort(A,A+pa);sort(B,B+pb);ll ans=0;
    rep(i,pa)ans+=abs(A[i]-B[i]);
    cout&lt;&lt;ans&lt;&lt;endl;
}

</pre><pre></pre><h2>Problem1659</h2><pre>main(){  }</pre><pre></pre><h2>Problem1660</h2><pre>H[80010],F[80010],n,i;main(){unsigned int ans=0;scanf("%d",&amp;n);for(i=0;i&lt;n;i++) scanf("%d",H+i);H[n]=~0U&gt;&gt;1;for(--i;i&gt;=0;i--){F[i]=i+1;while(H[F[i]]&lt;H[i]) F[i]=F[F[i]];ans+=F[i]-i-1;}printf("%u",ans);}
</pre><pre></pre><h2>Problem1661</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=100;
using namespace std;
int Map[maxn][maxn];
int n;
inline bool Legal(int i,int j){return i&gt;=0&amp;&amp;i&lt;n&amp;&amp;j&gt;=0&amp;&amp;j&lt;n;}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;char c;
    rep(i,n)rep(j,n)cin&gt;&gt;c,Map[i][j]=(c=='J'?0:(c=='*'?1:100));
    int Ans=0,x2,x3,y2,y3,x,y,tmp;
    rep(x0,n)rep(y0,n)rep(x1,n)for(int y1=y0;y1&lt;n;y1++)
    {
        x=x1-x0;y=y1-y0;tmp=x*x+y*y;
        if(tmp&lt;=Ans)continue;
        x2=x0+x+y;y2=y0+y-x;
        x3=x0+y;y3=y0-x;
        if(Legal(x2,y2)&amp;&amp;Legal(x3,y3))
            if(Map[x0][y0]+Map[x1][y1]+Map[x2][y2]+Map[x3][y3]&lt;=1)
            {
                Ans&gt;?=tmp;
            }
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1666</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
int Cal(ll a)
{
    if(a==1) return 0;
    if(a%2==0) return Cal(a/2)+1;
    return Cal(3*a+1)+1;
}
int main()
{
   //freopen("in","r",stdin);
   ll a;cin&gt;&gt;a;
   cout&lt;&lt;Cal(a)&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1667</h2><pre>int main(){}</pre><pre></pre><h2>Problem1667</h2><pre>main(){  }</pre><pre></pre><h2>Problem1667</h2><pre>main(){}   </pre><pre></pre><h2>Problem1668</h2><pre>Program P1668;
var
  r,c:longint;
  map:array[1..100,1..100] of longint;
  f:array[0..101,0..101]  of longint;
  i,j:longint;

  Function max(a,b:longint):longint;
  begin
    if a&gt;b then max:=a else max:=b;
  end;

begin

  Read(r,c);
  For i:=1 to r do
    For j:=1 to c do
    begin
      Read(map[i,j]);
    end;
  f[1,1]:=map[1,1];
  For i:=2 to 100 do
  begin
    For j:=1 to r do
    begin
       if j&gt;i then Continue;
       f[j,i]:=max(f[j,i-1],f[j-1,i-1]);
       f[j,i]:=max(f[j,i],f[j+1,i-1]);
       f[j,i]:=f[j,i]+map[j,i];
    end;
  end;
  Writeln(f[r,c]);

end.



</pre><pre></pre><h2>Problem1669</h2><pre>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int inf=~0U&gt;&gt;2,maxn=5000+1;
int A[maxn],n,c,x,ans=0;
int main()
{
    cin&gt;&gt;n;fill(A,A+n,inf);for(int i=0;i&lt;n;i++)cin&gt;&gt;x,c=lower_bound(A,A+n,x)-A,A[c]=x,ans=max(ans,c+1);
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1677</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=1e6+1;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
ll mod=1e9,F[maxn];
int main()
{
    int n;cin&gt;&gt;n;
    F[0]=1;
    for(int i=1;i&lt;=n;i++)
        if(i&amp;1)F[i]=F[i-1];
        else F[i]=F[i/2]+F[i-1],F[i]%=mod;
    cout&lt;&lt;F[n]&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1679</h2><pre>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=1e5;
using namespace std;
typedef long long ll;
ll A[maxn],n;
int main()
{
    cin&gt;&gt;n;rep(i,n)scanf("%I64d",A+i);
    sort(A,A+n);ll ans=0,s=0;
    rep(i,n) ans+=i*A[i]-s,s+=A[i];
    printf("%I64d\n",ans*2);
}


</pre><pre></pre><h2>Problem1680</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,a,b) for(int i=a;i&lt;=b;i++)
#define tr(i,x) for(typeof(x.begin()) i=x.begin();i!=x.end();i++)
#define all(x) x.begin(),x.end()
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef pair&lt;int,int&gt; ii;
typedef long long ll;
int n,s;
int main()
{
    //freopen("in.cpp","r",stdin);
    //freopen("out.cpp","w",stdout);
    cin&gt;&gt;n&gt;&gt;s;int c,y,minc=inf;
    ll ans=0;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;c&gt;&gt;y;
        minc=min(minc,c-i*s);
        ans+=(ll(i)*s+minc)*y;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1681</h2><pre>Program P1681;
var
  f,p,c,m:longint;
  a:array[1..500,0..500] of longint;
  b:array[1..500,0..500] of longint;
  loc:array[1..500] of longint;
  dist:array[1..500] of int64;
  i,j:longint;
  x,y,d:longint;
  answer:longint;
  ans:array[1..500] of longint;
  Procedure SPFA;
  var
    l:array[0..500] of longint;
    v:array[0..500] of boolean;
    h,t:longint;
    i:longint;
    x:longint;
  begin
    Fillchar(l,sizeof(l),0);
    Fillchar(v,sizeof(v),0);
    h:=0;
    t:=1 mod f;
    For i:=1 to f do
    begin
      dist[i]:=maxlongint;
    end;
    dist[1]:=0;
    v[1]:=true;
    l[1]:=1;
    While not (h=t) do
    begin
      h:=(h+1) mod f;
      x:=l[h];
      v[x]:=false;
      if a[x,0]=0 then continue;
      For i:=1 to a[x,0] do
      begin
        if dist[b[x,i]]&gt;dist[x]+a[x,i] then
        begin
          dist[b[x,i]]:=dist[x]+a[x,i];
          if not v[b[x,i]] then
          begin
            v[b[x,i]]:=true;
            t:=(t+1) mod f;
            l[t]:=b[x,i];
          end;
        end;
      end;
    end;
  end;

begin
  Read(f,p,c,m);
  For i:=1 to p do
  begin
    Read(x,y,d);
    if x=y then Continue;
    inc(a[x,0]);
    inc(a[y,0]);
    inc(b[x,0]);
    inc(b[y,0]);
    a[x,a[x,0]]:=d;
    a[y,a[y,0]]:=d;
    b[x,b[x,0]]:=y;
    b[y,b[y,0]]:=x;
  end;
  SPFA;
  For i:=1 to c do
  begin
    Read(loc[i]);
  end;
  answer:=0;
  For i:=1 to c do
  begin
    if dist[loc[i]]&lt;=m then
    begin
      inc(answer);
      ans[answer]:=i;
    end;
  end;
  Writeln(answer);
  For  i:=1 to answer do
  begin
    Writeln(ans[i]);
  end;
end.
</pre><pre></pre><h2>Problem1682</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
const int maxn=2000+10;
typedef pair&lt;int,int&gt; pi;
typedef pair&lt;int,pi&gt; Edge;
#define x first
#define y second
int con[maxn],n,m;
int main()
{
    //freopen("in","r",stdin);
    int s,t,c;
    cin&gt;&gt;n&gt;&gt;m;
    vector&lt;Edge&gt; A;
    rep(i,m)
    {
        cin&gt;&gt;s&gt;&gt;t&gt;&gt;c;--s;--t;
        A.pb(Edge(c,pi(s,t)));
    }
    sort(All(A));
    rep(i,n)con[i]=i;
    int ans=0;
    rep(i,m)
    {
        c=A[i].x;s=A[i].y.x;t=A[i].y.y;
        if(con[s]==con[t])continue;
        int ch=con[t];
        ans=c;
        rep(i,n)if(con[i]==ch)con[i]=con[s];
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1683</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int maxy=500000,maxn=50000;
int w,n;
int H[maxn];
int cal(int i,int j)
{
	if(i&gt;j) return 0;
	if(i==j) return H[i]&gt;0;
	int c=maxy;
	for(int o=i;o&lt;=j;o++)
		c=min(H[o],c);
	int a=i,ans=0;
	for(int o=i;o&lt;=j;o++)
		if(H[o]==c)
			ans+=cal(a,o-1),a=o+1;
	ans+=cal(a,j);
	if(c) ans++;
	return ans;
}
int main()
{	
	cin&gt;&gt;n&gt;&gt;w;int x;
	for(int i=0;i&lt;n;i++)
	{
		scanf("%d %d",&amp;x,H+i);
	}
	cout&lt;&lt;cal(0,n-1)&lt;&lt;endl;
}

</pre><pre></pre><h2>Problem1684</h2><pre>#include &lt;iostream&gt;
#include &lt;cmath&gt;
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long LL;
LL gcd(LL a,LL b){return b?gcd(b,a%b):a;}
struct Fraction
{
    LL a,b;
    Fraction(){}
    Fraction(LL _a,LL _b):a(_a),b(_b)
    {
        LL d=gcd(a,b);
        if(d&lt;0)d*=-1;
        a/=d;b/=d;
    }
    double value()
    {
        return double(a)/b;
    }
    void Print()
    {
        cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;
    }
};
Fraction operator-(Fraction x,Fraction y)
{
    return Fraction(x.a*y.b-x.b*y.a,x.b*y.b);
}
bool operator&lt;(Fraction x,Fraction y)
{
    return x.a*y.b&lt;x.b*y.a;
}
bool operator==(Fraction x,Fraction y)
{
    return x.a==y.a&amp;&amp;x.b==y.b;
}
Fraction it,diff,ans;
void Init()
{
    int a,b;cin&gt;&gt;a;cin.get();cin&gt;&gt;b;
    it=Fraction(a,b);
    ans=Fraction(1,1);
    diff=ans-it;
}
int main()
{
    Init();double v=it.value();
    for(int d=1;d&lt;=32767;d++)
    {
        int t=v*d;
        for(int c=t-3;c&lt;=t+3&amp;&amp;c&lt;=32767;c++)
        {
            if(c&lt;0)continue;
            Fraction now(c,d);
            if(now==it)continue;
            Fraction nowdiff=now-it;
            if(nowdiff.a&lt;0)nowdiff.a*=-1;
            if(nowdiff&lt;diff)
            {
                diff=nowdiff;
                ans=now;
            }
            else if(nowdiff==diff)
            {
                if(now&lt;ans)
                {
                    ans=now;
                    diff=nowdiff;
                }
            }
        }
    }
    ans.Print();
}
</pre><pre></pre><h2>Problem1685</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; pnt;
pnt A[20];
int n,c;
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;c;
    rep(i,n)cin&gt;&gt;A[i].first&gt;&gt;A[i].second;
    sort(A,A+n);
    bool ok=true;
    int ans=0;
    while(ok)
    {
        int now=c;
        ok=false;
        for(int i=n-1;i&gt;=0;i--)
            while(A[i].second&gt;0&amp;&amp;now-A[i].first&gt;=0)
            {
                A[i].second--;
                now-=A[i].first;
            }
        rep(i,n)
            if(A[i].second&gt;0&amp;&amp;now&gt;0)
            {
                A[i].second--;now-=A[i].first;
                break;
            }
        if(now&lt;=0)ok=true;
        if(ok)ans++;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1687</h2><pre>Program P1687;
var
  n,m:longint;
  a:array[1..20000,0..4] of longint;
  b:array[1..20000,0..4] of longint;
  ahead:array[1..20000] of longint;
  dist:array[1..20000] of longint;
  start,ending:longint;
  total:longint;
  route:ansistring;
  Procedure makeroute;
  var
    n:longint;
  begin
    n:=ending;
    route:='';
    While n&lt;&gt;start do
    begin
      if (n-ahead[n]=1) and (ahead[n] mod m&lt;&gt;0) then
      begin
        route:='E'+route;
      end;
      if (n-ahead[n]=-1) and (n mod m&lt;&gt;0) then
      begin
        route:='W'+route;
      end;
      if (n-ahead[n]=m) then
      begin
        route:='S'+route;
      end;
      if (ahead[n]-n=m) then
      begin
        route:='N'+route;
      end;
      n:=ahead[n];
    end;
  end;

  Procedure SPFA;
  var
    h,t:longint;
    l:array[0..20000] of longint;
    v:array[0..20000] of boolean;
    i:longint;
    x:longint;
  begin
    Fillchar(l,sizeof(l),0);
    Fillchar(v,sizeof(v),0);
    For i:=1 to total do
    begin
      dist[i]:=maxlongint;
    end;
    h:=0;
    t:=1;
    v[start]:=true;
    l[1]:=start;
    dist[l[1]]:=0;
    While h&lt;&gt;t do
    begin
      h:=(h+1) mod total;
      x:=l[h];
      v[x]:=false;
      For i:=1 to a[x,0] do
      begin
        if (dist[x]+1&lt;dist[b[x,i]]) then
        begin
          ahead[b[x,i]]:=x;
          dist[b[x,i]]:=dist[x]+1;
          if v[b[x,i]]=false then
          begin
            v[b[x,i]]:=true;
            t:=(t+1) mod total;
            l[t]:=b[x,i];
          end;
        end;
      end;
    end;
  end;

  Procedure Connect(x1,y1,x2,y2:longint);
  var
    ax,ay,bx,by:longint;
    Node1,node2:longint;
  begin
    ax:=(x1+1) div 2;
    ay:=(y1+1) div 2;
    bx:=(x2+1) div 2;
    by:=(y2+1) div 2;
    node1:=(ax-1)*m+ay;
    node2:=(bx-1)*m+by;
    inc(a[node1,0]);
    inc(b[node1,0]);
    inc(a[node2,0]);
    inc(b[node2,0]);
    a[node1,a[node1,0]]:=1;
    b[node1,b[node1,0]]:=node2;
    a[node2,a[node2,0]]:=1;
    b[node2,b[node2,0]]:=node1;
  end;

  Procedure init;
  var
    s:string;
    i,j:longint;
  begin
    For i:=1 to (n*2-1) do
    begin
      Readln(s);
      For j:=1 to (m*2-1) do
      begin
        if s[j]='-' then Connect(i,j-1,i,j+1);
        if s[j]='|' then Connect(i-1,j,i+1,j);
        if s[j]='S' then start:=((i-1) div 2 * m +(j+1) div 2);
        if s[j]='E' then ending:=((i-1) div 2 * m + (j+1) div 2);
      end;
    end;
  end;

{  Procedure inittest;
  var
    i,j:longint;
  begin
    Writeln(Start);
    Writeln(ending);
    For i:=1 to total do
    begin
      For j:=1 to a[i,0] do
      begin
        Writeln(i,' ',b[i,j]);
      end;
    end;
  end;             }

  Procedure Print;
  var
    nowchar:char;
    nowcount:longint;
    i:longint;
  begin
    nowchar:=route[1];
    nowcount:=1;
    For i:=2 to length(route) do
    begin
      if route[i]&lt;&gt;nowchar then
      begin
        Writeln(nowchar,' ',nowcount);
        nowchar:=route[i];
        nowcount:=1;
        continue;
      end;
      inc(nowcount);
    end;
    Writeln(nowchar,' ',nowcount);
  end;

begin
  Fillchar(a,sizeof(a),0);
  Fillchar(b,sizeof(b),0);
  Readln(n,m);
  init;
  total:=n*m;
  spfa;
  makeroute;
  print;
end.

</pre><pre></pre><h2>Problem1688</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=1000;
int n,d,k,A[maxn]={},s,x,ans=0;
void Dfs(int p,int c,int now)
{
    if(d-p+c&lt;k||c&gt;k)return;
    if(p==d)
    {
        int tmp=0;
        rep(i,n)tmp+=((A[i]&amp;now)==A[i]);
        ans&gt;?=tmp;
        return;
    }
    Dfs(p+1,c,now);
    Dfs(p+1,c+1,(now|(1&lt;&lt;p)));
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d%d",&amp;n,&amp;d,&amp;k);
    rep(i,n)
    {
        scanf("%d",&amp;s);
        while(s--)scanf("%d",&amp;x),A[i]|=(1&lt;&lt;(x-1));
    }
    Dfs(0,0,0);
    printf("%d\n",ans);
}
</pre><pre></pre><h2>Problem1689</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=10000;
using namespace std;
struct Interval
{
    int l,r;
    Interval(){}
    Interval(int _l,int _r):l(_l),r(_r){}
    bool operator&lt;(const Interval&amp;that)const
    {
        if(l!=that.l)return l&lt;that.l;
        return r&gt;that.r;
    }
    bool Intersect(const Interval&amp;that)const
    {
        return !(l&gt;that.r||r&lt;that.l);
    }
    int size()
    {
        return r-l;
    }
}A[maxn];
int n,L;
void Init()
{
    cin&gt;&gt;n&gt;&gt;L;int l,r;
    rep(i,n)
    {
        scanf("%d%d",&amp;l,&amp;r);
        A[i]=Interval(l,r);
    }
}
void PreCondition()
{
    sort(A,A+n);int m=0;
    rep(i,n)
    {
        if(!m||!A[m-1].Intersect(A[i]))
            A[m++]=A[i];
        else
            A[m-1].r=A[i].r;
    }
    n=m;
}
int ans;
void Solve()
{
    int last=-1;ans=0;
    rep(i,n)
    {
        if(last&gt;=A[i].l)A[i].l=last+1;
        int s=A[i].size();if(s&lt;=0)continue;
        int t=(s-1)/L+1;
        ans+=t;last=A[i].l+t*L-1;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    PreCondition();
    Solve();
}


</pre><pre></pre><h2>Problem1690</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define tr(i,x) for(eit i=x.begin();i!=x.end();i++)
const int inf=~0U&gt;&gt;1,maxn=1000,maxm=5000;
using namespace std;
int n,m,F[maxn];
struct Edge
{
    int t,oc;
    double c;
    Edge(int _t,int _c):t(_t),oc(_c){}
};
typedef vector&lt;Edge&gt;::iterator eit;
vector&lt;Edge&gt; E[maxn];
double D;
bool vis[maxn]={0},Find;
double Dist[maxn];
void dfs(int x)
{
    vis[x]=true;double cost=Dist[x],ncost;
    tr(e,E[x])if((ncost=cost+e-&gt;c)&gt;Dist[e-&gt;t])
    {
        if(!vis[e-&gt;t]){Dist[e-&gt;t]=ncost;dfs(e-&gt;t);}
        else Find=true;
        if(Find)break;
    }
    vis[x]=false;
}
bool Check(double _D)
{
    D=_D;
    rep(i,n)tr(e,E[i])e-&gt;c=F[i]+F[e-&gt;t]-D*e-&gt;oc*2;
    Find=false;
    rep(i,n)Dist[i]=0;
    rep(i,n){dfs(i);if(Find)return true;}
    return false;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;rep(i,n)scanf("%d",F+i);
    int s,t,c;
    rep(i,m)scanf("%d %d %d",&amp;s,&amp;t,&amp;c),--s,--t,E[s].pb(Edge(t,c));
    double l=0,r=2000;
    while(r-l&gt;1e-3)
    {
        double m=(l+r)/2;
        if(Check(m))l=m;
        else r=m;
    }
    printf("%0.2lf\n",l);
}


</pre><pre></pre><h2>Problem1691</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long ll;
struct Thing
{
    int type,Money,Good;
    Thing(int _type,int _Money,int _Good):
        type(_type),Money(_Money),Good(_Good){}
    bool operator&lt;(const Thing&amp;that)const
    {
        if(Good!=that.Good)return Good&gt;that.Good;
        if(type!=that.type)return type==1;
        return Money&gt;that.Money;
    }
};
vector&lt;Thing&gt; A;
int main()
{
    //freopen("in","r",stdin);
    multiset&lt;int&gt; S;
    int n,m,a,b;
    cin&gt;&gt;n&gt;&gt;m;
    rep(i,n)
    {
        scanf("%d%d",&amp;a,&amp;b);
        A.pb(Thing(0,a,b));
    }
    rep(i,m)
    {
        scanf("%d%d",&amp;a,&amp;b);
        A.pb(Thing(1,a,b));
    }
    sort(A.begin(),A.end());
    ll ans=0;
    for(vector&lt;Thing&gt;::iterator it=A.begin();it!=A.end();it++)
    {
        if(it-&gt;type)
            S.insert(it-&gt;Money);
        else
        {
            multiset&lt;int&gt;::iterator sit=S.lower_bound(it-&gt;Money);
            if(sit==S.end())
            {
                cout&lt;&lt;-1&lt;&lt;endl;
                return 0;
            }
            ans+=*sit;
            S.erase(sit);
        }
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1692</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=30000+10,maxs=maxn*2;
char C[maxs],Ans[maxn];
int n,sa[maxs],R[maxs],ta[maxs],tb[maxs],*x=ta,*y=tb,m;
bool cmp(int i,int j,int l)
{
    return y[i]==y[j]&amp;&amp;y[i+l]==y[j+l];
}
void Sort()
{
    static int w[maxs];
    rep(i,m)w[i]=0;rep(i,n)w[x[y[i]]]++;
    rep(i,m-1)w[i+1]+=w[i];for(int i=n-1;i&gt;=0;i--)sa[--w[x[y[i]]]]=y[i];
}
void Da()
{
    int j,k,p,i;rep(i,n)x[i]=C[i],y[i]=i;Sort();
    for(j=1,p=1;p&lt;n;m=p,j*=2)
    {
        for(p=0,i=n-j;i&lt;n;i++)y[p++]=i;
        rep(i,n)if(sa[i]&gt;=j)y[p++]=sa[i]-j;
        Sort();
        for(swap(x,y),p=1,x[sa[0]]=0,i=1;i&lt;n;i++)
            x[sa[i]]=cmp(sa[i],sa[i-1],j)?p-1:p++;
    }
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);rep(i,n)scanf("\n%c",C+i);
    C[n]=1;rep(i,n)C[n*2-i]=C[i];n=n*2+1;m=256;
    Da();rep(i,n)R[sa[i]]=i;n/=2;int l=0,r=n-1,p=0;
    while(l&lt;=r)Ans[p++]=R[l]&lt;R[n*2-r]?C[l++]:C[r--];
    rep(i,n)
    {
        if(i&amp;&amp;i%80==0)printf("\n");
        printf("%c",Ans[i]);
    }
}
</pre><pre></pre><h2>Problem1693</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
const int maxn=500;
bool E[maxn][maxn]={};
int Link[maxn],n,k;
bool Vis[maxn];
bool dfs(int x)
{
    if(Vis[x])return false;
    Vis[x]=true;
    rep(i,n)if(E[x][i])
        if(Link[i]==-1||dfs(Link[i]))
            return Link[i]=x,true;
    return false;
}
int main()
{
    cin&gt;&gt;n&gt;&gt;k;int x,y;
    rep(i,k)
    {
        cin&gt;&gt;x&gt;&gt;y;
        E[--x][--y]=true;
    }
    int ans=0;memset(Link,-1,sizeof Link);
    rep(i,n)
    {
        memset(Vis,0,sizeof Vis);
        if(dfs(i))ans++;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1699</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=50000;
struct info
{
    int Max,Min;
    info(int x=0,int y=0):Max(x),Min(y){}
};
info T[maxn*3],none(-inf,inf);
info operator+(const info&amp;l,const info&amp;r)
{
    return info(max(l.Max,r.Max),min(l.Min,r.Min));
}
int A[maxn],n,q;
void build(int t,int l,int r)
{
    if(l+1==r){T[t]=info(A[l],A[l]);return;}
    build(t*2,l,(l+r)/2);
    build(t*2+1,(l+r)/2,r);
    T[t]=T[t*2]+T[t*2+1];
}
info ask(int t,int l,int r,int a,int b)
{
    if(a&gt;=r||b&lt;=l)return none;
    if(l&gt;=a&amp;&amp;r&lt;=b)return T[t];
    return ask(t*2,l,(l+r)/2,a,b)+ask(t*2+1,(l+r)/2,r,a,b);
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d %d",&amp;n,&amp;q);
    rep(i,n) scanf("%d",A+i);
    build(1,0,n);int l,r;info a;
    rep(i,q)scanf("%d %d",&amp;l,&amp;r),a=ask(1,0,n,l-1,r),printf("%d\n",a.Max-a.Min);
}

</pre><pre></pre><h2>Problem1701</h2><pre>/*
 *  [Usaco2007 Jan]Cow School牛学校.cpp
 *
 *  Created on: 2011-4-7
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 50000 + 10;

const double EPS = 1e-8;

int sign(double x) {
	return x &lt; -EPS ? -1 : x &gt; EPS;
}

int compare(double a, double b) {
	return sign(a - b);
}

struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
		x(_x), y(_y) {
	}
	int compareTo(const Point&amp;p) const {
		int cx = compare(x, p.x);
		if (cx != 0)
			return cx;
		return compare(y, p.y);
	}
	bool operator&lt;(const Point&amp;p) const {
		return compareTo(p) == -1;
	}

	double dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	Point rot90() {
		return Point(-y, x);
	}
};

const Point ORIGIN(0, 0);

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y) - (p3.x-p1.x)*(p2.y-p1.y))

#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))

double getAlpha(Point src, Point dst) {
	return atan2(dst.y - src.y, dst.x - src.x);
}

struct ConvexHull {
	Point ps[MAX_N];
	int nPs;
	void clear() {
		nPs = 0;
	}
	void add(Point p) {
		ps[nPs++] = p;
	}

	struct Vector {
		int src, dst;
		double alpha;
		Vector() {
		}
		Vector(double _alpha) :
			alpha(_alpha) {
		}

		void set(Point ps[], int _src, int _dst) {
			src = _src;
			dst = _dst;
			alpha = getAlpha(ps[src], ps[dst]);
		}

		bool operator&lt;(const Vector&amp;v) const {
			return alpha &lt; v.alpha;
		}
	};

	Vector vs[MAX_N];

	void doit() {
		sort(ps, ps + nPs);
		int k = 0;
		static Point qs[MAX_N];
		for (int i = 0; i &lt; nPs; qs[k++] = ps[i++]) {
			while (k &gt; 1 &amp;&amp; crossOp(qs[k-2],qs[k-1],ps[i]) &lt;= 0)
				--k;
		}
		for (int i = nPs - 2, t = k; i &gt;= 0; qs[k++] = ps[i--]) {
			while (k &gt; t &amp;&amp; crossOp(qs[k-2],qs[k-1],ps[i]) &lt;= 0)
				--k;
		}
		nPs = k - 1;
		if (nPs &lt; 1)
			nPs = 1;
		memcpy(ps, qs, sizeof(Point) * nPs);

		for (int i = 0; i &lt; nPs; ++i) {
			vs[i].set(ps, i, (i + 1) % nPs);
		}
		sort(vs, vs + nPs);
	}

	double ask(double a, double b) {
		//min ax+by
		Point me(a, b);
		double alpha = getAlpha(me.rot90(), ORIGIN);

		int at = upper_bound(vs, vs + nPs, Vector(alpha)) - vs;
		if (at == nPs)
			at = 0;

		return me.dot(ps[vs[at].src]);
	}
};

struct Test {
	int myScore;
	int sum;

	void read() {
		scanf("%d%d", &amp;myScore, &amp;sum);
	}

	bool operator&lt;(const Test&amp;test) const {
		return myScore * test.sum &gt; sum * test.myScore;
	}
};

Test tests[MAX_N];
int nTests;

void inputData() {
	cin &gt;&gt; nTests;
	for (int i = 1; i &lt;= nTests; ++i) {
		tests[i].read();
	}
}

void rec(int l, int r, double ask[], double ret[]) {
	static ConvexHull con;
	int m = l + r &gt;&gt; 1;
	if (l + 1 == r) {
		con.clear();
		int at = l;
		con.add(Point(tests[at].myScore, tests[at].sum));
		con.doit();
		ret[at] = min(ret[at], con.ask(1, -ask[at]));
		return;
	} else {
		con.clear();
		for (int i = l; i &lt; m; i++)
			con.add(Point(tests[i].myScore, tests[i].sum));
		con.doit();
		for (int i = m; i &lt; r; ++i) {
			ret[i] = min(ret[i], con.ask(1, -ask[i]));
		}
		rec(l, m, ask, ret);
		rec(m, r, ask, ret);
	}
}

double bfAsk(int l, int r, double a, double b) {
	double ret = 1e100;
	for (int i = l; i &lt; r; i++)
		ret = min(ret, tests[i].myScore * a + tests[i].sum * b);
	return ret;
}

void work() {
	sort(tests + 1, tests + nTests + 1);

//	for (int i = 1; i &lt;= nTests; ++i) {
//		cout &lt;&lt; tests[i].myScore &lt;&lt; "/" &lt;&lt; tests[i].sum &lt;&lt; endl;
//	}

	static double ask[MAX_N];

	double sumMyScore = 0;
	double sumSum = 0;

	for (int i = 1; i &lt;= nTests; i++) {
		sumMyScore += tests[i].myScore;
		sumSum += tests[i].sum;
		double alpha = 1.0 * sumMyScore / sumSum;
		ask[i] = alpha;
//		cout &lt;&lt; ask[i] &lt;&lt; endl;
	}

	static double firstMin[MAX_N];
	static double lastMax[MAX_N];

	fill(firstMin, firstMin + nTests, 1e100);
	rec(1, nTests + 1, ask, firstMin);

//	for (int i = 1; i &lt;= nTests; ++i) {
//		double a1 = firstMin[i], a2 = bfAsk(1, i + 1, 1, -ask[i]);
//		if (compare(a1, a2) != 0)
//			puts("FUCK!");
//	}

	reverse(tests + 1, tests + nTests + 1);
	double rask[MAX_N];
	for (int i = 1; i &lt;= nTests; ++i) {
		int lastCnt = i;
		int beforeCnt = nTests - lastCnt;
		rask[i] = ask[beforeCnt];
	}
	for (int i = 1; i &lt;= nTests; ++i) {
		tests[i].myScore *= -1;
		tests[i].sum *= -1;
	}

	fill(lastMax, lastMax + nTests, 1e100);
	rec(1, nTests + 1, rask, lastMax);
	for (int i = 1; i &lt;= nTests; ++i) {
		lastMax[i] *= -1;
	}

	int cnt = 0;

	static int ans[MAX_N];
	for (int i = 1; i &lt;= nTests - 1; ++i) {
//		cout &lt;&lt; firstMin[i] &lt;&lt; " : " &lt;&lt; lastMax[nTests - i] &lt;&lt; endl;
		if (compare(firstMin[i], lastMax[nTests - i]) &lt; 0) {
			ans[cnt++] = nTests - i;
		}
	}

	printf("%d\n", cnt);
	reverse(ans, ans + cnt);

	for (int i = 0; i &lt; cnt; ++i) {
		printf("%d\n", ans[i]);
	}
}

int main() {
	inputData();
	work();
}
</pre><pre></pre><h2>Problem1702</h2><pre>#include&lt;cstdio&gt;

#include&lt;bitset&gt;

#include&lt;cstring&gt;

using namespace std;

const int maxk=30,size=100007;

const int seed[]={131,1331,1771,19711};

class Hash

{

	int k;

	struct node

	{

		int keys[maxk],pos;

		unsigned int h[4];		

		node*next;

		node(int A[],int p):pos(p)

		{

			memmove(keys,A,sizeof(keys));

		}

		bool operator==(node*p)

		{

			for(int i=0;i&lt;4;i++)

				if(h[i]!=p-&gt;h[i])

					return false;

			return true;

		}

	}*H[size];

	void code(node*p)

	{

		for(int i=0;i&lt;4;i++)	

			p-&gt;h[0]=0;

		for(int i=0;i&lt;k;i++)

			for(int j=0;j&lt;4;j++)

				p-&gt;h[j]*=seed[j],p-&gt;h[j]+=p-&gt;keys[i];

		for(int i=0;i&lt;4;i++)

			p-&gt;h[i]%=size;

	}

	public:

	Hash(int _k):k(_k){memset(H,0,sizeof(H));}

	int ins(int A[],int pos)

	{

		node*p=new node(A,pos);code(p);int h=p-&gt;h[0];

		node*q=H[h];

		while(q)

		{

			if((*q)==p) return q-&gt;pos;

			q=q-&gt;next;

		}

		p-&gt;next=H[h];H[h]=p;return -1;

	}

};

class solve

{

	Hash*H;

	int now[maxk],n,k;

	typedef bitset&lt;maxk&gt; bit;

	bit code;

	void work()

	{

		scanf("%d %d",&amp;n,&amp;k);int tmp,ans=0;

		for(int i=0;i&lt;k;i++)now[i]=0;

		H=new Hash(k);H-&gt;ins(now,0);

		for(int i=1;i&lt;=n;i++)

		{

			scanf("%d",&amp;tmp);

			code=bit(tmp);		

			for(int j=0;j&lt;k;j++)

				now[j]+=(code[j]?1:0);//printf("%d",code[j]==true);

			//puts("");

			tmp=now[0];

			for(int j=0;j&lt;k;j++)

			{

				now[j]-=tmp;

				//printf("%d ",now[j]);

			}

			//puts("");

			tmp=H-&gt;ins(now,i);

			if(tmp!=-1&amp;&amp;(i-tmp)&gt;ans)	

				ans=i-tmp;

		}

		printf("%d\n",ans);

	}

	public:

	solve()

	{

		work();

	}

};

int main()

{

	solve now;

}</pre><pre></pre><h2>Problem1703</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
typedef vector&lt;int&gt;::iterator it;
const int maxn=1000;
bool rec[maxn][maxn]={0};
vector&lt;int&gt; E[maxn];
int now;
void dfs(int x)
{
	rec[now][x]=true;
	for(it i=E[x].begin();i!=E[x].end();i++)
		if(!rec[now][*i])
			dfs(*i);
}
int main()
{
	int n,m,s,t;scanf("%d %d",&amp;n,&amp;m);
	while(m--)
		scanf("%d %d",&amp;s,&amp;t),E[s-1].push_back(t-1);
	for(int i=0;i&lt;n;i++)
		now=i,dfs(i);
	int ans=0;
	for(int i=0;i&lt;n;i++)	
		for(int j=i+1;j&lt;n;j++)
			if(!rec[i][j]&amp;&amp;!rec[j][i])
				ans++;
	printf("%d\n",ans);
}</pre><pre></pre><h2>Problem1704</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int n,k,min=~0U&gt;&gt;1;
bool A[5000],C[5001]={0};
int cal()
{
	int i,ans=0;bool t=0,imp=false;
	for(i=0;i+k&lt;=n;i++)
	{
		t^=C[i];
		if(A[i]^t)
			t^=1,C[i+k]^=1,ans++;
		if(ans&gt;=min) {imp=true;break;}
	}
	if(imp){memset(C,false,sizeof(bool)*(i+k+1));return -1;}
	for(i=n-k+1;i&lt;n;i++)
	{
		t^=C[i];
		if(A[i]^t) break;
	}
	memset(C,false,sizeof(bool)*(n+1));
	if(i!=n) return-1;
	return ans;
}
int main()
{
	scanf("%d",&amp;n);char t;int tmp,ansk=-1;
	for(int i=0;i&lt;n;i++)
		scanf("\n%c",&amp;t),A[i]=(t=='B');
	for(k=1;k&lt;=n;k++)
		if((tmp=cal())!=-1)
		{
			if(tmp&lt;min)
				min=tmp,ansk=k;
		}
	printf("%d %d\n",ansk,min);
}</pre><pre></pre><h2>Problem1705</h2><pre>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#define Renew(x,c) x=min(x,c)
using namespace std;
const int maxh=100,maxn=100000,inf=~0U&gt;&gt;2;
int n,c,x,best[2][maxh+1],now,old,low[maxh+2],up[maxh+2];
inline int abs(int x){return x&lt;0?-x:x;}
int main()
{
	cin&gt;&gt;n&gt;&gt;c&gt;&gt;x;
	for(int i=1;i&lt;x;i++)	
		best[0][i]=inf;	
	for(int i=x;i&lt;=maxh;i++)
		best[0][i]=(x-i)*(x-i);
	for(int t=1;t&lt;n;t++)
	{
		now=t%2;old=1-now;
		int get;scanf("%d",&amp;x);
		for(int i=1;i&lt;=maxh;i++) best[now][i]=inf;
		memset(low,127,sizeof(low));
		memset(up,127,sizeof(up));
		for(int i=1;i&lt;=maxh;i++)
			low[i]=min(low[i-1],best[old][i]-c*i);
		for(int i=maxh;i&gt;=1;i--)
			up[i]=min(up[i+1],best[old][i]+c*i);
		for(int i=x;i&lt;=maxh;i++)
		{	
			best[now][i]=(i-x)*(i-x);
			best[now][i]+=min(low[i]+c*i,up[i]-c*i);
		}
	}
	int ans=inf;
	for(int i=1;i&lt;=maxh;i++) Renew(ans,best[now][i]);
	cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1706</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define Update(x,c) x=min(x,c)
using namespace std;
typedef long long ll;
const int maxn=100+10,inf=~0U&gt;&gt;1;
int l,m,vs,vt,n=0;
ll T[maxn][maxn];
map&lt;int,int&gt; M;
struct Mat
{
    ll M[maxn][maxn];
    ll&amp;operator()(int i,int j){return M[i][j];}
    Mat(){rep(i,maxn)rep(j,maxn)M[i][j]=inf;}
    void operator*=(Mat&amp;o)
    {
        rep(i,n)rep(j,n)T[i][j]=inf;
        rep(i,n)rep(j,n)rep(k,n)Update(T[i][j],M[i][k]+o(k,j));
        memcpy(M,T,sizeof(T));
    }
    void operator=(Mat&amp;o)
    {memcpy(M,o.M,sizeof(M));}
}orig,Ans;
void Power(Mat&amp;a,int t)
{
    if(t==1){a=orig;return;}
    Power(a,t/2);a*=a;if(t&amp;1)a*=orig;
}
void get(int&amp;s){if(M.count(s))s=M[s];else s=M[s]=n++;}
int main()
{
  //freopen("in","r",stdin);
  scanf("%d %d %d %d",&amp;l,&amp;m,&amp;vs,&amp;vt);int s,t,c;
  while(m--)scanf("%d %d %d",&amp;c,&amp;s,&amp;t),get(s),get(t),orig(s,t)=orig(t,s)=c;
  get(vs),get(vt);Power(Ans,l);
  cout&lt;&lt;Ans(vs,vt)&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1706</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define Update(x,c) x=min(x,c)
using namespace std;
typedef long long ll;
const int maxn=100+10,inf=~0U&gt;&gt;2;
int l,m,vs,vt,n=0,T[maxn][maxn];
map&lt;int,int&gt; M;
struct Mat
{
    int M[maxn][maxn];
    int&amp;operator()(int i,int j){return M[i][j];}
    Mat(){rep(i,maxn)rep(j,maxn)M[i][j]=inf;}
    void operator*=(Mat&amp;o)
    {
        rep(i,n)rep(j,n)T[i][j]=inf;
        rep(i,n)rep(j,n)rep(k,n)Update(T[i][j],M[i][k]+o(k,j));
        memcpy(M,T,sizeof(T));
    }
    void operator=(Mat&amp;o)
    {memcpy(M,o.M,sizeof(M));}
}orig,Ans;
void Power(Mat&amp;a,int t)
{
    if(t==1){a=orig;return;}
    Power(a,t/2);a*=a;if(t&amp;1)a*=orig;
}
void get(int&amp;s){if(M.count(s))s=M[s];else s=M[s]=n++;}
int main()
{
  //freopen("in","r",stdin);
  scanf("%d %d %d %d",&amp;l,&amp;m,&amp;vs,&amp;vt);int s,t,c;
  while(m--)scanf("%d %d %d",&amp;c,&amp;s,&amp;t),get(s),get(t),orig(s,t)=orig(t,s)=c;
  get(vs),get(vt);Power(Ans,l);
  cout&lt;&lt;Ans(vs,vt)&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1706</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define Update(x,c) x=min(x,c)
using namespace std;
const int maxn=100+10,inf=~0U&gt;&gt;2;
int l,m,vs,vt,n=0,T[maxn][maxn];
map&lt;int,int&gt; M;
struct Mat
{
    int M[maxn][maxn];
    int&amp;operator()(int i,int j){return M[i][j];}
    Mat(){rep(i,maxn)rep(j,maxn)M[i][j]=inf;}
    void operator*=(Mat&amp;o)
    {
        rep(i,n)rep(j,n)T[i][j]=inf;
        rep(i,n)rep(j,n)rep(k,n)Update(T[i][j],M[i][k]+o(k,j));
        memcpy(M,T,sizeof(T));
    }
    void operator=(Mat&amp;o)
    {memcpy(M,o.M,sizeof(M));}
}orig,Ans;
void Power(Mat&amp;a,int t)
{
    if(t==1){a=orig;return;}
    Power(a,t/2);a*=a;if(t&amp;1)a*=orig;
}
void get(int&amp;s){if(M.count(s))s=M[s];else s=M[s]=n++;}
int main()
{
  scanf("%d %d %d %d",&amp;l,&amp;m,&amp;vs,&amp;vt);int s,t,c;
  while(m--)scanf("%d %d %d",&amp;c,&amp;s,&amp;t),get(s),get(t),orig(s,t)=orig(t,s)=c;
  get(vs),get(vt);Power(Ans,l);
  printf("%d\n",Ans(vs,vt));
}
</pre><pre></pre><h2>Problem1707</h2><pre>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
using namespace std;
typedef pair&lt;int,int&gt; pi;
int Cover[1000+1]={0},C;
pi Cs[2500],Bs[2500];
priority_queue&lt;int&gt; Q;
inline void ins(int x)
{	Q.push(-x);	}
inline int top()
{	return -Q.top();	}
inline void pop()
{	Q.pop();	}
int main()
{
	int L;cin&gt;&gt;C&gt;&gt;L;
	for(int i=0;i&lt;C;i++)
	{
		cin&gt;&gt;Cs[i].first&gt;&gt;Cs[i].second;
	}
	for(int i=0;i&lt;L;i++)
	{
		cin&gt;&gt;Bs[i].first&gt;&gt;Bs[i].second;		
	}
	sort(Cs,Cs+C);
	sort(Bs,Bs+L);
	pi*s=Cs;int ans=0;
	for(pi*i=Bs;i!=Bs+L;i++)
	{
		while(s!=Cs+C&amp;&amp;s-&gt;first&lt;=i-&gt;first)
			ins(s-&gt;second),s++;
		while(Q.size()&amp;&amp;top()&lt;i-&gt;first)
			pop();
		while(i-&gt;second&amp;&amp;Q.size())
		{
			pop(),i-&gt;second--,ans++;	
		}
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem1708</h2><pre>#include&lt;iostream&gt;
using namespace std;
long long f[1&lt;&lt;14]={1},v,n,x;
int main()
{
  cin&gt;&gt;v&gt;&gt;n;
  while(v--) {cin&gt;&gt;x;for(int j=x;j&lt;=n;j++)f[j]+=f[j-x];}
  cout&lt;&lt;f[n]&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1709</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=100,inf=~0U&gt;&gt;1;
int M[maxn][maxn]={0},n;
const int di[]={1,1,0,-1,-1,-1,0,1},dj[]={0,1,1,1,0,-1,-1,-1};
inline bool Legal(int i,int j){return i&gt;=0&amp;&amp;i&lt;n&amp;&amp;j&gt;=0&amp;&amp;j&lt;n;}
void Put(int i,int j)
{
    M[i][j]++;
    rep(d,8)
        for(int ii=i+di[d],jj=j+dj[d];Legal(ii,jj);ii+=di[d],jj+=dj[d])
            M[ii][jj]++;
}
int main()
{
   //freopen("in","r",stdin);
   cin&gt;&gt;n;int m,x,y,ans=0;cin&gt;&gt;m;
   rep(i,m)cin&gt;&gt;x&gt;&gt;y,Put(x-1,y-1);
   rep(i,n)rep(j,n)ans+=(M[i][j]==m);
   cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1710</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define Renew(x,c) x=min(x,c)
using namespace std;
int n,m;
char C[3000];
int cost[26];
int dp[2000][2000];
void init()
{
	scanf("%d %d\n",&amp;n,&amp;m);
	gets(C);int a,b;char c;
	for(int i=0;i&lt;n;i++)		
		scanf("\n%c %d %d",&amp;c,&amp;a,&amp;b),cost[c-'a']=min(a,b);
}
void solve()
{
	dp[0][0]=0;
	for(int i=1;i&lt;n;i++)
		dp[i][i]=dp[i][i-1]=0;
	int tmp;
	for(int l=1;l&lt;m;l++)
		for(int i=0;i+l&lt;m;i++)
		{
			int j=i+l;			
			if(C[i]==C[j])
				dp[i][j]=dp[i+1][j-1];
			else
			{
				tmp=~0U&gt;&gt;1;
				Renew(tmp,dp[i][j-1]+cost[C[j]-'a']);
				Renew(tmp,dp[i+1][j]+cost[C[i]-'a']);
				dp[i][j]=tmp;
			}
		}
	printf("%d\n",dp[0][m-1]);		
}
int main()
{
	init();
	solve();
}</pre><pre></pre><h2>Problem1711</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int V=600,E=220,maxn=100;
int n,m,h[V],vh[V],v,vs,vt;
inline int Food(int x){return x;}
inline int Drink(int x){return x+maxn;}
inline int Cowin(int x){return x+maxn*2;}
inline int Cowout(int x){return x+maxn*3;}
struct edge
{
    int t,u;
    edge *next,*op;
    edge(int t_,int u_,edge* next_):t(t_),u(u_),next(next_){}
}*e[V]={0};
void add(int s,int t,int u)
{
	e[s]=new edge(t,u,e[s]);
	e[t]=new edge(s,0,e[t]);
	e[s]-&gt;op=e[t];e[t]-&gt;op=e[s];
}
int aug(int no,int m)
{
    if(no==vt)return m;
    int l=m;
    for(edge*i=e[no];i;i=i-&gt;next)
    if(i-&gt;u&amp;&amp;h[i-&gt;t]+1==h[no])
    {
    	int d=aug(i-&gt;t,min(i-&gt;u,l));
    	l-=d;i-&gt;u-=d;i-&gt;op-&gt;u+=d;
    	if(!l||h[no]&gt;=v) return m-l;    	
    }
    int minh=v;
    for(edge*i=e[no];i;i=i-&gt;next)
    	if(i-&gt;u) minh=min(minh,h[i-&gt;t]);
    if(!--vh[h[no]])h[vs]=v;
    vh[h[no]=minh+1]++;
    return m-l;
}
int N,F,D;
void init()
{
	vs=0;vt=V-1;
	scanf("%d %d %d",&amp;N,&amp;F,&amp;D);
	v=2+N*2+F+D;
	memset(vh,0,sizeof(vh));
	memset(h,0,sizeof(h));
	vh[0]=v;int f,d,t;
	for(int i=1;i&lt;=N;i++)
	{
		scanf("%d %d",&amp;f,&amp;d);
		add(Cowin(i),Cowout(i),1);
		while(f--) scanf("%d",&amp;t),add(Food(t),Cowin(i),1);
		while(d--) scanf("%d",&amp;t),add(Cowout(i),Drink(t),1);
	}
	for(int i=1;i&lt;=F;i++)
		add(vs,Food(i),1);
	for(int i=1;i&lt;=D;i++)
		add(Drink(i),vt,1);	
}
void solve()
{
	int ans=0;
	while(h[vs]&lt;v)
		ans+=aug(vs,~0U&gt;&gt;1);
	printf("%d\n",ans);
}
int main()
{
	init();
	solve();	
} </pre><pre></pre><h2>Problem1712</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
typedef long long Board[2][2];
const int maxn=50000;
const long long Mod=98765431;
int N;
long long T;
int C[maxn];
struct Matrix
{
	Board own;		
	Matrix(){memset(own,0,sizeof(own));}
	Matrix operator*(const Matrix&amp;x) 
	{
		Matrix now;
		REP(i,2) REP(j,2)
		{
			REP(k,2)now.own[i][j]+=(own[i][k]*x.own[k][j])%Mod;
			now.own[i][j]%=Mod;if(now.own[i][j]&lt;0) now.own[i][j]+=Mod;
		}
		return now;
	}
	long long* cal(int A[])
	{
		long long* ans=new long long[2];
		ans[0]=ans[1]=0;
		REP(i,2) REP(j,2)
			ans[i]+=own[i][j]*A[j];
		return ans;
	}
	void operator=(const Matrix&amp;x) 
	{
		memmove(own,x.own,sizeof(own));
	}
	void show()
	{
		REP(i,2){REP(j,2) cout&lt;&lt;own[i][j]&lt;&lt;" ";cout&lt;&lt;endl;}
	}
}ans,orig;
Matrix power(long long t)
{
	if(t==1)	
	{
		return orig;
	}
	Matrix now;	
	now=power(t/2);
	now=now*now;
	if(t%2==1)
		now=now*orig;
	return now;
}
int main()
{
	cin&gt;&gt;N&gt;&gt;T;int S=0;
	REP(i,N) {scanf("%d",C+i);S+=C[i];S%=Mod;}
	orig.own[0][0]=N-1;orig.own[0][1]=1;
	orig.own[1][0]=0;orig.own[1][1]=-1;
	ans=power(T);
	int A[2]={0,1};
	long long*get=ans.cal(A);
	REP(i,N)
	{
		long long t=get[0]*S+get[1]*C[i];
		t%=Mod;
		printf("%lld\n",t);
	}
}
</pre><pre></pre><h2>Problem1715</h2><pre>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
struct edge
{
	int t,c;
	edge(int t,int c):t(t),c(c){}
};
const int maxn=500+10,inf=~0U&gt;&gt;1;
vector&lt;edge&gt; E[maxn];
void add(int s,int t,int c)
{
	E[s].push_back(edge(t,c));
}
void clear()
{
	for(int i=0;i&lt;maxn;i++)
		E[i].clear();
}
int dist[maxn];
int n,m,w,s,t,c,limit;
bool inQ[maxn];
queue&lt;int&gt; Q;
inline void Push(int n){inQ[n]=true;Q.push(n);}
inline int Pop(){int t=Q.front();Q.pop();inQ[t]=false;return t;}
inline void Renew(int n,int c)
{
	if(dist[n]&gt;c)
	{
		dist[n]=c;
		if(!inQ[n]) Push(n);
	}
}
bool spfa(int vs)
{
	for(int i=0;i&lt;=n;i++) dist[i]=inf,inQ[i]=false;
	dist[vs]=0;Push(vs);
	while(Q.size()&amp;&amp;limit--)
	{
		int t=Pop(),get;
		for(int i=0;i&lt;E[t].size();i++)
		{
			get=dist[t]+E[t][i].c;
			Renew(E[t][i].t,get);
		}
	}
	while(Q.size()) Q.pop();
	return limit&gt;0;
}
void solve()
{
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;w;
	limit=n*(m+w);
	clear();
	while(m--)
	{
		cin&gt;&gt;s&gt;&gt;t&gt;&gt;c;		
		s--;t--;
		add(s,t,c);
		add(t,s,c);
	}
	while(w--)
	{
		cin&gt;&gt;s&gt;&gt;t&gt;&gt;c;
		s--;t--;
		add(s,t,-c);
	}
	for(int i=0;i&lt;n;i++)
		add(n,i,0);	
	if(!spfa(n))
		cout&lt;&lt;"YES"&lt;&lt;endl;
	else
		cout&lt;&lt;"NO"&lt;&lt;endl;
}
int main()
{
	int t;cin&gt;&gt;t;
	while(t--)
	{
		solve();
	}
}
</pre><pre></pre><h2>Problem1716</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;pi&gt;::iterator it;
const int maxn=100,limit=10100,maxs=10100,inf=~0U&gt;&gt;3;
int V[maxn],C[maxn],n,t;
class dp
{
	vector&lt;pi&gt;&amp; T;
	int size;
	int*D;
	public:
	dp(vector&lt;pi&gt;&amp; A,int s,bool fin):T(A),size(s)
	{
		D=new int[size+1];D[0]=0;
		for(int i=1;i&lt;=size;i++) D[i]=inf;
		for(it i=T.begin();i!=T.end();i++)
		{
			if(fin)
			{
				for(int j=size;j&gt;=i-&gt;first;j--)
					if(D[j-i-&gt;first]!=inf)
						D[j]=min(D[j],D[j-i-&gt;first]+i-&gt;second);
			}
			else					
			{
				for(int j=i-&gt;first;j&lt;=size;j++)
					if(D[j-i-&gt;first]!=inf)
						D[j]=min(D[j],D[j-i-&gt;first]+i-&gt;second);
			}
		}
	}
	int operator[](int v){return D[v];}
};
int main()
{
	//init
	cin&gt;&gt;n&gt;&gt;t;
	for(int i=0;i&lt;n;i++) cin&gt;&gt;V[i];
	for(int i=0;i&lt;n;i++) cin&gt;&gt;C[i];
	//unlimited dp
	vector&lt;pi&gt; A;
	for(int i=0;i&lt;n;i++) A.push_back(pi(V[i],1));
	dp Un(A,limit,false);
	//limited dp
	vector&lt;pi&gt; B;
	for(int i=0;i&lt;n;i++)
	{
		int t=1;		
		while(C[i]&gt;=t)
			B.push_back(pi(V[i]*t,t)),C[i]-=t,t&lt;&lt;=1;
		if(C[i]&gt;0)	B.push_back(pi(V[i]*C[i],C[i]));
	}
	dp Lim(B,t+limit,true);
	//cal
	int ans=inf;
	for(int i=t;i&lt;=t+limit;i++)
		{
			ans=min(ans,Lim[i]+Un[i-t]);
		}
	if(ans==inf) cout&lt;&lt;-1&lt;&lt;endl;
	else cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem1717</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int seed=1333331,maxn=20000;
using namespace std;
typedef unsigned long long ull;
ull P[maxn];
int n,k,A[maxn];
bool Check(int L)
{
    ull ret=0;map&lt;ull,int&gt; M;
    rep(i,L) ret*=seed,ret+=A[i];
    M[ret]=1;
    rep(i,n-L)
    {
        ret-=P[L-1]*A[i];ret*=seed;ret+=A[i+L];
        int&amp;x=M[ret];if(++x&gt;=k)return true;
    }
    return false;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;k;rep(i,n)scanf("%d",A+i);
    P[0]=1;for(int i=1;i&lt;n;i++)P[i]=P[i-1]*seed;
    int l=0,r=n/k+1;
    while(l+1&lt;r)
    {
        int m=(l+r)/2;
        if(Check(m)) l=m;
        else r=m;
    }
    cout&lt;&lt;l&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1717</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int seed=1333331,maxn=20000;
using namespace std;
typedef unsigned long long ull;
ull P[maxn];
int n,k,A[maxn];
bool Check(int L)
{
    ull ret=0;map&lt;ull,int&gt; M;
    rep(i,L) ret*=seed,ret+=A[i];
    M[ret]=1;
    rep(i,n-L)
    {
        ret-=P[L-1]*A[i];ret*=seed;ret+=A[i+L];
        int&amp;x=M[ret];if(++x&gt;=k)return true;
    }
    return false;
}
int main()
{
    scanf("%d%d",&amp;n,&amp;k);rep(i,n)scanf("%d",A+i);
    P[0]=1;rep(i,n-1)P[i+1]=P[i]*seed;
    int l=0,r=n/k+1;
    while(l+1&lt;r)
    {
        int m=(l+r)/2;
        if(Check(m)) l=m;
        else r=m;
    }
    printf("%d\n",l);
}


</pre><pre></pre><h2>Problem1723</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=50000+10;
int H[maxn],V[maxn],L[maxn],R[maxn],n,P[maxn],A[maxn]={};
bool cmp(int i,int j)
{
    return H[i]&lt;H[j];
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);rep(i,n)scanf("%d%d",H+i,V+i),P[i]=i;
    rep(i,n+1)R[i]=i+1,L[i+1]=i;sort(P,P+n,cmp);
    rep(i,n)
    {
        int t=P[i]+1;A[L[t]]+=V[t-1];A[R[t]]+=V[t-1];
        R[L[t]]=R[t];L[R[t]]=L[t];
    }
    int ans=0;
    rep(i,n)ans&gt;?=A[i+1];
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1724</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
#include&lt;stack&gt;
using namespace std;
int n,t;
priority_queue&lt;int&gt; Heap;
int main()
{
	cin&gt;&gt;n;long long ans=0;
	while(n--) scanf("%d",&amp;t),Heap.push(-t);int a,b;
	while(Heap.size()&gt;=2)
	{
		a=Heap.top();Heap.pop();
		b=Heap.top();Heap.pop();
		ans-=a+b;
		Heap.push(a+b);
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem1725</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;iostream&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=13;
int N,M,cur;
int map[maxn];
int F[2][1&lt;&lt;maxn]={0};
int S[1&lt;&lt;maxn],ns=0;
inline bool check(int a,int b)
{
	return (a&amp;b)==0;
}
void dfs(int c,int n)
{
	if(c&gt;=M)
	{
		S[ns++]=n;
		return;
	}
	dfs(c+1,n);
	dfs(c+2,n+(1&lt;&lt;c));
}
void init()
{
	cin&gt;&gt;N&gt;&gt;M;int tmp,t;
	REP(i,N) 
	{
		tmp=0;
		REP(j,M)	
		{	
			cin&gt;&gt;t;
			if(t==0) tmp+=1&lt;&lt;j;
		}
		map[i]=tmp;
	}
}
void solve()
{
	dfs(0,0);
	for(int i=0;i&lt;ns;i++)
		if(check(S[i],map[0]))
			F[0][i]++;
	int now=0,old=1;
	for(int i=1;i&lt;N;i++)
	{
		now=i&amp;1;old=1-now;		
		for(int j=0;j&lt;ns;j++)
		{
			F[now][j]=0;
			if(check(map[i],S[j]))
				for(int k=0;k&lt;ns;k++)
					if(check(S[j],S[k]))
					{				
						F[now][j]+=F[old][k];
						F[now][j]%=100000000;
					}
		}
	}
	int ans=0;
	for(int i=0;i&lt;ns;i++)
	{
		ans+=F[now][i];
		ans%=100000000;
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
	init();
	solve();
}
</pre><pre></pre><h2>Problem1726</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
typedef pair&lt;int,int&gt; pi;
typedef vector&lt;pi&gt;::iterator it;
const int maxn=5000,inf=~0U&gt;&gt;2;
vector&lt;pi&gt; E[maxn];
void add(int s,int t,int c)
{	
	E[s].push_back(pi(t,c));
	E[t].push_back(pi(s,c));
}
struct node
{
	int best,second;
	node(){best=second=inf;}
};
int n;
node dist[maxn];
queue&lt;int&gt; Q;
bool inQ[maxn]={0};
inline bool Renew(int x,int cost)
{
	if(dist[x].best&gt;cost)
	{
		dist[x].second=dist[x].best;
		dist[x].best=cost;
		return true;
	}
	if(dist[x].best==cost)
	{
		return false;
	}
	if(dist[x].second&gt;cost)
	{		
		dist[x].second=cost;
		return true;
	}
	return false;
}
inline void Push(int x,int cost)
{
	if(Renew(x,cost))
		if(!inQ[x])
			Q.push(x),inQ[x]=true;
}
void spfa()
{
	Q.push(0);Push(0,0);int t;node cost;
	while(Q.size())	
	{
		t=Q.front();cost=dist[t];inQ[t]=false;Q.pop();
		for(it i=E[t].begin();i!=E[t].end();i++)
		{
			Push(i-&gt;first,i-&gt;second+cost.best);
			Push(i-&gt;first,i-&gt;second+cost.second);
		}			
	}
	cout&lt;&lt;dist[n-1].second&lt;&lt;endl;
}
int main()
{	
	int m,s,t,c;cin&gt;&gt;n&gt;&gt;m;
	while(m--)
	{
		scanf("%d %d %d",&amp;s,&amp;t,&amp;c);s--;t--;
		add(s,t,c);
	}
	spfa();
}</pre><pre></pre><h2>Problem1726</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
/*if I have time I should improve it*/
using namespace std;
const int maxn=5000+10,inf=~0U&gt;&gt;2;
int n,m,vs,vt;
struct Edge
{
    int t,c;
    Edge(int _t,int _c)
        :t(_t),c(_c){}
};
vector&lt;Edge&gt;E[maxn];
void AddEdge(int s,int t,int c)
{
    E[s].pb(Edge(t,c));
    E[t].pb(Edge(s,c));
}
struct Data
{
    int best,second;
    Data()
    {
        best=second=inf;
    }
    bool Update(int cost)
    {
        if(cost&gt;second)return false;
        if(cost&lt;best)
        {
            second=best;
            best=cost;
            return true;
        }
        if(cost&lt;second&amp;&amp;cost&gt;best)
            return second=cost,true;
        return false;
    }
}D[maxn];
void Input_Data()
{
    cin&gt;&gt;n&gt;&gt;m;vs=0;vt=n-1;
    int s,t,c;
    rep(i,m)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);
        AddEdge(s-1,t-1,c);
    }
}
struct Queue
{
    int Q[maxn],h,t;
    bool inQ[maxn];
    void clear()
    {
        h=t=0;memset(inQ,0,sizeof inQ);
    }
    void inc(int&amp;i)
    {
        if(++i==maxn)i=0;
    }
    void add(int x)
    {
        if(inQ[x])return;
        Q[t]=x;inQ[x]=true;
        inc(t);
    }
    int get()
    {
        int tmp=Q[h];inc(h);
        inQ[tmp]=false;
        return tmp;
    }
    bool empty()
    {
        return h==t;
    }
}Q;
void Solve()
{
    Q.clear();
    D[vs].Update(0);
    Q.add(vs);
    while(!Q.empty())
    {
        int t=Q.get();
        for(vector&lt;Edge&gt;::iterator it=E[t].begin();it!=E[t].end();it++)
        {
            if(D[it-&gt;t].Update(D[t].best+it-&gt;c)|D[it-&gt;t].Update(D[t].second+it-&gt;c))
            {
                Q.add(it-&gt;t);
            }
        }
    }
    if(D[vt].best==inf)
    {
        cout&lt;&lt;"He lose his love"&lt;&lt;endl;
    }
    else if(D[vt].second==inf)
    {
        cout&lt;&lt;"He will be cursed"&lt;&lt;endl;
    }
    else
    {
        cout&lt;&lt;D[vt].second&lt;&lt;endl;
    }
}
int main()
{
    //freopen("in","r",stdin);
    Input_Data();
    Solve();
}
</pre><pre></pre><h2>Problem1727</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=30000;
using namespace std;
typedef long long ll;
struct data
{
    int a,b;
    int NextIs(const data&amp;o)const
    {
        return max(a+o.a+o.b,a+b+o.b);
    }
    bool operator&lt;(const data&amp;o)const
    {
        return NextIs(o)&lt;o.NextIs(*this);
    }
}A[maxn];
int main()
{
    //freopen("in","r",stdin);
    int n;cin&gt;&gt;n;
    rep(i,n)
    {
        cin&gt;&gt;A[i].a&gt;&gt;A[i].b;
    }
    sort(A,A+n);ll sa=0,sb=0;
    rep(i,n)sb+=A[i].b;
    ll ans=0;
    rep(i,n)
    {
        sa+=A[i].a;
        ans=max(ans,sa+sb);
        sb-=A[i].b;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1728</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(set&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define trV(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=50000;
using namespace std;
struct UF
{
    set&lt;int&gt; node[maxn];
    int root[maxn];
    UF()
    {
        rep(i,maxn)
            root[i]=i,node[i].insert(i);
    }
    bool Union(int i,int j)
    {
        i=root[i];j=root[j];
        if(i!=j)
        {
            if(node[i].size()&lt;node[j].size())
                swap(i,j);
            tr(e,node[j])
            {
                int x=*e;
                if(node[i].find(x^1)!=node[i].end())return false;
                node[i].insert(x);root[x]=i;
            }
            node[j].clear();
        }
        return true;
    }
}U;
int n,m;
vector&lt;int&gt; E[maxn];
void AddEdge(int s,int t)
{
    if(s&lt;t)swap(s,t);
    E[s].pb(t);
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;int s;char c;
    rep(i,m)
    {
        cin&gt;&gt;s&gt;&gt;c;--s;int a=s*2+c-'A';
        cin&gt;&gt;s&gt;&gt;c;--s;int b=s*2+c-'A';
        AddEdge(a,b^1);AddEdge(b,a^1);
    }
    int ans=0;int pre=-1;
    rep(i,n)
    {
        for(int t=i*2;t&lt;i*2+2;t++)
            trV(e,E[t])if(*e&gt;pre*2+1&amp;&amp;!U.Union(t,*e))
            {
                ans++;
                pre=i;
                continue;
            }
    }
    ans++;
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1729</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
//#define DB
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int LN_MAX=100000+10;
const int S_MAX=25+10;
int N,K,S;
int Str[LN_MAX],Pet[LN_MAX];
struct Node
{
    int Less,Equ;
    Node(){}
    Node(int _Less,int _Equ):Less(_Less),Equ(_Equ){}
    bool operator==(const Node&amp;that)
    {
        return Less==that.Less&amp;&amp;Equ==that.Equ;
    }
};
struct TA
{
    int A[S_MAX],n;
    void init(int _n)
    {
        n=_n;
        memset(A,0,sizeof(int)*n);
    }
    void add(int p,int d=1)
    {
        for(p++;p&lt;=n;p+=p&amp;-p)
            A[p-1]+=d;
    }
    int sum(int p)
    {
        int ret=0;
        for(p++;p;p-=p&amp;-p)
            ret+=A[p-1];
        return ret;
    }
    Node get(int p)
    {
        return Node(sum(p-1),sum(p));
    }
};
int pi[LN_MAX];
inline void scan(int&amp;t)
{
    char c;while(c=getchar(),c&lt;'0'||c&gt;'9');
    t=c-'0';while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
}
inline void print_int(int t)
{
    static int A[20],p;p=0;
    if(!t){putchar('0');putchar('\n');return;}
    while(t)A[p++]=t%10,t/=10;
    for(int i=p-1;i&gt;=0;i--)putchar('0'+A[i]);
    putchar('\n');
}
void input_data()
{
    scan(N);scan(K);scan(S);
    rep(i,N)scan(Str[i]);
    rep(i,K)scan(Pet[i]);
}
Node Count[LN_MAX];
TA T_Mem;
void init_pi()
{
    //Calc count
    TA&amp;Pre=T_Mem;Pre.init(S+1);
    for(int i=0;i&lt;K;i++)
    {
        Count[i]=Pre.get(Pet[i]);
        //cout&lt;&lt;count[i]&lt;&lt;" ";
        Pre.add(Pet[i]);
    }
    //Calc pi
    TA&amp;Cur=T_Mem;
    pi[0]=-1;Cur.init(S+1);
    int l=0,r=-1,t;
    #define add_line(l,r,d) {for(int p=l;p&lt;=r;p++)Cur.add(Pet[p],d);}
    #define move_to(nl,nr){add_line(r+1,nr,1);add_line(l,nl-1,-1);l=nl;r=nr;}
    for(int i=1;i&lt;K;i++)
    {
        for(t=pi[i-1];t!=-1;)
        {
            move_to(i-t-1,i-1);
            if(Count[t+1]==Cur.get(Pet[i])){t++;break;}
            t=pi[t];
        }
        if(t==-1)t=0;pi[i]=t;
    }
    #undef add_line
    #undef move_to
    #ifdef DB
        rep(i,K)cout&lt;&lt;pi[i]&lt;&lt;" ";
        cout&lt;&lt;endl;
    #endif
}
void calc_kmp()
{
    TA&amp;Cur=T_Mem;Cur.init(S+1);
    int l=0,r=-1,t=-1;
    #define add_line(l,r,d) {for(int p=l;p&lt;=r;p++)Cur.add(Str[p],d);}
    #define move_to(nl,nr){add_line(r+1,nr,1);add_line(l,nl-1,-1);l=nl;r=nr;}
    static int Ans[LN_MAX];int cAns=0;
    rep(i,N)
    {
        //cout&lt;&lt;t&lt;&lt;endl;
        while(t!=-1)
        {
            move_to(i-t-1,i-1);
            if(Count[t+1]==Cur.get(Str[i])){t++;break;}
            t=pi[t];
        }
        if(t==-1)t=0;
        if(t==K-1)
        {
            Ans[cAns++]=i-K+2;
            t=pi[t];
        }
    }
    #undef add_line
    #undef move_to
    #ifdef DB
    rep(p,K)
        printf("%d ",Pet[p]);
    puts("");
    #endif DB
    print_int(cAns);
    rep(i,cAns)
    {
        int t=Ans[i];
        #ifdef DB
        puts("First:");
        #endif DB
        print_int(t);
        #ifdef DB
        --t;
        rep(p,K)
            printf("%d ",Str[t+p]);
        puts("");
        #endif DB
    }
}
int main()
{
    //freopen("in","r",stdin);
    input_data();
    init_pi();
    calc_kmp();
}
</pre><pre></pre><h2>Problem1734</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=100000;int N,C,X[maxn];
bool Can(int limit)
{
	int old=0,now=1;
	for(int i=1;i&lt;C;i++)
	{
		while(X[now]-X[old]&lt;limit&amp;&amp;now&lt;N)
			now++;
		if(now&gt;=N)
			return false;
		old=now;now++;
	}
	return true;
}
void solve();
int main()
{
		solve();
}
void solve()
{
	cin&gt;&gt;N&gt;&gt;C;
	for(int i=0;i&lt;N;i++)
		scanf("%d",X+i);
	sort(X,X+N);
	int l=1,r=X[N-1];
	while(l+1&lt;r)
	{
		int mid=(l+r)/2;
		if(Can(mid))
			l=mid;
		else
			r=mid;
	}
	cout&lt;&lt;l&lt;&lt;endl;
}</pre><pre></pre><h2>Problem1739</h2><pre>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxh=40000+100,maxk=400;
struct node
{
	int h,c,a;
	bool operator&lt;(const node&amp;x) const
	{return a&lt;x.a;}
}A[maxk];
bool Can[maxh]={0};
int main()
{
	int K;cin&gt;&gt;K;
	for(int i=0;i&lt;K;i++)
		cin&gt;&gt;A[i].h&gt;&gt;A[i].a&gt;&gt;A[i].c;
	sort(A,A+K);Can[0]=true;int hh=0;
	for(int i=0;i&lt;K;i++)
	{
		int h=A[i].h,a=A[i].a,c=A[i].c,limit=h*c;
		for(int j=a;j&gt;=0;j--) if(!Can[j])
		{
			for(int k=h;k&lt;=limit&amp;&amp;j-k&gt;=0;k+=h)
				if(Can[j-k]) {Can[j]=true;break;}
		}
	}
	for(int j=maxh-1;j&gt;=0;j--) 
	if(Can[j]){cout&lt;&lt;j&lt;&lt;endl;return 0;}	
}</pre><pre></pre><h2>Problem1740</h2><pre>#include&lt;iostream&gt;
using namespace std;
const int inf=~0U&gt;&gt;2;
int main()
{
	int c,y,s,n;
	cin&gt;&gt;n&gt;&gt;s;	
	long long ans=0;int cost=inf;	
	for(int i=0;i&lt;n;i++)
	{
		cin&gt;&gt;c&gt;&gt;y;
		cost=min(cost+s,c);
		ans+=cost*y;
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem1741</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
const int maxn=500;
bool E[maxn][maxn]={};
int Link[maxn],n,k;
bool Vis[maxn];
bool dfs(int x)
{
    if(Vis[x])return false;
    Vis[x]=true;
    rep(i,n)if(E[x][i])
        if(Link[i]==-1||dfs(Link[i]))
            return Link[i]=x,true;
    return false;
}
int main()
{
    cin&gt;&gt;n&gt;&gt;k;int x,y;
    rep(i,k)
    {
        cin&gt;&gt;x&gt;&gt;y;
        E[--x][--y]=true;
    }
    int ans=0;memset(Link,-1,sizeof Link);
    rep(i,n)
    {
        memset(Vis,0,sizeof Vis);
        if(dfs(i))ans++;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1748</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1,maxn=5000,maxs=100000;
using namespace std;
struct State
{
    int x,p,c;
    State(){}
    State(int _x,int _p,int _c):x(_x),p(_p),c(_c){}
};
struct Queue
{
    State Q[maxs];
    int h,t;
    void inc(int&amp;x){if(++x==maxs)x=0;}
    Queue():h(0),t(0){}
    void add(State s)
    {
        Q[t]=s;inc(t);
    }
    State get()
    {
        State tmp=Q[h];inc(h);
        return tmp;
    }
    bool empty(){return h==t;}
}Q;
struct Edge
{
    int t;
    Edge*next;
    Edge(int _t,Edge*_next):t(_t),next(_next){}
}*E[maxn]={};
void InsEdge(int s,int t)
{
    E[s]=new Edge(t,E[s]);
    E[t]=new Edge(s,E[t]);
}
int X[maxn],n,m;
set&lt;int&gt; Mem[maxn];
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d",&amp;n,&amp;m);rep(i,n)scanf("%d",X+i);int s,t;
    rep(i,m)
    {
        scanf("%d%d",&amp;s,&amp;t);--s;--t;InsEdge(s,t);
    }
    Q.add(State(X[0],0,0));Mem[0].insert(X[0]);
    while(!Q.empty())
    {
        State s=Q.get();
        for(Edge*e=E[s.p];e;e=e-&gt;next)
        {
            int j=e-&gt;t,dist=X[j]-X[s.p];
            if(dist&gt;180)dist-=360;else if(dist&lt;-180)dist+=360;
            if(Mem[j].find(s.x+dist)==Mem[j].end())
            {
                if(!j){cout&lt;&lt;s.c+1&lt;&lt;endl;return 0;}
                Mem[j].insert(s.x+dist);
                Q.add(State(s.x+dist,j,s.c+1));
            }
        }
    }
    cout&lt;&lt;-1&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1756</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=500000;
int A[maxn];
struct info
{
    int L,R,M,S;
    info(int x=0):L(x),R(x),M(x),S(x){}
}none;
info operator+(const info&amp;l,const info&amp;r)
{
    info f;if(l.M==-inf)return r;
    if(r.M==-inf)return l;
    f.L=max(l.L,l.S+r.L);
    f.R=max(r.R,r.S+l.R);
    f.S=l.S+r.S;
    f.M=max(l.M,r.M);
    f.M=max(f.M,l.R+r.L);
    return f;
}
info T[maxn*3];
inline void set(int t,int x)
{
    T[t]=info(x);
}
void build(int t,int l,int r)
{
    if(l+1==r) {set(t,A[l]);return;}
    build(t*2,l,(l+r)/2);
    build(t*2+1,(l+r)/2,r);
    T[t]=T[t*2]+T[t*2+1];
}
void change(int t,int l,int r,int p,int s)
{
    if(l+1==r){set(t,s);return;}
    if(p&lt;(l+r)/2) change(t*2,l,(l+r)/2,p,s);
    else change(t*2+1,(l+r)/2,r,p,s);
    T[t]=T[t*2]+T[t*2+1];
}
info ask(int t,int l,int r,int a,int b)
{
    if(b&lt;=l||a&gt;=r) return none;
    if(l&gt;=a&amp;&amp;r&lt;=b) return T[t];
    return ask(t*2,l,(l+r)/2,a,b)+ask(t*2+1,(l+r)/2,r,a,b);
}
int main()
{
    //freopen("in","r",stdin);
    none.M=-inf;
    int n,m,a,b,c;scanf("%d %d",&amp;n,&amp;m);
    rep(i,n)scanf("%d",A+i);
    build(1,0,n);
    while(m--)
    {
        scanf("%d %d %d",&amp;a,&amp;b,&amp;c);
        if(a==1) {if(b&gt;c)swap(b,c);printf("%d\n",ask(1,0,n,b-1,c).M);}
        else change(1,0,n,b-1,c);
    }
}
</pre><pre></pre><h2>Problem1756</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define OK puts("OK")
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=500000;
struct info
{
    int L,R,M,S;
    info(int x=-inf):L(x),R(x),M(x),S(x){}
};
info operator+(const info&amp;l,const info&amp;r)
{
    info f;if(l.M==-inf)return r;
    if(r.M==-inf)return l;
    f.L=max(l.L,l.S+r.L);
    f.R=max(r.R,r.S+l.R);
    f.S=l.S+r.S;
    f.M=max(l.M,r.M);
    f.M=max(f.M,l.R+r.L);
    return f;
}
info A[1&lt;&lt;20];
int main()
{
    //freopen("in","r",stdin);
    int n,m,q,a,b,c;scanf("%d %d",&amp;n,&amp;q);
    m=1;while(m&lt;=n+3)m&lt;&lt;=1;
    rep(i,n)scanf("%d",&amp;c),A[i+1+m]=info(c);
    for(int i=m-1;i&gt;=1;i--)A[i]=A[i*2]+A[i*2+1];
    rep(i,q)
    {
        scanf("%d%d%d",&amp;c,&amp;a,&amp;b);
        if(c==1)
        {
            info L,R;if(a&gt;b)swap(a,b);
            for(a+=m-1,b+=m+1;a^b^1;a&gt;&gt;=1,b&gt;&gt;=1)
            {
                if(~a&amp;1)L=L+A[a^1];
                if(b&amp;1)R=A[b^1]+R;
            }
            printf("%d\n",(L+R).M);
        }
        else
        {
            for(A[a+=m]=info(b),a&gt;&gt;=1;a;a&gt;&gt;=1)
                A[a]=A[a*2]+A[a*2+1];
        }
    }
}
</pre><pre></pre><h2>Problem1756</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define OK puts("OK")
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=500000;
struct info
{
    int L,R,M,S;
    info(int x=-inf):L(x),R(x),M(x),S(x){}
};
inline int Max(int a,int b)
{
    int m=(a-b)&gt;&gt;31;
    return b&amp;m|a&amp;~m;
}
info operator+(const info&amp;l,const info&amp;r)
{
    info f;if(l.M==-inf)return r;
    if(r.M==-inf)return l;
    f.L=Max(l.L,l.S+r.L);
    f.R=Max(r.R,r.S+l.R);
    f.S=l.S+r.S;
    f.M=Max(l.M,r.M);
    f.M=Max(f.M,l.R+r.L);
    return f;
}
info A[1&lt;&lt;20];
int main()
{
    //freopen("in","r",stdin);
    int n,m,q,a,b,c;scanf("%d %d",&amp;n,&amp;q);
    m=1;while(m&lt;=n+3)m&lt;&lt;=1;
    rep(i,n)scanf("%d",&amp;c),A[i+1+m]=info(c);
    for(int i=m-1;i&gt;=1;i--)A[i]=A[i*2]+A[i*2+1];
    rep(i,q)
    {
        scanf("%d%d%d",&amp;c,&amp;a,&amp;b);
        if(c==1)
        {
            info L,R;if(a&gt;b)swap(a,b);
            for(a+=m-1,b+=m+1;a^b^1;a&gt;&gt;=1,b&gt;&gt;=1)
            {
                if(~a&amp;1)L=L+A[a^1];
                if(b&amp;1)R=A[b^1]+R;
            }
            printf("%d\n",(L+R).M);
        }
        else
        {
            for(A[a+=m]=info(b),a&gt;&gt;=1;a;a&gt;&gt;=1)
                A[a]=A[a*2]+A[a*2+1];
        }
    }
}
</pre><pre></pre><h2>Problem1756</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define OK puts("OK")
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=500000;
struct info
{
    int L,R,M,S;
    info(int x=-inf):L(x),R(x),M(x),S(x){}
};
inline int Max(int a,int b)
{
    int m=(a-b)&gt;&gt;31;
    return b&amp;m|a&amp;~m;
}
info operator+(const info&amp;l,const info&amp;r)
{
    info f;if(l.M==-inf)return r;
    if(r.M==-inf)return l;
    f.L=Max(l.L,l.S+r.L);
    f.R=Max(r.R,r.S+l.R);
    f.S=l.S+r.S;
    f.M=Max(l.M,r.M);
    f.M=Max(f.M,l.R+r.L);
    return f;
}
info A[1&lt;&lt;20];
int nextInt()
{
    char c;c=getchar();
    while(c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9'))c=getchar();
    int n=0,s=1;if(c=='-')s=-1,c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')n*=10,n+=c-'0',c=getchar();
    return n*s;
}
int main()
{
    //freopen("in","r",stdin);
    int n,m,q,a,b,c;scanf("%d %d",&amp;n,&amp;q);
    m=1;while(m&lt;=n+3)m&lt;&lt;=1;
    rep(i,n)c=nextInt(),A[i+1+m]=info(c);
    for(int i=m-1;i&gt;=1;i--)A[i]=A[i*2]+A[i*2+1];
    rep(i,q)
    {
        c=nextInt();a=nextInt();b=nextInt();
        if(c==1)
        {
            info L,R;if(a&gt;b)swap(a,b);
            for(a+=m-1,b+=m+1;a^b^1;a&gt;&gt;=1,b&gt;&gt;=1)
            {
                if(~a&amp;1)L=L+A[a^1];
                if(b&amp;1)R=A[b^1]+R;
            }
            printf("%d\n",(L+R).M);
        }
        else
        {
            for(A[a+=m]=info(b),a&gt;&gt;=1;a;a&gt;&gt;=1)
                A[a]=A[a*2]+A[a*2+1];
        }
    }
}
</pre><pre></pre><h2>Problem1758</h2><pre>/*
 * [Wc2010]重建计划.cpp
 *
 *  Created on: 2011-1-14
 *      Author: wjmzbmr
 */
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
using namespace std;
const int MAX_VERTEX=100000+100;
const double INF=1e30;
const double MAX_ANS=1000000;
struct Tree{
	static const int MAX_EDGE=MAX_VERTEX*2;
	int head[MAX_VERTEX];
	int next[MAX_EDGE],dest[MAX_EDGE],length[MAX_EDGE];
	bool exist[MAX_EDGE];

	int nVets,nEdges;

	void initSize(int _nVets){
		nVets=_nVets;
		memset(head,-1,sizeof(int)*nVets);
		nEdges=0;
	}

	void makeEdge(int s,int t,int c){
		int id=nEdges++;
		dest[id]=t;length[id]=c;next[id]=head[s];
		exist[id]=true;
		head[s]=id;
	}

	void addEdge(int s,int t,int c){
		makeEdge(s,t,c);
		makeEdge(t,s,c);
	}
};

Tree tree;
#define forEdge(e,u) for(int e=tree.head[u];e!=-1;e=tree.next[e])\
	if(tree.exist[e])

int pathLenMax,pathLenMin;

void inputTree(){
	int nVets;
	scanf("%d",&amp;nVets);
	scanf("%d%d",&amp;pathLenMin,&amp;pathLenMax);

	tree.initSize(nVets);
	int s,t,c;
	for(int edgeId=0;edgeId&lt;nVets-1;edgeId++){
		scanf("%d%d%d",&amp;s,&amp;t,&amp;c);
		--s;--t;
		tree.addEdge(s,t,c);
	}
}

int bfsOrd[MAX_VERTEX],subSize;
int prevEdge[MAX_VERTEX];
inline int father(int u){
	if(prevEdge[u]==-1)
		return -1;
	return tree.dest[prevEdge[u]^1];
}

void bfs(int vs){
	int*que=bfsOrd;
	int h=0,t=0;

	que[t++]=vs;prevEdge[vs]=-1;
	for(;h&lt;t;h++){
		int u=que[h];
		forEdge(e,u){
			int v=tree.dest[e];
			if(e!=(prevEdge[u]^1)){
				que[t++]=v;
				prevEdge[v]=e;
			}
		}
	}

	subSize=t;
}

int size[MAX_VERTEX];
void calcSize(){
	for(int cur=subSize-1;cur&gt;=0;cur--){
		int u=bfsOrd[cur];
		size[u]=1;

		forEdge(e,u){
			int v=tree.dest[e];
			if(e!=(prevEdge[u]^1)){
				size[u]+=size[v];
			}
		}
	}
}

int findSplitVertex(int subRoot){
	bfs(subRoot);
	calcSize();

	int best,bestOpt=MAX_VERTEX;

	for(int i=0;i&lt;subSize;i++){
		int u=bfsOrd[i];
		int tmp=size[subRoot]-size[u];

		forEdge(e,u){
			int v=tree.dest[e];
			if(e!=(prevEdge[u]^1)){
				if(size[v]&gt;tmp)
					tmp=size[v];
			}
		}

		if(tmp&lt;bestOpt){
			bestOpt=tmp;
			best=u;
		}
	}

	return best;//best and its father
}

struct Memory{
	double mem[MAX_VERTEX*2+10000];
	double*cur;

	void clear(){
		cur=mem;
	}

	double*New(int size){
		cur+=size;
		return cur-size;
	}
};

Memory mem;
struct Array{
	double*a;
	int n;

	void initSize(int _n){
		n=_n;
		a=mem.New(n);
		for(register int i=0;i&lt;n;i++)
			a[i]=0;
	}

	double&amp;operator[](int at){return a[at];}
	double operator[](int at) const{return a[at];}
};

Array valSets[MAX_VERTEX],distSets[MAX_VERTEX];
double dist[MAX_VERTEX];
int dep[MAX_VERTEX];

void getdistSet(Array&amp;distSet,int edgeFromRoot){
	int subRoot=tree.dest[edgeFromRoot];
	bfs(subRoot);
	dist[subRoot]=tree.length[edgeFromRoot];dep[subRoot]=1;

	int maxDep=dep[subRoot];

	for(int cur=1;cur&lt;subSize;cur++){
		int u=bfsOrd[cur];
		int fa=father(u);
		dep[u]=dep[fa]+1;
		dist[u]=dist[fa]+tree.length[prevEdge[u]];
		if(dep[u]&gt;maxDep)
			maxDep=dep[u];
	}

	distSet.initSize(maxDep+1);
	for(int cur=0;cur&lt;subSize;cur++){
		int u=bfsOrd[cur];
		if(dist[u]&gt;distSet[dep[u]])
			distSet[dep[u]]=dist[u];
	}
}

double curAlpha;
void getValSet(Array&amp;valSet,const Array&amp;distSet){
	for(int dep=0;dep&lt;distSet.n;dep++){
		valSet[dep]=distSet[dep]-dep*curAlpha;
	}
}

int ordBySize[MAX_VERTEX];
int nChilds=0;
bool cmpBySize(int a,int b){
	return valSets[a].n&lt;valSets[b].n;
}

double getMax(const Array&amp;a,const Array&amp;b){
	static int que[MAX_VERTEX];
	int h=0,t=0;

	#define addQue(dep) {\
		while(h&lt;t&amp;&amp;a[que[t-1]]&lt;a[dep])\
			t--;\
		que[t++]=dep;\
	}

	for(int insDep=pathLenMin;insDep&lt;a.n&amp;&amp;insDep&lt;pathLenMax;insDep++){
		addQue(insDep);
	}

	double Max=-INF;

	for(int bDep=0;bDep&lt;b.n;bDep++){
		while(h&lt;t&amp;&amp;que[h]+bDep&gt;pathLenMax)
			h++;
		int insDep=pathLenMin-bDep;
		if(insDep&lt;a.n&amp;&amp;insDep&gt;=0)
			addQue(insDep);
		if(h&lt;t){
			double tmp=b[bDep]+a[que[h]];
			if(bDep+que[h]&gt;0){
				tmp/=bDep+que[h];
				tmp+=curAlpha;
				if(tmp&gt;Max)
					Max=tmp;
			}
		}
	}
	return Max;
}

void mergeValSet(Array&amp;a,Array&amp;b){//add b into a
	for(int bDep=0;bDep&lt;b.n;bDep++){
		if(b[bDep]&gt;a[bDep])
			a[bDep]=b[bDep];
	}
}

Array emptySet;

double getMaxAlpha(double alpha){
	curAlpha=alpha;
	for(int cur=0;cur&lt;nChilds;cur++)
		getValSet(valSets[cur],distSets[cur]);

	double Max=0;

	Max=getMax(emptySet,valSets[ordBySize[0]]);
	for(int curOrd=1;curOrd&lt;nChilds;curOrd++){
		int cur=ordBySize[curOrd];
		int prev=ordBySize[curOrd-1];
		double tmp=getMax(valSets[prev],valSets[cur]);
		if(tmp&gt;Max)
			Max=tmp;
		mergeValSet(valSets[cur],valSets[prev]);
	}
	return Max;
}

double globalAns=0;

void splitSubTree(int subRoot){
	int splitVertex=findSplitVertex(subRoot);
	if(subSize==1)
		return;

	nChilds=0;mem.clear();
	forEdge(e,splitVertex){
		tree.exist[e^1]=false;
		getdistSet(distSets[nChilds],e);
		valSets[nChilds].initSize(distSets[nChilds].n);
		ordBySize[nChilds]=nChilds;
		nChilds++;
	}

	sort(ordBySize,ordBySize+nChilds,cmpBySize);
	emptySet.initSize(1);
	double cur=0,prev=INF;
	while(fabs(cur-prev)&gt;1e-3){
		prev=cur;
		cur=getMaxAlpha(prev);
	}

	double res=(cur+prev)/2;
	if(res&gt;globalAns)
		globalAns=res;

	forEdge(e,splitVertex){
		int v=tree.dest[e];
		splitSubTree(v);
	}
}

void solve(){
	splitSubTree(0);
	printf("%0.3lf\n",globalAns);
}

int main(){
//	freopen("in","r",stdin);
	inputTree();
	solve();
}
</pre><pre></pre><h2>Problem1760</h2><pre>/*
 *  [Baltic2009]Triangulation.cpp
 *
 *  Created on: 2011-5-25
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VERTICES = 100000 + 10;

struct Vertex {
	vector&lt;Vertex*&gt; adj;
	Vertex*father;
	Vertex*top;
	Vertex() {
		top = this;
		father = 0;
	}
	Vertex*find() {
		if (this == top)
			return this;
		return top = top-&gt;find();
	}
	int depth;
	void dfs(int _depth) {
		depth = _depth;
		foreach(iter,adj) {
			Vertex*v = *iter;
			if (v != father) {
				v-&gt;father = this;
				v-&gt;dfs(depth + 1);
			}
		}
	}
};

Vertex vertices[MAX_N_VERTICES];
int nVertices;
int nTriangles;

typedef pair&lt;int, int&gt; ipair;

map&lt;ipair, Vertex*&gt; edgeToVertex;

vector&lt;Vertex*&gt; byColor[MAX_N_VERTICES];

void buildEdge(Vertex*u, Vertex*v) {
	u-&gt;adj.push_back(v);
	v-&gt;adj.push_back(u);
}

void addEdge(int a, int b, Vertex*tri) {
	if (a &gt; b)
		swap(a, b);
	ipair key(a, b);
	if (edgeToVertex.count(key)) {
		Vertex*t2 = edgeToVertex[key];
		buildEdge(tri, t2);
	} else {
		edgeToVertex[key] = tri;
	}
}

void readInput() {
	scanf("%d", &amp;nVertices);
	nTriangles = nVertices - 2;
	for (int i = 0; i &lt; nTriangles; ++i) {
		int a, b, c, d;
		scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d);
		Vertex*u = vertices + i;
		addEdge(a, b, u);
		addEdge(b, c, u);
		addEdge(a, c, u);
		byColor[d].push_back(u);
	}
}

int ans;

void mark(Vertex*u, Vertex*v) {
	u = u-&gt;find();
	v = v-&gt;find();
	while (u != v) {
		if (u-&gt;depth &lt; v-&gt;depth)
			swap(u, v);
		if (u-&gt;father == 0)
			break;
		--ans;
		u-&gt;top = u-&gt;father;
		u = u-&gt;find();
	}
}

void work() {
	vertices[0].dfs(0);
	ans = nTriangles - 1;
	for (int color = 1; color &lt;= nVertices; ++color) {
		vector&lt;Vertex*&gt;&amp;cur = byColor[color];
		if (cur.empty())
			continue;
		for (int i = 0; i &lt; cur.size() - 1; ++i) {
			mark(cur[i], cur[i + 1]);
		}
	}
	printf("%d\n", ans);
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem1761</h2><pre>/*
 *  [Baltic2009]beetle.cpp
 *
 *  Created on: 2011-5-25
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 300 + 10;
int dp[2][MAX_N][MAX_N][2];
int x[MAX_N], n, m;
const int INF = 0x7f7f7f7f;

const int LEFT = 0, RIGHT = 1;

int main() {
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; x[i];
	}
	x[n++] = 0;
	sort(x, x + n);
	int start = lower_bound(x, x + n, 0) - x;
	int(*am)[MAX_N][2] = dp[0];
	int(*nam)[MAX_N][2] = dp[1];
	memset(am, 0x7f, sizeof dp[0]);
	for (int rcnt = 0; rcnt &lt; n; ++rcnt) {
		am[start][rcnt][LEFT] = 0;
	}

	int ans = 0;

	for (int len = 0; len &lt; n; ++len) {
		memset(nam, 0x7f, sizeof dp[0]);
		for (int l = 0; l + len &lt; n; ++l) {
			int r = l + len;
			for (int rcnt = 0; rcnt &lt; n; ++rcnt) {
				int&amp;amL = am[l][rcnt][LEFT];
				int&amp;amR = am[l][rcnt][RIGHT];
				if (amL == INF &amp;&amp; amR == INF)
					continue;
				int travelCost = (x[r] - x[l]) * rcnt;

				amL = min(amL, amR + travelCost);
				amR = min(amR, amL + travelCost);

				if (rcnt == 0) {
					int tmp = min(amL, amR);
					int eaten = r - l;
					ans = max(ans, eaten * m - tmp);
					continue;
				}

				if (l &gt; 0) {
					nam[l - 1][rcnt - 1][LEFT] = min(
							nam[l - 1][rcnt - 1][LEFT], amL + (x[l] - x[l - 1])
									* rcnt);
				}

				if (r + 1 &lt; n) {
					nam[l][rcnt - 1][RIGHT] = min(nam[l][rcnt - 1][RIGHT], amR
							+ (x[r + 1] - x[r]) * rcnt);
				}
			}
		}
		swap(am, nam);
	}

	printf("%d\n", ans);
}
</pre><pre></pre><h2>Problem1764</h2><pre>/*
 * [Baltic2009]monument.cpp
 *
 *  Created on: 2011-3-27
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

int nX, nY, nZ;
const int MAX_N = 150 + 10;

bool what[MAX_N][MAX_N][MAX_N];

bool nWhat[MAX_N][MAX_N][MAX_N];

void swapXY() {
	for (int x = 0; x &lt; nX; ++x) {
		for (int y = 0; y &lt; nY; ++y) {
			for (int z = 0; z &lt; nZ; ++z) {
				nWhat[y][x][z] = what[x][y][z];
			}
		}
	}
	memcpy(what, nWhat, sizeof what);
	swap(nX, nY);
}

void swapXZ() {
	for (int x = 0; x &lt; nX; ++x) {
		for (int y = 0; y &lt; nY; ++y) {
			for (int z = 0; z &lt; nZ; ++z) {
				nWhat[z][y][x] = what[x][y][z];
			}
		}
	}
	memcpy(what, nWhat, sizeof what);
	swap(nX, nZ);
}

int extend[MAX_N][MAX_N][MAX_N];

int sum[MAX_N][MAX_N];

void prepareSum(bool what[MAX_N][MAX_N], int nY, int nZ) {
	memset(sum, 0, sizeof sum);
	for (int y = 0; y &lt; nY; ++y) {
		for (int z = 0; z &lt; nZ; ++z) {
			sum[y + 1][z + 1] = sum[y][z + 1] + sum[y + 1][z] - sum[y][z]
					+ what[y][z];
		}
	}
}

int getSum(int ly, int lz, int ry, int rz) {
	return sum[ry][rz] - sum[ly][rz] - sum[ry][lz] + sum[ly][lz];
}

void calcExtend(bool what[MAX_N][MAX_N], int nY, int nZ,
		int extend[MAX_N][MAX_N]) {
	prepareSum(what, nY, nZ);
	for (int y = 0; y &lt; nY; ++y) {
		for (int z = 0; z &lt; nZ; ++z) {
			if (!what[y][z])
				extend[y][z] = 0;
			else {
				int cur = 1;
				if (y &gt; 0 &amp;&amp; z &gt; 0)
					cur = extend[y - 1][z - 1] - 1;
				if (cur &lt; 1)
					cur = 1;

				while (y + cur &lt;= nY &amp;&amp; z + cur &lt;= nZ) {
					int cnt = getSum(y, z, y + cur, z + cur);
					if (cnt == cur * cur)
						++cur;
					else {
						break;
					}
				}

				--cur;
				extend[y][z] = cur;
			}
		}
	}
}

int ans = 0;

void doit(int seq[], int n) {
	//1..n
	seq[0] = -1;
	seq[n + 1] = -1;

	static int prev[MAX_N], next[MAX_N];

	for (int i = 1; i &lt;= n; ++i) {
		int at = i - 1;
		while (seq[at] &gt;= seq[i])
			at = prev[at];
		prev[i] = at;
	}

	for (int i = n; i &gt;= 1; --i) {
		int at = i + 1;
		while (seq[at] &gt;= seq[i])
			at = next[at];
		next[i] = at;
	}

	for (int whereMin = 1; whereMin &lt;= n; ++whereMin) {
		int left = prev[whereMin] + 1;
		int right = next[whereMin] - 1;

		int cnt = right - left + 1;
		int tmp = cnt * seq[whereMin];

		if (tmp &gt; ans)
			ans = tmp;
	}
}

void prepareExtend() {
	for (int x = 0; x &lt; nX; ++x) {
		calcExtend(what[x], nY, nZ, extend[x]);
	}
}

void calc() {
	static int seq[MAX_N];
	prepareExtend();

	for (int y = 0; y &lt; nY; ++y) {
		for (int z = 0; z &lt; nZ; ++z) {
			for (int x = 0; x &lt; nX; ++x) {
				seq[x + 1] = extend[x][y][z];
			}
			doit(seq, nX);
		}
	}
}

void work() {

	//X,Y,Z
	calc();

	swapXY();
	//Y,X,Z
	calc();

	//Z,X,Y
	swapXZ();
	calc();

	printf("%d", ans * 4);
}

void inputData() {
	scanf("%d%d%d", &amp;nX, &amp;nY, &amp;nZ);
	for (int y = 0; y &lt; nY; ++y) {
		for (int x = 0; x &lt; nX; ++x) {
			for (int z = 0; z &lt; nZ; ++z) {
				char ch;
				while (ch = getchar(), ch != 'P' &amp;&amp; ch != 'N')
					;
				what[x][y][z] = ch == 'N';
			}
		}
	}
}

void solve() {
	inputData();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem1765</h2><pre>/*
 *  [Baltic2009]rectangle.cpp
 *
 *  Created on: 2011-5-25
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

typedef long long int64;

struct Point {
	int x, y;
	void read() {
		scanf("%lld%lld", &amp;x, &amp;y);
		x *= 2;
		y *= 2;
	}
	Point() {
	}
	Point(int _x, int _y) :
		x(_x), y(_y) {
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	bool operator&lt;(const Point&amp;p) const {
		return x == p.x ? y &lt; p.y : x &lt; p.x;
	}
	Point operator/(int d) const {
		return Point(x / d, y / d);
	}
	int64 dist2To(const Point&amp;p) const {
		int64 dx = x - p.x, dy = y - p.y;
		return dx * dx + dy * dy;
	}
	int64 det(const Point&amp;p) const {
		return 1LL * x * p.y - 1LL * y * p.x;
	}
	int64 dot(const Point&amp;p) const {
		return 1LL * x * p.x + 1LL * y * p.y;
	}
};

const int MAX_N_POINTS = 1500 + 10;
int nPoints;
Point points[MAX_N_POINTS];

struct PointPair {
	Point mid;
	int64 len;
	int aId, bId;
	PointPair() {
	}
	PointPair(int aId, int bId) {
		this-&gt;aId = aId;
		this-&gt;bId = bId;
		Point a = points[aId], b = points[bId];
		mid = (a + b) / 2;
		len = a.dist2To(b);
	}
	bool operator&lt;(const PointPair&amp;p) const {
		return len == p.len ? mid &lt; p.mid : len &lt; p.len;
	}
	bool operator==(const PointPair&amp;p) const {
		return len == p.len &amp;&amp; mid.x == p.mid.x &amp;&amp; mid.y == p.mid.y;
	}
};

int nPairs;
PointPair pairs[MAX_N_POINTS * MAX_N_POINTS / 2];

void readInput() {
	scanf("%d", &amp;nPoints);
	for (int i = 0; i &lt; nPoints; ++i) {
		points[i].read();
	}
}

bool cmpByAngle(const Point&amp;a, const Point&amp;b) {
	return a.det(b) &gt; 0;
}

void work() {
	nPairs = 0;
	for (int i = 0; i &lt; nPoints; ++i) {
		for (int j = 0; j &lt; i; ++j) {
			pairs[nPairs++] = PointPair(i, j);
		}
	}

	int64 ans = 0;
	sort(pairs, pairs + nPairs);
	for (int i = 0; i &lt; nPairs;) {
		int last = i;
		while (last &lt; nPairs &amp;&amp; pairs[last] == pairs[i])
			++last;
		Point mid = pairs[i].mid;
		static Point ps[MAX_N_POINTS * MAX_N_POINTS];
		int cnt = 0;
		for (int j = i; j &lt; last; ++j) {
			{
				int id = pairs[j].aId;
				Point p = points[id] - mid;
				if (p.y &gt; 0 || (p.y == 0 &amp;&amp; p.x &gt; 0))
					ps[cnt++] = p;
			}
			{
				int id = pairs[j].bId;
				Point p = points[id] - mid;
				if (p.y &gt; 0 || (p.y == 0 &amp;&amp; p.x &gt; 0))
					ps[cnt++] = p;
			}
		}
		sort(ps, ps + cnt, cmpByAngle);
		//		cout &lt;&lt; "--------------" &lt;&lt; endl;
		//		for (int i = 0; i &lt; cnt; ++i) {
		//			cout &lt;&lt; ps[i].x &lt;&lt; " " &lt;&lt; ps[i].y &lt;&lt; endl;
		//		}

		int r = 0;
		for (int l = 0; l &lt; cnt; ++l) {
			while (r + 1 &lt; cnt &amp;&amp; ps[l].dot(ps[r + 1]) &gt;= 0)
				++r;
			ans = max(ans, ps[l].det(ps[r]) * 2);
			if (r + 1 &lt; cnt)
				ans = max(ans, ps[l].det(ps[r + 1]) * 2);
		}

		i = last;
	}

	cout &lt;&lt; ans / 4 &lt;&lt; endl;
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem1766</h2><pre>/*
 * [Ceoi2009]photo.cpp
 *
 *  Created on: 2011-4-4
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

int nPoints, maxArea;
const int MAX_N_POINTS = 100 + 10;

struct Point {
	int x, y;
	void read() {
		scanf("%d%d", &amp;x, &amp;y);
	}
	bool operator&lt;(const Point&amp;p) const {
		return x &lt; p.x;
	}
};

Point ps[MAX_N_POINTS];

int ys[MAX_N_POINTS];

void inputData() {
	cin &gt;&gt; nPoints &gt;&gt; maxArea;
	for (int i = 0; i &lt; nPoints; ++i) {
		ps[i].read();
	}
}

void prepare() {
	for (int i = 0; i &lt; nPoints; ++i) {
		ys[i] = ps[i].y;
	}
	sort(ys, ys + nPoints);
	for (int i = 0; i &lt; nPoints; ++i) {
		ps[i].y = lower_bound(ys, ys + nPoints, ps[i].y) - ys;
	}
	sort(ps, ps + nPoints);
}

int memo[MAX_N_POINTS][MAX_N_POINTS][MAX_N_POINTS];

int rec(int left, int right, int cover) {
	if (left &gt; right)
		return 0;
	if (ps[left].y &lt;= cover)
		return rec(left + 1, right, cover);
	if (ps[right].y &lt;= cover)
		return rec(left, right - 1, cover);
	int&amp;ret = memo[left][right][cover + 1];
	if (ret != -1)
		return ret;
	ret = INT_MAX;
	for (int split = left; split &lt; right; ++split) {
		int tmp = rec(left, split, cover) + rec(split + 1, right, cover);
		if (tmp &lt; ret)
			ret = tmp;
	}
	int maxY = -1;
	int len = ps[right].x - ps[left].x;
	while (maxY + 1 &lt; nPoints &amp;&amp; ys[maxY + 1] * len &lt;= maxArea)
		++maxY;
	if (maxY &gt; cover) {
		int tmp = rec(left, right, maxY) + 1;
		if (tmp &lt; ret)
			ret = tmp;
	}

	return ret;
}

void work() {
	prepare();
	memset(memo, -1, sizeof memo);
	printf("%d\n", rec(0, nPoints - 1, -1));
}

int main() {
	inputData();
	work();
}
</pre><pre></pre><h2>Problem1767</h2><pre>/*
 * [Ceoi2009]harbingers.cpp
 *
 *  Created on: 2011-4-4
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

typedef long long int64;

struct Line {
	int64 f, d;//f-d*x
	int64 calc(int64 x) {
		return f - d * x;
	}
};

double isLL(const Line&amp;l1, const Line&amp;l2) {
	return 1.0 * (l1.f - l2.f) / (l1.d - l2.d);
}

const int MAX_N_VETS = 100000 + 10;

Line stack[MAX_N_VETS];
int top;

int nVets;
vector&lt;pair&lt;int, int&gt; &gt; edge[MAX_N_VETS];

void addEdge(int s, int t, int c) {
	edge[s].push_back(make_pair(t, c));
	edge[t].push_back(make_pair(s, c));
}

int v[MAX_N_VETS], start[MAX_N_VETS];

int64 getVal(int64 v) {
	//min f-d*v
	int l = 0, r = top - 1;
	while (l + 5 &lt; r) {
		int mid1 = (l * 2 + r) / 3;
		int mid2 = (l + r * 2) / 3;
		if (stack[mid1].calc(v) &lt; stack[mid2].calc(v))
			r = mid2;
		else
			l = mid1;
	}

	int64 ret = LONG_LONG_MAX / 4;
	for (int i = l; i &lt;= r; ++i) {
		ret = min(ret, stack[i].calc(v));
	}

	return ret;
}

int64 ans[MAX_N_VETS];

void dfs(int u, int fa, int64 dist) {
	ans[u] = min(dist * v[u] + start[u], getVal(v[u]) + dist * v[u] + start[u]);
	//insert
	Line me;
	me.f = ans[u];
	me.d = dist;
	int prevTop = top;
	if (top &gt;= 2 &amp;&amp; isLL(stack[top - 1], stack[top - 2]) &gt; isLL(stack[top - 1],
			me)) {
		int l = 1, r = top - 1;
		while (l + 1 &lt; r) {
			int mid = l + r &gt;&gt; 1;
			if (isLL(stack[mid - 1], stack[mid]) &gt; isLL(stack[mid], me))
				r = mid;
			else
				l = mid;
		}
		top = r;
	}
	Line copy = stack[top];
	stack[top++] = me;

	foreach(e,edge[u]) {
		if (e-&gt;first != fa) {
			dfs(e-&gt;first, u, dist + e-&gt;second);
		}
	}

	stack[--top] = copy;
	top = prevTop;
}

void inputData() {
	scanf("%d", &amp;nVets);
	for (int i = 0; i &lt; nVets - 1; ++i) {
		int s, t, c;
		scanf("%d%d%d", &amp;s, &amp;t, &amp;c);
		--s;
		--t;
		addEdge(s, t, c);
	}
	start[0] = v[0] = 0;
	for (int i = 1; i &lt; nVets; ++i) {
		scanf("%d%d", start + i, v + i);
	}
}

int main() {
	//	freopen("in", "r", stdin);
	inputData();
	dfs(0, -1, 0);
	for (int i = 1; i &lt; nVets; ++i) {
		printf("%lld", ans[i]);
		if (i != nVets - 1)
			printf(" ");
	}
	printf("\n");
}
</pre><pre></pre><h2>Problem1768</h2><pre>/*
 * [Ceoi2009]logs.cpp
 *
 *  Created on: 2011-4-4
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_ROWS = 15000 + 10, MAX_N_COLS = 1500 + 10;
char str[MAX_N_COLS];

int prev[MAX_N_COLS], next[MAX_N_COLS];
int addAll;

int nRows, nCols;

int height[MAX_N_COLS];

void erase(int at) {
	next[prev[at]] = next[at];
	prev[next[at]] = prev[at];
}

void reSet(int at) {
	next[prev[at]] = at;
	prev[next[at]] = at;
}

inline void setToZero(int me) {
	height[me] = -addAll;
	erase(me);
	prev[me] = 0;
	next[me] = next[0];
	reSet(me);
}

inline void incAll() {
	addAll += 1;
}

int main() {
	scanf("%d%d", &amp;nRows, &amp;nCols);
	addAll = 0;

	for (int c = 0; c &lt;= nCols + 1; ++c) {
		prev[c] = c - 1;
		next[c] = c + 1;
		height[c] = 0;
	}

	int ans = 0;
	for (int r = 0; r &lt; nRows; ++r) {
		scanf(" ");
		scanf("%s", str);
		incAll();
		for (int c = 1; c &lt;= nCols; ++c) {
			if (str[c - 1] == '0')
				setToZero(c);
		}
		int cnt = 0;
		int at = nCols + 1;

		while (true) {
			at = prev[at];
			if (at == 0)
				break;
			++cnt;
			int tmp = cnt * (height[at] + addAll);
			if (tmp &gt; ans)
				ans = tmp;
		}
	}

	printf("%d\n", ans);
}
</pre><pre></pre><h2>Problem1769</h2><pre>/*
 * [Ceoi2009]tri.cpp
 *
 *  Created on: 2011-4-4
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_POINTS = 100000 + 10;

typedef long long int64;

struct Point {
	int x, y;
	void read() {
		scanf("%d%d", &amp;x, &amp;y);
	}
	Point() {
	}
	Point(int _x, int _y) :
		x(_x), y(_y) {
	}
	bool operator&lt;(const Point&amp;p) const {
		if (x != p.x)
			return x &lt; p.x;
		return y &lt; p.y;
	}
	inline int64 det(const Point&amp;p) const {
		return 1LL * x * p.y - 1LL * y * p.x;
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	double alpha() {
		return atan2(y, x);
	}
};

#define cross(p1,p2,p3) (1LL*(p2.x-p1.x)*(p3.y-p1.y) - 1LL*(p3.x-p1.x)*(p2.y-p1.y))

inline int sign(int64 x) {
	return x &lt; 0 ? -1 : x &gt; 0;
}

#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))

bool compareAngel(Point p1, Point p2) {
	return p1.det(p2) &gt; 0;
}

struct ConvexHull {
	Point*ps;
	int nPs;

	struct Vector {
		int src, dst;
		double alpha;

		void setVector(int _src, int _dst, Point ps[]) {
			src = _src;
			dst = _dst;
			alpha = (ps[dst] - ps[src]).alpha();
		}

		bool operator&lt;(const Vector&amp;v) const {
			return alpha &lt; v.alpha;
		}
	};

	Vector*vs;

	void makeConvexHull(Point*l, Point*r) {
		static Point ps[MAX_N_POINTS];
		nPs = 0;
		for (Point*me = l; me != r; ++me)
			ps[nPs++] = *me;
		sort(ps, ps + nPs);
		static Point qs[MAX_N_POINTS];
		int k = 0;
		for (int i = 0; i &lt; nPs; qs[k++] = ps[i++]) {
			while (k &gt; 1 &amp;&amp; crossOp(qs[k-2],qs[k-1],ps[i]) &lt;= 0)
				--k;
		}
		for (int i = nPs - 2, t = k; i &gt;= 0; qs[k++] = ps[i--]) {
			while (k &gt; t &amp;&amp; crossOp(qs[k-2],qs[k-1],ps[i]) &lt;= 0)
				--k;
		}
		nPs = k - 1;
		if (nPs &lt; 1)
			nPs++;
		this-&gt;ps = new Point[nPs];
		memcpy(this-&gt;ps, qs, sizeof(Point) * nPs);
	}

	void prepareVs() {
		vs = new Vector[nPs];
		for (int i = 0; i &lt; nPs; ++i) {
			vs[i].setVector(i, (i + 1) % nPs, ps);
		}
		sort(vs, vs + nPs);
	}

	void doit(Point*l, Point*r) {
		makeConvexHull(l, r);
		prepareVs();
	}

	int getMostLeft(Point p1, Point p2) {
		Vector me;
		me.alpha = (p1 - p2).alpha();
		int where = upper_bound(vs, vs + nPs, me) - vs;
		if (where == nPs)
			where = 0;
		return vs[where].src;
	}

	bool hasLeft(Point p1, Point p2) {
		return crossOp(p1,p2,ps[getMostLeft(p1,p2)]) &gt;= 0;
	}
};

int nPs;
Point ps[MAX_N_POINTS];

struct Tree {
	ConvexHull con;
	int left, right;
	Tree*ch[2];

	bool hasLeft(int aLeft, int aRight, Point p1, Point p2) {
		if (aLeft &lt;= left &amp;&amp; aRight &gt;= right)
			return con.hasLeft(p1, p2);
		if (aLeft &gt;= right || left &gt;= aRight)
			return false;
		for (int c = 0; c &lt; 2; ++c) {
			if (ch[c] != 0)
				if (ch[c]-&gt;hasLeft(aLeft, aRight, p1, p2))
					return true;
		}
		return false;
	}

	Tree(int _left, int _right) {
		left = _left;
		right = _right;
		con.doit(ps + left, ps + right);
		ch[0] = ch[1] = 0;
		if (left + 1 == right)
			return;
		int mid = left + right &gt;&gt; 1;
		ch[0] = new Tree(left, mid);
		ch[1] = new Tree(mid, right);
	}
};

Tree*root;

int nQ;
void inputData() {
	scanf("%d%d", &amp;nPs, &amp;nQ);
	for (int i = 0; i &lt; nPs; ++i) {
		ps[i].read();
	}
}

void prepare() {
	sort(ps, ps + nPs, compareAngel);
	root = new Tree(0, nPs);
}

bool askTriangle(Point p1, Point p2) {
	//(O,p1,p2)
	if (compareAngel(p2, p1))
		swap(p1, p2);
	int left = lower_bound(ps, ps + nPs, p1, compareAngel) - ps;
	int right = upper_bound(ps, ps + nPs, p2, compareAngel) - ps;
	return root-&gt;hasLeft(left, right, p1, p2);
}

void solve() {
	inputData();
	prepare();
	while (nQ--) {
		Point p1, p2;
		p1.read();
		p2.read();
		if (askTriangle(p1, p2))
			puts("Y");
		else
			puts("N");
	}
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem1770</h2><pre>/*
 	PROG: lights
 	LANG: C++
 	ID: Tom Chen
 */
#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=40;
int A[maxn][maxn]={0};
int N[maxn];
void init();
void solve();
int n,m;
void swap(int&amp;x,int&amp;y)
{int t=x;x=y;y=t;}
void init()
{	
	//freopen("lights.in","r",stdin);
	//freopen("lights.out","w",stdout);	
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)	
		A[i][n+1]=A[i][i]=1,N[i]=i;	
	while(m--)
	{
		int s,t;cin&gt;&gt;s&gt;&gt;t;
		A[s][t]=A[t][s]=1;
	}
}
int Frees[maxn]={0},cnt=0;
bool Free[maxn]={0};
void solve()
{
	int i,j;
	for(i=1;i&lt;=n;i++)
	{
		for(j=i;j&lt;=n;j++)
			if(A[i][j]) break;
		if(j==n+1) continue;
		swap(N[i],N[j]);	
		for(int k=1;k&lt;=n;k++)
			swap(A[k][i],A[k][j]);
		for(int j=1;j&lt;=n;j++) if(j!=i)
			if(A[j][i])
				for(int k=1;k&lt;=n+1;k++)
					A[j][k]=A[j][k] xor A[i][k];
	}
	for(int i=1;i&lt;=n;i++)
		if(A[i][i]==0)
			Frees[cnt++]=N[i],Free[N[i]]=true;
}
int ans=~0U&gt;&gt;1;
int C[maxn]={0};
void dfs(int pos,int now)
{
	if(now&gt;ans)
		return;
	if(pos==cnt)
	{
		for(int i=1;i&lt;=n;i++)
			if(A[i][i])
			{
				C[N[i]]=0;
				for(int j=1;j&lt;=n;j++)if(Free[N[j]]&amp;&amp;A[i][j])
					C[N[i]]^=C[N[j]];
				C[N[i]]^=A[i][n+1];
			}
		int t=count(C+1,C+n+1,1);		
		ans=min(ans,t);
		return;
	}
	C[Frees[pos]]=0;dfs(pos+1,now);
	C[Frees[pos]]=1;dfs(pos+1,now+1);
}
int main()
{
	init();
	solve();
	dfs(0,0);
	cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1772</h2><pre>/*
 	PROG: rescue
 	LANG: C++
    ID: Tom Chen 
 */
#include&lt;iostream&gt;
using namespace std;
int n,m;
struct point
{
	int i,j,x,y,z;
	void read()
	{
		cin&gt;&gt;i&gt;&gt;j;
		x=i;
		y=i-j/2;
		z=(j+1)/2;
	}
	void show()
	{
		cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl;
	}
	int operator-(const point&amp;o) const
	{return abs(x-o.x)+abs(y-o.y)+abs(z-o.z);}
};
int main()
{
	//freopen("rescue.in","r",stdin);
	//freopen("rescue.out","w",stdout);
	cin&gt;&gt;n&gt;&gt;m;point now,ans;
	now.read();int min=~0U&gt;&gt;1;
	for(int i=0;i&lt;m;i++)
	{
		point out;out.read();
		if(now-out&lt;min)
		{
			min=now-out;
			ans=out;
		}
	}
	ans.show();
	cout&lt;&lt;min+1&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1774</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int inf=~0U&gt;&gt;3,maxn=250;
int D[maxn][maxn],Ans[maxn][maxn],n,m,q,C[maxn],P[maxn];
void Init()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;rep(i,n)scanf("%d",C+i),P[i]=i;int s,t,c;
    rep(i,n)rep(j,n)D[i][j]=Ans[i][j]=inf;
    rep(i,n)D[i][i]=0;
    rep(i,m)scanf("%d %d %d",&amp;s,&amp;t,&amp;c),--s,--t,D[s][t]=D[t][s]=min(D[s][t],c);
}
bool cmp(int a,int b)
{return C[a]&lt;C[b];}
inline void Renew(int&amp;x,int c){x=min(x,c);}
void Work()
{
    sort(P,P+n,cmp);
    rep(t,n)
    {
        int k=P[t];
        rep(i,n)rep(j,n)if(C[i]&lt;=C[k]&amp;&amp;C[j]&lt;=C[k])Renew(Ans[i][j],D[i][k]+D[k][j]+C[k]);
        rep(i,n)rep(j,n)Renew(D[i][j],D[i][k]+D[k][j]);
    }
    int s,t;
    rep(i,q)scanf("%d %d",&amp;s,&amp;t),--s,--t,printf("%d\n",Ans[s][t]);
}
int main()
{
  //freopen("in","r",stdin);
  Init();
  Work();
}
</pre><pre></pre><h2>Problem1776</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=200000+10,maxp=maxn/2;
using namespace std;
vector&lt;int&gt; Party[maxp],E[maxn];
int n,k,vs,D[maxn],Own[maxn],Size[maxn];
void init()
{
    cin&gt;&gt;n&gt;&gt;k;int a,p;
    rep(i,n)
    {
        scanf("%d%d",&amp;a,&amp;p);
        a--;p--;
        Party[a].pb(i);
        if(p==-1)vs=i;
        else E[p].pb(i);
    }
}
int Q[maxn],h,t,F[maxn];
void BFS()
{
    h=t=0;
    for(Q[t++]=vs,D[vs]=0;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,E[x])Q[t++]=*e,F[*e]=x,D[*e]=D[x]+1;
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(e,E[x])Size[x]+=Size[*e];
    }
    memset(Own,-1,sizeof Own);
    for(int i=0;i&lt;h;i++)
    {
        int a=Q[i];if(Own[a]&gt;=0)continue;
        int x=a,next;
        for(;;x=next)
        {
            next=-1;Own[x]=a;
            tr(e,E[x])if(next==-1||Size[*e]&gt;Size[next])
                next=*e;
            if(next==-1)break;
        }
    }
}
int Lca(int u,int v)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(Own[u]==Own[v])return v;
        if(D[Own[u]]&lt;D[Own[v]])swap(u,v);
        u=F[Own[u]];
    }
}
int Dist(int u,int v)
{
    return D[u]+D[v]-2*D[Lca(u,v)];
}
void Solve()
{
    rep(i,k)
    {
        int Max=-1;
        tr(e,Party[i])if(Max==-1||D[*e]&gt;D[Max])
            Max=*e;
        int ret=0;
        tr(e,Party[i])ret=max(ret,Dist(Max,*e));
        printf("%d\n",ret);
    }
}
int main()
{
    //freopen("in","r",stdin);
    init();
    BFS();
    Solve();
}


</pre><pre></pre><h2>Problem1776</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=200000+10,maxp=maxn/2;
using namespace std;
vector&lt;int&gt; Party[maxp],E[maxn];
int n,k,vs,D[maxn],Own[maxn],Size[maxn];
int nextInt()
{
    int ret=0;char c;
    while(c=getchar(),c&gt;'9'||c&lt;'0');
    ret=c-'0';while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')ret*=10,ret+=c-'0';
    return ret;
}
void init()
{
    cin&gt;&gt;n&gt;&gt;k;int a,p;
    rep(i,n)
    {
        a=nextInt();p=nextInt();
        a--;p--;
        Party[a].pb(i);
        if(p==-1)vs=i;
        else E[p].pb(i);
    }
}
int Q[maxn],h,t,F[maxn];
void BFS()
{
    h=t=0;
    for(Q[t++]=vs,D[vs]=0;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,E[x])Q[t++]=*e,F[*e]=x,D[*e]=D[x]+1;
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(e,E[x])Size[x]+=Size[*e];
    }
    memset(Own,-1,sizeof Own);
    for(int i=0;i&lt;h;i++)
    {
        int a=Q[i];if(Own[a]&gt;=0)continue;
        int x=a,next;
        for(;;x=next)
        {
            next=-1;Own[x]=a;
            tr(e,E[x])if(next==-1||Size[*e]&gt;Size[next])
                next=*e;
            if(next==-1)break;
        }
    }
}
int Lca(int u,int v)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(Own[u]==Own[v])return v;
        if(D[Own[u]]&lt;D[Own[v]])swap(u,v);
        u=F[Own[u]];
    }
}
int Dist(int u,int v)
{
    return D[u]+D[v]-2*D[Lca(u,v)];
}
void Solve()
{
    rep(i,k)
    {
        int Max=-1;
        tr(e,Party[i])if(Max==-1||D[*e]&gt;D[Max])
            Max=*e;
        int ret=0;
        tr(e,Party[i])ret=max(ret,Dist(Max,*e));
        printf("%d\n",ret);
    }
}
int main()
{
    //freopen("in","r",stdin);
    init();
    BFS();
    Solve();
}


</pre><pre></pre><h2>Problem1777</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1,maxn=10000;
using namespace std;
vector&lt;int&gt; E[maxn];
int n,A[maxn],L,T;
bool e[maxn];
void dfs(int x)
{
    tr(it,E[x])e[*it]=!e[x],dfs(*it);
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;T&gt;&gt;L;int p;
    for(int i=1;i&lt;n;i++)
    {
        cin&gt;&gt;p;cin&gt;&gt;A[i];p--;
        E[p].pb(i);
    }
    e[0]=false;dfs(0);
    int a,b,xsum=0;
    rep(i,n)if(e[i])xsum^=A[i]%(L+1);
    rep(i,T)
    {
        cin&gt;&gt;a&gt;&gt;b;--a;
        if(e[a])xsum^=A[a]%(L+1);
        A[a]=b;
        if(e[a])xsum^=A[a]%(L+1);
        if(xsum)puts("Yes");else puts("No");
    }
}


</pre><pre></pre><h2>Problem1778</h2><pre>/*
 *  [Usaco2010 Hol]Dotp 驱逐猪猡.cpp
 *
 *  Created on: 2011-6-6
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_NV = 300 + 10;
vector&lt;int&gt; E[MAX_NV];
int nV, nE;
double P;
void readInput() {
	cin &gt;&gt; nV &gt;&gt; nE;
	double A, B;
	cin &gt;&gt; A &gt;&gt; B;
	P = A / B;
	for (int i = 0; i &lt; nE; ++i) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		--a;
		--b;
		E[a].push_back(b);
		if (a != b)
			E[b].push_back(a);
	}
}

double mat[MAX_NV][MAX_NV], b[MAX_NV];

void buildMat() {
	memset(mat, 0, sizeof mat);
	memset(b, 0, sizeof b);
	for (int u = 0; u &lt; nV; ++u) {
		mat[u][u] = 1;
		b[u] = u ? 0 : P;
		foreach(e,E[u]) {
			mat[u][*e] = -(1 - P) / E[*e].size();
		}
	}
}

double ret[MAX_NV];
int used[MAX_NV];

void solveMat() {
	memset(used, -1, sizeof used);
	for (int r = 0; r &lt; nV; ++r) {
		int maxId = -1;
		for (int c = 0; c &lt; nV; ++c) {
			if (used[c] == -1 &amp;&amp; (maxId == -1 || fabs(mat[r][c]) &gt; fabs(
					mat[r][maxId])))
				maxId = c;
		}
		used[maxId] = r;
		{
			double by = mat[r][maxId];
			for (int c = 0; c &lt; nV; ++c) {
				mat[r][c] /= by;
			}
			b[r] /= by;
		}
		for (int nr = 0; nr &lt; nV; ++nr) {
			if (nr != r) {
				double by = mat[nr][maxId];
				for (int c = 0; c &lt; nV; ++c) {
					mat[nr][c] -= by * mat[r][c];
				}
				b[nr] -= by * b[r];
			}
		}
	}

	for (int c = 0; c &lt; nV; ++c) {
		ret[c] = b[used[c]];
	}
}

void work() {
	buildMat();
	solveMat();
	for (int i = 0; i &lt; nV; ++i) {
		printf("%0.9lf\n", ret[i]);
	}
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem1780</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int maxn=100000;
int C,N=0;
struct Seg
{
    int l,r;
    Seg(){}
    Seg(int _l,int _r):
        l(_l),r(_r){}
    bool operator&lt;(const Seg&amp;a)const
    {
        return l!=a.l?l&lt;a.l:r&gt;a.r;
    }
    bool Contain(const Seg&amp;a)const
    {
        return l&lt;=a.l&amp;&amp;r&gt;=a.r;
    }
    bool Intersect(const Seg&amp;a)const
    {
        return !(l&gt;a.r||a.l&gt;r);
    }
}S[maxn*2];
void addSeg(int l,int r)
{
    S[N++]=Seg(l,r);
    if(r&lt;C)
        S[N++]=Seg(l+C,r+C);
}
void PreCondition()
{
    sort(S,S+N);
    int p=0;
    rep(i,N)
        if(!p||!S[p-1].Contain(S[i]))
            S[p++]=S[i];
    N=p;
}
int next[maxn*2];
const int Log=18;
int Next[maxn*2][Log];
void CalNext()
{
    int r=N-1;
    for(int i=N-1;i&gt;=0;i--)
    {
        while(!S[i].Intersect(S[r]))r--;
        Next[i][0]=next[i]=r;
    }
    for(int log=1;log&lt;Log;log++)
        rep(i,N)
        {
            int tmp=Next[i][log-1];
            Next[i][log]=Next[tmp][log-1];
        }
}
void Solve()
{
    int ans=inf;
    for(int i=0;i&lt;N;i++)
    {
        int ret=1;
        int at=i;
        if(S[i].r-S[i].l&gt;=C)
        {
            ans=1;
            break;
        }
        for(int log=Log-1;log&gt;=0;log--)
        {
            int go=Next[at][log];
            if(S[go].r-S[i].l&lt;C)
                at=go,ret+=1&lt;&lt;log;
        }
        at=next[at];ret++;
        if(S[at].r-S[i].l+1&gt;=C)
            ans=min(ans,ret);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
void Init()
{
    int n,l,r,s;
    scanf("%d%d",&amp;C,&amp;n);
    rep(i,n)
    {
        scanf("%d%d",&amp;l,&amp;s);r=l+s;
        addSeg(l,r);
    }
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    PreCondition();
    CalNext();
    Solve();
}


</pre><pre></pre><h2>Problem1781</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef set&lt;int&gt;::iterator sit;
int N;
struct Point
{
    int x,y;
    Point(){}
    Point(int _x,int _y):
        x(_x),y(_y){}
    void Read()
    {
        scanf("%d %d",&amp;x,&amp;y);
    }
    bool operator!=(const Point&amp;a)const
    {
        return x!=a.x||y!=a.y;
    }
    bool operator&lt;(const Point&amp;a)const
    {
        return x!=a.x?x&lt;a.x:y&lt;a.y;
    }
}vs,vt,None(inf,inf);
map&lt;int,set&lt;int&gt; &gt;MapX,MapY;
void AddPoint(const Point&amp;a)
{
    MapX[a.x].insert(a.y);
    MapY[a.y].insert(a.x);
}
Point getLeft(Point a)
{
    if(!MapY.count(a.y))return None;
    sit it=MapY[a.y].lower_bound(a.x);
    if(it==MapY[a.y].begin())return None;
    it--;
    return Point(*it+1,a.y);
}
Point getRight(Point a)
{
    if(!MapY.count(a.y))return None;
    sit it=MapY[a.y].upper_bound(a.x);
    if(it==MapY[a.y].end())return None;
    return Point(*it-1,a.y);
}
Point getUp(Point a)
{
    if(!MapX.count(a.x))return None;
    sit it=MapX[a.x].upper_bound(a.y);
    if(it==MapX[a.x].end())return None;
    return Point(a.x,*it-1);
}
Point getDown(Point a)
{
    if(!MapX.count(a.x))return None;
    sit it=MapX[a.x].lower_bound(a.y);
    if(it==MapX[a.x].begin())return None;
    it--;
    return Point(a.x,*it+1);
}
map&lt;Point,int&gt; Dist;
queue&lt;Point&gt; Q;
void BFS(Point vs)
{
    Dist[vs]=0;
    Q.push(vs);
    while(!Q.empty())
    {
        Point now=Q.front(),go;Q.pop();
        int c=Dist[now];
        if(go=getLeft(now),go!=None)
        {
            if(!Dist.count(go))
            {
                Dist[go]=c+1;
                Q.push(go);
            }
        }
        if(go=getRight(now),go!=None)
        {
            if(!Dist.count(go))
            {
                Dist[go]=c+1;
                Q.push(go);
            }
        }
        if(go=getUp(now),go!=None)
        {
            if(!Dist.count(go))
            {
                Dist[go]=c+1;
                Q.push(go);
            }
        }
        if(go=getDown(now),go!=None)
        {
            if(!Dist.count(go))
            {
                Dist[go]=c+1;
                Q.push(go);
            }
        }
    }
}
void Init()
{
    scanf("%d",&amp;N);
    vs.Read();vt.Read();Point a;
    rep(i,N)
    {
        a.Read();
        AddPoint(a);
    }
}
void Solve()
{
    BFS(vs);
    printf("%d\n",Dist[vt]);
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


</pre><pre></pre><h2>Problem1782</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define all(x) x.begin(),x.end()
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=100000+10;
int C[maxn]={0},n;
void add(int p,int d)
{
    for(;p&lt;=n;p+=p&amp;-p)
        C[p]+=d;
}
void add(int l,int r,int d)
{
    add(l,d);add(r,-d);
}
int sum(int l)
{
    int ret=0;
    for(;l&gt;0;l-=l&amp;-l) ret+=C[l];
    return ret;
}
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator it;
int l[maxn],r[maxn],cnt=1;
void dfs(int x,int f)
{
    l[x]=cnt++;
    for(it e=E[x].begin();e!=E[x].end();++e)
        if(*e!=f) dfs(*e,x);
    r[x]=cnt;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;int s,t;
    rep(i,n-1)scanf("%d %d",&amp;s,&amp;t),E[--s].pb(--t),E[t].pb(s);
    dfs(0,-1);t=n++;
    rep(i,t)
    {
        scanf("%d",&amp;s);--s;
        printf("%d\n",sum(l[s]));
        add(l[s],r[s],1);
    }
}
</pre><pre></pre><h2>Problem1782</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int maxn=1e5+10;
int C[maxn]={0},n;
void add(int p,int d)
{
    for(;p&lt;=n;p+=p&amp;-p)
        C[p]+=d;
}
void add(int l,int r,int d)
{
    add(l,d);add(r,-d);
}
int sum(int l)
{
    int ret=0;
    for(;l&gt;0;l-=l&amp;-l) ret+=C[l];
    return ret;
}
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator it;
int l[maxn],r[maxn],cnt=1;
void dfs(int x,int f)
{
    l[x]=cnt++;
    for(it e=E[x].begin();e!=E[x].end();++e)
        if(*e!=f) dfs(*e,x);
    r[x]=cnt;
}
int main()
{
    scanf("%d",&amp;n);int s,t;
    rep(i,n-1)scanf("%d %d",&amp;s,&amp;t),E[--s].pb(--t),E[t].pb(s);
    dfs(0,-1);t=n++;
    rep(i,t)
    {
        scanf("%d",&amp;s);--s;
        printf("%d\n",sum(l[s]));
        add(l[s],r[s],1);
    }
}
</pre><pre></pre><h2>Problem1783</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1,maxn=700000;
using namespace std;
typedef long long ll;
int n,A[maxn];
int nextInt()
{
    char c;int ret=0;
    while(c=getchar(),c&lt;'0'||c&gt;'9');
    ret=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')ret=ret*10+c-'0';
    return ret;
}
int main()
{
    //freopen("in","r",stdin);
    n=nextInt();
    rep(i,n)A[i]=nextInt();
    ll a=0,b=0,tmp;
    for(int i=n-1;i&gt;=0;i--)
    {
        if(b+A[i]&gt;=a)
            tmp=a,a=b+A[i],b=tmp;
    }
    cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1787</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1,maxn=500000+10;
using namespace std;
int n,q;
int Size[maxn],Q[maxn],h,t,F[maxn],D[maxn];
vector&lt;int&gt; E[maxn];
int own[maxn];
void AddEdge(int s,int t)
{
    E[s].pb(t);
    E[t].pb(s);
}
void BFS(int vs)
{
    h=t=0;
    for(Q[t++]=vs,F[vs]=-1,D[vs]=0;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,E[x])if(*e!=F[x])
        {
            F[*e]=x;
            Q[t++]=*e;
            D[*e]=D[x]+1;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(e,E[x])if(*e!=F[x])
            Size[x]+=Size[*e];
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int a=Q[i],nxt,x=a;
        if(own[a]&gt;=0)continue;
        for(;;x=nxt)
        {
            nxt=-1;own[x]=a;
            tr(e,E[x])if(*e!=F[x])
                if(nxt==-1||Size[*e]&gt;Size[nxt])
                    nxt=*e;
            if(nxt==-1)break;
        }
    }
}
void scan(int&amp;ret)
{
    char c;
    while(c=getchar(),c&lt;'0'||c&gt;'9');
    ret=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')ret=ret*10+c-'0';
}
void Init()
{
    scan(n);scan(q);
    int s,t;
    rep(i,n-1)
    {
        scan(s);scan(t);
        --s;--t;
        AddEdge(s,t);
    }
}
int Lca(int u,int v)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])return v;
        if(D[own[u]]&lt;D[own[v]])swap(u,v);
        u=F[own[u]];
    }
}
int Dist(int u,int v)
{
    int lca=Lca(u,v);
    return D[u]+D[v]-D[lca]*2;
}
void Solve()
{
    int a[3];
    rep(i,q)
    {
        rep(j,3)scan(a[j]),a[j]--;
        int ans=inf,to;
        rep(c1,3)rep(c2,c1)
        {
            int dest=Lca(a[c1],a[c2]);
            int ret=0;
            rep(c,3)
            {
                ret+=Dist(dest,a[c]);
                if(ret&gt;=ans)break;
            }
            if(ret&lt;ans)ans=ret,to=dest;
        }
        printf("%d %d\n",to+1,ans);
    }
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    BFS(0);
    Solve();
}


</pre><pre></pre><h2>Problem1787</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1,maxn=500000+10;
using namespace std;
int n,q;
int Size[maxn],Q[maxn],h,t,F[maxn],D[maxn];
vector&lt;int&gt; E[maxn];
int own[maxn];
void AddEdge(int s,int t)
{
    E[s].pb(t);
    E[t].pb(s);
}
void BFS(int vs)
{
    h=t=0;
    for(Q[t++]=vs,F[vs]=-1,D[vs]=0;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,E[x])if(*e!=F[x])
        {
            F[*e]=x;
            Q[t++]=*e;
            D[*e]=D[x]+1;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(e,E[x])if(*e!=F[x])
            Size[x]+=Size[*e];
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int a=Q[i],nxt,x=a;
        if(own[a]&gt;=0)continue;
        for(;;x=nxt)
        {
            nxt=-1;own[x]=a;
            tr(e,E[x])if(*e!=F[x])
                if(nxt==-1||Size[*e]&gt;Size[nxt])
                    nxt=*e;
            if(nxt==-1)break;
        }
    }
}
void scan(int&amp;ret)
{
    char c;
    while(c=getchar(),c&lt;'0'||c&gt;'9');
    ret=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')ret=ret*10+c-'0';
}
int A[20],k;
inline void print_int(int x)
{
    if(x&lt;0)putchar('-'),x=-x;
    if(!x)putchar('0');
    k=0;while(x)A[k++]=x%10,x/=10;
    for(int i=k-1;i&gt;=0;i--)putchar('0'+A[i]);
}
void Init()
{
    scan(n);scan(q);
    int s,t;
    rep(i,n-1)
    {
        scan(s);scan(t);
        --s;--t;
        AddEdge(s,t);
    }
}
int Lca(int u,int v)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])return v;
        if(D[own[u]]&lt;D[own[v]])swap(u,v);
        u=F[own[u]];
    }
}
int Dist(int u,int v)
{
    int lca=Lca(u,v);
    return D[u]+D[v]-D[lca]*2;
}
void Solve()
{
    int a[3];
    rep(i,q)
    {
        rep(j,3)scan(a[j]),a[j]--;
        int ans=inf,to;
        rep(c1,3)rep(c2,c1)
        {
            int dest=Lca(a[c1],a[c2]);
            int ret=0;
            rep(c,3)
            {
                ret+=Dist(dest,a[c]);
                if(ret&gt;=ans)break;
            }
            if(ret&lt;ans)ans=ret,to=dest;
        }
        print_int(to+1);putchar(' ');
        print_int(ans);putchar('\n');
    }
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    BFS(0);
    Solve();
}


</pre><pre></pre><h2>Problem1797</h2><pre>/*
 * [Ahoi2009]Mincut 最小割.cpp
 *
 *  Created on: 2011-3-10
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VETS = 4000 + 100;
const int MAX_N_EDGES = 60010 * 2;

int head[MAX_N_VETS];
int next[MAX_N_EDGES], dest[MAX_N_EDGES], cap[MAX_N_EDGES];

int nVets, nEdges;
int curEdge;
int vs, vt;

inline void makeEdge(int s, int t, int c) {
	int id = curEdge++;
	dest[id] = t;
	cap[id] = c;
	next[id] = head[s];
	head[s] = id;
}

inline void addEdge(int s, int t, int c) {
	makeEdge(s, t, c);
	makeEdge(t, s, 0);
}

void inputData() {
	scanf("%d%d%d%d", &amp;nVets, &amp;nEdges, &amp;vs, &amp;vt);
	--vs;
	--vt;
	memset(head, -1, sizeof head);
	curEdge = 0;
	for (int edgeId = 0; edgeId &lt; nEdges; ++edgeId) {
		int s, t, c;
		scanf("%d%d%d", &amp;s, &amp;t, &amp;c);
		--s;
		--t;
		addEdge(s, t, c);
	}
}

int a[MAX_N_VETS], cur[MAX_N_VETS], h[MAX_N_VETS], cnt[MAX_N_VETS];
int prev[MAX_N_VETS];

const int INF = INT_MAX / 2;
int totalFlow;
void sap() {
	memset(a, 0, sizeof a);
	memset(cur, -1, sizeof cur);
	memset(h, 0, sizeof h);
	memset(cnt, 0, sizeof cnt);
	cnt[0] = nVets;
	int now, u = vs;
	a[u] = INF;
	totalFlow = 0;
	while (h[u] &lt; nVets) {
		for (now = cur[u]; now != -1; now = next[now])
			if (h[u] == h[dest[now]] + 1 &amp;&amp; cap[now] &gt; 0)
				break;
//		cout &lt;&lt; u &lt;&lt; " " &lt;&lt; now &lt;&lt; endl;
		if (now != -1) {
			int v = dest[now];
			a[v] = min(a[u], cap[now]);
			prev[v] = cur[u] = now;
			if ((u = v) == vt) {
				int flow = a[vt];
				totalFlow += flow;
				while (u != vs) {
					cap[prev[u]] -= flow;
					cap[prev[u] ^ 1] += flow;
					u = dest[prev[u] ^ 1];
				}
				a[u] = INF;
			}
		} else {
			if (!--cnt[h[u]])
				break;
			h[u] = nVets;
			for (now = head[u]; now != -1; now = next[now])
				if (cap[now] &gt; 0 &amp;&amp; h[dest[now]] + 1 &lt; h[u]) {
					h[u] = h[dest[now]] + 1;
					cur[u] = now;
				}
			++cnt[h[u]];
			if (u != vs)
				u = dest[prev[u] ^ 1];
		}
	}
}

int seq[MAX_N_VETS], curSeq;
bool visited[MAX_N_VETS] = { };
void dfs(int u) {
	if (visited[u])
		return;
	visited[u] = true;
	for (int e = head[u]; e != -1; e = next[e])
		if (cap[e] &gt; 0)
			dfs(dest[e]);
	seq[curSeq++] = u;
}

int sccId[MAX_N_VETS], curSccId;

void revDfs(int u) {
	if (sccId[u] != -1)
		return;
	sccId[u] = curSccId;
	for (int e = head[u]; e != -1; e = next[e])
		if (cap[e ^ 1] &gt; 0)
			revDfs(dest[e]);
}

void calcSCC() {
	memset(visited, false, sizeof visited);
	curSeq = 0;
	for (int i = 0; i &lt; nVets; ++i) {
		if (!visited[i]) {
			dfs(i);
		}
	}

	memset(sccId, -1, sizeof sccId);
	curSccId = 0;
	for (int iter = nVets - 1; iter &gt;= 0; --iter) {
		int u = seq[iter];
		if (sccId[u] == -1) {
			revDfs(u);
			curSccId++;
		}
	}
}

void answerQuestions() {
	for (int edgeId = 0; edgeId &lt; nEdges; ++edgeId) {
		int am = edgeId * 2;
		int u = dest[am ^ 1], v = dest[am];
		int ans0 = 0, ans1 = 0;
		if (cap[am] == 0 &amp;&amp; sccId[u] != sccId[v]) {
			ans0 = 1;
			if (sccId[u] == sccId[vs] &amp;&amp; sccId[v] == sccId[vt]) {
				ans1 = 1;
			}
		}
		printf("%d %d\n", ans0, ans1);
	}
}

int main() {
//	freopen("in","r",stdin);
//	freopen("out","w",stdout);
	inputData();
	sap();
//	cout &lt;&lt; totalFlow &lt;&lt; endl;
	calcSCC();
	answerQuestions();
}
</pre><pre></pre><h2>Problem1798</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=100000;
typedef long long ll;
ll sum[maxn*3],A[maxn],mod;
int n;
struct Mark
{
    ll mul,plus;
    bool operator==(const Mark&amp;o)const
    {return mul==o.mul&amp;&amp;plus==o.plus;}
    Mark(ll _mul=1,ll _plus=0):mul(_mul),plus(_plus){}
}none,mark[maxn*3];
void Plus(ll&amp;a,ll b){a+=b;a%=mod;}
void Mul(ll&amp;a,ll b){a*=b;a%=mod;}
#define Tree int t,int l,int r
#define This t,l,r
#define Left t*2,l,(l+r)/2
#define Right t*2+1,(l+r)/2,r
void MarkIt(Tree,Mark m)
{
    Mul(sum[t],m.mul);Plus(sum[t],(r-l)*m.plus);
    Mul(mark[t].mul,m.mul);Mul(mark[t].plus,m.mul);Plus(mark[t].plus,m.plus);
}
void PushDown(Tree)
{
    if(mark[t]==none)return;
    MarkIt(Left,mark[t]),MarkIt(Right,mark[t]),mark[t]=none;
}
void Build(Tree)
{
    mark[t]=none;
    if(l+1==r){sum[t]=A[l];return;}
    Build(Left);Build(Right);
    sum[t]=(sum[t*2]+sum[t*2+1])%mod;
}
void Change(Tree,int a,int b,Mark m)
{
    if(l&gt;=b||r&lt;=a)return;
    if(l&gt;=a&amp;&amp;r&lt;=b){MarkIt(This,m);return;}
    PushDown(This);
    Change(Left,a,b,m);Change(Right,a,b,m);
    sum[t]=sum[t*2]+sum[t*2+1];sum[t]%=mod;
}
ll Ask(Tree,int a,int b)
{
    if(l&gt;=b||r&lt;=a)return 0;
    if(l&gt;=a&amp;&amp;r&lt;=b) return sum[t];
    PushDown(This);
    return (Ask(Left,a,b)+Ask(Right,a,b))%mod;
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d %d",&amp;n,&amp;mod);
    rep(i,n) scanf("%d",A+i);
    Build(1,0,n);
    int m,l,r,c,x;scanf("%d",&amp;m);
    rep(i,m)
    {
        scanf("%d %d %d",&amp;x,&amp;l,&amp;r);
        switch(x)
        {
            case 1:scanf("%d",&amp;c),Change(1,0,n,l-1,r,Mark(c,0));break;
            case 2:scanf("%d",&amp;c),Change(1,0,n,l-1,r,Mark(1,c));break;
            case 3:printf("%d\n",Ask(1,0,n,l-1,r));break;
        }
    }
}
</pre><pre></pre><h2>Problem1800</h2><pre>#include&lt;iostream&gt;
using namespace std;
const int maxn=1000;
int S[maxn]={0},n,ans;
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;for(int i=1;i&lt;=n;i++)cin&gt;&gt;S[i],S[i]+=S[i-1];
    for(int a=1;a&lt;=n;a++)
        for(int b=a+1;b&lt;=n;b++)
            for(int c=b+1;c&lt;=n;c++)
                for(int d=c+1;d&lt;=n;d++)
                {
                    int x=S[b]-S[a],y=S[c]-S[b],z=S[d]-S[c],w=S[n]-x-y-z;
                    if(x==z&amp;&amp;y==w) ans++;
                }
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1801</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,a,b) for(int i=a;i&lt;=b;i++)
#define tr(i,x) for(typeof(x.begin()) i=x.begin();i!=x.end();i++)
#define all(x) x.begin(),x.end()
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef pair&lt;int,int&gt; ii;
const int maxn=100+10,mod=9999973;
int Dp[2][maxn][maxn],n,m;
int C[maxn][maxn]={0};
int plus_mod(int&amp;a,int b)
{
    a+=b;return a%=mod;
}
int multi_mod(int&amp;a,int b)
{
    return a=((long long)a*b)%mod;
}
void GetC()
{
    C[0][0]=1;
    for(int i=1;i&lt;=m;i++)
    {
        C[i][0]=C[i][i]=1;
        for(int j=1;j&lt;i;j++)
        {
            C[i][j]=C[i-1][j-1]+C[i-1][j];
            C[i][j]%=mod;
        }
    }
}
#define MM(x) memset(x,0,sizeof(x))
int main()
{
    cin&gt;&gt;n&gt;&gt;m;int now=0,next=1;
    MM(Dp);GetC();
    Dp[next][m][0]=1;
    for(int i=0;i&lt;n;i++)
    {
        swap(now,next);
        MM(Dp[next]);
        for(int a0=0;a0&lt;=m;a0++)
            for(int a1=0;a1+a0&lt;=m;a1++)
            if(Dp[now][a0][a1])
            {
                int x=Dp[now][a0][a1],c;
                //Dont used Row i
                plus_mod(Dp[next][a0][a1],x);
                //Put one
                if(a0)
                {
                    c=x;
                    multi_mod(c,C[a0][1]);
                    plus_mod(Dp[next][a0-1][a1+1],c);
                }
                if(a1)
                {
                    c=x;
                    multi_mod(c,C[a1][1]);
                    plus_mod(Dp[next][a0][a1-1],c);
                }
                //Put two
                if(a0&gt;=2)
                {
                    c=x;
                    multi_mod(c,C[a0][2]);
                    plus_mod(Dp[next][a0-2][a1+2],c);
                }
                if(a1&gt;=2)
                {
                    c=x;
                    multi_mod(c,C[a1][2]);
                    plus_mod(Dp[next][a0][a1-2],c);
                }
                if(a0&amp;&amp;a1)
                {
                    c=x;
                    multi_mod(c,C[a0][1]);
                    multi_mod(c,C[a1][1]);
                    plus_mod(Dp[next][a0-1][a1],c);
                }
            }
    }
    int ans=0;
    rep(i,m+1)rep(j,m+1)plus_mod(ans,Dp[next][i][j]);
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1803</h2><pre>/*
 * Spoj1487 Query on a tree III.cpp
 *
 *  Created on: 2011-3-18
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VETS = 100000 + 10;
const int MAX_LOG = 20;
vector&lt;int&gt; edge[MAX_N_VETS];
int label[MAX_N_VETS];
int nVets;
void addEdge(int s, int t) {
	edge[s].push_back(t);
	edge[t].push_back(s);
}
void clearEdges() {
	for (int i = 0; i &lt; nVets; ++i)
		edge[i].clear();
}

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

void inputData() {
	scanInt(nVets);
	for (int i = 0; i &lt; nVets; ++i) {
		scanInt(label[i]);
	}
	clearEdges();
	for (int iter = 0; iter &lt; nVets - 1; ++iter) {
		int s, t;
		scanInt(s);
		scanInt(t);
		--s;
		--t;
		addEdge(s, t);
	}
}

int ord[MAX_N_VETS], ordPointer;
int Left[MAX_N_VETS], Right[MAX_N_VETS];

typedef vector&lt;int&gt;::iterator vit;

struct DfsState {
	int u;
	vit e;
	void start(int _u) {
		u = _u;
		e = edge[u].begin();
	}
	void get(int&amp;_u, vit&amp;_e) {
		_u = u;
		_e = e;
	}
	void nextEdge() {
		++e;
	}
	bool isFinished() {
		return e == edge[u].end();
	}
};

bool visited[MAX_N_VETS];
void dfs(int vs) {
	static DfsState stack[MAX_N_VETS];
	int top = 0;
	memset(visited, false, sizeof visited);
	visited[vs] = true;
	stack[top++].start(vs);
	while (top &gt; 0) {
		DfsState&amp;cur = stack[top - 1];
		int u;
		vit e;
		cur.get(u, e);
		if (e == edge[u].begin()) {
			Left[u] = ordPointer;
			ord[ordPointer++] = u;
		}
		if (cur.isFinished()) {
			--top;
			Right[u] = ordPointer;
			continue;
		}
		{
			int v = *e;
			if (!visited[v]) {
				visited[v] = true;
				stack[top++].start(v);
			}
		}
		cur.nextEdge();
	}
}

pair&lt;int, int&gt; seq[MAX_N_VETS];
int what[MAX_LOG][MAX_N_VETS];
int cnt[MAX_LOG][MAX_N_VETS];

void makeDfsOrd() {
	ordPointer = 0;
	dfs(0);
	//	for (int i = 0; i &lt; nVets; ++i) {
	//		cout &lt;&lt; ord[i] &lt;&lt; " ";
	//	}
	//	cout &lt;&lt; endl;
}

void build(int dep, int l, int r) {
	if (l + 1 == r)
		return;
	int tl = 0, tr = 0, mid = l + r &gt;&gt; 1;
	for (int i = l; i &lt; r; ++i) {
		if (seq[what[dep][i]] &lt; seq[mid])
			what[dep + 1][l + tl++] = what[dep][i];
		else
			what[dep + 1][mid + tr++] = what[dep][i];
		cnt[dep][i] = tl;
	}
	build(dep + 1, l, mid);
	build(dep + 1, mid, r);
}

int ask(int dep, int dl, int dr, int l, int r, int k) {
	//	cout &lt;&lt; dep &lt;&lt; " " &lt;&lt; dl &lt;&lt; " " &lt;&lt; dr &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt; k
	//			&lt;&lt; endl;
	if (l + 1 == r) {
		//		int value = seq[what[dep][l]].first;
		//		int name = seq[what[dep][l]].second;
		//		cout &lt;&lt; label[ord[name]] &lt;&lt; " == " &lt;&lt; value &lt;&lt; endl;
		return seq[what[dep][l]].second;
	}
	int ls = dl == l ? 0 : cnt[dep][l - 1], rs = cnt[dep][r - 1], mid = dl + dr
			&gt;&gt; 1;
	if (rs - ls &lt;= k)
		return ask(dep + 1, mid, dr, mid + l - dl - ls, mid + r - dl - rs, k
				- (rs - ls));
	else
		return ask(dep + 1, dl, mid, dl + ls, dl + rs, k);
}

void initPartitonTree() {
	for (int i = 0; i &lt; nVets; ++i) {
		seq[i].first = label[ord[i]];
		seq[i].second = i;
	}
	sort(seq, seq + nVets);
	for (int i = 0; i &lt; nVets; ++i) {
		what[0][seq[i].second] = i;
	}
	build(0, 0, nVets);
}

void answerQuestions() {
	int nQ;
	scanInt(nQ);
	for (int i = 0; i &lt; nQ; ++i) {
		int me, kth;
		scanInt(me);
		scanInt(kth);
		--me;
		int l = Left[me], r = Right[me];
		int cnt = r - l;
		//		cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt; cnt - kth &lt;&lt; endl;
		//		for (int i = l; i &lt; r; ++i) {
		//			cout &lt;&lt; label[ord[i]] &lt;&lt; " ";
		//		}
		////		cout &lt;&lt; endl;
		//		cout &lt;&lt; "ord:" &lt;&lt; ask(0, 0, nVets, l, r, cnt - kth) &lt;&lt; endl;
		printf("%d\n", ord[ask(0, 0, nVets, l, r, kth - 1)] + 1);
	}
}

void work() {
	makeDfsOrd();
	initPartitonTree();
	answerQuestions();
}

int main() {
	inputData();
	work();
}
</pre><pre></pre><h2>Problem1805</h2><pre>#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;set&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define CLR(x,c) memset(x,c,sizeof x)
using namespace std;

void setIO(string name){
	string inFile = name + ".in";
	string outFile = name + ".out";
	freopen(inFile.c_str(),"r",stdin);
	freopen(outFile.c_str(),"w",stdout);
}

struct Stf{
	int h,n;
	void read(){
		scanf("%d%d",&amp;h,&amp;n);
	}
	bool operator&lt;(const Stf&amp;s)const{
		return h&lt;s.h;
	}
};

const int MAX_N = 100000+10;
const int MAX_H = 100000+10;
Stf stfs[MAX_N];
int n;

void readInput(){
	scanf("%d",&amp;n);
	rep(i,n)
		stfs[i].read();
}

typedef long long int64;
const int INF = ~0U&gt;&gt;1;
set&lt;int&gt; nzs;
int d[MAX_N],H;
//d[i]=h[i]-h[i-1]
//h[0]=maxV

void addV(int at,int v){
	int o=d[at],n=d[at]+v;
	d[at]=n;
	if(o!=0&amp;&amp;n==0){
		nzs.erase(at);
	} else if(o==0&amp;&amp;n!=0){
		nzs.insert(at);
	}
}

void add(int L,int R){
	addV(L,1);
	addV(R+1,-1);
}

void debug(){
	int cur=MAX_H;
	for(int i=1;i&lt;=H;i++){
		cur+=d[i];
		cout&lt;&lt;cur&lt;&lt;" ";
	}
	cout&lt;&lt;endl;
}

int64 work(){
	sort(stfs,stfs+n);
	CLR(d,0);H=0;
	addV(1,-MAX_H);
	nzs.insert(MAX_H+1);
	rep(i,n){
		H=stfs[i].h;
		int num=stfs[i].n;
		int L=H-num+1,R=H;
		//h[L..R]++
		//d[L]+1,d[R+1]-1
		if(d[L]+1&gt;0){
			int a=*(--nzs.lower_bound(L));
			int b=*nzs.upper_bound(L)-1;
			if(b&gt;H)
				b=H;
			//[a..b]
			add(b+1,H);
			int cnt = H-b;
			int r = (R-L+1)-cnt;
			add(a,a+r-1);
		} else {
			add(L,R);
		}
	}
	
	int64 ans = 0;
	int cur=MAX_H;
	for(int i=1;i&lt;=H;i++){
		cur += d[i];
		ans += 1LL*cur*(cur-1)/2;
	}
	return ans;
}

void solve(){
//	setIO("sails");
	readInput();
	cout&lt;&lt;work()&lt;&lt;endl;
}

int main(){
	solve();
}
</pre><pre></pre><h2>Problem1812</h2><pre>/*
 *  [Ioi2005]riv.cpp
 *
 *  Created on: 2011-5-24
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VERTICES = 100 + 10;
const int MAX_N_FARMS = 50 + 10;

int w[MAX_N_VERTICES], fa[MAX_N_VERTICES], d[MAX_N_VERTICES];
int nVertices, nFarms;

void readInput() {
	scanf("%d%d", &amp;nVertices, &amp;nFarms);
	fa[0] = -1;
	for (int i = 1; i &lt;= nVertices; ++i) {
		scanf("%d%d%d", w + i, fa + i, d + i);
	}
}

int memo[MAX_N_VERTICES][MAX_N_VERTICES][MAX_N_FARMS];//u,anc,farms
int dep[MAX_N_VERTICES];

int dfs(int u, int ch, int anc, int nF) {
	while (ch &lt;= nVertices &amp;&amp; fa[ch] != u)
		++ch;
	if (ch == nVertices + 1)
		return 0;
	int&amp;ret = memo[ch][anc][nF];
	if (ret != -1)
		return ret;
	ret = INT_MAX;
	for (int atC = 0; atC &lt;= 1; ++atC) {
		for (int inC = 0; inC + atC &lt;= nF; ++inC) {
			int tmp = dfs(ch, 0, atC ? ch : anc, inC) + dfs(u, ch + 1, anc, nF
					- inC - atC);
			if (!atC)
				tmp += (dep[ch] - dep[anc]) * w[ch];
			ret = min(ret, tmp);
		}
	}
	return ret;
}

void dfs(int u, int _dep) {
	dep[u] = _dep;
	for (int i = 0; i &lt;= nVertices; ++i) {
		if (fa[i] == u)
			dfs(i, dep[u] + d[i]);
	}
}

void work() {
	dfs(0, 0);
	memset(memo, -1, sizeof memo);
	int ans = dfs(0, 0, 0, nFarms);
	cout &lt;&lt; ans &lt;&lt; endl;
}

void solve() {
	readInput();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem1814</h2><pre>/*
 *  Ural 1519 Formula 1.cpp
 *
 *  Created on: 2011-6-21
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 12;
char map[MAX_N][MAX_N + 1];
int n, m;

void readInput() {
	cin &gt;&gt; n &gt;&gt; m;
	for (int r = 0; r &lt; n; ++r) {
		scanf(" ");
		scanf("%s", map[r]);
	}
}

const int MAX_V_STATES = 1600000;
const int MAX_N_STATES = 50000;
const int NONE = 0, LEFT = 1, RIGHT = 2;
const int ADD[] = { 0, 1, -1 };
int states[MAX_N_STATES], nStates;
int stateToId[MAX_V_STATES];

int match[MAX_N_STATES][MAX_N + 1];
int pow3[MAX_N + 1];

void dfs(int at, int state, int balance) {
	if (at == m + 1) {
		if (balance == 0) {
			int id = nStates++;
			states[id] = state;
			stateToId[state] = id;
		}
		return;
	}
	for (int cur = 0; cur &lt; 3; ++cur) {
		int add = ADD[cur];
		if (balance + add &gt;= 0)
			dfs(at + 1, state + cur * pow3[at], balance + add);
	}
}

inline int get(int x, int at) {
	return x / pow3[at] % 3;
}

void prepare() {
	nStates = 0;
	pow3[0] = 1;
	for (int i = 1; i &lt;= m; ++i) {
		pow3[i] = pow3[i - 1] * 3;
	}
	dfs(0, 0, 0);

	for (int i = 0; i &lt; nStates; ++i) {
		int s = states[i];
		static int stack[MAX_N + 1];
		int top = 0;
		int*ma = match[i];
		for (int j = 0; j &lt;= m; ++j) {
			int w = get(s, j);
			if (w == NONE)
				continue;
			if (w == LEFT)
				stack[top++] = j;
			else {
				int l = stack[--top];
				ma[l] = j;
				ma[j] = l;
			}
		}
	}
}

typedef long long int64;

int64 dp[2][MAX_N_STATES];
int64*am = dp[0], *nam = dp[1];

inline void update(int ns, int64 cur) {
	nam[stateToId[ns]] += cur;
}

void work() {
	memset(am, 0, sizeof(int64) * nStates);
	am[stateToId[0]] = 1;
	int lr = -1, lc = -1;
	for (int r = 0; r &lt; n; ++r) {
		for (int c = 0; c &lt; m; ++c) {
			if (map[r][c] == '.')
				lr = r, lc = c;
		}
	}
	for (int r = 0; r &lt; n; ++r) {
		for (int c = 0; c &lt; m; ++c) {
			memset(nam, 0, sizeof(int64) * nStates);
			for (int id = 0; id &lt; nStates; ++id) {
				int64 cur = am[id];
				if (cur == 0)
					continue;
				int s = states[id];
				int p1 = get(s, c), p2 = get(s, c + 1);
				int w1 = pow3[c], w2 = pow3[c + 1];
				int cs = s - w1 * p1 - w2 * p2;
				if (map[r][c] == '*') {
					if (p1 == NONE &amp;&amp; p2 == NONE)
						update(cs, cur);
					continue;
				}
				if (p1 == NONE &amp;&amp; p2 == NONE) {
					if (r + 1 &lt; n &amp;&amp; c + 1 &lt; m)
						update(cs + w1 * LEFT + w2 * RIGHT, cur);
				} else if (p1 == LEFT &amp;&amp; p2 == LEFT) {
					int r = match[id][c + 1];
					int ns = cs + pow3[r] * (LEFT - RIGHT);
					update(ns, cur);
				} else if (p1 == RIGHT &amp;&amp; p2 == RIGHT) {
					int l = match[id][c];
					int ns = cs + pow3[l] * (RIGHT - LEFT);
					update(ns, cur);
				} else if (p1 == RIGHT &amp;&amp; p2 == LEFT) {
					update(cs, cur);
				} else if (p1 == LEFT &amp;&amp; p2 == RIGHT) {
					if (r == lr &amp;&amp; c == lc)
						update(cs, cur);
				} else {
					int t = p1 == NONE ? p2 : p1;
					if (r + 1 &lt; n)
						update(cs + w1 * t, cur);
					if (c + 1 &lt; m)
						update(cs + w2 * t, cur);
				}
			}
			swap(am, nam);
		}

		memset(nam, 0, sizeof(int64) * nStates);
		for (int id = 0; id &lt; nStates; ++id) {
			int s = states[id];
			int64 cur = am[id];
			if (cur == 0)
				continue;
			if (get(s, m) == NONE)
				update(s * 3, cur);
		}
		swap(am, nam);
	}

	int64 ans = am[0];
	cout &lt;&lt; ans &lt;&lt; endl;
}

void solve() {
	readInput();
	prepare();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem1816</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxn=100;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
ll A[maxn];int n;
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;n++;rep(i,n)cin&gt;&gt;A[i];
    sort(A,A+n);ll l=0,r=inf;
    while(l+1&lt;r)
    {
        ll m=l+r&gt;&gt;1,s=0;
        rep(i,n)if(A[i]&lt;m)s+=m-A[i];
        if(s&lt;=m)l=m;else r=m;
    }
    cout&lt;&lt;l&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1816</h2><pre>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=100;
using namespace std;
typedef long long ll;
ll A[maxn];int n;
int main()
{
    cin&gt;&gt;n;n++;rep(i,n)cin&gt;&gt;A[i];
    sort(A,A+n);ll l=0,r=inf;
    while(l+1&lt;r)
    {
        ll m=l+r&gt;&gt;1,s=0;
        rep(i,n)if(A[i]&lt;m)s+=m-A[i];
        if(s&lt;=m)l=m;else r=m;
    }
    cout&lt;&lt;l&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1818</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define All(x) x.begin(),x.end()
const int inf=~0U&gt;&gt;1,maxn=100000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n;
struct Index
{
    int A[maxn],n;
    Index(){n=0;}
    void Add(int x){A[n++]=x;}
    void DoIt()
    {
        sort(A,A+n);
        n=unique(A,A+n)-A;
    }
    int operator[](int v)
    {
        return lower_bound(A,A+n,v)-A;
    }
}IndexY;
struct TreeArray
{
    int A[maxn],n;
    TreeArray()
    {
        memset(A,0,sizeof A);
    }
    void SetN(int _n){n=_n;}
    void Add(int x,int d)
    {
        for(x++;x&lt;=n;x+=x&amp;-x)
            A[x-1]+=d;
    }
    int Sum(int x)
    {
        int ret=0;
        for(x++;x;x-=x&amp;-x)
            ret+=A[x-1];
        return ret;
    }
}TA;
map&lt;int,vector&lt;int&gt; &gt; Ps;
typedef map&lt;int,vector&lt;int&gt; &gt;::iterator mit;
multiset&lt;int&gt; Left,Right;
void Init()
{
    scanf("%d",&amp;n);int x,y;
    rep(i,n)
    {
        scanf("%d%d",&amp;x,&amp;y);
        Ps[x].pb(y);
        IndexY.Add(y);
    }
    IndexY.DoIt();
    for(mit it=Ps.begin();it!=Ps.end();it++)
    {
        vector&lt;int&gt;&amp;V=it-&gt;second;
        rep(i,V.size())V[i]=IndexY[V[i]],Right.insert(V[i]);
        sort(All(V));
    }
}
#define Contain(x,c) (x.find(c)!=x.end())
#define Delete(x,c) x.erase(x.find(c))
#define OK(x) (Contain(Left,x)&amp;&amp;Contain(Right,x))
inline void Update(int x,int d)
{
    int s=OK(x);
    if(d==1)Left.insert(x);
    else Delete(Right,x);
    TA.Add(x,OK(x)-s);
}
void Solve()
{
    ll ans=0;
    TA.SetN(IndexY.n);
    for(mit it=Ps.begin();it!=Ps.end();it++)
    {
        vector&lt;int&gt;&amp;V=it-&gt;second;
        int n=V.size();
        rep(i,n)Update(V[i],-1);
        ans+=TA.Sum(V[n-1])-TA.Sum(V[0]-1);
        rep(i,n)ans-=OK(V[i]);
        rep(i,n)Update(V[i],1);
    }
    cout&lt;&lt;ans+n&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


</pre><pre></pre><h2>Problem1818</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define All(x) x.begin(),x.end()
const int inf=~0U&gt;&gt;1,maxn=100000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n;
struct Index
{
    int A[maxn],n;
    Index(){n=0;}
    void Add(int x){A[n++]=x;}
    void DoIt()
    {
        sort(A,A+n);
        n=unique(A,A+n)-A;
    }
    int operator[](int v)
    {
        return lower_bound(A,A+n,v)-A;
    }
}IndexY;
struct TreeArray
{
    int A[maxn],n;
    TreeArray()
    {
        memset(A,0,sizeof A);
    }
    void SetN(int _n){n=_n;}
    void Add(int x,int d)
    {
        for(x++;x&lt;=n;x+=x&amp;-x)
            A[x-1]+=d;
    }
    int Sum(int x)
    {
        int ret=0;
        for(x++;x;x-=x&amp;-x)
            ret+=A[x-1];
        return ret;
    }
}TA;
map&lt;int,vector&lt;int&gt; &gt; Ps;
typedef map&lt;int,vector&lt;int&gt; &gt;::iterator mit;
int Left[maxn]={},Right[maxn]={};
void Init()
{
    scanf("%d",&amp;n);int x,y;
    rep(i,n)
    {
        scanf("%d%d",&amp;x,&amp;y);
        Ps[x].pb(y);
        IndexY.Add(y);
    }
    IndexY.DoIt();
    for(mit it=Ps.begin();it!=Ps.end();it++)
    {
        vector&lt;int&gt;&amp;V=it-&gt;second;
        rep(i,V.size())V[i]=IndexY[V[i]],Right[V[i]]++;
        sort(All(V));
    }
}
#define OK(x) (Left[x]&amp;&amp;Right[x])
inline void Update(int x,int d)
{
    int s=OK(x);
    if(d==1)Left[x]++;
    else Right[x]--;
    TA.Add(x,OK(x)-s);
}
void Solve()
{
    ll ans=0;
    TA.SetN(IndexY.n);
    for(mit it=Ps.begin();it!=Ps.end();it++)
    {
        vector&lt;int&gt;&amp;V=it-&gt;second;
        int n=V.size();
        rep(i,n)Update(V[i],-1);
        ans+=TA.Sum(V[n-1])-TA.Sum(V[0]-1);
        rep(i,n)ans-=OK(V[i]);
        rep(i,n)Update(V[i],1);
    }
    cout&lt;&lt;ans+n&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


</pre><pre></pre><h2>Problem1819</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;set&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1;
const int seed=131,maxl=20+10;
typedef unsigned long long ull;
struct Hash
{
    static const int size=17771;
    struct node
    {
        ull key;
        int num;
        node*next;
        node(ull _key,int _num,node*_n):key(_key),num(_num),next(_n){}
    }*H[size];
    Hash(){memset(H,0,sizeof(H));}
    int find(ull code)
    {
        int h=code%size;
        for(node*i=H[h];i;i=i-&gt;next)if(i-&gt;key==code)return i-&gt;num;
        return -1;
    }
    void insert(ull code,int num)
    {
        //cout&lt;&lt;"I"&lt;&lt;code&lt;&lt;endl;
        int h=code%size;
        H[h]=new node(code,num,H[h]);
    }
}hash;
ull Code(char*s)
{
    ull ret=0;
    while(*s) ret*=seed,ret+=*(s++);
    return ret;
}
int n,m;
void solve()
{
    static ull Power[maxl];
    char s[maxl];
    Power[0]=1;
    For(i,1,maxl-1)Power[i]=Power[i-1]*seed;
    scanf("%d %d",&amp;n,&amp;m);
    rep(i,n) scanf("%s\n",s),hash.insert(Code(s),i);
    ull Left[maxl],Right[maxl];
    while(m--)
    {
        scanf("%s\n",s);ull t=Code(s),x,ret=0,l=strlen(s),tmp;
        set&lt;int&gt; S;
        if(hash.find(t)!=-1){printf("-1\n");continue;}
        //Replace a letter1
        for(int i=0;i&lt;l;i++)
        {
            for(char c='a';c&lt;='z';c++)if(c!=s[i])
                if((tmp=hash.find(t+Power[l-i-1]*(c-s[i])))!=-1)
                    S.insert(tmp);
        }
        //Cal the Left Hash value ans the Right Hash value
        Left[0]=0;
        for(int i=1;i&lt;=l;i++)
            Left[i]=Left[i-1]*seed+s[i-1];
        Right[l+1]=0;
        for(int i=l;i&gt;=1;i--)
            Right[i]=Right[i+1]+Power[l-i]*s[i-1];
        //Delete a letter
        for(int i=1;i&lt;=l;i++)
        {
            ull x=Left[i-1]*Power[l-i]+Right[i+1];
            if((tmp=hash.find(x))!=-1)S.insert(tmp);//cout&lt;&lt;"D"&lt;&lt;endl;
        }
        //Insert a letter
        for(int i=0;i&lt;=l;i++)
        {
            ull x=Left[i]*Power[l-i+1]+Right[i+1];
            for(char c='a';c&lt;='z';c++)if((tmp=hash.find(x+Power[l-i]*c))!=-1)S.insert(tmp);//cout&lt;&lt;"I"&lt;&lt;endl;
        }
        printf("%d\n",S.size());
    }
}
int main()
{
    //freopen("in","r",stdin);
    solve();
}
</pre><pre></pre><h2>Problem1820</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
typedef long long ll;
const int maxn=200+10,maxp=1000+10;
const int inf=~0U&gt;&gt;1;
int Dist[maxn][maxn];
int Dp[2][maxn][maxn];
int A[maxp],n,p=0;
void Init()
{
    scanf("%d",&amp;n);
    rep(i,n) rep(j,n)scanf("%d",&amp;Dist[i][j]);
    A[p++]=0;
    while(scanf("%d",A+p)==1)--A[p++];
}
inline void Update(int&amp;x,int c){x=min(x,c);}
void Work()
{
    int now=0,next=1;int cost;
    rep(j,n) rep(k,n) Dp[next][j][k]=inf;
    Dp[next][1][2]=0;
    rep(i,p-1)
    {
        swap(now,next);
        rep(j,n) rep(k,n) Dp[next][j][k]=inf;
        rep(j,n) rep(k,n) if((cost=Dp[now][j][k])!=inf)
        {
            //use the car in previous place
            Update(Dp[next][j][k],cost+Dist[A[i]][A[i+1]]);
            //use other two car
            Update(Dp[next][A[i]][j],cost+Dist[k][A[i+1]]);
            Update(Dp[next][A[i]][k],cost+Dist[j][A[i+1]]);
        }
    }
    int Ans=inf;
    rep(j,n) rep(k,n) Update(Ans,Dp[next][j][k]);
    cout&lt;&lt;Ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Work();
}
</pre><pre></pre><h2>Problem1820</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
typedef long long ll;
const int maxn=200+10,maxp=1000+10;
const int inf=~0U&gt;&gt;1;
int Dist[maxn][maxn];
int Dp[2][maxn][maxn];
int A[maxp],n,p=0;
void Init()
{
    scanf("%d",&amp;n);
    rep(i,n) rep(j,n)scanf("%d",&amp;Dist[i][j]);
    A[p++]=0;
    while(scanf("%d",A+p)==1)--A[p++];
}
inline void Update(int&amp;x,int c){x=min(x,c);}
void Work()
{
    int now=0,next=1;int cost;
    rep(j,n) rep(k,j+1) Dp[next][j][k]=inf;
    Dp[next][2][1]=0;
    rep(i,p-1)
    {
        swap(now,next);
        rep(j,n) rep(k,j+1) Dp[next][j][k]=inf;
        rep(j,n) rep(k,j+1) if((cost=Dp[now][j][k])!=inf)
        {
            //use the car in previous place
            Update(Dp[next][max(j,k)][min(j,k)],cost+Dist[A[i]][A[i+1]]);
            //use other two car
            Update(Dp[next][max(A[i],j)][min(j,A[i])],cost+Dist[k][A[i+1]]);
            Update(Dp[next][max(A[i],k)][min(A[i],k)],cost+Dist[j][A[i+1]]);
        }
    }
    int Ans=inf;
    rep(j,n) rep(k,j+1) Update(Ans,Dp[next][j][k]);
    cout&lt;&lt;Ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Work();
}
</pre><pre></pre><h2>Problem1820</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
typedef long long ll;
const int maxn=200+10,maxp=1000+10;
const int inf=~0U&gt;&gt;1;
int Dist[maxn][maxn];
int Dp[2][maxn][maxn];
int A[maxp],n,p=0;
void Init()
{
    scanf("%d",&amp;n);
    rep(i,n) rep(j,n)scanf("%d",&amp;Dist[i][j]);
    A[p++]=0;
    while(scanf("%d",A+p)==1)--A[p++];
}
void Work()
{
    int now=0,next=1;int cost;
    rep(j,n) rep(k,j+1) Dp[next][j][k]=inf;
    Dp[next][2][1]=0;
    rep(i,p-1)
    {
        swap(now,next);
        rep(j,n) rep(k,j+1) Dp[next][j][k]=inf;
        rep(j,n) rep(k,j+1) if((cost=Dp[now][j][k])!=inf)
        {
            Dp[next][max(j,k)][min(j,k)]&lt;?=cost+Dist[A[i]][A[i+1]];
            Dp[next][max(A[i],j)][min(j,A[i])]&lt;?=cost+Dist[k][A[i+1]];
            Dp[next][max(A[i],k)][min(A[i],k)]&lt;?=cost+Dist[j][A[i+1]];
        }
    }
    int Ans=inf;
    rep(j,n) rep(k,j+1) Ans&lt;?=Dp[next][j][k];
    cout&lt;&lt;Ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Work();
}
</pre><pre></pre><h2>Problem1820</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
typedef long long ll;
const int maxn=200+10,maxp=1000+10;
const int inf=~0U&gt;&gt;1;
int Dist[maxn][maxn];
int Dp[2][maxn][maxn];
int A[maxp],n,p=0;
void Init()
{
    scanf("%d",&amp;n);
    rep(i,n) rep(j,n)scanf("%d",&amp;Dist[i][j]);
    A[p++]=0;
    while(scanf("%d",A+p)==1)--A[p++];
}
inline void Update(int&amp;x,int c){if(x==-1||x&gt;c)x=c;}
void Work()
{
    int now=0,next=1;int cost;
    memset(Dp[next],-1,sizeof Dp[next]);
    Dp[next][2][1]=0;
    rep(i,p-1)
    {
        swap(now,next);
        memset(Dp[next],-1,sizeof Dp[next]);
        rep(j,n) rep(k,j+1) if((cost=Dp[now][j][k])!=-1)
        {
            Update(Dp[next][max(j,k)][min(j,k)],cost+Dist[A[i]][A[i+1]]);
            Update(Dp[next][max(A[i],j)][min(j,A[i])],cost+Dist[k][A[i+1]]);
            Update(Dp[next][max(A[i],k)][min(A[i],k)],cost+Dist[j][A[i+1]]);
        }
    }
    int Ans=-1;
    rep(j,n) rep(k,j+1)if(Dp[next][j][k]!=-1)Update(Ans,Dp[next][j][k]);
    cout&lt;&lt;Ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Work();
}
</pre><pre></pre><h2>Problem1821</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;utility&gt;
#include&lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=1000+10;
typedef pair&lt;int,int&gt; ii;
typedef pair&lt;int,ii&gt; Edge;
Edge Es[maxn*maxn/2];
ii P[maxn];
int F[maxn];
int find(int x){return x==F[x]?x:(F[x]=find(F[x]));}
int n,k,cnt=0;
int Dist(ii a,ii b)
{
    int x=a.first-b.first,y=a.second-b.second;
    return x*x+y*y;
}
void Init()
{
    scanf("%d %d",&amp;n,&amp;k);
    rep(i,n) scanf("%d %d",&amp;P[i].first,&amp;P[i].second),F[i]=i;
    rep(i,n) rep(j,i) Es[cnt++]=Edge(Dist(P[i],P[j]),ii(i,j));
}
void Work()
{
    sort(Es,Es+cnt);Edge*i=Es;
    while(true)
    {
        int a=i-&gt;second.first,b=i-&gt;second.second;
        a=find(a),b=find(b);
        if(a!=b)
        {
            if(n&gt;k) F[a]=b,--n;
            else{printf("%0.2lf\n",sqrt(i-&gt;first));break;}
        }
        ++i;
    }
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Work();
}
</pre><pre></pre><h2>Problem1822</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;3,maxn=200+10;
struct Point //点
{
    int x,y;
    Point(){}
    Point(int _x,int _y):x(_x),y(_y){}
};
Point operator+(const Point&amp;a,const Point&amp;b)
{
    return Point(a.x+b.x,a.y+b.y);
}
Point operator-(const Point&amp;a,const Point&amp;b)
{
    return Point(a.x-b.x,a.y-b.y);
}
int operator*(const Point&amp;a,const Point&amp;b)
{
    return a.x*b.y-a.y*b.x;
}
struct Lich //巫妖
{
    Point p;
    int r,t;
    Lich(){}
    Lich(int x,int y,int _r,int _t):p(x,y),r(_r),t(_t){}
}Lichs[maxn];
typedef Point Spirit;
Spirit Spirits[maxn];
struct Tree
{
    Point p;
    int r;
    Tree(){}
    Tree(int x,int y,int _r):p(x,y),r(_r){}
}Trees[maxn];
int nLich,nTree,nSpirit;
double eps=1e-8;
int cmp(double x)
{
    if(abs(x)&lt;eps)return 0;
    return x&lt;0?-1:1;
}
double Dist(Point a,Point b)
{
    double x=a.x-b.x,y=a.y-b.y;
    return sqrt(x*x+y*y);
}
double DistToLine(Point a,Point b,Point t)
{
    return abs((t-a)*(t-b))/Dist(a,b);
}
bool OnPath(Point a,Point b,Tree t)
{
    //cout&lt;&lt;DistToLine(a,b,t.p)&lt;&lt;" "&lt;&lt;t.r&lt;&lt;endl;
    return cmp(DistToLine(a,b,t.p)-t.r)==-1;
}
bool CanAttack(Lich l,Spirit s)
{
    if(cmp(l.r-Dist(l.p,s))==-1) return false;
    rep(i,nTree)
        if(OnPath(l.p,s,Trees[i])) return false;
    return true;
}
void Init()
{
    scanf("%d %d %d",&amp;nLich,&amp;nSpirit,&amp;nTree);
    int x,y,r,t;
    rep(i,nLich)scanf("%d %d %d %d",&amp;x,&amp;y,&amp;r,&amp;t),Lichs[i]=Lich(x,y,r,t);
    rep(i,nSpirit) scanf("%d %d",&amp;x,&amp;y),Spirits[i]=Spirit(x,y);
    rep(i,nTree) scanf("%d %d %d",&amp;x,&amp;y,&amp;r),Trees[i]=Tree(x,y,r);
}
inline int nodeLich(int i){return i;}
inline int nodeSpirit(int i){return nLich+i;}
const int maxv=maxn*2;
struct Edge
{
    int t,c;
    Edge*next,*op;
    Edge(int _t,int _c,Edge*_next):t(_t),c(_c),next(_next){}
}*E[maxv];
int vs,vt,h[maxv],vh[maxv],v;
void InsEdge(int s,int t,int c)
{
    E[s]=new Edge(t,c,E[s]);
    E[t]=new Edge(s,0,E[t]);
    E[s]-&gt;op=E[t];E[t]-&gt;op=E[s];
}
void BuildGraph(int Limit)
{
    v=nLich+nSpirit+2;vs=v-1;vt=v-2;
    rep(i,nLich) InsEdge(vs,nodeLich(i),Limit/Lichs[i].t+1);
    rep(i,nSpirit) InsEdge(nodeSpirit(i),vt,1);
    rep(i,nLich)rep(j,nSpirit)
        if(CanAttack(Lichs[i],Spirits[j]))
            InsEdge(nodeLich(i),nodeSpirit(j),1);
}
int aug(int no,int m)
{
    if(no==vt) return m;
    int l=m,minh=v;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;c)
    {
        if(h[no]==h[i-&gt;t]+1)
        {
            int d=aug(i-&gt;t,min(l,i-&gt;c));
            i-&gt;c-=d,i-&gt;op-&gt;c+=d,l-=d;
            if(!l||h[vs]==v)return m-l;
        }
        minh=min(minh,h[i-&gt;t]+1);
    }
    if(!--vh[h[no]]) h[vs]=v;
    vh[h[no]=minh]++;
    return m-l;
}
int CalFlow()
{
    int flow=0;
    memset(h,0,sizeof(h));
    memset(vh,0,sizeof(vh));
    vh[0]=v;
    while(h[vs]&lt;v) flow+=aug(vs,inf);
    return flow;
}
bool Check(int Limit)
{
    memset(E,0,sizeof(E));
    BuildGraph(Limit);
    return CalFlow()==nSpirit;
}
void Work()
{
    int l=0,r=inf;
    if(!Check(r)){printf("-1\n");return;}
    if(Check(l)){printf("%d\n",l);return;}
    while(l+1&lt;r)
    {
        int m=(l+r)/2;
        if(Check(m)) r=m;
        else l=m;
    }
    printf("%d\n",r);
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Work();
}
</pre><pre></pre><h2>Problem1822</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;3,maxn=200+10;
typedef vector&lt;int&gt; vi;
struct Point //点
{
    int x,y;
    Point(){}
    Point(int _x,int _y):x(_x),y(_y){}
};
Point operator+(const Point&amp;a,const Point&amp;b)
{
    return Point(a.x+b.x,a.y+b.y);
}
Point operator-(const Point&amp;a,const Point&amp;b)
{
    return Point(a.x-b.x,a.y-b.y);
}
int operator*(const Point&amp;a,const Point&amp;b)
{
    return a.x*b.y-a.y*b.x;
}
struct Lich //巫妖
{
    Point p;
    int r,t;
    Lich(){}
    Lich(int x,int y,int _r,int _t):p(x,y),r(_r),t(_t){}
}Lichs[maxn];
typedef Point Spirit;
Spirit Spirits[maxn];
struct Tree
{
    Point p;
    int r;
    Tree(){}
    Tree(int x,int y,int _r):p(x,y),r(_r){}
}Trees[maxn];
int nLich,nTree,nSpirit;
double eps=1e-8;
int cmp(double x)
{
    if(abs(x)&lt;eps)return 0;
    return x&lt;0?-1:1;
}
double Dist(Point a,Point b)
{
    double x=a.x-b.x,y=a.y-b.y;
    return sqrt(x*x+y*y);
}
double DistToLine(Point a,Point b,Point t)
{
    return abs((t-a)*(t-b))/Dist(a,b);
}
bool OnPath(Point a,Point b,Tree t)
{
    //cout&lt;&lt;DistToLine(a,b,t.p)&lt;&lt;" "&lt;&lt;t.r&lt;&lt;endl;
    return cmp(DistToLine(a,b,t.p)-t.r)==-1;
}
bool CanAttack(Lich l,Spirit s)
{
    if(cmp(l.r-Dist(l.p,s))==-1) return false;
    rep(i,nTree)
        if(OnPath(l.p,s,Trees[i])) return false;
    return true;
}
void Init()
{
    scanf("%d %d %d",&amp;nLich,&amp;nSpirit,&amp;nTree);
    int x,y,r,t;
    rep(i,nLich)scanf("%d %d %d %d",&amp;x,&amp;y,&amp;r,&amp;t),Lichs[i]=Lich(x,y,r,t);
    rep(i,nSpirit) scanf("%d %d",&amp;x,&amp;y),Spirits[i]=Spirit(x,y);
    rep(i,nTree) scanf("%d %d %d",&amp;x,&amp;y,&amp;r),Trees[i]=Tree(x,y,r);
}
inline int nodeLich(int i){return i;}
inline int nodeSpirit(int i){return nLich+i;}
const int maxv=maxn*2;
struct Edge
{
    int t,c;
    Edge*next,*op;
    Edge(int _t,int _c,Edge*_next):t(_t),c(_c),next(_next){}
}*E[maxv];
int vs,vt,h[maxv],vh[maxv],v;
void InsEdge(int s,int t,int c)
{
    E[s]=new Edge(t,c,E[s]);
    E[t]=new Edge(s,0,E[t]);
    E[s]-&gt;op=E[t];E[t]-&gt;op=E[s];
}
vi CanAttacks[maxn];
void CalAttacks()
{
    rep(i,nLich)rep(j,nSpirit)
        if(CanAttack(Lichs[i],Spirits[j]))
            CanAttacks[nodeLich(i)].pb(nodeSpirit(j));
}
void BuildGraph(int Limit)
{
    v=nLich+nSpirit+2;vs=v-1;vt=v-2;
    rep(i,nLich) InsEdge(vs,nodeLich(i),Limit/Lichs[i].t+1);
    rep(i,nSpirit) InsEdge(nodeSpirit(i),vt,1);
    rep(i,nLich)for(vi::iterator e=CanAttacks[i].begin();e!=CanAttacks[i].end();++e)
        InsEdge(i,*e,1);
}
int aug(int no,int m)
{
    if(no==vt) return m;
    int l=m,minh=v;
    for(Edge*i=E[no];i;i=i-&gt;next)if(i-&gt;c)
    {
        if(h[no]==h[i-&gt;t]+1)
        {
            int d=aug(i-&gt;t,min(l,i-&gt;c));
            i-&gt;c-=d,i-&gt;op-&gt;c+=d,l-=d;
            if(!l||h[vs]==v)return m-l;
        }
        minh=min(minh,h[i-&gt;t]+1);
    }
    if(!--vh[h[no]]) h[vs]=v;
    vh[h[no]=minh]++;
    return m-l;
}
int CalFlow()
{
    int flow=0;
    memset(h,0,sizeof(h));
    memset(vh,0,sizeof(vh));
    vh[0]=v;
    while(h[vs]&lt;v) flow+=aug(vs,inf);
    return flow;
}
bool Check(int Limit)
{
    memset(E,0,sizeof(E));
    BuildGraph(Limit);
    return CalFlow()==nSpirit;
}
void Work()
{
    int l=0,r=inf;CalAttacks();
    if(!Check(r)){printf("-1\n");return;}
    if(Check(l)){printf("%d\n",l);return;}
    while(l+1&lt;r)
    {
        int m=(l+r)/2;
        if(Check(m)) r=m;
        else l=m;
    }
    printf("%d\n",r);
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Work();
}
</pre><pre></pre><h2>Problem1823</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;stack&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int inf=~0U&gt;&gt;1,maxn=100*2;
struct Edge
{
    int t;Edge*next;
    Edge(int _t,Edge* _next):t(_t),next(_next){}
}*E[maxn]={0};
void AddEdge(int s,int t){E[s]=new Edge(t,E[s]);}
int n,m;
inline int node(int i,bool j){return i*2+j;}
int low[maxn],ord[maxn],id[maxn],cnt,snt;bool instack[maxn];
stack&lt;int&gt; S;
int dfs(int x)
{
    low[x]=ord[x]=++cnt;
    S.push(x);instack[x]=true;
    for(Edge*e=E[x];e;e=e-&gt;next)
        if(!ord[e-&gt;t]) low[x]=min(low[x],dfs(e-&gt;t));
        else if(instack[e-&gt;t]) low[x]=min(low[x],ord[e-&gt;t]);
    if(low[x]==ord[x])
    {
        int u;
        do{u=S.top();S.pop();id[u]=snt;instack[u]=false;}while(u!=x);
        snt++;
    }
    return low[x];
}
void Tarjan()
{
    memset(ord,0,sizeof(ord));
    memset(instack,0,sizeof(instack));
    cnt=snt=0;
    rep(i,2*n)if(!ord[i])dfs(i);
}
bool Judge()
{
    rep(i,n) if(id[2*i]==id[2*i+1])return false;
    return true;
}
void solve()
{
    scanf("%d %d\n",&amp;n,&amp;m);bool c[2];int x[2];char t;
    memset(E,0,sizeof(E));
    while(m--)
    {
        rep(i,2)scanf("%c%d\n",&amp;t,x+i),--x[i],c[i]=t=='h';
        rep(i,2) AddEdge(node(x[i],!c[i]),node(x[1-i],c[1-i]));
    }
    Tarjan();
    if(Judge())cout&lt;&lt;"GOOD"&lt;&lt;endl;
    else cout&lt;&lt;"BAD"&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    int t;cin&gt;&gt;t;while(t--)solve();
}
</pre><pre></pre><h2>Problem1824</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int MAX_N=5000;
struct Point{
	int x,y;
	bool operator&lt;(const Point&amp;p)const{
		return x&lt;p.x;
	}
	bool operator==(const Point&amp;p)const{
		return x==p.x&amp;&amp;y==p.y;
	}
	bool operator!=(const Point&amp;p)const{
		return x!=p.x||y!=p.y;
	}
	void read(){
		scanf("%d%d",&amp;x,&amp;y);
	}
	void write(){
		cout&lt;&lt;"("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;")";
	}
	void refX(){x=-x;}
	void refY(){y=-y;}
};

int nPs;
int pCnt;
Point ps[MAX_N];
void inputData(){
	scanf("%d",&amp;pCnt);
	rep(i,pCnt)
		ps[i].read();
}

Point RU[MAX_N],LU[MAX_N],LD[MAX_N],RD[MAX_N];
int nRU,nLU,nLD,nRD;

void orderIt(Point qs[MAX_N],int nQs){
	if(nQs&gt;1&amp;&amp;qs[0].x&gt;qs[1].x)
		reverse(qs,qs+nQs);
}

void doit(Point RU[MAX_N],int&amp;nRU){
	if(!nRU)return;
	orderIt(RU,nRU);

	int cRU=0;
	RU[cRU++]=RU[0];
	for(int i=1;i&lt;nRU;i++){
		if(RU[i].y&lt;RU[cRU-1].y)
			RU[cRU++]=RU[i];
	}

	nRU=cRU;
}

void refX(Point qs[MAX_N],int nQs){
	rep(i,nQs)
		qs[i].refX();
}

void refY(Point qs[MAX_N],int nQs){
	rep(i,nQs)
		qs[i].refY();
}

int countMinus(Point RU[MAX_N],int nRU,Point LU[MAX_N],int nLU,
			   Point LD[MAX_N],int nLD,Point RD[MAX_N],int nRD){
	int minus=0;
	int atLU=nLU-1,atRD=-1;
	int LUtoLD=nLD,RDtoLD=nLD-1;
	for(int atRU=0;atRU&lt;nRU;atRU++){
		Point p=RU[atRU];
		while(atLU&gt;=0&amp;&amp;LU[atLU].y&gt;p.y)
			--atLU;
		while(atRD+1&lt;nRD&amp;&amp;RD[atRD+1].x&lt;p.x)
			++atRD;
		int left;
		if(atLU&gt;=0&amp;&amp;LU[atLU].y&lt;p.y){
			Point np=LU[atLU];
			int&amp;cLD=LUtoLD;
			while(cLD&gt;0&amp;&amp;LD[cLD-1].x&gt;np.x)
				--cLD;
			if(cLD&lt;nLD&amp;&amp;LD[cLD].x&gt;np.x)
				left=cLD;
			else
				left=nLD;
		} else {
			left=0;
		}

		int right;

		if(atRD&gt;=0&amp;&amp;RD[atRD].x&lt;p.x){
			Point np=RD[atRD];
			int&amp;cLD=RDtoLD;
			while(cLD&gt;=0&amp;&amp;LD[cLD].y&lt;np.y)
				--cLD;
			if(cLD&gt;=0&amp;&amp;LD[cLD].y&gt;np.y)
				right=cLD;
			else
			 	right=-1;
		} else {
			right=nLD-1;
		}
		if(left&lt;=right){
			minus+=right-left+1;
		}
	}
	return minus;
}

void count(const Point&amp;o,int&amp;add,int&amp;minus){
	add=0;minus=0;
	nRU=nLU=nLD=nRD=0;
	rep(i,nPs){
		Point p=ps[i];
		if(p==o)continue;
		int a=p.x&gt;o.x;int b=p.y&gt;o.y;
		if(a&amp;&amp;b){//RU
			RU[nRU++]=p;
		} else if(!a&amp;&amp;b){//LU
			LU[nLU++]=p;
		} else if(!a&amp;&amp;!b){//LD
			LD[nLD++]=p;
		} else {//RD
			RD[nRD++]=p;
		}
	}

	//RU
	{
		doit(RU,nRU);
		orderIt(RU,nRU);
	}
	//LU
	{
		refX(LU,nLU);
		doit(LU,nLU);
		refX(LU,nLU);
		orderIt(LU,nLU);
	}
	//LD
	{
		refX(LD,nLD);
		refY(LD,nLD);
		doit(LD,nLD);
		refX(LD,nLD);
		refY(LD,nLD);
		orderIt(LD,nLD);
	}
	//RD
	{
		refY(RD,nRD);
		doit(RD,nRD);
		refY(RD,nRD);
		orderIt(RD,nRD);
	}

	add=nRU+nLU+nLD+nRD;

	minus=0;
	{
		minus+=countMinus(RU,nRU,LU,nLU,LD,nLD,RD,nRD);
	}
	{
		refX(RU,nRU);orderIt(RU,nRU);
		refX(LU,nLU);orderIt(LU,nLU);
		refX(LD,nLD);orderIt(LD,nLD);
		refX(RD,nRD);orderIt(RD,nRD);
		minus+=countMinus(LU,nLU,RU,nRU,RD,nRD,LD,nLD);
	}
}

void work(){
	nPs=0;
	int curAns=0;
	long long sA=0,sB=0;
	rep(i,pCnt){
		int add,minus;
		Point p=ps[i];
		count(p,add,minus);
		ps[nPs++]=p;
		int at=nPs-1;
		while(at&gt;0&amp;&amp;ps[at].x&lt;ps[at-1].x)
			swap(ps[at],ps[at-1]),--at;
		curAns+=add;curAns-=minus;
		if(i%2==0)
			sA+=curAns;
		else
			sB+=curAns;
	}

	cout&lt;&lt;sA&lt;&lt;" "&lt;&lt;sB&lt;&lt;endl;
}

void solve(){
	inputData();
	work();
}

int main(){
	solve();
}
</pre><pre></pre><h2>Problem1827</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(vector&lt;Edge&gt;::iterator e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1,maxn=100000;
using namespace std;
typedef long long ll;
struct Edge
{
    int t,c;
    Edge(int _t,int _c):
        t(_t),c(_c){}
};
int N;
vector&lt;Edge&gt; E[maxn];
void AddEdge(int s,int t,int c)
{
    E[s].pb(Edge(t,c));
    E[t].pb(Edge(s,c));
}
int Q[maxn],F[maxn],h,t;
int C[maxn];
ll Size[maxn];
ll Ans[maxn];
void BFS(int vs)
{
    h=t=0;
    for(Q[t++]=vs,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,E[x])if(e-&gt;t!=F[x])
            Q[t++]=e-&gt;t,F[e-&gt;t]=x;
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=C[x];
        Ans[x]=0;
        tr(e,E[x])if(F[e-&gt;t]==x)
        {
            Size[x]+=Size[e-&gt;t];
            Ans[x]+=(e-&gt;c*Size[e-&gt;t])+Ans[e-&gt;t];
        }
    }
    ll ret=1LL&lt;&lt;60;
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i];
        ret=min(ret,Ans[x]);
        tr(e,E[x])if(e-&gt;t!=F[x])
        {
            ll Down=Size[e-&gt;t],Up=Size[vs]-Down;
            Ans[e-&gt;t]=Ans[x]+Up*e-&gt;c-Down*e-&gt;c;
        }
    }
    cout&lt;&lt;ret&lt;&lt;endl;
}
int nextInt()
{
    int ret=0;char c;
    while(c=getchar(),c&lt;'0'||c&gt;'9');
    ret=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')ret=ret*10+c-'0';
    return ret;
}
void Init()
{
    N=nextInt();
    rep(i,N)C[i]=nextInt();
    int s,t,c;
    rep(i,N-1)
    {
        s=nextInt();t=nextInt();c=nextInt();
        --s;--t;
        AddEdge(s,t,c);
    }
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    BFS(0);
}


</pre><pre></pre><h2>Problem1828</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
using namespace std;
const int maxn=100000,inf=~0U&gt;&gt;1;
struct seg
{
    int l,r;
    seg(){}
    seg(int _l,int _r):
        l(_l),r(_r){}
    bool operator&lt;(const seg&amp;s)const
    {
        return r!=s.r?r&lt;s.r:l&gt;s.l;
    }
    seg left()
    {
        return seg(l,l+r&gt;&gt;1);
    }
    seg right()
    {
        return seg(l+r&gt;&gt;1,r);
    }
    bool inter(seg a)
    {
        return !(a.l&gt;=r||l&gt;=a.r);
    }
    bool contain(seg a)
    {
        return a.l&gt;=l&amp;&amp;a.r&lt;=r;
    }
    int size(){return r-l;}
}S[maxn];
int A[maxn],n,m;
int Mark[4*maxn]={},Min[4*maxn];
void Update(int t)
{
    Min[t]=min(Min[t*2],Min[t*2+1]);
}
void build(int t,seg s)
{
    if(s.size()==1)
    {
        Min[t]=A[s.l];
        return;
    }
    build(t*2,s.left());
    build(t*2+1,s.right());
    Update(t);
}
void MarkIt(int t,int add)
{
    Mark[t]+=add;
    Min[t]+=add;
}
void PushDown(int t)
{
    if(Mark[t])
        MarkIt(t*2,Mark[t]),
        MarkIt(t*2+1,Mark[t]);
    Mark[t]=0;
}
int AskMin(int t,seg s,seg q)
{
    if(!s.inter(q)) return inf;
    if(q.contain(s)) return Min[t];
    PushDown(t);
    return min(AskMin(t*2,s.left(),q),AskMin(t*2+1,s.right(),q));
}
void ChangeDec(int t,seg s,seg q,int add)
{
    if(!s.inter(q))return;
    if(q.contain(s)){MarkIt(t,add);return;}
    PushDown(t);
    ChangeDec(t*2,s.left(),q,add);
    ChangeDec(t*2+1,s.right(),q,add);
    Update(t);
}
void Init()
{
    scanf("%d%d",&amp;n,&amp;m);
    rep(i,n)scanf("%d",A+i);int l,r;
    rep(i,m)
    {
        scanf("%d%d",&amp;l,&amp;r);
        S[i]=seg(l-1,r);
    }
    sort(S,S+m);
}
void Solve()
{
    seg root(0,n);
    build(1,root);
    int ans=0;
    rep(i,m)
    {
        if(AskMin(1,root,S[i])&gt;0)
        {
            ans++;
            ChangeDec(1,root,S[i],-1);
        }
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


</pre><pre></pre><h2>Problem1829</h2><pre>/*
 * [Usaco2010 Mar]starc星际争霸.cpp
 *
 *  Created on: 2011-3-9
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
		x(_x), y(_y) {
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	Point operator*(double d) const {
		return Point(x * d, y * d);
	}
	Point operator/(double d) const {
		return Point(x / d, y / d);
	}
	double det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	double dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	Point rot90() const {
		return Point(-y, x);
	}
	void read() {
		scanf("%lf%lf", &amp;x, &amp;y);
	}
	void write() const {
		printf("%lf %lf", x, y);
	}
};

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))

const double EPS = 1e-8;
inline int sign(double a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}

#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))

Point isSS(Point p1, Point p2, Point q1, Point q2) {
	double a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);
	return (p1 * a2 + p2 * a1) / (a1 + a2);
}

vector&lt;Point&gt; makeVector(double a, double b, double c) {
	//ax+by+c &gt; 0
	Point normal(a, b);
	vector&lt;Point&gt; ret;
	Point p1;
	if (sign(b) == 0) {
		double x0 = (-c) / a;
		p1 = Point(x0, 0);
	} else {
		double x0 = 0;
		double y0 = (-c) / b;
		p1 = Point(x0, y0);
	}
	Point p2 = p1 - normal.rot90();
	ret.push_back(p1);
	ret.push_back(p2);
	return ret;
}

vector&lt;Point&gt; convexCut(const vector&lt;Point&gt;&amp;ps, Point q1, Point q2) {
	vector&lt;Point&gt; qs;
	int n = ps.size();
	for (int i = 0; i &lt; n; ++i) {
		Point p1 = ps[i], p2 = ps[(i + 1) % n];
		int d1 = crossOp(q1,q2,p1), d2 = crossOp(q1,q2,p2);
		if (d1 &gt;= 0)
			qs.push_back(p1);
		if (d1 * d2 &lt; 0)
			qs.push_back(isSS(p1, p2, q1, q2));
	}
	return qs;
}

double calcArea(const vector&lt;Point&gt;&amp;ps) {
	int n = ps.size();
	double ret = 0;
	for (int i = 0; i &lt; n; ++i) {
		ret += ps[i].det(ps[(i + 1) % n]);
	}
	return ret / 2;
}

vector&lt;Point&gt; can;

void addConstraint(double a,double b,double c){
	//ax+by+c &gt; 0
	vector&lt;Point&gt; qs = makeVector(a, b, c);
	can = convexCut(can, qs[0], qs[1]);
//	cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" "&lt;&lt;c&lt;&lt;endl;

}

void addBeat(int a1, int b1, int c1, int a2, int b2, int c2) {
	//a1*x+b1*y+c1 &gt; a2*x+b2*y+c2
	addConstraint(a1-a2,b1-b2,c1-c2);
}

void doEstimate(int a1, int b1, int c1, int a2, int b2, int c2) {
//	cout&lt;&lt;calcArea(can)&lt;&lt;endl;
	vector&lt;Point&gt; qs = makeVector(a1 - a2, b1 - b2, c1 - c2);
//	qs[0].write();cout&lt;&lt;"&lt;-&gt;";qs[1].write();cout&lt;&lt;endl;
	vector&lt;Point&gt; left = convexCut(can, qs[0], qs[1]);
	vector&lt;Point&gt; right = convexCut(can, qs[1], qs[0]);
	if (right.size() == 0) {
		puts("J");
	} else if (left.size() == 0) {
		puts("B");
	} else {
		puts("U");
	}
}

const double BIGEST = 1e2;
const double SMALLEST = 1e-2;

vector&lt;Point&gt; bigSquare() {
	vector&lt;Point&gt; ps;
	ps.push_back(Point(SMALLEST, SMALLEST));
	ps.push_back(Point(BIGEST, SMALLEST));
	ps.push_back(Point(BIGEST, BIGEST));
	ps.push_back(Point(SMALLEST, BIGEST));
	return ps;
}

void solve() {
	can = bigSquare();
	addConstraint(-1,100,0);
	addConstraint(100,-1,0);
	int nBattles, nQuestions;
	scanf("%d%d", &amp;nBattles, &amp;nQuestions);
	for (int i = 0; i &lt; nBattles; ++i) {
		char winner;
		scanf(" ");
		scanf("%c",&amp;winner);
		vector&lt;int&gt; have[2];
		for (int am = 0; am &lt; 2; ++am) {
			for (int cur = 0; cur &lt; 3; ++cur) {
				int x;
				scanf("%d", &amp;x);
				have[am].push_back(x);
			}
		}
		if (winner == 'B')
			swap(have[0], have[1]);
		#define expand(var) var[0],var[1],var[2]
		addBeat(expand(have[0]),expand(have[1])) ;
		#undef expand
//		cout&lt;&lt;calcArea(can)&lt;&lt;endl;
	}

	for (int i = 0; i &lt; nQuestions; ++i) {
		vector&lt;int&gt; have[2];
		for (int am = 0; am &lt; 2; ++am) {
			for (int cur = 0; cur &lt; 3; ++cur) {
				int x;
				scanf("%d", &amp;x);
				have[am].push_back(x);
			}
		}
		#define expand(var) var[0],var[1],var[2]
		doEstimate(expand(have[0]),expand(have[1])) ;
		#undef expand
	}
}

void testIt(){
	double a,b,c;
	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
	vector&lt;Point&gt;qs=makeVector(a,b,c);
	for (int i = 0; i &lt; 10; ++i) {
		Point p(rand(),rand());
		if(crossOp(qs[0],qs[1],p) != sign(a*p.x+b*p.y+c))
			puts("bad!");
		else
			puts("ok!");
	}
}

int main() {
	solve();
//	testIt();
}
</pre><pre></pre><h2>Problem1833</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=10,maxd=15;
using namespace std;
typedef long long ll;
ll A[maxn],C[maxn],Pow[maxd],Pre[maxn];
int N[maxd],n;
void Dfs(int p)
{
    int t=N[p];
    if(p&lt;0)
    {
        rep(j,10)C[j]+=Pre[j];
        return;
    }
    rep(i,t)
    {
        ll num=Pow[p];
        if(p==n-1&amp;&amp;i==0)
        {
            rep(j,10)C[j]+=num/10*p;
            rep(j,p+1)
            {
                C[0]-=(Pow[p-j]-Pow[p-j]/10)*j;
            }
        }
        else
        {
            Pre[i]++;
            rep(j,10)C[j]+=Pre[j]*num;
            Pre[i]--;num/=10;
            rep(j,10)C[j]+=p*num;
        }
    }
    Pre[t]++;Dfs(p-1);
}
void Cal(ll x)
{
    for(n=0;x;x/=10,n++)N[n]=x%10;
    memset(C,0,sizeof(C));
    memset(Pre,0,sizeof(Pre));
    Dfs(n-1);
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    ll a,b;cin&gt;&gt;a&gt;&gt;b;Pow[0]=1;rep(i,maxd-1)Pow[i+1]=Pow[i]*10;
    Cal(b);rep(i,10)A[i]=C[i];
    Cal(a-1);rep(i,10)A[i]-=C[i];
    rep(i,10)cout&lt;&lt;A[i]&lt;&lt;" ";
}


</pre><pre></pre><h2>Problem1834</h2><pre>#include&lt;cstdio&gt;
#include&lt;deque&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxv=1000+10,maxm=25000,inf=0x7F7F7F7F;
int head[maxv],mnt;
int t[maxm],u[maxm],c[maxm],nxt[maxm];
int v,n,m,k,vs,vt;
void ClearList()
{
     memset(head,-1,sizeof head);
     mnt=0;
}
void AddEdge(int s,int _t,int _u,int _c)
{
     t[mnt]=_t;u[mnt]=_u;c[mnt]=_c;nxt[mnt]=head[s];
     head[s]=mnt++;
}
void InsEdge(int s,int t,int u,int c)
{
     AddEdge(s,t,u,c);
     AddEdge(t,s,0,-c);
}
void Input_Data()
{
     scanf("%d%d%d",&amp;n,&amp;m,&amp;k);int s,t,c,w;
     ClearList();
     vs=0;vt=n-1;v=n;
     rep(i,m)
     {
          scanf("%d%d%d%d",&amp;s,&amp;t,&amp;c,&amp;w);
          --s;--t;
          InsEdge(s,t,c,0);
          InsEdge(s,t,inf,w);
     }
}
#define tr(e,x) for(int e=head[x];e!=-1;e=nxt[e])
int Vis[maxv]={},flag=0,flow=0;
int Aug_MaxFlow(int no,int m)
{
     if(no==vt)return flow+=m,m;
     Vis[no]=flag;
     tr(e,no)if(Vis[t[e]]!=flag&amp;&amp;u[e]&amp;&amp;!c[e])
     {
          int d=Aug_MaxFlow(t[e],min(u[e],m));
          if(d) return u[e]-=d,u[e^1]+=d,d;
     }
     return 0;
}
int Cal_MaxFlow()
{
     do ++flag;while(Aug_MaxFlow(vs,inf));
     return flow;
}
int Cost=0,piS=0;
int Aug_MinCostFlow(int no,int m)
{
     if(no==vt) return Cost+=piS*m,m;
     int l=m;Vis[no]=flag;
     tr(e,no)if(!c[e]&amp;&amp;u[e]&amp;&amp;Vis[t[e]]!=flag)
     {
          int d=Aug_MinCostFlow(t[e],min(u[e],m));
          l-=d;u[e]-=d;u[e^1]+=d;
          if(!l)return m-l;
     }
     return m-l;
}
bool ReLabel()
{
     static deque&lt;int&gt; Q;
     static int D[maxv];
     memset(D,0x7F,sizeof(int)*v);
     D[vt]=0;Q.push_back(vt);
     while(Q.size())
     {
          int dt,no=Q.front();Q.pop_front();
          tr(e,no)
          {
               if(u[e^1]&amp;&amp;(dt=D[no]-c[e])&lt;D[t[e]])
               (D[t[e]]=dt)&lt;=D[Q.size()?Q.front():0]?
                    Q.push_front(t[e]):Q.push_back(t[e]);
          }
     }
     piS+=D[vs];
     rep(no,v)tr(e,no)c[e]+=D[t[e]]-D[no];
     return D[vs]&lt;inf;
}
int Cal_MinCostFlow()
{
     while(ReLabel())
          do ++flag;
          while(Aug_MinCostFlow(vs,inf));;
     return Cost;
}
void BuildGraph()
{
     vs=v++;
     InsEdge(vs,0,k,0);
}
void Solve()
{
     cout&lt;&lt;Cal_MaxFlow()&lt;&lt;" ";
     BuildGraph();
     cout&lt;&lt;Cal_MinCostFlow()&lt;&lt;endl;
}
int main()
{
     Input_Data();
     Solve();
}
</pre><pre></pre><h2>Problem1835</h2><pre>/*
 * [ZJOI2010]base 基站选址.cpp
 *
 *  Created on: 2011-3-14
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 20000 + 10;
const int MAX_K = 100 + 10;
const int INF = INT_MAX / 2;
typedef long long int64;
int N, K;
int where[MAX_N], costToBuild[MAX_N], range[MAX_N], costNotCovered[MAX_N];

void input(int arr[], int n) {
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", arr + i);
	}
}

void inputData() {
	scanf("%d%d", &amp;N, &amp;K);
	where[1] = 0;
	input(where + 2, N - 1);
	input(costToBuild + 1, N);
	input(range + 1, N);
	input(costNotCovered + 1, N);
	where[0] = -INF;
	range[0] = 0;
	costToBuild[0] = 0;
	costNotCovered[0] = 0;

	where[N + 1] = INF;
	range[N + 1] = 0;
	costToBuild[N + 1] = 0;
	costNotCovered[N + 1] = 0;

	N += 2;
	K += 2;
}

int toLeft[MAX_N], toRight[MAX_N];

vector&lt;int&gt; idByToRight[MAX_N];

void prepare() {
	for (int i = 0; i &lt; N; ++i) {
		toLeft[i] = lower_bound(where, where + N, where[i] - range[i]) - where;
		toRight[i] = upper_bound(where, where + N, where[i] + range[i]) - where
				- 1;
	}

	for (int i = 0; i &lt; N; ++i) {
		idByToRight[toRight[i]].push_back(i);
	}
}

struct SegTree {
	static const int MAX_N_NODES = MAX_N * 4;

	int add[MAX_N_NODES], min[MAX_N_NODES];
	int n;

	inline int getMin(int a, int b) {
		return a &lt; b ? a : b;
	}

	void update(int t) {
		min[t] = getMin(min[t + t], min[t + t + 1]);
	}

	int*arr;
	void build(int t, int l, int r) {
		if (l + 1 == r) {
			add[t] = 0;
			min[t] = arr[l];
			return;
		}
		build(t + t, l, l + r &gt;&gt; 1);
		build(t + t + 1, l + r &gt;&gt; 1, r);
		add[t] = 0;
		update(t);
	}

	void apply(int t, int a) {
		add[t] += a;
		min[t] += a;
	}

	void relax(int t) {
		if (add[t]) {
			apply(t + t, add[t]);
			apply(t + t + 1, add[t]);
			add[t] = 0;
		}
	}

	int ask(int t, int l, int r, int tl, int tr) {
		if (tr &lt;= l || r &lt;= tl)
			return INF;
		if (tl &lt;= l &amp;&amp; tr &gt;= r)
			return min[t];
		relax(t);
		return getMin(ask(t + t, l, l + r &gt;&gt; 1, tl, tr), ask(t + t + 1, l + r
				&gt;&gt; 1, r, tl, tr));
	}

	void changeAdd(int t, int l, int r, int tl, int tr, int a) {
		if (tr &lt;= l || r &lt;= tl)
			return;
		if (tl &lt;= l &amp;&amp; r &lt;= tr) {
			apply(t, a);
			return;
		}
		relax(t);
		changeAdd(t + t, l, l + r &gt;&gt; 1, tl, tr, a);
		changeAdd(t + t + 1, l + r &gt;&gt; 1, r, tl, tr, a);
		update(t);
	}

	void changeAdd(int tl, int tr, int a) {
		changeAdd(1, 0, n, tl, tr, a);
	}

	int ask(int tl, int tr) {
		return ask(1, 0, n, tl, tr);
	}

	void init(int _n, int *_arr) {
		n = _n;
		arr = _arr;
		build(1, 0, n);
	}
};

SegTree segTree;

int dp[MAX_K][MAX_N];

void work() {
	prepare();

	for (int i = 0; i &lt; N; ++i) {
		dp[1][i] = INF;
	}
	dp[1][0] = 0;
	for (int k = 2; k &lt;= K; k++) {
		segTree.init(N, dp[k - 1]);
		dp[k][0] = 0;
		for (int i = 1; i &lt; N; ++i) {
			foreach(e,idByToRight[i-1]) {
				int cur = *e;
				segTree.changeAdd(0, toLeft[cur], costNotCovered[cur]);
			}
			dp[k][i] = segTree.ask(0, i) + costToBuild[i];
		}
	}

	//	for (int k = 1; k &lt;= K; k++) {
	//		cout &lt;&lt; "K:" &lt;&lt; k &lt;&lt; endl;
	//		for (int i = 0; i &lt; N; i++)
	//			cout &lt;&lt; dp[k][i] &lt;&lt; " ";
	//		cout &lt;&lt; endl;
	//	}

	cout &lt;&lt; dp[K][N - 1] &lt;&lt; endl;
}

int main() {
	inputData();
	work();
}
</pre><pre></pre><h2>Problem1838</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_N_CUT = 9;

struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
		x(_x), y(_y) {
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	Point operator*(double d) const {
		return Point(x * d, y * d);
	}
	Point operator/(double d) const {
		return Point(x / d, y / d);
	}
	double det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	double dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	Point rot90() const {
		return Point(-y, x);
	}
	void read() {
		scanf("%lf%lf", &amp;x, &amp;y);
	}
	void write() const {
		printf("%lf %lf", x, y);
	}
};

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))

const double EPS = 1e-8;
inline int sign(double a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}

#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))

Point isSS(const Point&amp;p1, const Point&amp;p2, const Point&amp;q1, const Point&amp;q2) {
	double a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);
	return Point((p1.x * a2 + p2.x * a1) / (a1 + a2), (p1.y * a2 + p2.y * a1)
			/ (a1 + a2));
}

vector&lt;Point&gt; convexCut(const vector&lt;Point&gt;&amp;ps, Point q1, Point q2) {
	vector&lt;Point&gt; qs;
	int n = ps.size();
	for (int i = 0; i &lt; n; ++i) {
		Point p1 = ps[i], p2 = ps[(i + 1) % n];
		int d1 = crossOp(q1,q2,p1), d2 = crossOp(q1,q2,p2);
		if (d1 &gt;= 0)
			qs.push_back(p1);
		if (d1 * d2 &lt; 0)
			qs.push_back(isSS(p1, p2, q1, q2));
	}
	return qs;
}

double calcArea(const vector&lt;Point&gt;&amp;ps) {
	int n = ps.size();
	double ret = 0;
	for (int i = 0; i &lt; n; ++i) {
		ret += ps[i].det(ps[(i + 1) % n]);
	}
	return ret / 2;
}

vector&lt;Point&gt; a, b;
vector&lt;Point&gt; poly;
int nCut;
double delta;
void inputData() {
	int n;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		Point p;
		p.read();
		poly.push_back(p);
	}
	cin &gt;&gt; nCut;
	a.resize(nCut);
	b.resize(nCut);
	for (int i = 0; i &lt; nCut; ++i) {
		a[i].read();
		b[i].read();
	}
	cin &gt;&gt; delta;
}

double area[60000];
int pow3[MAX_N_CUT];
const int IGNORE = 0, LEFT = 1, RIGHT = 2;
void rec(int state, int cur, vector&lt;Point&gt; ps) {
	if (cur == nCut) {
		area[state] = calcArea(ps);
		return;
	}
	rec(state + pow3[cur] * IGNORE, cur + 1, ps);
	rec(state + pow3[cur] * LEFT, cur + 1, convexCut(ps, a[cur], b[cur]));
	rec(state + pow3[cur] * RIGHT, cur + 1, convexCut(ps, b[cur], a[cur]));
}

void prepare() {
	pow3[0] = 1;
	for (int i = 1; i &lt; MAX_N_CUT; ++i) {
		pow3[i] = pow3[i - 1] * 3;
	}
	rec(0, 0, poly);
}

bool used[MAX_N_CUT];
double best;
void dfs(int state,int nUsed) {
	if (nUsed == nCut) {
		if (area[state] &gt; best)
			best = area[state];
		return;
	}
	for(int cur=0;cur&lt;nCut;++cur)if(!used[cur]){
		used[cur]=true;
		int left=state+pow3[cur]*LEFT;
		int right=state+pow3[cur]*RIGHT;
		double aLeft=area[left],aRight=area[right];
		if(fabs(aLeft-aRight)&lt;=delta+EPS)
			dfs(state,nUsed+1);
		else {
			if(aLeft &gt;aRight)
				dfs(left,nUsed+1);
			else
				dfs(right,nUsed+1);
		}
		used[cur]=false;
	}
}

void work(){
	prepare();
	best=0;
	dfs(0,0);
}

void solve() {
	inputData();
	work();
	printf("%0.5lf\n",best);
}

void runLargest() {
	int n = 20;
	poly.clear();
	for (int i = 0; i &lt; n; ++i) {
		Point p(i, i * i);
		poly.push_back(p);
	}
	nCut = 9;
	a.reserve(nCut);
	b.resize(nCut);
	for (int i = 0; i &lt; nCut; ++i) {
		a[i] = Point(rand(), rand());
		b[i] = Point(rand(), rand());
	}
	delta = 0;
	work();
	printf("%0.5lf\n",best);
}

int main() {
	solve();
//	runLargest();
}
</pre><pre></pre><h2>Problem1842</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define OK puts("OK")
using namespace std;
const int N_MAX=100000+10,Q_MAX=100000+10;
namespace IO
{
    namespace Scanner
    {
        inline void scan(int&amp;t)
        {
            int sign=1;char c;
            while(c=getchar(),c&lt;'0'||c&gt;'9')
                if(c=='-')break;
            if(c=='-')t=0,sign=-1;
            else t=c-'0';
            while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
            t*=sign;
        }
    }
    namespace Printer
    {
        inline void print_int(int t)
        {
            static int A[20];int p=0;
            if(!t){putchar('0');putchar('\n');return;}
            while(t)A[p++]=t%10,t/=10;
            for(int i=p-1;i&gt;=0;i--)
                putchar('0'+A[i]);
            putchar('\n');
        }
    }
}
namespace Splay_Data
{
    const int ND_MAX=N_MAX+Q_MAX;
    struct Node
    {
        Node*p,*ch[2],*did;
        int Size,id;
        bool ex;
        bool d(){return this==p-&gt;ch[1];}
        void sc(Node*_c,bool _d)
        {
            ch[_d]=_c;_c-&gt;p=this;
        }
        void update()
        {
            Size=ch[0]-&gt;Size+ch[1]-&gt;Size+ex;
            if(ex)did=this;
            else
            {
                did=0;
                if(ch[0]-&gt;did)did=ch[0]-&gt;did;
                if(ch[1]-&gt;did)did=ch[1]-&gt;did;
            }
        }
    }*Null,*root;
    namespace Memory
    {
        Node Mem[ND_MAX];
        int top;
        void init_Mem()
        {
            top=-1;
        }
        Node*New_Node()
        {
            top++;
            return Mem+top;
        }
    }
    Node*New_Node(int _id)
    {
        Node*ret=Memory::New_Node();
        ret-&gt;ch[0]=ret-&gt;ch[1]=ret-&gt;p=Null;
        ret-&gt;Size=1;ret-&gt;id=_id;
        ret-&gt;ex=true;
        return ret;
    }
    void init_Null()
    {
        Null=New_Node(-1);
        Null-&gt;ch[0]=Null-&gt;ch[1]=Null-&gt;p=Null;
        Null-&gt;did=0;
        Null-&gt;Size=0;
    }
    void Rotate(Node*t)
    {
        Node*p=t-&gt;p;bool d=t-&gt;d();
        p-&gt;sc(t-&gt;ch[!d],d);
        p-&gt;p-&gt;sc(t,p-&gt;d());
        t-&gt;sc(p,!d);
        p-&gt;update();
        if(p==root)root=t;
    }
    void Splay(Node*t,Node*f=Null)
    {
        while(t-&gt;p!=f)
        {
            if(t-&gt;p-&gt;p==f)
                Rotate(t);
            else
                (t-&gt;d()==t-&gt;p-&gt;d())?(Rotate(t-&gt;p),Rotate(t)):(Rotate(t),Rotate(t));
        }
        t-&gt;update();
    }
    void init_Splay()
    {
        Memory::init_Mem();
        init_Null();
        Node*L=New_Node(-1),*R=New_Node(-1);
        L-&gt;sc(R,1);root=L;root-&gt;p=Null;
        Splay(R);
    }
    Node*make_tree(int*l,int*r)
    {
        if(l&gt;=r)return Null;
        int*m=l+(r-l)/2;
        Node*t=New_Node(*m);
        t-&gt;sc(make_tree(l,m),0);
        t-&gt;sc(make_tree(m+1,r),1);
        t-&gt;update();
        return t;
    }
    Node*Select(int k)
    {
        for(Node*t=root;;)
        {
            int cnt=t-&gt;ch[0]-&gt;Size;
            if(cnt==k&amp;&amp;t-&gt;ex)return t;
            if(k&gt;=cnt)
                k-=cnt+t-&gt;ex,t=t-&gt;ch[1];
            else
                t=t-&gt;ch[0];
        }
    }
    Node*get_Seq(int l,int r)
    {
        Node*L=Select(l);
        Splay(L,Null);
        Node*R=Select(r);
        Splay(R,root);
        return root-&gt;ch[1]-&gt;ch[0];
    }
    Node*LeftMost(Node*t)
    {
        while(t-&gt;ch[0]!=Null)t=t-&gt;ch[0];
        return t;
    }
    int get_id(int k)
    {
        return get_Seq(k-1,k+1)-&gt;did-&gt;id;
    }
    void Insert_Tree(int p,Node*t)
    {
        Node*L=Select(p);Splay(L);
        Node*R=LeftMost(L-&gt;ch[1]);
        Splay(R,root);
        root-&gt;ch[1]-&gt;sc(t,0);
        Splay(t);
    }
    void Insert_Seq(int p,int*Data,int n)
    {
        Node*t=make_tree(Data,Data+n);
        Insert_Tree(p,t);
    }
    void Insert_Node(int p,int id)
    {
        Node*t=New_Node(id);
        Insert_Tree(p,t);
    }
    void Delete_Node(int p)
    {
        Node*t=get_Seq(p-1,p+1)-&gt;did;
        t-&gt;ex=false;t-&gt;update();
        Splay(t);
    }
    int*Out;
    void Dfs(Node*t)
    {
        if(t==Null)return;
        Dfs(t-&gt;ch[0]);
        *Out++=t-&gt;id;
        Dfs(t-&gt;ch[1]);
    }
    void Dfs_Out(int *_Out)
    {
        Out=_Out;
        Dfs(root);
    }
}
namespace BlockArray_Data
{
    const int S_MAX=500;
    struct TBlcok
    {
        int A[S_MAX],S[S_MAX],n;
        void init(){n=0;}
        void add_item(int x){A[n++]=x;}
        void doit()
        {
            memcpy(S,A,sizeof(int)*n);
            sort(S,S+n);
        }
        int count_less(int t)
        {
            return lower_bound(S,S+n,t)-S;
        }
        int count_less(int l,int r,int t)
        {
            int ret=0;
            if(l&lt;0)l=0;if(r&gt;=n)r=n-1;
            for(int i=l;i&lt;=r;i++)
                ret+=(A[i]&lt;t);
            return ret;
        }
        void update(int p,int s)
        {
            A[p]=s;doit();
        }
    };
    TBlcok Bs[S_MAX];
    int N,S;
    void init_Seq(int*Data,int n)
    {
        N=n;S=0;while(S*S&lt;=N)S++;
        rep(i,S)Bs[i].init();
        rep(i,N)
        {
            Bs[i/S].add_item(Data[i]);
        }
        rep(i,S)Bs[i].doit();
    }
    void Output()
    {
        rep(i,N)
        {
            cout&lt;&lt;Bs[i/S].A[i%S]&lt;&lt;" ";
        }
        cout&lt;&lt;endl;
    }
    int count_less(int l,int r,int t)
    {
        /*
        cout&lt;&lt;"Hello World!"&lt;&lt;endl;
        Output();
        cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;" "&lt;&lt;t&lt;&lt;endl;
        cout&lt;&lt;"End"&lt;&lt;endl;
        */
        int i=l/S,j=r/S;
        if(i==j)return Bs[i].count_less(l-i*S,r-j*S,t);
        int ret=Bs[i].count_less(l-i*S,S-1,t)+Bs[j].count_less(0,r-j*S,t);
        for(int idx=i+1;idx&lt;=j-1;idx++)
            ret+=Bs[idx].count_less(t);
        return ret;
    }
    void update(int p,int v)
    {
        Bs[p/S].update(p%S,v);
    }
}
namespace Solve
{
    using namespace IO::Scanner;
    using namespace IO::Printer;
    using namespace Splay_Data;
    using namespace BlockArray_Data;
    const int Count=0,Insert=1,Delete=2,Update=3;
    const int inf=~0U&gt;&gt;1;
    int Pos[ND_MAX],IdCount;
    int Ord[ND_MAX];
    int N,Q;
    int Val[N_MAX];
    int Data[ND_MAX];
    struct Topt
    {
        int Kind;
        int a,b,c;
    };
    struct Topts
    {
        Topt T[Q_MAX];
        int n,now;
        void init(){n=0;}
        void add(Topt opt){T[n++]=opt;}
        void doit(){now=0;}
        bool has_next(){return now&lt;n;}
        Topt get(){return T[now++];}
    }Seq;
    namespace PreCondition
    {
        void ins_sequence(int n)
        {
            static int Ids[N_MAX];
            rep(i,n)Ids[i]=IdCount++;
            Insert_Seq(0,Ids,n);
        }
        void opt_count(int a,int b,int c)
        {
            Topt opt;
            opt.Kind=Count;
            opt.a=get_id(a);opt.b=get_id(b);opt.c=c;
            Seq.add(opt);
        }
        void opt_insert(int p,int v)
        {
            Topt opt;
            opt.Kind=Insert;
            opt.a=IdCount;Insert_Node(p,IdCount);IdCount++;
            opt.b=v;
            Seq.add(opt);
        }
        void opt_delete(int p)
        {
            Topt opt;
            opt.Kind=Delete;
            opt.a=get_id(p);
            Delete_Node(p);
            Seq.add(opt);
        }
        void opt_update(int p,int v)
        {
            Topt opt;
            opt.Kind=Update;
            opt.a=get_id(p);opt.b=v;
            Seq.add(opt);
        }
        void make_sequence()
        {
            Dfs_Out(Ord);
            int Num=Out-Ord;
            rep(i,Num)
            {
                Data[i]=inf;
                //cout&lt;&lt;Ord[i]&lt;&lt;" ";
                if(Ord[i]!=-1)
                {
                    Pos[Ord[i]]=i;
                    if(Ord[i]&lt;N)
                    {
                        Data[i]=Val[Ord[i]];
                    }
                }
            }
            init_Seq(Data,Num);
            /*
            cout&lt;&lt;endl;
            cout&lt;&lt;Num&lt;&lt;endl;
            rep(i,Num)
            {
                cout&lt;&lt;Data[i]&lt;&lt;" ";
            }
            cout&lt;&lt;endl;
            */
        }
    }
    using namespace PreCondition;
    void input_data()
    {
        scan(N);scan(Q);
        rep(i,N)scan(Val[i]);
        init_Splay();IdCount=0;
        ins_sequence(N);
        int type;
        rep(i,Q)
        {
            scan(type);
            int a,b,c,p,v;
            switch(type)
            {
                case Count:
                    scan(a);scan(b);scan(c);
                    c++;
                    opt_count(a,b,c);
                    break;
                case Insert:
                    scan(p);scan(v);
                    opt_insert(p,v);
                    break;
                case Delete:
                    scan(p);
                    opt_delete(p);
                    break;
                case Update:
                    scan(p);scan(v);
                    opt_update(p,v);
                    break;
            }
        }
    }
    void calc_ans()
    {
        Seq.doit();Topt now;
        int l,r,v,p;
        while(Seq.has_next())
        {
            now=Seq.get();
            switch(now.Kind)
            {
                case Count:
                    l=Pos[now.a],r=Pos[now.b],v=now.c;
                    print_int(count_less(l,r,v));
                    break;
                case Insert:
                    p=Pos[now.a],v=now.b;
                    update(p,v);
                    break;
                case Delete:
                    p=Pos[now.a];
                    update(p,inf);
                    break;
                case Update:
                    p=Pos[now.a],v=now.b;
                    update(p,v);
                    break;
            }
        }
    }
    void solve()
    {
        input_data();
        make_sequence();
        calc_ans();
    }
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("out2","w",stdout);
    Solve::solve();
}
</pre><pre></pre><h2>Problem1847</h2><pre>/*
 * p3.cpp
 *
 *  Created on: 2012-4-14
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

int ans[] = { 0, 1, 6, 68, 1170, 27142, 793002, 27914126, 150212803, 326011036, 532422896, 280807462, 964723653, 727302296, 880230970, 871308933, 380032625, 84542615, 677887122, 556092959, 924913504,
		456251244, 434430935, 19910633, 995239149, 278341411, 194660221, 879047814, 468374325, 453740976, 24386302, 377764771, 781671736, 232452677, 643590853, 930129537, 759690203, 623221107,
		912186614, 741738633, 573619300, 485106445, 640709421, 377969272, 757779716, 516007795, 74093838, 189780695, 93606422, 781424563, 370940959, 728985390, 938592559, 316371724, 866266405,
		93853453, 172454832, 633359912, 280702034, 125630246, 147145873, 201547834, 544939708, 42945618, 343997994, 637920352, 46117078, 914037044, 907432125, 468818407, 678618736, 314261988,
		833318531, 643339051, 395984375, 282497343, 546773795, 7202490, 902921361, 4371735, 348727670, 627305933, 673557463, 326198461, 689927805, 791235740, 648490999, 145722864, 192893596,
		600985266, 47409731, 679148160, 451921630, 622592033, 834842190, 724406109, 72330781, 137459697, 683463566, 158802270, 598060753 };

int main() {
//	int n;
//	cin &gt;&gt; n;
//	for (int i = 0; i &lt; n; ++i) {
//		int a;
//		cin &gt;&gt; a;
//		cout &lt;&lt; ans[a] &lt;&lt; endl;
//	}
	for (;;) {
		int a;
		cin &gt;&gt; a;
		if (!a)
			break;
		cout &lt;&lt; ans[a] &lt;&lt; endl;
	}
	return 0;
}
</pre><pre></pre><h2>Problem1854</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxs=10000;
using namespace std;
struct UF
{
    int F[maxs],S[maxs],n;
    UF()
    {
        rep(i,maxs)F[i]=i,S[i]=0;
    }
    int Find(int x)
    {
        if(x==F[x])return x;
        return F[x]=Find(F[x]);
    }
    void Union(int i,int j)
    {
        i=Find(i);j=Find(j);
        F[j]=i;if(i!=j)S[i]+=S[j];
        S[i]++;
    }
    int&amp;remain(int i)
    {
        return S[Find(i)];
    }
}U;
int n;
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);int s,t;
    rep(i,n)
    {
        scanf("%d%d",&amp;s,&amp;t);
        --s;--t;
        U.Union(s,t);
    }
    rep(i,maxs)
    {
        int&amp;s=U.remain(i);
        if(s)s--;
        else
        {
            printf("%d\n",i);
            return 0;
        }
    }
    printf("%d\n",maxs);
}


</pre><pre></pre><h2>Problem1856</h2><pre>#include &lt;iostream&gt;
using namespace std;
typedef long long ll;
const int maxn=1000000*2+10,mod=20100403;
ll Fact[maxn];
int n,m;
ll pow_mod(ll x,int e)
{
    if(e==0)return 1;
    ll tmp=pow_mod(x,e&gt;&gt;1);
    tmp=tmp*tmp%mod;
    if(e%2)tmp=tmp*x%mod;
    return tmp;
}
ll rev_mod(ll x)
{
    return pow_mod(x,mod-2);
}
ll Chose(int n,int m)
{
    return Fact[n]*rev_mod(Fact[m])%mod*rev_mod(Fact[n-m])%mod;
}
int main()
{
    Fact[0]=1;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n+m;i++)
        Fact[i]=Fact[i-1]*i%mod;
    ll ret=Chose(n+m,n)-Chose(n+m,n+1);
    if(ret&lt;0)ret+=mod;
    cout&lt;&lt;ret&lt;&lt;endl;
}

</pre><pre></pre><h2>Problem1857</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
double P,Q,R;
struct Point
{
    double x,y;
    Point(){}
    Point(double _x,double _y):x(_x),y(_y){}
    Point operator*(double d)
    {
        return Point(x*d,y*d);
    }
    Point operator+(const Point&amp;o)const
    {
        return Point(x+o.x,y+o.y);
    }
};
struct Line
{
    Point A,B;
    Line(){}
    Point get(double d)
    {
        return A*d+B*(1-d);
    }
}A,B;
istream&amp; operator&gt;&gt;(istream&amp;in,Point&amp;p)
{
    in&gt;&gt;p.x&gt;&gt;p.y;
    return in;
}
istream&amp; operator&gt;&gt;(istream&amp;in,Line&amp;l)
{
    in&gt;&gt;l.A&gt;&gt;l.B;
    return in;
}
struct State
{
    double Up,Down;
    State(){}
    State(double _Up,double _Down):Up(_Up),Down(_Down){}
    void Just(double a,double b)
    {
        Up+=a;Down+=b;
    }
};
double Dist(const Point&amp;a,const Point&amp;b)
{
    static double A,B;
    A=a.x-b.x,B=a.y-b.y;
    return sqrt(A*A+B*B);
}
double Cal(State s)
{
    Point a=A.get(s.Up),b=B.get(s.Down);
    return Dist(a,A.A)/P+Dist(a,b)/R+Dist(b,B.B)/Q;
}
double rand_double()
{
    return (double(2*rand())/RAND_MAX)-1;
}
double check_Legal(State s)
{
    return s.Up&gt;=0&amp;&amp;s.Up&lt;=1&amp;&amp;s.Down&gt;=0&amp;&amp;s.Down&lt;=1;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;A&gt;&gt;B&gt;&gt;P&gt;&gt;Q&gt;&gt;R;
    State now(0,0),tmp;double min=Cal(now);
    for(double e=1;e&gt;1e-10;e/=2)
    {
        int time=1000;
        while(time--)
        {
            tmp=now;tmp.Just(rand_double()*e,rand_double()*e);
            if(!check_Legal(tmp))continue;
            double new_min=Cal(tmp);
            if(new_min&lt;min)
            {
                min=new_min;now=tmp;
            }
        }
    }
    printf("%0.2lf\n",min);
}


</pre><pre></pre><h2>Problem1857</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
double P,Q,R;
struct Point
{
    double x,y;
    Point(){}
    Point(double _x,double _y):x(_x),y(_y){}
    Point operator*(double d)
    {
        return Point(x*d,y*d);
    }
    Point operator+(const Point&amp;o)const
    {
        return Point(x+o.x,y+o.y);
    }
};
struct Line
{
    Point A,B;
    Line(){}
    Point get(double d)
    {
        return A*d+B*(1-d);
    }
}A,B;
istream&amp; operator&gt;&gt;(istream&amp;in,Point&amp;p)
{
    in&gt;&gt;p.x&gt;&gt;p.y;
    return in;
}
istream&amp; operator&gt;&gt;(istream&amp;in,Line&amp;l)
{
    in&gt;&gt;l.A&gt;&gt;l.B;
    return in;
}
struct State
{
    double Up,Down;
    State(){}
    State(double _Up,double _Down):Up(_Up),Down(_Down){}
    void Just(double a,double b)
    {
        Up+=a;Down+=b;
    }
};
double Dist(const Point&amp;a,const Point&amp;b)
{
    static double A,B;
    A=a.x-b.x,B=a.y-b.y;
    return sqrt(A*A+B*B);
}
double Cal(State s)
{
    Point a=A.get(s.Up),b=B.get(s.Down);
    return Dist(a,A.A)/P+Dist(a,b)/R+Dist(b,B.B)/Q;
}
double rand_double()
{
    return (double(2*rand())/RAND_MAX)-1;
}
double check_Legal(State s)
{
    return s.Up&gt;=0&amp;&amp;s.Up&lt;=1&amp;&amp;s.Down&gt;=0&amp;&amp;s.Down&lt;=1;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;A&gt;&gt;B&gt;&gt;P&gt;&gt;Q&gt;&gt;R;
    State now(0,0),tmp;double min=Cal(now);
    for(double e=1;e&gt;1e-10;e/=2)
    {
        int time=100;
        while(time--)
        {
            tmp=now;tmp.Just(rand_double()*e,rand_double()*e);
            if(!check_Legal(tmp))continue;
            double new_min=Cal(tmp);
            if(new_min&lt;min)
            {
                min=new_min;now=tmp;
            }
        }
    }
    printf("%0.2lf\n",min);
}


</pre><pre></pre><h2>Problem1858</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=100000;
using namespace std;
#define Tree int t,int l,int r
#define Left t*2,l,l+r&gt;&gt;1
#define Right t*2+1,l+r&gt;&gt;1,r
int n,m;
struct sinfo
{
    int sum,maxl,maxr,maxs,size;
    void set(bool x){sum=maxl=maxr=maxs=x?size:0;}
    sinfo():size(1){}
    bool full()const{return sum==size;}
};
sinfo operator+(const sinfo&amp;L,const sinfo&amp;R)
{
    sinfo F;
    F.size=L.size+R.size;
    F.sum=L.sum+R.sum;
    F.maxl=L.full()?L.sum+R.maxl:L.maxl;
    F.maxr=R.full()?R.sum+L.maxr:R.maxr;
    F.maxs=max(L.maxr+R.maxl,max(L.maxs,R.maxs));
    return F;
}
struct info
{
    sinfo I[2];
    bool e;
    info(bool _e=true):e(_e){}
    void set(bool c){rep(i,2)I[i].set(i==c);}
}T[maxn*4];
info operator+(const info&amp;L,const info&amp;R)
{
    if(!L.e)return R;if(!R.e)return L;
    info F;rep(i,2)F.I[i]=L.I[i]+R.I[i];
    return F;
}
int A[maxn],M[maxn*4]={};
void Mark(int t,int m)
{
    if(m==3){swap(T[t].I[0],T[t].I[1]);M[t]=3-M[t];}
    else{T[t].set(m-1);M[t]=m;}
}
void PushDown(int t)
{
    if(M[t])Mark(t*2,M[t]),Mark(t*2+1,M[t]),M[t]=0;
}
void Build(Tree)
{
    if(l+1==r){T[t].set(A[l]);return;}
    Build(Left);Build(Right);
    T[t]=T[t*2]+T[t*2+1];
}
info Ask(Tree,int a,int b)
{
    if(a&gt;=r||b&lt;=l)return info(false);
    if(l&gt;=a&amp;&amp;r&lt;=b)return T[t];
    PushDown(t);
    return Ask(Left,a,b)+Ask(Right,a,b);
}
void Change(Tree,int a,int b,int m)
{
    if(a&gt;=r||b&lt;=l)return;
    if(l&gt;=a&amp;&amp;r&lt;=b){Mark(t,m);return;}
    PushDown(t);
    Change(Left,a,b,m);Change(Right,a,b,m);
    T[t]=T[t*2]+T[t*2+1];
}
#define root 1,0,n
int main()
{
    scanf("%d%d",&amp;n,&amp;m);rep(i,n)scanf("%d",A+i);
    Build(root);int k,l,r;
    while(m--)
    {
        scanf("%d%d%d",&amp;k,&amp;l,&amp;r);r++;
        switch(k)
        {
            case 0:Change(root,l,r,1);break;
            case 1:Change(root,l,r,2);break;
            case 2:Change(root,l,r,3);break;
            case 3:printf("%d\n",Ask(root,l,r).I[1].sum);break;
            case 4:printf("%d\n",Ask(root,l,r).I[1].maxs);break;
        }
    }
}


</pre><pre></pre><h2>Problem1860</h2><pre>#include &lt;cstdio&gt;
#include &lt;set&gt;
#include &lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
const int inf=~0U&gt;&gt;1,seed=131,maxn=100;
using namespace std;
typedef unsigned long long ull;
ull P[maxn+1];
set&lt;ull&gt; S;
int A[maxn];
bool ok;
void dfs(int p,bool can,ull code)
{
    if(!S.insert(code).second)return;
    while(p&lt;maxn&amp;&amp;A[p]==0)p++;
    if(p==maxn){if(!can)ok=true;return;}
    //three consecutive
    if(p+2&lt;maxn&amp;&amp;A[p]&amp;&amp;A[p+1]&amp;&amp;A[p+2])
    {
        A[p]--;A[p+1]--;A[p+2]--;
        ull ncode=code-P[p]-P[p+1]-P[p+2];
        dfs(p,can,ncode);if(ok)return;
        A[p]++;A[p+1]++;A[p+2]++;
    }
    //three same
    if(A[p]&gt;=3)
    {
        A[p]-=3;
        ull ncode=code-P[p]*3;
        dfs(p,can,ncode);if(ok)return;
        A[p]+=3;
    }
    //four same
    if(A[p]&gt;=4)
    {
        A[p]-=4;
        ull ncode=code-P[p]*4;
        dfs(p,can,ncode);if(ok)return;
        A[p]+=4;
    }
    //use pair
    if(A[p]&gt;=2&amp;&amp;can)
    {
        A[p]-=2;
        ull ncode=code-P[p]*2-P[maxn];
        dfs(p,!can,ncode);if(ok)return;
        A[p]+=2;
    }
}
void Solve()
{
    ull ret=0;
    rep(i,maxn)
    {
        scanf("%d",A+i);
        ret*=seed;ret+=A[i];
    }
    ret*=seed;ret+=1;
    S.clear();
    ok=false;
    dfs(0,true,ret);
    if(ok)puts("Yes");
    else puts("No");
}
int main()
{
    //freopen("in","r",stdin);
    P[0]=1;rep(i,maxn)P[i+1]=P[i]*seed;
    int t;cin&gt;&gt;t;rep(i,t)Solve();
}


</pre><pre></pre><h2>Problem1861</h2><pre>/*
 * [Zjoi2006]Book 书架.cpp
 *
 *  Created on: 2011-3-4
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_NBOOKS = 80000 + 100;
struct Node {
	int id, size;
	Node*ch[2], *p;
	void set(Node*c, bool d) {
		c-&gt;p = this;
		ch[d] = c;
	}
	bool dir() {
		return this == p-&gt;ch[1];
	}
	void update() {
		size = 1 + ch[0]-&gt;size + ch[1]-&gt;size;
	}
	Node() {
		size = 0;
	}
} nullData, *null = &amp;nullData;

struct Splay {
	Node*root;
	void clear(Node*t) {
		t-&gt;size = 1;
		t-&gt;ch[0] = t-&gt;ch[1] = null;
	}
	Node*build(Node*l, Node*r) {
		if (l &gt;= r)
			return null;
		Node*m = l + (r - l) / 2;
		m-&gt;set(build(l, m), 0);
		m-&gt;set(build(m + 1, r), 1);
		m-&gt;update();
		return m;
	}
	void init(Node*l, Node*r) {
		root = build(l, r);
		root-&gt;p = null;
	}
	void rotate(Node*t) {
		Node*p = t-&gt;p;
		bool d = t-&gt;dir();
		p-&gt;p-&gt;set(t, p-&gt;dir());
		p-&gt;set(t-&gt;ch[!d], d);
		t-&gt;set(p, !d);
		p-&gt;update();
		if (root == p)
			root = t;
	}
	void splay(Node*t, Node*f = null) {
		while (t-&gt;p != f) {
			if (t-&gt;p-&gt;p == f)
				rotate(t);
			else
				t-&gt;p-&gt;dir() == t-&gt;dir() ? (rotate(t-&gt;p), rotate(t))
						: (rotate(t), rotate(t));
		}
		t-&gt;update();
	}
	Node*getKth(int kth) {
		for (Node*t = root;;) {
			int cnt = t-&gt;ch[0]-&gt;size;
			if (kth == cnt)
				return t;
			t = t-&gt;ch[kth &gt; cnt];
			if (kth &gt; cnt)
				kth -= cnt + 1;
		}
	}
	Node*getSeq(int l, int r) {//it's father
		//(l,r)
		Node*Left = getKth(l);
		splay(Left);
		Node*Right = getKth(r);
		splay(Right, Left);
		return Right;
	}
	void insert(int at, Node*t) {
		getSeq(at - 1, at)-&gt;set(t, 0);
		splay(t);
	}
	Node*erase(int at) {
		Node*p = getSeq(at - 1, at + 1);
		Node*t = p-&gt;ch[0];
		p-&gt;set(null, 0);
		splay(p);
		clear(t);
		return t;
	}
	int rank(Node*t) {
		splay(t);
		return t-&gt;ch[0]-&gt;size;
	}
	void erase(Node*t) {
		int at = rank(t);
		erase(at);
	}
};

Splay*splay;

Node books[MAX_NBOOKS];
int nBooks, nOpts;
Node*idToBook[MAX_NBOOKS];

void inputData() {
	scanf("%d%d", &amp;nBooks, &amp;nOpts);
	for (int i = 1; i &lt; nBooks + 1; ++i) {
		int id;
		scanf("%d", &amp;id);
		books[i].id = id;
		idToBook[id] = books + i;
	}
}

void work() {
	splay=new Splay;
	splay-&gt;init(books,books+nBooks+2);
	char cmd[100];
	while (nOpts--) {
		scanf(" ");
		scanf("%s", cmd);
		switch (cmd[0]) {
		case 'Q': {
			int at;
			scanf("%d", &amp;at);
			Node*t = splay-&gt;getKth(at);
			printf("%d\n", t-&gt;id);
			break;
		}
		case 'T': {
			int id;
			scanf("%d", &amp;id);
			Node*t = idToBook[id];
			splay-&gt;erase(t);
			splay-&gt;insert(1, t);
			break;
		}
		case 'B': {
			int id;
			scanf("%d", &amp;id);
			Node*t = idToBook[id];
			splay-&gt;erase(t);
			splay-&gt;insert(nBooks, t);
			break;
		}
		case 'I':{
			int id, add;
			scanf("%d%d", &amp;id,&amp;add);
			if(!add)break;
			Node*t = idToBook[id];
			int at=splay-&gt;rank(t);
			splay-&gt;erase(at);
			at+=add;
			splay-&gt;insert(at,t);
			break;
		}
		case 'A':{
			int id;scanf("%d",&amp;id);
			Node*t=idToBook[id];
			int at=splay-&gt;rank(t);
			printf("%d\n",at-1);
			break;
		}
		default:
		break;
	}
}
}

void solve() {
	inputData();
	work();
}

int main() {
//	freopen("in","r",stdin);
	solve();
}
</pre><pre></pre><h2>Problem1862</h2><pre>/*
 * [Zjoi2006]GameZ游戏排名系统.cpp
 *
 *  Created on: 2011-3-4
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;cstdlib&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int INF = ~0U &gt;&gt; 1;
int globalTime = 0;
const int SEED = 133331;
const int MAX_LEN=10+1;

struct Node {
	int size;
	int score, time;
	char name[MAX_LEN];
	Node*ch[2], *p;
	Node() {
		size = 0;
	}
	void set(Node*c, bool d) {
		ch[d] = c;
		c-&gt;p = this;
	}
	bool dir() {
		return this == p-&gt;ch[1];
	}
	void update() {
		size = ch[0]-&gt;size + ch[1]-&gt;size + 1;
	}
} nullData, *null = &amp;nullData;

Node*newNode(int score,const char name[]) {
	Node*t = new Node;
	t-&gt;ch[0] = t-&gt;ch[1] = null;
	t-&gt;size = 1;
	t-&gt;score = score;
	strcpy(t-&gt;name,name);
	return t;
}

void clear(Node*t) {
	t-&gt;ch[0] = t-&gt;ch[1] = null;
	t-&gt;size = 1;
}

int hashCode(const char name[]) {
	const char*it=name;
	int code=0;
	while(*it!='\0')
		code=code*SEED+*it++;
	return code;
}

map&lt;int, Node*&gt; nameToNode;

Node* getId(const char name[]) {
	int code = hashCode(name);
	if (nameToNode.count(code))
		return nameToNode[code];
	Node*t = newNode(-INF, name);
	return nameToNode[code] = t;
}

bool compare(Node*a, Node*b) {
	if (a-&gt;score != b-&gt;score)
		return a-&gt;score &gt; b-&gt;score;
	return a-&gt;time &lt; b-&gt;time;
}

struct Splay {
	Node*root;

	void rotate(Node*t) {
		Node*p = t-&gt;p;
		bool d = t-&gt;dir();
		p-&gt;p-&gt;set(t, p-&gt;dir());
		p-&gt;set(t-&gt;ch[!d], d);
		t-&gt;set(p, !d);
		p-&gt;update();
		if (root == p)
			root = t;
	}

	void splay(Node*t, Node*f = null) {
		while (t-&gt;p != f) {
			if (t-&gt;p-&gt;p == f)
				rotate(t);
			else
				(t-&gt;dir() == t-&gt;p-&gt;dir()) ? (rotate(t-&gt;p), rotate(t))
						: (rotate(t), rotate(t));
		}
		t-&gt;update();
	}

	Node*getKth(int kth) {
		for (Node*t = root;;) {
			int cnt = t-&gt;ch[0]-&gt;size;
			if (kth == cnt)
				return t;
			t = t-&gt;ch[kth &gt; cnt];
			if (kth &gt; cnt)
				kth -= cnt + 1;
		}
	}

	void insert(Node*ins) {
		clear(ins);
		for (Node*t = root;;) {
			bool dir = compare(t, ins);
			if (t-&gt;ch[dir] == null) {
				t-&gt;set(ins, dir);
				splay(ins);
				return;
			}
			t = t-&gt;ch[dir];
		}
	}

	Node*rightMost(Node*t) {
		while (t-&gt;ch[1] != null)
			t = t-&gt;ch[1];
		return t;
	}

	Node*leftMost(Node*t){
		while (t-&gt;ch[0] != null)
			t=t-&gt;ch[0];
		return t;
	}

	void erase(Node*t) {
		splay(t);
		Node*prev = rightMost(t-&gt;ch[0]);
		Node*next= leftMost(t-&gt;ch[1]);
		splay(prev);
		splay(next,prev);
		next-&gt;set(null,0);
		splay(next);
	}

	void write(Node*t) {
		if (t == null)
			return;
		write(t-&gt;ch[0]);
		//		assert(false);
		printf("%s ",t-&gt;name);
		write(t-&gt;ch[1]);
	}

	void write(int l, int r) {
		//		cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;endl;
		Node*Left = getKth(l - 1);
		splay(Left);
		Node*Right = getKth(r + 1);
		splay(Right, Left);
		write(Right-&gt;ch[0]);
	}

	int rank(Node*t) {
		splay(t);
		return t-&gt;ch[0]-&gt;size;
	}

	Splay() {
		char name[MAX_LEN]="?";
		Node*begin = newNode(INF,name);
		root = begin;
		root-&gt;p = null;
		Node*end = newNode(-INF,name);
		begin-&gt;set(end, 1);
		splay(end);
	}

	int size() {
		return root-&gt;size - 2;
	}
};

void solve() {
	Splay*splay = new Splay;

	int nOpt;
	scanf("%d", &amp;nOpt);
	char name[MAX_LEN];
	for (int step = 0; step &lt; nOpt; ++step) {
		scanf(" ");
		char cmd;
		while(cmd=getchar(),cmd!='+' &amp;&amp; cmd !='?');
		Node*t;
		//		cout&lt;&lt;splay-&gt;size()&lt;&lt;endl;
		//		cout &lt;&lt; cmd &lt;&lt; endl;
		switch (cmd) {
		case '+':
			scanf(" ");
			scanf("%s",name);
			//			cout &lt;&lt; name &lt;&lt; endl;
			int score;
			scanf("%d", &amp;score);
			t = getId(name);
			if (t-&gt;score == -INF) {
				t-&gt;score = score;
				t-&gt;time = globalTime++;
				splay-&gt;insert(t);
			} else {
				splay-&gt;erase(t);
				t-&gt;score = score;
				t-&gt;time = globalTime++;
				splay-&gt;insert(t);
			}
			break;
		case '?':
			int index;
			char c;
			while(c=getchar(),c==' '||c=='\n');
			ungetc(c,stdin);
			if (isdigit(c)) {
				scanf("%d",&amp;index);
				int l = index;
				int r = min(l + 9, splay-&gt;size());
				splay-&gt;write(l, r);
				printf("\n");
			} else {
				scanf("%s",name);
				t = getId(name);
				printf("%d\n", splay-&gt;rank(t));
			}
			break;
		default:
			break;
		}
	}
}

int main() {
//	freopen("in","r",stdin);
//	runTest();
//	cout&lt;&lt;INF&lt;&lt;endl;
	solve();
}
</pre><pre></pre><h2>Problem1863</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int maxn=20000,inf=~0U&gt;&gt;1;
using namespace std;
int a[maxn],n,l[maxn],r[maxn];
inline void checkmin(int&amp;x,int c){if(x&gt;c)x=c;}
inline void checkmax(int&amp;x,int c){if(x&lt;c)x=c;}
bool Check(int K)
{
    l[0]=r[0]=a[0];
    for(int i=1;i&lt;n;i++)
    {
        l[i]=-inf;r[i]=inf;
        if(a[i-1]+a[i]&gt;K)return false;
        checkmin(r[i],a[0]-l[i-1]);
        checkmin(r[i],a[0]);
        checkmin(r[i],a[i]);
        checkmax(l[i],a[0]+a[i-1]+a[i]-K-r[i-1]);
        checkmax(l[i],a[i]-K+a[0]);
        checkmax(l[i],0);
        if(l[i]&gt;r[i])return false;
    }
    return l[n-1]&lt;=0;
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);rep(i,n)scanf("%d",a+i);
    int l=0,r=500000;
    while(l+1&lt;r)
    {
        int m=l+r&gt;&gt;1;
        if(Check(m))r=m;else l=m;
    }
    printf("%d\n",r);
}


</pre><pre></pre><h2>Problem1864</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=10000+10;
using namespace std;
char C[maxn];
int Dp[maxn][2],now,c;//0=green 1=other
int dfs()
{
    int tmp=++now,ch,ch1,ch2;
    switch(C[tmp])
    {
        case '0':
            Dp[tmp][0]=c;Dp[tmp][1]=0;break;
        case '1':
            ch=dfs();Dp[tmp][0]=Dp[ch][1]+c;
            Dp[tmp][1]=max(Dp[ch][1],Dp[ch][0]);break;
        case '2':
            ch1=dfs();ch2=dfs();
            Dp[tmp][0]=Dp[ch1][1]+Dp[ch2][1]+c;
            Dp[tmp][1]=max(Dp[ch1][0]+Dp[ch2][1],Dp[ch1][1]+Dp[ch2][0]);break;
    }
    return tmp;
}
int Cal(int _c)
{
    c=_c;now=-1;
    int root=dfs();
    return max(Dp[root][0],Dp[root][1]);
}
int main()
{
    //freopen("in","r",stdin);
    gets(C);
    cout&lt;&lt;Cal(1)&lt;&lt;" "&lt;&lt;-Cal(-1)&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1866</h2><pre>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=30,maxc=8;
using namespace std;
map&lt;string,int&gt; Map;
vector&lt;int&gt; Mark[maxn];
int n,m,Ans=inf;
int E[maxn][maxn];
struct State
{
    int at,mask;
    State(){}
    State(int _at,int _mask):
        at(_at),mask(_mask){}
    void mark(int go)
    {
        rep(i,Mark[go].size())
            mask|=1&lt;&lt;(Mark[go][i]);
    }
    bool full()
    {
        return mask+1==(1&lt;&lt;8);
    }
    bool movefree()
    {
        rep(i,4)
        {
            int t=(mask&gt;&gt;(i*2))&amp;3;
            if(t!=0&amp;&amp;t!=3)return false;
        }
        return true;
    }
    int hash()const{return (at&lt;&lt;8)+mask;}
};
queue&lt;State&gt; Q;
int TDist[maxn&lt;&lt;8];
bool TinQ[maxn&lt;&lt;8];
int&amp;Dist(const State&amp;st){return TDist[st.hash()];}
bool&amp;inQ(const State&amp;st){return TinQ[st.hash()];}
void spfa()
{
    memset(TDist,-1,sizeof TDist);
    memset(TinQ,0,sizeof TinQ);
    rep(at,n)
    {
        State now(at,0);
        now.mark(at);
        Dist(now)=0;inQ(now)=true;
        Q.push(now);
    }
    while(Q.size())
    {
        State now=Q.front();Q.pop();
        int c=Dist(now);inQ(now)=false;
        if(now.full())
        {
            if(c&lt;Ans)Ans=c;
            continue;
        }
        bool free=now.movefree();
        State next;int w;
        //let's go
        rep(go,n)
            if((w=E[now.at][go])!=inf)
            {
                if(free)w=0;
                int nc=c+w;
                next.at=go;next.mask=now.mask;
                next.mark(go);
                if(Dist(next)==-1||Dist(next)&gt;nc)
                {
                    Dist(next)=nc;
                    if(!inQ(next))
                        Q.push(next),inQ(next)=true;
                }
            }
        //or we merge somthing
        rep(j,(1&lt;&lt;8))
        {
            State tmp(now.at,j);
            int tmpc=Dist(tmp);
            if(tmpc!=-1)
            {
                State next(now.at,j|(now.mask));
                int nc=tmpc+c;
                if(Dist(next)==-1||Dist(next)&gt;nc)
                {
                    Dist(next)=nc;
                    if(!inQ(next))
                        Q.push(next),inQ(next)=true;
                }
            }
        }
    }
}
void init()
{
    cin&gt;&gt;n&gt;&gt;m;string a,b;int c;
    rep(i,n)rep(j,n)E[i][j]=inf;
    rep(i,n)cin&gt;&gt;a,Map[a]=i;
    rep(i,m)
    {
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        int s=Map[a],t=Map[b];
        E[s][t]=E[t][s]=min(E[s][t],c);
    }
    memset(Mark,-1,sizeof Mark);
    rep(i,8)
    {
        cin&gt;&gt;a;Mark[Map[a]].push_back(i);
    }
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    init();
    spfa();
    cout&lt;&lt;Ans&lt;&lt;endl;
}

</pre><pre></pre><h2>Problem1868</h2><pre>/*
 * MinCut Query.cpp
 *
 *  Created on: 2011-4-5
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int INF = ~0U &gt;&gt; 1;
const int MAX_N_VETS = 150 + 10;
struct Network {
	static const int MAX_N_EDGES = 10000;

	int head[MAX_N_VETS];
	int dest[MAX_N_EDGES], cap[MAX_N_EDGES], next[MAX_N_EDGES];
	int origCap[MAX_N_EDGES];

	int nVets, nEdges;

	void init(int _nVets) {
		nVets = _nVets;
		memset(head, -1, sizeof head);
		nEdges = 0;
	}

	void makeEdge(int s, int t, int c) {
		int id = nEdges++;
		next[id] = head[s];
		dest[id] = t;
		origCap[id] = c;
		head[s] = id;
	}

	void addEdge(int s, int t, int c) {
		makeEdge(s, t, c);
		makeEdge(t, s, c);
	}

	void reSetCap() {
		memcpy(cap, origCap, sizeof(int) * nEdges);
	}

	int am[MAX_N_VETS], prev[MAX_N_VETS], h[MAX_N_VETS], cnt[MAX_N_VETS],
			cur[MAX_N_VETS];
	int totalFlow;

	int vs, vt;
	bool side[MAX_N_VETS];

	void dfsSide(int u) {
		if (side[u])
			return;
		side[u] = true;
		for (int e = head[u]; e != -1; e = next[e])
			if (cap[e] &gt; 0)
				dfsSide(dest[e]);
	}

	void findMinCut() {
		memset(side, false, sizeof side);
		dfsSide(vs);
	}

	int calcMaxFlow(int _vs, int _vt) {
		vs = _vs;
		vt = _vt;
		memset(am, 0, sizeof am);
		memset(cur, -1, sizeof cur);
		memset(h, 0, sizeof h);
		memset(cnt, 0, sizeof cnt);
		cnt[0] = nVets;
		int u = vs, now;
		totalFlow = 0;
		am[u] = INF;
		while (h[vs] &lt; nVets) {
			for (now = cur[u]; now != -1; now = next[now])
				if (cap[now] &gt; 0 &amp;&amp; h[u] == h[dest[now]] + 1)
					break;
			if (now != -1) {
				int v = dest[now];
				cur[u] = prev[v] = now;
				am[v] = min(am[u], cap[now]);
				u = v;
				if (u == vt) {
					int by = am[u];
					while (u != vs) {
						cap[prev[u]] -= by;
						cap[prev[u] ^ 1] += by;
						u = dest[prev[u] ^ 1];
					}
					totalFlow += by;
					am[u] = INF;
				}
			} else {
				if (!--cnt[h[u]])
					break;
				h[u] = nVets;
				for (now = head[u]; now != -1; now = next[now])
					if (cap[now] &gt; 0 &amp;&amp; h[dest[now]] + 1 &lt; h[u]) {
						h[u] = h[dest[now]] + 1;
						cur[u] = now;
					}
				++cnt[h[u]];
				if (u != vs)
					u = dest[prev[u] ^ 1];
			}
		}

		return totalFlow;
	}
};

int minCut[MAX_N_VETS][MAX_N_VETS];
Network network;

void solve(vector&lt;int&gt; cur) {
	if (cur.size() &lt;= 1)
		return;
	int a = cur[0], b = cur[1];
	network.reSetCap();
	int cut = network.calcMaxFlow(a, b);
	network.findMinCut();
	for (int a = 0; a &lt; network.nVets; ++a) {
		if (network.side[a])
			for (int b = 0; b &lt; network.nVets; ++b) {
				if (!network.side[b]) {
					minCut[a][b] = minCut[b][a] = min(minCut[a][b], cut);
				}
			}
	}

	vector&lt;int&gt; ch[2];
	foreach(e,cur)
		ch[network.side[*e]].push_back(*e);
	solve(ch[0]);
	solve(ch[1]);
}

void inputData() {
	int nV, nE;
	scanf("%d%d", &amp;nV, &amp;nE);
	network.init(nV);
	for (int i = 0; i &lt; nE; ++i) {
		int u, v, c;
		scanf("%d%d%d", &amp;u, &amp;v, &amp;c);
		--u;
		--v;
		network.addEdge(u, v, c);
	}
}

void prepare() {
	vector&lt;int&gt; cur;
	for (int i = 0; i &lt; network.nVets; ++i) {
		cur.push_back(i);
	}
	for (int i = 0; i &lt; network.nVets; ++i) {
		for (int j = 0; j &lt; network.nVets; ++j) {
			minCut[i][j] = INF;
		}
	}
	solve(cur);
}

int ask(int what) {
	int cnt = 0;
	for (int i = 0; i &lt; network.nVets; ++i) {
		for (int j = 0; j &lt; i; ++j) {
			cnt += minCut[i][j] &lt;= what;
		}
	}
	return cnt;
}

void answer() {
	int nQ;
	scanf("%d", &amp;nQ);
	for (int i = 0; i &lt; nQ; ++i) {
		int what;
		scanf("%d", &amp;what);
		printf("%d\n", ask(what));
	}
}

int main() {
	int nT;
	scanf("%d", &amp;nT);
	for (int i = 0; i &lt; nT; ++i) {
		inputData();
		prepare();
		answer();
		if (i != nT - 1)
			puts("");
	}
}
</pre><pre></pre><h2>Problem1869</h2><pre>/*
 * 珠子游戏.cpp
 *
 *  Created on: 2011-7-16
 *      Author: mac
 */

#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;climits&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;

typedef long long int64;
struct Fraction {
	int64 a, b; //a/b
	Fraction() {
	}
	Fraction(int64 _a, int64 _b) :
			a(_a), b(_b) {
	}
	Fraction adjust(int64 nb) const {
		int64 by = nb / b;
		return Fraction(a * by, b * by);
	}
	Fraction operator+(const Fraction&amp;o) const {
		if (b &lt; o.b)
			return adjust(o.b) + o;
		else if (b &gt; o.b)
			return o.adjust(b) + (*this);
		else
			return Fraction(a + o.a, b);
	}
	bool operator&lt;(const Fraction&amp;o) const {
		if (b &lt; o.b)
			return adjust(o.b) &lt; o;
		else if (b &gt; o.b)
			return (*this) &lt; o.adjust(b);
		else
			return a &lt; o.a;
	}
};

Fraction readTower(int n) {
	static char buf[100];
	scanf(" ");
	for (int i = 0; i &lt; n; ++i) {
		scanf(" ");
		scanf("%c", buf + i);
	}
	int x = 0, i;
	for (i = 0; i &lt; n &amp;&amp; buf[i] == buf[0]; ++i) {
		if (buf[i] == 'W')
			++x;
		else
			--x;
	}
	Fraction ret(x, 1);
	int64 k = 2;
	for (; i &lt; n; ++i) {
		ret = ret + Fraction(buf[i] == 'W' ? 1 : -1, k);
		k &lt;&lt;= 1;
	}
	return ret;
}

Fraction readState() {
	int ns[3];
	for (int i = 0; i &lt; 3; ++i) {
		scanf("%d", ns + i);
	}
	Fraction ret(0, 1);
	for (int i = 0; i &lt; 3; ++i) {
		ret = ret + readTower(ns[i]);
	}
	return ret;
}

int main() {
	int nTests;
	scanf("%d", &amp;nTests);
	for (int i = 0; i &lt; nTests; ++i) {
		scanf(" ");
		char buf[1000];
		scanf("%[^\n]\n", buf);
		Fraction a = readState(), b = readState();
		printf("Test %d: ", i + 1);
		if (a &lt; b)
			printf("No\n");
		else
			printf("Yes\n");
	}
}</pre><pre></pre><h2>Problem1876</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define Rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=10000+10,m=10000,L=4;
char C[maxn+10];
int tmp[maxn/L+1],P[L]={1,10,100,1000};
struct BigInt
{
    int H[maxn/L+1],l;
    BigInt()
    {
        memset(H,0,sizeof(H));l=0;
    }
    void Set(int x)
    {
        H[l]=x;
    }
    void divide()
    {
        int d=0;
        for(int i=l;i&gt;=0;i--)
        {
            d*=m;d+=H[i];
            H[i]=d/2;d%=2;
        }
        while(l&amp;&amp;!H[l])l--;
    }
    int mod()
    {
        return H[0]%2;
    }
    void operator*=(int x)
    {
        int d=0;
        for(int i=0;i&lt;=l;i++)
        {
            d+=H[i]*x;H[i]=d%m;
            d/=m;
        }
        while(d)H[++l]=d%m,d/=m;
    }
    void operator-=(const BigInt&amp;o)
    {
        int d=0;
        for(int i=0;i&lt;=l;i++)
        {
            H[i]-=d;
            if(H[i]&lt;o.H[i])H[i]+=m,d=1;
            else d=0;
            H[i]-=o.H[i];
        }
        while(l&amp;&amp;!H[l])l--;
    }
    void ReadIn()
    {
        memset(C,0,sizeof(C));
        scanf("%s",C);int s=0,a=0;l=0;
        for(int i=strlen(C)-1;i&gt;=0;i--)
        {
            a+=(C[i]-'0')*P[s++];
            if(s==4)H[l++]=a,s=0,a=0;
        }
        if(!s)l--;else H[l]=a;
    }
    void Print()
    {
        printf("%d",H[l]);
        for(int i=l-1;i&gt;=0;i--)printf("%04d",H[i]);
    }
    bool operator&lt;(const BigInt&amp;o)const
    {
        if(l!=o.l)return l&lt;o.l;
        for(int i=l;i&gt;=0;i--)
        {
            if(H[i]&lt;o.H[i])return true;
            if(H[i]&gt;o.H[i])return false;
        }
    }
    bool iszero()const{return l==0&amp;&amp;H[l]==0;}
}A[2];
int main()
{
    //freopen("in","r",stdin);
    A[0].ReadIn();A[1].ReadIn();
    int a=0,b=1,c=0;
    while(true)
    {
        if(A[b]&lt;A[a])a^=b^=a^=b;
        //A[a].Print();printf(",");A[b].Print();
        //puts("");
        if(A[a].iszero())
        {
            while(c&gt;=16)A[b]*=(1&lt;&lt;16),c-=16;
            while(c--)A[b]*=2;
            A[b].Print();
            break;
        }
        int i=A[a].mod(),j=A[b].mod();
        if(!i)A[a].divide();
        if(!j)A[b].divide();
        if(!i&amp;&amp;!j)c++;
        if(i&amp;&amp;j)A[b]-=A[a];
    }
}

</pre><pre></pre><h2>Problem1876</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define Rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
typedef unsigned long long ull;
const int maxn=10000+10,L=10;
const ull m=1e10;
char C[maxn+10];
ull P[L];
struct BigInt
{
    ull H[maxn/L+1];int l;
    BigInt()
    {
        memset(H,0,sizeof(H));l=0;
    }
    void divide()
    {
        ull d=0;
        for(int i=l;i&gt;=0;i--)
        {
            d*=m;d+=H[i];
            H[i]=d/2;d%=2;
        }
        while(l&amp;&amp;!H[l])l--;
    }
    int mod()
    {
        return H[0]%2;
    }
    void operator*=(int x)
    {
        ull d=0;
        for(int i=0;i&lt;=l;i++)
        {
            d+=H[i]*x;H[i]=d%m;
            d/=m;
        }
        while(d)H[++l]=d%m,d/=m;
    }
    void operator-=(const BigInt&amp;o)
    {
        ull d=0;
        for(int i=0;i&lt;=l;i++)
        {
            H[i]-=d;
            if(H[i]&lt;o.H[i])H[i]+=m,d=1;
            else d=0;
            H[i]-=o.H[i];
        }
        while(l&amp;&amp;!H[l])l--;
    }
    void ReadIn()
    {
        memset(C,0,sizeof(C));
        scanf("%s",C);int s=0;l=0;ull a=0;
        for(int i=strlen(C)-1;i&gt;=0;i--)
        {
            a+=(C[i]-'0')*P[s++];
            if(s==L)H[l++]=a,s=0,a=0;
        }
        if(!s)l--;else H[l]=a;
    }
    void Print()
    {
        printf("%I64d",H[l]);
        for(int i=l-1;i&gt;=0;i--)printf("%010I64d",H[i]);
    }
    bool operator&lt;(const BigInt&amp;o)const
    {
        if(l!=o.l)return l&lt;o.l;
        for(int i=l;i&gt;=0;i--)
        {
            if(H[i]&lt;o.H[i])return true;
            if(H[i]&gt;o.H[i])return false;
        }
    }
    bool iszero()const{return l==0&amp;&amp;H[l]==0;}
}A[2];
int main()
{
    //freopen("in","r",stdin);
    P[0]=1;Rep(i,L-1)P[i+1]=P[i]*10;
    A[0].ReadIn();A[1].ReadIn();
    int a=0,b=1,c=0;
    while(true)
    {
        if(A[b]&lt;A[a])a^=b^=a^=b;
        //A[a].Print();printf(",");A[b].Print();
        //puts("");
        if(A[a].iszero())
        {
            while(c&gt;=16)A[b]*=(1&lt;&lt;16),c-=16;
            while(c--)A[b]*=2;
            A[b].Print();
            break;
        }
        int i=A[a].mod(),j=A[b].mod();
        if(!i)A[a].divide();
        if(!j)A[b].divide();
        if(!i&amp;&amp;!j)c++;
        if(i&amp;&amp;j)A[b]-=A[a];
    }
}

</pre><pre></pre><h2>Problem1876</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define Rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
typedef unsigned long long ull;
const int maxn=10000+10,L=10;
const ull m=1e10;
char C[maxn+10];
ull P[L];
struct BigInt
{
    ull H[maxn/L+1];int l;
    BigInt()
    {
        memset(H,0,sizeof(H));l=0;
    }
    void divide()
    {
        ull d=0;
        for(int i=l;i&gt;=0;i--)
        {
            d*=m;d+=H[i];
            H[i]=d/2;d%=2;
        }
        while(l&amp;&amp;!H[l])l--;
    }
    int mod()
    {
        return H[0]%2;
    }
    void operator*=(int x)
    {
        ull d=0;
        for(int i=0;i&lt;=l;i++)
        {
            d+=H[i]*x;H[i]=d%m;
            d/=m;
        }
        while(d)H[++l]=d%m,d/=m;
    }
    void operator-=(const BigInt&amp;o)
    {
        ull d=0;
        for(int i=0;i&lt;=l;i++)
        {
            H[i]-=d;
            if(H[i]&lt;o.H[i])H[i]+=m,d=1;
            else d=0;
            H[i]-=o.H[i];
        }
        while(l&amp;&amp;!H[l])l--;
    }
    void ReadIn()
    {
        memset(C,0,sizeof(C));
        scanf("%s",C);int s=0;l=0;ull a=0;
        for(int i=strlen(C)-1;i&gt;=0;i--)
        {
            a+=(C[i]-'0')*P[s++];
            if(s==L)H[l++]=a,s=0,a=0;
        }
        if(!s)l--;else H[l]=a;
    }
    void Print()
    {
        printf("%I64d",H[l]);
        for(int i=l-1;i&gt;=0;i--)printf("%010I64d",H[i]);
    }
    bool operator&lt;(const BigInt&amp;o)const
    {
        if(l!=o.l)return l&lt;o.l;
        for(int i=l;i&gt;=0;i--)
        {
            if(H[i]&lt;o.H[i])return true;
            if(H[i]&gt;o.H[i])return false;
        }
    }
    bool iszero()const{return l==0&amp;&amp;H[l]==0;}
}A[2];
int main()
{
    //freopen("in","r",stdin);
    P[0]=1;Rep(i,L-1)P[i+1]=P[i]*10;
    A[0].ReadIn();A[1].ReadIn();
    int a=0,b=1,c=0;
    while(true)
    {
        if(A[b]&lt;A[a])a^=b^=a^=b;
        //A[a].Print();printf(",");A[b].Print();
        //puts("");
        if(A[a].iszero())
        {
            while(c&gt;=24)A[b]*=(1&lt;&lt;24),c-=24;
            while(c--)A[b]*=2;
            A[b].Print();
            break;
        }
        int i=A[a].mod(),j=A[b].mod();
        if(!i)A[a].divide();
        if(!j)A[b].divide();
        if(!i&amp;&amp;!j)c++;
        if(i&amp;&amp;j)A[b]-=A[a];
    }
}
</pre><pre></pre><h2>Problem1876</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define Rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
typedef unsigned long long ull;
const int maxn=10000+10,L=10;
const ull m=1e10;
char C[maxn+10];
ull P[L];
struct BigInt
{
    ull H[maxn/L+1];int l;
    BigInt()
    {
        memset(H,0,sizeof(H));l=0;
    }
    void divide()
    {
        ull d=0;
        for(int i=l;i&gt;=0;i--)
        {
            d*=m;d+=H[i];
            H[i]=d/2;d%=2;
        }
        while(l&amp;&amp;!H[l])l--;
    }
    int mod()
    {
        return H[0]%2;
    }
    void operator*=(int x)
    {
        ull d=0;
        for(int i=0;i&lt;=l;i++)
        {
            d+=H[i]*x;H[i]=d%m;
            d/=m;
        }
        while(d)H[++l]=d%m,d/=m;
    }
    void operator-=(const BigInt&amp;o)
    {
        ull d=0;
        for(int i=0;i&lt;=l;i++)
        {
            H[i]-=d;
            if(H[i]&lt;o.H[i])H[i]+=m,d=1;
            else d=0;
            H[i]-=o.H[i];
        }
        while(l&amp;&amp;!H[l])l--;
    }
    void ReadIn()
    {
        memset(C,0,sizeof(C));
        scanf("%s",C);int s=0;l=0;ull a=0;
        for(int i=strlen(C)-1;i&gt;=0;i--)
        {
            a+=(C[i]-'0')*P[s++];
            if(s==L)H[l++]=a,s=0,a=0;
        }
        if(!s)l--;else H[l]=a;
    }
    void Print()
    {
        printf("%I64d",H[l]);
        for(int i=l-1;i&gt;=0;i--)printf("%010I64d",H[i]);
    }
    bool operator&lt;(const BigInt&amp;o)const
    {
        if(l!=o.l)return l&lt;o.l;
        for(int i=l;i&gt;=0;i--)
        {
            if(H[i]&lt;o.H[i])return true;
            if(H[i]&gt;o.H[i])return false;
        }
    }
    bool iszero()const{return l==0&amp;&amp;H[l]==0;}
}A[2];
int main()
{
    //freopen("in","r",stdin);
    P[0]=1;Rep(i,L-1)P[i+1]=P[i]*10;
    A[0].ReadIn();A[1].ReadIn();
    int a=0,b=1,c=0;
    while(true)
    {
        if(A[b]&lt;A[a])a^=b^=a^=b;
        //A[a].Print();printf(",");A[b].Print();
        //puts("");
        if(A[a].iszero())
        {
            while(c&gt;=24)A[b]*=(1&lt;&lt;24),c-=24;
            if(c)A[b]*=(1&lt;&lt;c);
            A[b].Print();
            break;
        }
        int i=A[a].mod(),j=A[b].mod();
        if(!i)A[a].divide();
        if(!j)A[b].divide();
        if(!i&amp;&amp;!j)c++;
        if(i&amp;&amp;j)A[b]-=A[a];
    }
}
</pre><pre></pre><h2>Problem1876</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define Rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
typedef unsigned long long ull;
const int maxn=10000+10,L=10;
const ull m=1e10;
char C[maxn+10];
ull P[L];
struct BigInt
{
    ull H[maxn/L+1];int l;
    BigInt()
    {
        memset(H,0,sizeof(H));l=0;
    }
    void divide(int x)
    {
        ull d=0;
        for(int i=l;i&gt;=0;i--)
        {
            d*=m;d+=H[i];
            H[i]=d/x;d%=x;
        }
        while(l&amp;&amp;!H[l])l--;
    }
    int mod()
    {
        Rep(i,10)if(H[0]&gt;&gt;i&amp;1)return i;
        return 10;
    }
    void operator*=(int x)
    {
        ull d=0;
        for(int i=0;i&lt;=l;i++)
        {
            d+=H[i]*x;H[i]=d%m;
            d/=m;
        }
        while(d)H[++l]=d%m,d/=m;
    }
    void operator-=(const BigInt&amp;o)
    {
        ull d=0;
        for(int i=0;i&lt;=l;i++)
        {
            H[i]-=d;
            if(H[i]&lt;o.H[i])H[i]+=m,d=1;
            else d=0;
            H[i]-=o.H[i];
        }
        while(l&amp;&amp;!H[l])l--;
    }
    void ReadIn()
    {
        memset(C,0,sizeof(C));
        scanf("%s",C);int s=0;l=0;ull a=0;
        for(int i=strlen(C)-1;i&gt;=0;i--)
        {
            a+=(C[i]-'0')*P[s++];
            if(s==L)H[l++]=a,s=0,a=0;
        }
        if(!s)l--;else H[l]=a;
    }
    void Print()
    {
        printf("%I64d",H[l]);
        for(int i=l-1;i&gt;=0;i--)printf("%010I64d",H[i]);
    }
    bool operator&lt;(const BigInt&amp;o)const
    {
        if(l!=o.l)return l&lt;o.l;
        for(int i=l;i&gt;=0;i--)
        {
            if(H[i]&lt;o.H[i])return true;
            if(H[i]&gt;o.H[i])return false;
        }
    }
    bool iszero()const{return l==0&amp;&amp;H[l]==0;}
}A[2];
int main()
{
    //freopen("in","r",stdin);
    P[0]=1;Rep(i,L-1)P[i+1]=P[i]*10;
    A[0].ReadIn();A[1].ReadIn();
    int a=0,b=1,c=0;
    while(true)
    {
        if(A[b]&lt;A[a])a^=b^=a^=b;
        //A[a].Print();printf(",");A[b].Print();
        //puts("");
        if(A[a].iszero())
        {
            while(c&gt;=16)A[b]*=(1&lt;&lt;16),c-=16;
            if(c)A[b]*=(1&lt;&lt;c);
            A[b].Print();
            break;
        }
        int i=A[a].mod(),j=A[b].mod(),m=min(i,j);
        if(i)A[a].divide(1&lt;&lt;i);
        if(j)A[b].divide(1&lt;&lt;j);
        if(m)c+=m;
        if(!i&amp;&amp;!j){A[b]-=A[a];}
    }
}
</pre><pre></pre><h2>Problem1877</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;deque&gt;
#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=400+10,maxm=30000*2,inf=0x3F3F3F3F;
int mnt=0;
int c[maxm],u[maxm],t[maxm],nxt[maxm];
int head[maxn];
void AddEdge(int s,int _t,int _u,int _c)
{
    c[mnt]=_c;t[mnt]=_t;u[mnt]=_u;
    nxt[mnt]=head[s];head[s]=mnt;
    mnt++;
}
void InsEdge(int s,int t,int u,int c)
{
    AddEdge(s,t,u,c);
    AddEdge(t,s,0,-c);
}
int vis[maxn]={0},flag=0;
int piS=0,cost=0,flow=0,vs,vt,v;
int aug(int no,int m)
{
    if(no==vt) return cost+=piS*m,flow+=m,m;
    vis[no]=flag;
    int l=m;
    for(int e=head[no];e!=-1;e=nxt[e])
        if(u[e]&amp;&amp;!c[e]&amp;&amp;vis[t[e]]!=flag)
        {
            int d=aug(t[e],min(l,u[e]));
            u[e]-=d;u[e^1]+=d;l-=d;
            if(!l)return m;
        }
    return m-l;
}
bool mod()
{
    static int D[maxn];memset(D,0x3F,sizeof D);D[vt]=0;
    static deque&lt;int&gt; Q;Q.push_back(vt);
    while(Q.size())
    {
        int dt,no=Q.front();Q.pop_front();
        for(int e=head[no];e!=-1;e=nxt[e])
            if(u[e^1]&amp;&amp;(dt=D[no]-c[e])&lt;D[t[e]])
                (D[t[e]]=dt)&lt;=D[Q.size()?Q.front():0]
                    ?Q.push_front(t[e]):Q.push_back(t[e]);
    }
    rep(i,v)
       for(int e=head[i];e!=-1;e=nxt[e])
           c[e]+=D[t[e]]-D[i];
    piS+=D[vs];
    return D[vs]&lt;inf;
}
int CalCostFlow()
{
    while(mod())
        do ++flag;
        while(aug(vs,inf));
    return cost;
}
int in(int v){return v*2;}
int out(int v){return v*2+1;}
int main()
{
    //freopen("in","r",stdin);
    int n,m,s,t,c;
    scanf("%d%d",&amp;n,&amp;m);
    memset(head,-1,sizeof head);
    v=n*2;vs=out(0);vt=in(n-1);
    rep(i,m)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);
        --s;--t;
        InsEdge(out(s),in(t),1,c);
    }
    rep(i,n)
        InsEdge(in(i),out(i),1,0);
    CalCostFlow();
    cout&lt;&lt;flow&lt;&lt;" "&lt;&lt;cost&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1878</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;2,maxn=50000+2,maxm=200000,maxd=1000000+1;
using namespace std;
typedef pair&lt;int,int&gt; ii;
int Ans[maxm],A[maxn],P[maxd],n,m,L[maxn],R[maxn];
vector&lt;ii&gt; E[maxn];
struct uf
{
    int F[maxn],n;
    void Set(int _n){n=_n;For(i,0,n)F[i]=i;}
    int Find(int x)
    {
        if(F[x]==x)return x;
        return F[x]=Find(F[x]);
    }
    void Union(int i,int j)
    {
        F[j]=i;
    }
}U;
struct TArray
{
    int A[maxn],n;
    void Add(int p,int d)
    {
        for(;p&lt;=n;p+=(p&amp;-p))A[p]+=d;
    }
    void Add(int l,int r,int d)
    {
        Add(l,d);Add(r+1,-d);
    }
    void Set(int _n){n=_n;For(i,0,n)A[i]=0;}
    int operator[](int i)
    {
        int ret=0;if(!i)return inf;
        for(;i;i-=(i&amp;-i))ret+=A[i];
        return ret;
    }
}T;
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);For(i,1,n)scanf("%d",A+i),P[A[i]]=0;
    scanf("%d",&amp;m);int l,r;rep(i,m)scanf("%d%d",&amp;l,&amp;r),E[r].pb(ii(l,i));
    For(i,0,n+1)L[i]=i-1,R[i]=i+1;U.Set(n);T.Set(n);
    For(i,1,n)
    {
        int t=A[i],p=P[t]+1;P[t]=i;
        T.Add(p,i,1);
        p=U.Find(p);
        while(T[L[p]]&lt;=T[p])
        {
            t=L[p];U.Union(p,t);
            R[L[t]]=R[t];L[R[t]]=L[t];
        }
        rep(j,E[i].size())Ans[E[i][j].second]=T[U.Find(E[i][j].first)];
    }
    rep(i,m)printf("%d\n",Ans[i]);
}


</pre><pre></pre><h2>Problem1878</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;2,maxn=50000+2,maxm=200000,maxd=1000000+1;
using namespace std;
typedef pair&lt;int,int&gt; ii;
int Ans[maxm],A[maxn],P[maxd],n,m;
vector&lt;ii&gt; E[maxn];
struct TArray
{
    int A[maxn],n;
    void Add(int p,int d)
    {
        for(;p&lt;=n;p+=(p&amp;-p))A[p]+=d;
    }
    void Add(int l,int r,int d)
    {
        Add(l,d);Add(r+1,-d);
    }
    void Set(int _n){n=_n;For(i,0,n)A[i]=0;}
    int operator[](int i)
    {
        int ret=0;if(!i)return inf;
        for(;i;i-=(i&amp;-i))ret+=A[i];
        return ret;
    }
}T;
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);For(i,1,n)scanf("%d",A+i),P[A[i]]=0;
    scanf("%d",&amp;m);int l,r;rep(i,m)scanf("%d%d",&amp;l,&amp;r),E[r].pb(ii(l,i));
    T.Set(n);
    For(i,1,n)
    {
        int t=A[i],p=P[t]+1;P[t]=i;
        T.Add(p,i,1);
        rep(j,E[i].size())Ans[E[i][j].second]=T[E[i][j].first];
    }
    rep(i,m)printf("%d\n",Ans[i]);
}


</pre><pre></pre><h2>Problem1879</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
const int maxn=15,maxL=50,mod=1000003;
int T,N,K;
string A[maxn];
bool C[maxn];
int Ret[1&lt;&lt;maxn];
void Calc_Ret()
{
    static char Fixed[maxL];
    memset(Fixed,0,sizeof Fixed);
    int Set=0;
    int ret=1;
    rep(i,N)if(C[i])
    {
        Set|=1&lt;&lt;i;
        rep(j,A[i].size())
        if(A[i][j]!='?')
        {
            if(Fixed[j]&amp;&amp;A[i][j]!=Fixed[j])
            {
                ret=0;
            }
            else
            {
                Fixed[j]=A[i][j];
            }
        }
    }
    rep(j,A[0].size())if(!Fixed[j])ret*=26,ret%=mod;
    Ret[Set]=ret;
}
void Generate_Ways(int str)
{
    if(str==N)
    {
        Calc_Ret();
        return;
    }
    //D choose A[str]
    C[str]=false;
    Generate_Ways(str+1);
    //choose A[str];
    C[str]=true;
    Generate_Ways(str+1);
}
void Calc_Ans()
{
    int Ans=0;
    for(int i=(1&lt;&lt;N)-1;i&gt;=0;i--)
    {
        for(int subset=(i-1)&amp;i;subset&gt;0;subset=(subset-1)&amp;i)
            Ret[subset]=(Ret[subset]-Ret[i]+mod)%mod;
        if(i)Ret[0]=(Ret[0]-Ret[i]+mod)%mod;
    }
    rep(i,(1&lt;&lt;N))
    {
        int cnt=0;
        rep(j,N)if(i&gt;&gt;j&amp;1)cnt++;
        if(cnt==K)Ans+=Ret[i],Ans%=mod;
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
}
void Input_Data()
{
    cin&gt;&gt;N&gt;&gt;K;
    rep(i,N)cin&gt;&gt;A[i];
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;T;
    rep(i,T)
    {
        Input_Data();
        Generate_Ways(0);
        Calc_Ans();
    }
}
</pre><pre></pre><h2>Problem1880</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=1500;
using namespace std;
int n,m,S[2],T[2];
struct Edge
{
    int t,c;Edge*next;
    Edge(int _t,int _c,Edge*_n):t(_t),c(_c),next(_n){}
}*E[maxn]={};
void AddEdge(int s,int t,int c)
{
    E[s]=new Edge(t,c,E[s]);
    E[t]=new Edge(s,c,E[t]);
}
int DistS[2][maxn],DistT[2][maxn];
struct Queue
{
    int Q[maxn],h,t;bool inQ[maxn];
    Queue(){h=t=0;memset(inQ,0,sizeof(inQ));}
    void inc(int&amp;i){if(++i==maxn)i=0;}
    void put(int x)
    {
        if(inQ[x])return;inQ[x]=true;
        Q[t]=x;inc(t);
    }
    int get()
    {
        int tmp=Q[h];inc(h);inQ[tmp]=false;
        return tmp;
    }
    bool empty(){return h==t;}
};
void Spfa(int vs,int Dist[maxn])
{
    static Queue Q;
    rep(i,n)Dist[i]=inf;Dist[vs]=0;Q.put(vs);
    while(!Q.empty())
    {
        int t=Q.get(),c=Dist[t];
        for(Edge*e=E[t];e;e=e-&gt;next)
            if(c+e-&gt;c&lt;Dist[e-&gt;t])
                Dist[e-&gt;t]=c+e-&gt;c,Q.put(e-&gt;t);
    }
}
int D[2];
bool inPath(int v)
{
    rep(i,2)if(DistS[i][v]+DistT[i][v]!=D[i])return false;
    return true;
}
bool inPath(int s,Edge*e)
{
    rep(i,2)
    {
        int Dist=min(DistS[i][s]+DistT[i][e-&gt;t],DistS[i][e-&gt;t]+DistT[i][s])+e-&gt;c;
        if(Dist!=D[i])return false;
    }
    return true;
}
bool In[maxn]={};
int A[maxn],v=0,Dp[maxn]={};
bool cmp(int i,int j)
{
    return DistS[0][i]&lt;DistS[0][j];
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d%d%d%d%d",&amp;n,&amp;m,S+0,T+0,S+1,T+1);int s,t,c;
    rep(i,2)S[i]--,T[i]--;
    while(m--)scanf("%d%d%d",&amp;s,&amp;t,&amp;c),--s,--t,AddEdge(s,t,c);
    rep(i,2)Spfa(S[i],DistS[i]),Spfa(T[i],DistT[i]);
    rep(i,2)D[i]=DistS[i][T[i]];
    rep(i,n)In[i]=inPath(i),In[i]?A[v++]=i:0;
    sort(A,A+v,cmp);
    int ans=0;
    rep(i,v)
    {
        int t=A[i];ans&gt;?=Dp[t];
        for(Edge*e=E[t];e;e=e-&gt;next)if(In[e-&gt;t]&amp;&amp;inPath(t,e))
            Dp[e-&gt;t]&gt;?=Dp[t]+e-&gt;c;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1887</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(eit e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1,maxn=100000,mod=1000000007;
using namespace std;
typedef long long ll;
int n;
struct Edge
{
    int t,c;
    Edge(int _t,int _c):t(_t),c(_c){}
};
vector&lt;Edge&gt; E[maxn];
typedef vector&lt;Edge&gt;::iterator eit;
void InsEdge(int s,int t,int c)
{
    E[s].pb(Edge(t,c));E[t].pb(Edge(s,c));
}
ll pow(int x,int e)
{
    if(!e)return 1;
    ll tmp=pow(x,e/2);tmp*=tmp;tmp%=mod;
    if(e&amp;1)tmp*=x,tmp%=mod;
    return tmp;
}
ll Sum[maxn],P,ans=0;
int Q[maxn],F[maxn],h,t;
void BFS(int vs)
{
    h=t=0;
    for(Q[t++]=vs,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,E[x])if(e-&gt;t!=F[x])
            F[e-&gt;t]=x,Q[t++]=e-&gt;t;
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Sum[x]=1;
        ll all,tmp,ret=0;
        tr(e,E[x])if(e-&gt;t!=F[x])
            Sum[x]+=Sum[e-&gt;t]*e-&gt;c,Sum[x]%=mod;
        all=Sum[x]+1;
        tr(e,E[x])if(e-&gt;t!=F[x])
            tmp=Sum[e-&gt;t]*e-&gt;c,tmp%=mod,ret+=(all-tmp)*tmp,ret%=mod;
        ret*=P;ret%=mod;if(ret&lt;0)ret+=mod;ans+=ret;ans%=mod;
    }
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;int s,t,c;
    rep(i,n-1)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);--s;--t;
        InsEdge(s,t,c);
    }
    P=pow(2,mod-2);
    BFS(0);
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1892</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int LN_MAX=500000+10;
const int S_MAX=10000+10;
int N,K,S;
int Str[LN_MAX],Pet[LN_MAX];
struct TA
{
    int A[S_MAX],n;
    void init(int _n)
    {
        n=_n;
        memset(A,0,sizeof(int)*n);
    }
    void add(int p,int d=1)
    {
        for(p++;p&lt;=n;p+=p&amp;-p)
            A[p-1]+=d;
    }
    int sum(int p)
    {
        int ret=0;
        for(p++;p;p-=p&amp;-p)
            ret+=A[p-1];
        return ret;
    }
};
int pi[LN_MAX];
inline void scan(int&amp;t)
{
    char c;while(c=getchar(),c&lt;'0'||c&gt;'9');
    t=c-'0';while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
}
void input_data()
{
    scan(N);scan(K);scan(S);
    rep(i,N)scan(Str[i]);
    rep(i,K)scan(Pet[i]);
}
int count[LN_MAX];
TA T_Mem;
void init_pi()
{
    //Calc count
    TA&amp;Pre=T_Mem;Pre.init(S+1);
    for(int i=0;i&lt;K;i++)
    {
        count[i]=Pre.sum(Pet[i]-1);
        //cout&lt;&lt;count[i]&lt;&lt;" ";
        Pre.add(Pet[i]);
    }
    //Calc pi
    TA&amp;Cur=T_Mem;
    pi[0]=-1;Cur.init(S+1);
    int l=0,r=-1,t;
    #define add_line(l,r,d) {for(int p=l;p&lt;=r;p++)Cur.add(Pet[p],d);}
    #define move_to(nl,nr){add_line(r+1,nr,1);add_line(l,nl-1,-1);l=nl;r=nr;}
    for(int i=1;i&lt;K;i++)
    {
        for(t=pi[i-1];t!=-1;)
        {
            move_to(i-t-1,i-1);
            if(count[t+1]==Cur.sum(Pet[i]-1)){t++;break;}
            t=pi[t];
        }
        if(t==-1)t=0;pi[i]=t;
    }
    #undef add_line
    #undef move_to
    //rep(i,K)cout&lt;&lt;pi[i]&lt;&lt;" ";
    //cout&lt;&lt;endl;
}
void calc_kmp()
{
    TA&amp;Cur=T_Mem;Cur.init(S+1);
    int l=0,r=-1,t=-1;
    #define add_line(l,r,d) {for(int p=l;p&lt;=r;p++)Cur.add(Str[p],d);}
    #define move_to(nl,nr){add_line(r+1,nr,1);add_line(l,nl-1,-1);l=nl;r=nr;}
    static int Ans[LN_MAX];int cAns=0;
    rep(i,N)
    {
        //cout&lt;&lt;t&lt;&lt;endl;
        while(t!=-1)
        {
            move_to(i-t-1,i-1);
            if(count[t+1]==Cur.sum(Str[i]-1)){t++;break;}
            t=pi[t];
        }
        if(t==-1)t=0;
        if(t==K-1)
        {
            Ans[cAns++]=i-K+2;
            t=pi[t];
        }
    }
    printf("%d\n",cAns);
    rep(i,cAns)printf("%d\n",Ans[i]);
}
int main()
{
    //freopen("in","r",stdin);
    input_data();
    init_pi();
    calc_kmp();
}
</pre><pre></pre><h2>Problem1892</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int LN_MAX=500000+10;
const int S_MAX=10000+10;
int N,K,S;
int Str[LN_MAX],Pet[LN_MAX];
struct TA
{
    int A[S_MAX],n;
    void init(int _n)
    {
        n=_n;
        memset(A,0,sizeof(int)*n);
    }
    void add(int p,int d=1)
    {
        for(p++;p&lt;=n;p+=p&amp;-p)
            A[p-1]+=d;
    }
    int sum(int p)
    {
        int ret=0;
        for(p++;p;p-=p&amp;-p)
            ret+=A[p-1];
        return ret;
    }
};
int pi[LN_MAX];
inline void scan(int&amp;t)
{
    char c;while(c=getchar(),c&lt;'0'||c&gt;'9');
    t=c-'0';while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
}
inline void print_int(int t)
{
    static int A[20],p;p=0;
    if(!t){putchar('0');putchar('\n');return;}
    while(t)A[p++]=t%10,t/=10;
    for(int i=p-1;i&gt;=0;i--)putchar('0'+A[i]);
    putchar('\n');
}
void input_data()
{
    scan(N);scan(K);scan(S);
    rep(i,N)scan(Str[i]);
    rep(i,K)scan(Pet[i]);
}
int count[LN_MAX];
TA T_Mem;
void init_pi()
{
    //Calc count
    TA&amp;Pre=T_Mem;Pre.init(S+1);
    for(int i=0;i&lt;K;i++)
    {
        count[i]=Pre.sum(Pet[i]-1);
        //cout&lt;&lt;count[i]&lt;&lt;" ";
        Pre.add(Pet[i]);
    }
    //Calc pi
    TA&amp;Cur=T_Mem;
    pi[0]=-1;Cur.init(S+1);
    int l=0,r=-1,t;
    #define add_line(l,r,d) {for(int p=l;p&lt;=r;p++)Cur.add(Pet[p],d);}
    #define move_to(nl,nr){add_line(r+1,nr,1);add_line(l,nl-1,-1);l=nl;r=nr;}
    for(int i=1;i&lt;K;i++)
    {
        for(t=pi[i-1];t!=-1;)
        {
            move_to(i-t-1,i-1);
            if(count[t+1]==Cur.sum(Pet[i]-1)){t++;break;}
            t=pi[t];
        }
        if(t==-1)t=0;pi[i]=t;
    }
    #undef add_line
    #undef move_to
    //rep(i,K)cout&lt;&lt;pi[i]&lt;&lt;" ";
    //cout&lt;&lt;endl;
}
void calc_kmp()
{
    TA&amp;Cur=T_Mem;Cur.init(S+1);
    int l=0,r=-1,t=-1;
    #define add_line(l,r,d) {for(int p=l;p&lt;=r;p++)Cur.add(Str[p],d);}
    #define move_to(nl,nr){add_line(r+1,nr,1);add_line(l,nl-1,-1);l=nl;r=nr;}
    static int Ans[LN_MAX];int cAns=0;
    rep(i,N)
    {
        //cout&lt;&lt;t&lt;&lt;endl;
        while(t!=-1)
        {
            move_to(i-t-1,i-1);
            if(count[t+1]==Cur.sum(Str[i]-1)){t++;break;}
            t=pi[t];
        }
        if(t==-1)t=0;
        if(t==K-1)
        {
            Ans[cAns++]=i-K+2;
            t=pi[t];
        }
    }
    print_int(cAns);
    rep(i,cAns)print_int(Ans[i]);
}
int main()
{
    //freopen("in","r",stdin);
    input_data();
    init_pi();
    calc_kmp();
}
</pre><pre></pre><h2>Problem1894</h2><pre>#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;climits&gt;
#include &lt;cassert&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
#define PB push_back
#define ALL(x) x.begin(),x.end()
#define FOREACH(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define FOR(i,a,b) for(int i=a;i&lt;b;i++)//for i in [a,b)
#define MP make_pair
#define SIZE(x) int(x.size())
#define SORT(x) sort(ALL(x))
#define UNIQUE(x) x.resize(unique(ALL(x))-x.begin())
#define CLR(x,t) memset(x,t,sizeof x)
#define ACM accumulate
#define MC(a,b) memcpy(a,b,sizeof a) //memcpy
#define TWO(a) (1&lt;&lt;(a))
#define CONTAIN(s,a) (((s)&amp;TWO(a))!=0)
using namespace std;
typedef long long int64;
typedef pair&lt;int,int&gt; ipair;
typedef vector&lt;int&gt; vi;
typedef stringstream SS;
template&lt;class T&gt; inline void checkmin(T&amp;x,T c){if(c&lt;x)x=c;}
template&lt;class T&gt; inline void checkmax(T&amp;x,T c){if(c&gt;x)x=c;}
//Finished

template&lt;class It&gt;
string toString(It l,It r){
	SS ss;
	ss&lt;&lt;"[";
	for(It i=l;i!=r;i++)
	{
		ss&lt;&lt;*i;
		if(i+1!=r)
			ss&lt;&lt;",";
	}
	ss&lt;&lt;"]";
	return ss.str();
}

class AvoidFour {
public:
	int count(long long);
};

const int MOD=1000000007;
typedef vector&lt;int64&gt; v64;
typedef vector&lt;v64&gt; mat;
mat zero(){
	return mat(4,v64(4,0));
}

mat unit(){
	mat res=zero();
	REP(i,4)
		res[i][i]=1;
	return res;
}

inline void add(int64&amp;x,int64 c){
	x+=c+MOD;x%=MOD;
}

mat operator*(mat a,mat b){
	mat c=zero();
	REP(i,4)REP(j,4)REP(k,4)
		add(c[i][j],a[i][k]*b[k][j]);
	return c;
}

mat operator+(mat a,mat b){
	mat c=zero();
	REP(i,4)REP(j,4)
		add(c[i][j],a[i][j]+b[i][j]);
	return c;
}

mat operator-(mat a,mat b){
	mat c=zero();
	REP(i,4)REP(j,4)
		add(c[i][j],a[i][j]-b[i][j]);
	return c;
}

v64 operator*(mat a,v64 b){
	v64 c(4,0);
	REP(i,4)REP(j,4)
		add(c[i],a[i][j]*b[j]);
	return c;
}

int64 total(v64 a){
	int64 res=0;
	REP(i,4)
		add(res,a[i]);
	return res;
}

mat orig;
void sumPow(mat m,int64 pow,mat&amp;sum,mat&amp;Max){
	if(!pow){
		sum=zero();Max=unit();
		return;
	}
	if(pow%2==0){
		mat psum,pmax;
		sumPow(m,pow/2,psum,pmax);
		Max=pmax*pmax;
		sum=psum*(pmax+unit());
	} else {
		mat psum,pmax;
		sumPow(m,pow-1,psum,pmax);
		Max=pmax*m;
		sum=unit()+m*psum;
	}
}
int64 gcd(int64 a,int64 b){
	return b?gcd(b,a%b):a;
}

mat pow(mat m,int64 p){
	if(p==0){return unit();}
	mat tmp=pow(m,p/2);
	tmp=tmp*tmp;
	if(p&amp;1){
		tmp=tmp*m;
	}
	return tmp;
}

int AvoidFour::count(int64 n) {
	orig=zero();
	REP(i,4){
		if(i)orig[i][i-1]=1;
		orig[0][i]=9;
	}
	v64 init(4,0);
	init[0]=8;init[1]=1;
	int fours[4]={44,444,44444,4444444};
	mat sum=zero();mat Max=zero();
	for(int set=0;set&lt;16;set++){
		int64 lcm=1;
		int cnt=0;
		REP(i,4)if(set&gt;&gt;i&amp;1){
			int64 by=fours[i]/gcd(lcm,fours[i]);
			if(lcm&gt;n/by){lcm=n+1;break;}
			lcm*=by;
			cnt++;
		}
		if(lcm&gt;n)continue;
		mat nsum=zero();
		sumPow(pow(orig,lcm),n/lcm,nsum,Max);
		nsum=nsum*pow(orig,lcm-1);
		if(cnt%2==0)
			sum=sum+nsum;
		else
			sum=sum-nsum;
	}
	return total(sum*init);
}

int main(){
    int64 n;cin&gt;&gt;n;
    AvoidFour sol;
    cout&lt;&lt;sol.count(n)&lt;&lt;endl;
}</pre><pre></pre><h2>Problem1898</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=50+10,maxL=4;
using namespace std;
const int mod=10000;
int n,m,vs,vt,k,f;
const int maxF=20+1;
struct Seq
{
    int L,A[maxL];
    void Input_Data()
    {
        cin&gt;&gt;L;
        rep(i,L)cin&gt;&gt;A[i];
    }
    int at(int t)
    {
        return A[t%L];
    }
}F[maxF];
int tmp[maxn][maxn];
struct Mat
{
    int A[maxn][maxn],n;
    void SetSize(int _n)
    {
        n=_n;
        memset(A,0,sizeof A);
    }
    void operator*=(const Mat&amp;M)
    {
        memset(tmp,0,sizeof tmp);
        rep(i,n)rep(j,n)rep(k,n)
            tmp[i][j]=(tmp[i][j]+A[i][k]*M.A[k][j])%mod;
        memcpy(A,tmp,sizeof A);
    }
    void operator=(const Mat&amp;M)
    {
        memcpy(A,M.A,sizeof A);
        n=M.n;
    }
    void Ins_Edge(int s,int t)
    {
        A[s][t]++;
        A[t][s]++;
    }
    void Mark_Vet(int v)
    {
        rep(i,n)A[i][v]=0;
    }
}G,Gs[12+1],Orig;
Mat Unit(int n)
{
    Mat ret;ret.SetSize(n);
    rep(i,n)ret.A[i][i]=1;
    return ret;
}
void Power(Mat&amp;ret,int e)
{
    if(!e){ret=Unit(n);return;}
    Power(ret,e/2);ret*=ret;
    if(e&amp;1)ret*=Orig;
}
void Input_Data()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;vs&gt;&gt;vt&gt;&gt;k;int x,y;
    G.SetSize(n);
    rep(i,m)
    {
        cin&gt;&gt;x&gt;&gt;y;
        G.Ins_Edge(x,y);
    }
    cin&gt;&gt;f;
    rep(i,f)
    {
        F[i].Input_Data();
    }

}
void Build_Mat()
{
    Orig=Unit(n);
    for(int t=1;t&lt;=12;t++)
    {
        Gs[t]=G;
        rep(i,f) Gs[t].Mark_Vet(F[i].at(t));
        Orig*=Gs[t];
    }
}
void Solve()
{
    Mat ret;Power(ret,k/12);
    for(int t=1;t&lt;=(k%12);t++)ret*=Gs[t];
    cout&lt;&lt;ret.A[vs][vt]&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Input_Data();
    Build_Mat();
    Solve();
}


</pre><pre></pre><h2>Problem1899</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=201;
using namespace std;
int A[maxn],B[maxn],P[maxn],n;
bool cmp(int i,int j)
{
    return B[i]&gt;B[j];
}
int Dp[2][maxn*maxn];
inline void Update(int&amp;t,int c)
{
    if(t==-1||t&gt;c)t=c;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;
    rep(i,n)
    {
        cin&gt;&gt;A[i]&gt;&gt;B[i];
        P[i]=i;
    }
    sort(P,P+n,cmp);
    int now=0,next=1,sum=0;
    memset(Dp[next],-1,sizeof Dp[next]);
    Dp[next][0]=0;
    for(int i=0;i&lt;n;i++)
    {
        int t=P[i],c,first,second,nc;
        swap(now,next);
        memset(Dp[next],-1,sizeof Dp[next]);
        rep(j,sum+1)
            if((c=Dp[now][j])!=-1)
            {
                first=j;
                second=sum-j;
                //Put it In First Queue
                nc=max(first+A[t]+B[t],c);
                Update(Dp[next][j+A[t]],nc);
                //Put it In Second Queue
                nc=max(second+A[t]+B[t],c);
                Update(Dp[next][j],nc);
            }
        sum+=A[t];
    }
    int ans=inf;
    rep(i,sum+1)if(Dp[next][i]!=-1)ans=min(ans,Dp[next][i]);
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1901</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=10000,size=100;
int T[size][size],N[size]={},A[maxn],n,m,t,d=1&lt;&lt;6;
using namespace std;
void init()
{
    scanf("%d%d",&amp;n,&amp;m);rep(i,n)scanf("%d",A+i),T[i/size][N[i/size]++]=A[i];
    t=1+(n-1)/size;rep(i,t)sort(T[i],T[i]+N[i]);
}
int get(int*A,int s,int x)
{
    int i,l;
    for(i=s,l=d;l;l&gt;&gt;=1)
        if(i-l&gt;=0&amp;&amp;A[i-l]&gt;=x)i-=l;
    return i;
}
int Count(int l,int r,int x)
{
    int a=l/size,b=r/size,s=0;;
    if(a==b){For(i,l,r)s+=A[i]&lt;x;return s;}
    For(i,l,(a+1)*size-1)s+=A[i]&lt;x;
    For(i,b*size,r)s+=A[i]&lt;x;a++;b--;
    For(i,a,b)s+=get(T[i],N[i],x);
    return s;
}
int kth(int l,int r,int k)
{
    #define C(x) (Count(l,r,x))
    int i,d;
    for(i=0,d=1&lt;&lt;30;d;d&gt;&gt;=1)
        if(C(i+d)&lt;k)i+=d;
    return i;
}
void Change(int p,int x)
{
    int a=p/size;int t=A[p];A[p]=x;
    t=lower_bound(T[a],T[a]+N[a],t)-T[a];
    T[a][t]=x;sort(T[a],T[a]+N[a]);
}
int main()
{
    //freopen("in","r",stdin);
    init();char c;int i,j,k;
    while(m--)
    {
        scanf("\n%c",&amp;c);
        if(c=='C')scanf("%d%d",&amp;i,&amp;j),Change(i-1,j);
        else scanf("%d%d%d",&amp;i,&amp;j,&amp;k),printf("%d\n",kth(i-1,j-1,k));
    }
}


</pre><pre></pre><h2>Problem1902</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxn=200;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
struct BigInt
{
    int A[maxn],n;
    int&amp;operator[](int i){return A[i];}
    int operator[](int i)const{return A[i];}
    BigInt(int x=0){memset(A,0,sizeof A);A[n=0]=x;}
    bool IsZero()const{return !n&amp;&amp;!A[n];}
    void operator+=(int x)
    {
        A[0]+=x;
        for(int i=0;i&lt;=n;i++)
        {
            if(A[i]&gt;=10)A[i+1]++,A[i]-=10;
        }
        if(A[n+1])n++;
    }
    void operator-=(const BigInt&amp;that)
    {
        int d=0;
        for(int i=0;i&lt;=n;i++)
        {
            if(d)A[i]--,d=0;
            if(A[i]&lt;that[i])d=1,A[i]+=10;
            A[i]-=that[i];
        }
        while(n&amp;&amp;!A[n])n--;
    }
    void operator*=(int x)
    {
        int d=0;
        for(int i=0;i&lt;=n;i++)
        {
            d+=A[i]*x;A[i]=d%10;
            d/=10;
        }
        while(d)A[++n]=d%10,d/=10;
    }
    void operator/=(int x)
    {
        int d=0;
        for(int i=n;i&gt;=0;i--)
        {
            d+=A[i];A[i]=d/x;d%=x;
            d*=10;
        }
        while(n&amp;&amp;!A[n])n--;
    }
    int mod(int x)
    {
        int d=0;
        for(int i=n;i&gt;=0;i--)d*=10,d+=A[i],d%=x;
        return d;
    }
    void operator=(const BigInt&amp;that)
    {
        memcpy(A,that.A,sizeof A);
        n=that.n;
    }
};
istream&amp; operator&gt;&gt;(istream&amp;in,BigInt&amp;x)
{
    string a;in&gt;&gt;a;
    x.n=a.size()-1;
    for(int i=0;i&lt;=x.n;i++)
        x[i]=a[x.n-i]-'0';
    return in;
}
ostream&amp; operator&lt;&lt;(ostream&amp;out,const BigInt&amp;x)
{
    for(int i=x.n;i&gt;=0;i--)
        cout&lt;&lt;x[i];
    return out;
}
int p;
int main()
{
    //freopen("in","r",stdin);
    BigInt tmp,n,ret(1);
    cin&gt;&gt;n&gt;&gt;p;tmp=n;
    while(!n.IsZero())ret*=n.mod(p)+1,n/=p;
    tmp+=1;tmp-=ret;
    cout&lt;&lt;tmp&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1907</h2><pre>/*
 * 树的路径覆盖.cpp
 *
 *  Created on: 2011-3-11
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VETS = 10000 + 10;
int dp[MAX_N_VETS][3];
vector&lt;int&gt; edge[MAX_N_VETS];
int nVets;
void addEdge(int s, int t) {
	edge[s].push_back(t);
	edge[t].push_back(s);
}
void clearEdges() {
	for (int i = 0; i &lt; nVets; ++i)
		edge[i].clear();
}
void inputData() {
	scanf("%d", &amp;nVets);
	clearEdges();
	for (int iter = 0; iter &lt; nVets - 1; ++iter) {
		int s, t;
		scanf("%d%d", &amp;s, &amp;t);
		--s;
		--t;
		addEdge(s, t);
	}
}

void dfs(int u, int f) {
	memset(dp[u], 0, sizeof dp[u]);
	int*am = dp[u];
	foreach(e,edge[u]) {
		int v = *e;
		if (v == f)
			continue;
		dfs(v, u);
		int* nam = dp[v];
		int cost[] = { max(nam[0], max(nam[1], nam[2])), max(nam[0], nam[1])
				+ 1 };
		for (int it = 1; it &gt;= 0; it--) {
			for (int toLink = 1; toLink &gt;= 0; --toLink) {
				am[it + toLink] = max(am[it + toLink], am[it] + cost[toLink]);
			}
		}
	}
}

int que[MAX_N_VETS], qh, qt;
int father[MAX_N_VETS];
void doDp() {
	qh = qt = 0;
	memset(father, -1, sizeof father);
	int vs=0;
	que[qt++] = vs;
	for (; qh &lt; qt;) {
		int u = que[qh++];
		foreach(e,edge[u]) {
			int v = *e;
			if (v == father[u])
				continue;
			que[qt++] = v;
			father[v] = u;
		}
	}

	for (int iter = qt - 1; iter &gt;= 0; --iter) {
		int u = que[iter];
		int*am = dp[u];
		memset(am, 0, sizeof(dp[u]));
		foreach(e,edge[u]) {
			int v = *e;
			if (v == father[u])
				continue;
			int* nam = dp[v];
			int cost[] = { max(nam[0], max(nam[1], nam[2])), max(nam[0], nam[1])
					+ 1 };
			for (int it = 2; it &gt;= 0; it--) {
				for (int toLink = 1; toLink &gt;= 0; --toLink) {
					if(it+toLink &lt;3)
						am[it + toLink] = max(am[it + toLink], am[it] + cost[toLink]);
				}
			}
		}
	}
}

void work() {
	doDp();
	int*am = dp[0];
	int ans = max(am[0], max(am[1], am[2]));
	ans = nVets - ans;
	cout &lt;&lt; ans &lt;&lt; endl;
}

void solve() {
	int nCase;
	scanf("%d", &amp;nCase);
	while (nCase--) {
		inputData();
		work();
	}
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem1911</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1,maxn=1000000+10;
using namespace std;
typedef long long ll;
ll Dp[maxn],S[maxn];
int N,A,B,C;
ll F(ll x)
{
    return (A*x+B)*x+C;
}
ll getValue(int ch,int now)
{
    return Dp[ch]+F(S[now]-S[ch]);
}
ll D[maxn];
bool better(int j,int k,int i)//j&lt;k
{
    return D[k]-D[j]&gt;2*A*S[i]*(S[k]-S[j]);
}
bool earlier(int j,int k,int i)//j&lt;k&lt;i
{
    return (D[i]-D[k])*(S[k]-S[j])&gt;(D[k]-D[j])*(S[i]-S[k]);
}
void getD(int i)
{
    D[i]=Dp[i]+A*S[i]*S[i]-B*S[i];
}
int Q[maxn],h,t;
int main()
{
    //freopen("in","r",stdin);
    S[0]=Dp[0]=0;int x;
    cin&gt;&gt;N&gt;&gt;A&gt;&gt;B&gt;&gt;C;
    getD(0);h=t=0;Q[t++]=0;
    for(int i=1;i&lt;=N;i++)
    {
        scanf("%d",&amp;x);
        S[i]=S[i-1]+x;
        while(h+1&lt;t&amp;&amp;better(Q[h],Q[h+1],i))
            h++;
        Dp[i]=getValue(Q[h],i);
        getD(i);
        while(h+1&lt;t&amp;&amp;earlier(Q[t-2],Q[t-1],i))t--;
        Q[t++]=i;
    }
    cout&lt;&lt;Dp[N]&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1912</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(vector&lt;Edge*&gt;::iterator e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;2,maxn=100000;
using namespace std;
struct Edge
{
    int s,t,c;
    int other(int v)
    {
        return v==s?t:s;
    }
    Edge(int _s,int _t,int _c):
        s(_s),t(_t),c(_c){}
};
vector&lt;Edge*&gt; E[maxn];
int n,k;
void AddEdge(int s,int t)
{
    Edge*e=new Edge(s,t,1);
    E[s].pb(e);E[t].pb(e);
}
struct State
{
    int to,dist;
    State(){}
    State(int _to,int _dist):
        to(_to),dist(_dist){}
    bool operator&gt;(const State&amp;st)const
    {
        return dist&gt;st.dist;
    }
    void Update(const State&amp;st)
    {
        if(st.dist&gt;dist)
            *this=st;
    }
    State operator+(int w)const
    {
        return State(to,dist+w);
    }
};
struct StateDown
{
    State down[2];
    void reset(int me)
    {
        down[0]=down[1]=State(me,0);
    }
    void Update(const State&amp;st)
    {
        if(st&gt;down[1])down[1]=st;
        if(down[1]&gt;down[0])swap(down[0],down[1]);
    }
}Down[maxn];
int Q[maxn],h,t,F[maxn],D[maxn];
Edge*P[maxn];
void doDp(int&amp;Max,int&amp;u,int&amp;v)
{
    h=t=0;int vs=0;
    for(Q[t++]=vs,F[vs]=-1,D[vs]=0,P[vs]=0;h&lt;t;h++)
    {
        int x=Q[h];
        tr(it,E[x])
        {
            Edge*e=*it;int dest=e-&gt;other(x);
            if(dest!=F[x])
            {
                Q[t++]=dest;F[dest]=x;
                D[dest]=D[x]+1;
                P[dest]=e;
            }
        }
    }
    Max=-inf;
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];StateDown&amp;ret=Down[x];
        ret.reset(x);
        tr(it,E[x])
        {
            Edge*e=*it;int dest=e-&gt;other(x);
            if(dest!=F[x])
                ret.Update(Down[dest].down[0]+e-&gt;c);
        }
        int Len=ret.down[0].dist+ret.down[1].dist;
        if(Len&gt;Max)
        {
            Max=Len;
            u=ret.down[0].to;
            v=ret.down[1].to;
        }
    }
}
int ans=inf;
int Calit()
{
    int Max,u,v;
    doDp(Max,u,v);
    for(;u!=v;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        P[u]-&gt;c*=-1;
        u=F[u];
    }
    return Max;
}
void Init()
{
    scanf("%d%d",&amp;n,&amp;k);
    int u,v;
    rep(i,n-1)
    {
        scanf("%d%d",&amp;u,&amp;v);--u;--v;
        AddEdge(u,v);
    }
}
void Solve()
{
    int ret=(n-1)*2;
    rep(i,k+1)
    {
        ans=min(ans,ret);
        ret-=Calit()-1;
    }
    printf("%d\n",ans);
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


</pre><pre></pre><h2>Problem1912</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(vector&lt;Edge*&gt;::iterator e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;2,maxn=100000;
using namespace std;
struct Edge
{
    int s,t,c;
    int other(int v)
    {
        return v==s?t:s;
    }
    Edge(int _s,int _t,int _c):
        s(_s),t(_t),c(_c){}
};
vector&lt;Edge*&gt; E[maxn];
int n,k;
void AddEdge(int s,int t)
{
    Edge*e=new Edge(s,t,1);
    E[s].pb(e);E[t].pb(e);
}
struct State
{
    int to,dist;
    State(){}
    State(int _to,int _dist):
        to(_to),dist(_dist){}
    bool operator&gt;(const State&amp;st)const
    {
        return dist&gt;st.dist;
    }
    void Update(const State&amp;st)
    {
        if(st.dist&gt;dist)
            *this=st;
    }
    State operator+(int w)const
    {
        return State(to,dist+w);
    }
};
struct StateDown
{
    State down[2];
    void reset(int me)
    {
        down[0]=down[1]=State(me,0);
    }
    void Update(const State&amp;st)
    {
        if(st&gt;down[1])down[1]=st;
        if(down[1]&gt;down[0])swap(down[0],down[1]);
    }
}Down[maxn];
int Q[maxn],h,t,F[maxn],D[maxn];
Edge*P[maxn];
void doDp(int&amp;Max,int&amp;u,int&amp;v)
{
    h=t=0;int vs=0;
    for(Q[t++]=vs,F[vs]=-1,D[vs]=0,P[vs]=0;h&lt;t;h++)
    {
        int x=Q[h];
        tr(it,E[x])
        {
            Edge*e=*it;int dest=e-&gt;other(x);
            if(dest!=F[x])
            {
                Q[t++]=dest;F[dest]=x;
                D[dest]=D[x]+1;
                P[dest]=e;
            }
        }
    }
    Max=-inf;
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];StateDown&amp;ret=Down[x];
        ret.reset(x);
        tr(it,E[x])
        {
            Edge*e=*it;int dest=e-&gt;other(x);
            if(dest!=F[x])
                ret.Update(Down[dest].down[0]+e-&gt;c);
        }
        int Len=ret.down[0].dist+ret.down[1].dist;
        if(Len&gt;Max)
        {
            Max=Len;
            u=ret.down[0].to;
            v=ret.down[1].to;
        }
    }
}
int ans=inf;
int Calit()
{
    int Max,u,v;
    doDp(Max,u,v);
    for(;u!=v;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        P[u]-&gt;c*=-1;
        u=F[u];
    }
    return Max;
}
void Init()
{
    scanf("%d%d",&amp;n,&amp;k);
    int u,v;
    rep(i,n-1)
    {
        scanf("%d%d",&amp;u,&amp;v);--u;--v;
        AddEdge(u,v);
    }
}
void Solve()
{
    int ret=(n-1)*2;
    rep(i,k+1)
    {
        ans=min(ans,ret);
        if(i&lt;k)ret-=Calit()-1;
    }
    printf("%d\n",ans);
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


</pre><pre></pre><h2>Problem1913</h2><pre>/*
 *  [Apio2010]signaling 信号覆盖.cpp
 *
 *  Created on: 2011-5-6
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
		x(_x), y(_y) {
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	Point operator*(double d) const {
		return Point(x * d, y * d);
	}
	Point operator/(double d) const {
		return Point(x / d, y / d);
	}
	double det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	double dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	double alpha() const {
		return atan2(y, x);
	}
	Point rot90() const {
		return Point(-y, x);
	}
	void read() {
		scanf("%lf%lf", &amp;x, &amp;y);
	}
	void write() const {
		printf("%lf %lf", x, y);
	}
	double abs() {
		return hypot(x, y);
	}
	Point unit() {
		return *this / abs();
	}
	double distTo(const Point&amp;p) const {
		return hypot(x - p.x, y - p.y);
	}
};

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))

const double EPS = 1e-8;
inline int sign(double a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}

#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))

Point isSS(Point p1, Point p2, Point q1, Point q2) {
	double a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);
	return (p1 * a2 + p2 * a1) / (a1 + a2);
}

bool crsSS(Point p1, Point p2, Point q1, Point q2) {
	return crossOp(p1,p2,q1) * crossOp(p1,p2,q2) &lt; 0 &amp;&amp; crossOp(q1,q2,p1)
			* crossOp(q1,q2,p2) &lt; 0;
}

void getC(Point p1, Point p2, Point p3, Point&amp;c, double&amp;r) {
	Point dir, mid;
	dir = (p2 - p1).rot90();
	mid = (p1 + p2) / 2;
	Point q1 = mid - dir, q2 = mid + dir;

	dir = (p3 - p1).rot90();
	mid = (p1 + p3) / 2;
	Point w1 = mid - dir, w2 = mid + dir;

	c = isSS(q1, q2, w1, w2);
	r = c.distTo(p1);
}

const int MAX_N_POINTS = 1500 + 10;
Point points[MAX_N_POINTS];
int nPoints;

void readInput() {
	scanf("%d", &amp;nPoints);
	for (int i = 0; i &lt; nPoints; ++i) {
		points[i].read();
	}
}

double calcC(int n, int m) {
	double ret = 1;
	for (int i = 0; i &lt; m; ++i) {
		ret *= (n - i);
		ret /= i + 1;
	}
	return ret;
}

double bfWork() {
	double Count = calcC(nPoints, 3);
	double sum = 0;
	for (int i1 = 0; i1 &lt; nPoints; ++i1) {
		for (int i2 = 0; i2 &lt; i1; ++i2) {
			for (int i3 = 0; i3 &lt; i2; ++i3) {
				Point c;
				double r;
				getC(points[i1], points[i2], points[i3], c, r);
				for (int me = 0; me &lt; nPoints; ++me) {
					if (me == i1 || me == i2 || me == i3)
						sum++;
					else
						sum += sign(r - c.distTo(points[me])) &gt;= 0;
				}
			}
		}
	}

	return sum / Count;
}

double bfCountTri() {
	double ret = 0;
	for (int i1 = 0; i1 &lt; nPoints; ++i1) {
		for (int i2 = 0; i2 &lt; i1; ++i2) {
			for (int i3 = 0; i3 &lt; i2; ++i3) {
				for (int me = 0; me &lt; nPoints; ++me) {
					if (me == i1 || me == i2 || me == i3)
						continue;
					Point ps[] = { points[i1], points[i2], points[i3],
							points[i1] };
					Point dst(rand() + 100000, rand() + 100000);
					int cnt = 0;
					for (int i = 0; i &lt; 3; ++i) {
						cnt += crsSS(ps[i], ps[i + 1], points[me], dst);
					}
					if (cnt % 2 == 1)
						ret++;
				}
			}
		}
	}
	return ret;
}

double countTri() {
	double ret = 0;
	for (int cId = 0; cId &lt; nPoints; ++cId) {
		static double alpha[MAX_N_POINTS];
		int cnt = 0;
		for (int i = 0; i &lt; nPoints; ++i) {
			if (i == cId)
				continue;
			alpha[cnt++] = (points[i] - points[cId]).alpha();
		}
		sort(alpha, alpha + cnt);
		double cur = calcC(cnt, 3);
		int r = 0;
		for (int i = 0; i &lt; cnt; ++i) {
			while (r &lt; i + cnt) {
				double delta = alpha[r % cnt] - alpha[i];
				if (delta &lt; 0)
					delta += 2 * M_PI;
				if (delta &gt; M_PI)
					break;
				++r;
			}
			int num = r - i - 1;
			cur -= calcC(num, 2);
		}
		ret += cur;
	}
	return ret;
}

double work() {
	double C3 = countTri();
	double C4 = calcC(nPoints, 4) - C3;
	double ans = C3 * 1 + C4 * 2;
	ans /= calcC(nPoints, 3);
	ans += (1 - calcC(nPoints - 1, 3) / calcC(nPoints, 3)) * nPoints;
	return ans;
}

void genData() {
	nPoints = 50;
	for (int i = 0; i &lt; nPoints; ++i) {
		points[i].x = rand();
		points[i].y = rand();
	}
}

void solve() {
	readInput();
	printf("%0.6lf\n", work());
}

void runTest() {
	genData();
	cout &lt;&lt; bfWork() &lt;&lt; endl;
	cout &lt;&lt; work() &lt;&lt; endl;
}

int main() {
	//	runTest();
	solve();
}
</pre><pre></pre><h2>Problem1916</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
typedef long long ll;
const int maxn=50000,maxk=11;
const ll inf=1LL&lt;&lt;60;
using namespace std;
ll Mem[maxn][maxk];int n,m,k;
struct Edge
{
    int t,c;
    Edge(int _t,int _c):t(_t),c(_c){}
};
vector&lt;Edge&gt; E[maxn];
typedef vector&lt;Edge&gt;::iterator it;
void AddEdge(int s,int t,int c)
{
    E[s].pb(Edge(t,c));
}
ll Dp(int i,int j)
{
    ll&amp;x=Mem[i][j],Max=-inf,Min=inf;
    if(x!=-1)return x;
    if(i==n-1)return x=0;
    tr(e,E[i])
    {
        Max=max(Max,Dp(e-&gt;t,j)+e-&gt;c);
        if(j)Min=min(Min,Dp(e-&gt;t,j-1)+e-&gt;c);
    }
    x=min(Max,Min);
    return x;
}
int main()
{
    //freopen("in","r",stdin);
    memset(Mem,-1,sizeof Mem);
    int s,t,c;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
    rep(i,m)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);--s;--t;
        AddEdge(s,t,c);
    }
    cout&lt;&lt;Dp(0,k)&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1917</h2><pre>/*
 *  [Ctsc2010]星际旅行.cpp
 *
 *  Created on: 2011-4-19
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VERTEXS = 50000 + 10;

struct Vertex {
	vector&lt;Vertex*&gt; adj;
	int H;
	int am[2][2];//normal ,if inc?
	int chAmSum[2];
	int ans;
	int dist;//dist from root to it
	int am2[2];//it's father chose or not/outside of subtree and it's ancs are inced
	Vertex*father;
};

Vertex vs[MAX_N_VERTEXS];
int nVs;

Vertex*que[MAX_N_VERTEXS];

void readInput() {
	cin &gt;&gt; nVs;
	for (int i = 0; i &lt; nVs; ++i) {
		scanf("%d", &amp;vs[i].H);
	}
	for (int i = 0; i &lt; nVs - 1; ++i) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		Vertex*u = vs + a, *v = vs + b;
		u-&gt;adj.push_back(v);
		v-&gt;adj.push_back(u);
	}
}

void doBFS(Vertex*root) {
	int qh = 0, qt = 0;
	que[qt++] = root;
	root-&gt;father = 0;
	root-&gt;dist = 0;
	for (; qh &lt; qt;) {
		Vertex*u = que[qh++];
		foreach(iter,u-&gt;adj) {
			Vertex*v = *iter;
			if (v == u-&gt;father)
				continue;
			que[qt++] = v;
			v-&gt;father = u;
			v-&gt;dist = u-&gt;dist + 1;
		}
	}
}
void work() {
	Vertex*root = vs + 0;
	doBFS(root);

	//calc am
	for (int at = nVs - 1; at &gt;= 0; --at) {
		Vertex*u = que[at];
		for (int cf = 0; cf &lt; 2; ++cf) {
			for (int inc = 0; inc &lt; 2; ++inc) {
				int val = u-&gt;H + inc;
				int&amp;ret = u-&gt;am[cf][inc];
				ret = INT_MAX;
				for (int cme = 0; cme &lt; 2; ++cme) {
					if (!cf &amp;&amp; !cme)
						continue;
					int tmp = cme ? val : 0;
					foreach(iter,u-&gt;adj) {
						Vertex*v = *iter;
						if (v == u-&gt;father)
							continue;
						tmp += v-&gt;am[cme][0];
					}
					ret = min(ret, tmp);
				}
			}
		}
		for (int c = 0; c &lt; 2; ++c) {
			u-&gt;chAmSum[c] = 0;
			foreach(iter,u-&gt;adj) {
				Vertex*v = *iter;
				if (v == u-&gt;father)
					continue;
				u-&gt;chAmSum[c] += v-&gt;am[c][0];
			}
		}
	}

	//calc am2
	root-&gt;am2[0] = 0;
	root-&gt;am2[1] = 0;
	for (int i = 1; i &lt; nVs; ++i) {
		Vertex*u = que[i];
		for (int cf = 0; cf &lt; 2; ++cf) {
			int&amp;ret = u-&gt;am2[cf];
			ret = INT_MAX;
			for (int cg = 0; cg &lt; 2; ++cg) {
				if (!cg &amp;&amp; !cf)
					continue;
				int tmp = 0;
				if (cf) {
					if (u-&gt;father != vs)
						tmp += u-&gt;father-&gt;H + 1;
					else
						tmp += u-&gt;father-&gt;H;
				}
				tmp += u-&gt;father-&gt;am2[cg];
				tmp += u-&gt;father-&gt;chAmSum[cf];
				tmp -= u-&gt;am[cf][0];
				ret = min(ret, tmp);
			}
		}
		//		cout &lt;&lt; u-&gt;am2[0] &lt;&lt; " " &lt;&lt; u-&gt;am2[1] &lt;&lt; endl;
	}

	//calc ans
	for (int i = 0; i &lt; nVs; ++i) {
		Vertex*u = que[i];
		int&amp;ret = u-&gt;ans;
		ret = INT_MAX;
		for (int cf = 0; cf &lt; 2; ++cf) {
			int tmp = 0;
			tmp += u-&gt;am2[cf];
			if (u == vs)
				tmp += u-&gt;am[cf][0];
			else
				tmp += u-&gt;am[cf][1];
			ret = min(ret, tmp);
		}
	}

	//output
	for (int i = 0; i &lt; nVs; ++i) {
		int ans = vs[i].ans;
		ans += nVs - 1;
		ans *= 2;
		ans -= vs[i].dist;
		printf("%d\n", ans);
	}
}

void prepare() {
	for (int i = 0; i &lt; nVs; ++i) {
		vs[i].H -= vs[i].adj.size();
	}
}

void solve() {
	readInput();
	prepare();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem1918</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N=7;
int n;
typedef double Mat[MAX_N][MAX_N];
Mat win[3][3];
void readMat(Mat a){
	REP(i,n)REP(j,n)cin&gt;&gt;a[i][j];
}
void rev(Mat ab,Mat ba){
	REP(i,n)REP(j,n)ba[i][j]=1-ab[j][i];
}
int id(int a,int i){
	return 1&lt;&lt;(a*n+i);
}
double dp2[3][3][1&lt;&lt;MAX_N][1&lt;&lt;MAX_N][MAX_N];
double calc2(int a,int b,int rema,int remb,int who){//last round a win
	double&amp;ret=dp2[a][b][rema][remb][who];
	if(ret&gt;-0.5)
		return ret;
	ret=0;
	if(remb==0)
		return ret=1;
	ret=1;
	REP(i,n)if(remb&gt;&gt;i&amp;1){
		double w=win[a][b][who][i];
		double p=w*calc2(a,b,rema,remb-(1&lt;&lt;i),who);
		p+=(1-w)*(1-calc2(b,a,remb,rema-(1&lt;&lt;who),i));
		ret=min(ret,p);
	}
	return ret;
}
double dp[1&lt;&lt;18][3][MAX_N][2];
double calc(int rem,int who,int wid,int no){
	if(rem==(1&lt;&lt;(3*n))-1){//first round
		double ret=0;
		REP(i,3){
			int a=(i+1)%3,b=(i+2)%3;
			double wab=win[a][b][n-1][n-1];
			REP(j,2){
				int w=j==0?a:b;
				double p=1.0/3*(j==0?wab:1-wab);
				REP(k,2){
					int cw=k==0?i:w;
					double wiw=win[i][w][n-1][n-1];
					double cp=p*(k==0?wiw:1-wiw);
					int r=rem-id(0,n-1)-id(1,n-1)-id(2,n-1)+id(cw,n-1);
					ret+=cp*calc(r,cw,n-1,3-i-w);					
				}
			}
		}
		return ret;
	}
	int a[3];
	int x=rem;
	REP(i,3)a[i]=x&amp;((1&lt;&lt;n)-1),x&gt;&gt;=n;
	int cd=0;
	for(int i=2;i&gt;=0;--i)cd&lt;&lt;=n-1,cd+=a[i]&amp;((1&lt;&lt;(n-1))-1);
	double&amp;ret=dp[cd][who][wid][(no+3-who)%3-1];
	if(ret&gt;-0.5)
		return ret;
	ret=0;
	REP(i,3)if(a[i]==0){
		int x=(i+1)%3,y=(i+2)%3;
		if(x!=who)swap(x,y);
		if(i==0)
			return ret=0;
		else {
			double p=calc2(x,y,a[x],a[y],wid);
			if(x==0)
				return ret=p;
			else
				return ret=1-p;
		}
	}
	
	double mi=1,mx=0;
	REP(i,n)if(a[no]&gt;&gt;i&amp;1){
		double w=win[no][who][i][wid];
		double p=w*calc(rem-id(who,wid),no,i,3-who-no);
		p+=(1-w)*calc(rem-id(no,i),who,wid,3-who-no);
		mi=min(mi,p);
		mx=max(mx,p);
	}
	if(no==0)return ret=mx;
	else return ret=mi;
}
int main(){
	cin&gt;&gt;n;
	readMat(win[0][1]);
	readMat(win[0][2]);
	readMat(win[1][2]);
	REP(i,3)REP(j,i)rev(win[j][i],win[i][j]);
	fill(&amp;dp[0][0][0][0],&amp;dp[1&lt;&lt;18][0][0][0],-1.0);
	fill(&amp;dp2[0][0][0][0][0],&amp;dp2[3][0][0][0][0],-1.0);
	printf("%0.6lf\n",calc((1&lt;&lt;(3*n))-1,-1,-1,-1));
}</pre><pre></pre><h2>Problem1919</h2><pre>/*
 *  [Ctsc2010]性能优化.cpp
 *
 *  Created on: 2011-4-19
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

typedef long long int64;
int64 doPowMod(int64 x, int64 e, int64 mod) {
	if (!e)
		return 1;
	if (e &amp; 1)
		return doPowMod(x, e - 1, mod) * x % mod;
	return doPowMod(x * x % mod, e &gt;&gt; 1, mod);
}

int64 invMod(int64 x, int64 mod) {
	return doPowMod(x, mod - 2, mod);
}

int64 powMod(int64 x, int64 e, int64 mod) {
	if (e &gt;= 0)
		return doPowMod(x, e, mod);
	int64 tmp = powMod(x, -e, mod);
	return invMod(tmp, mod);
}

int n, C;
const int MAX_N = 1000000;
vector&lt;int64&gt; a, b;

const int PRIMES[] = { 2, 3, 5, 7 };

void readInput() {
	cin &gt;&gt; n &gt;&gt; C;
	for (int i = 0; i &lt; n; ++i) {
		int x;
		scanf("%d", &amp;x);
		a.push_back(x % (n + 1));
	}
	for (int i = 0; i &lt; n; ++i) {
		int x;
		scanf("%d", &amp;x);
		b.push_back(x % (n + 1));
	}

	if (C != 0) {
		C %= n;
		if (C == 0)
			C = n;
	}
}

bool ispRoot(int me) {
	for (int t = 0; t &lt; 4; ++t) {
		int x = PRIMES[t];
		if (n % x != 0)
			continue;
		if (powMod(me, n / x, n + 1) == 1)
			return false;
	}
	return true;
}

int g;

void getpRoot() {
	for (int i = 2; i &lt;= n; ++i) {
		if (ispRoot(i)) {
			g = i;
			break;
		}
	}
//	cerr &lt;&lt; g &lt;&lt; endl;
}

void DFT(vector&lt;int64&gt;&amp;a, int rev) {
	int s = a.size();
	if (s == 1)
		return;
	int d;
	for (int i = 0; i &lt; 4; ++i) {
		if (s % PRIMES[i] == 0) {
			d = PRIMES[i];
			break;
		}
	}

	vector&lt;vector&lt;int64&gt; &gt; ch(d);
	for (int i = 0; i &lt; s; ++i) {
		ch[i % d].push_back(a[i]);
	}

	for (int i = 0; i &lt; d; ++i) {
		DFT(ch[i], rev);
	}

	int64 step = powMod(g, rev * n / s, n + 1);
	int64 w = 1;
	for (int i = 0; i &lt; s; ++i) {
		int64 p = 1;
		a[i] = 0;
		for (int j = 0; j &lt; d; ++j) {
			(a[i] += ch[j][i % (s / d)] * p) %= n + 1;
			(p *= w) %= n + 1;
		}
		(w *= step) %= n + 1;
	}
}

void bfWork() {
	vector&lt;int64&gt; x = a;
	for (int iter = 0; iter &lt; C; ++iter) {
		vector&lt;int64&gt; y(n, 0);
		for (int i = 0; i &lt; n; ++i) {
			for (int j = 0; j &lt; n; ++j) {
				(y[(i + j) % n] += x[i] * b[j]) %= n + 1;
			}
		}
		x = y;
	}

	cout &lt;&lt; "Ans:" &lt;&lt; endl;
	for (int i = 0; i &lt; n; ++i) {
		cout &lt;&lt; x[i] &lt;&lt; endl;
	}
	cout &lt;&lt; "End" &lt;&lt; endl;
}

void work() {
	getpRoot();

	DFT(a, 1);

	//	for (int i = 0; i &lt; n; ++i) {
	//		cout &lt;&lt; a[i] &lt;&lt; endl;
	//	}

	DFT(b, 1);
	for (int i = 0; i &lt; n; ++i) {
		(a[i] *= powMod(b[i], C, n + 1)) %= n + 1;
	}
	DFT(a, -1);
	for (int i = 0; i &lt; n; ++i) {
		(a[i] *= invMod(n, n + 1)) %= n + 1;
	}
	for (int i = 0; i &lt; n; ++i) {
		printf("%d\n", (int) a[i]);
	}
}

void genData() {
	n = 2 * 3 * 5;
	C = rand() % 1000;
	for (int i = 0; i &lt; n; ++i) {
		a.push_back(rand() % (n + 1));
		b.push_back(rand() % (n + 1));
	}
}

void solve() {
	readInput();
	//	bfWork();
	work();
}

int main() {
	solve();
	//	genData();
	//	bfWork();
	//	work();
}
</pre><pre></pre><h2>Problem1921</h2><pre>/*
 *  [Ctsc2010]珠宝商.cpp
 *
 *  Created on: 2011-4-20
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;cctype&gt;
#include &lt;cassert&gt;
#include &lt;map&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_N_VERTEXS = 50000 + 10;
const int MAX_L_PAT = 50000 + 10;
const int MAX_LOG = 20;
const int MAX_NLOGN = MAX_N_VERTEXS * MAX_LOG;
const int MAX_N_ALPHA = 26;

int nVertexs;
int patLen;
char pat[MAX_L_PAT];

struct Vertex;

struct Edge {
	Edge*prev, *next, *op;
	Vertex*dst;
	void reSet() {
		prev-&gt;next = this;
		next-&gt;prev = this;
	}
	void erase() {
		prev-&gt;next = next;
		next-&gt;prev = prev;
	}
	Edge(Vertex*_dst, Edge*_prev, Edge*_next) :
		dst(_dst), prev(_prev), next(_next) {
		reSet();
	}
	Edge() {
		prev = next = 0;
		dst = 0;
	}
};

struct Trie {
	Trie*ch[MAX_N_ALPHA];

	Trie*fail;
	Trie() {
		memset(ch, 0, sizeof ch);
	}

	int begin, end;
	int depth;

	Trie*fail2k[MAX_LOG];

	Trie*go(int what) {
		Trie*&amp;c = ch[what];
		if (c == 0)
			c = new Trie;
		return c;
	}
};

struct Vertex {
	Edge*begin, *end;
	char ch;
	Vertex*father;

	int size;

	Trie*where;
	int branch;

	bool visited;

	Vertex() {
		begin = new Edge;
		end = new Edge;
		begin-&gt;next = end;
		end-&gt;prev = begin;
	}
};

Vertex vertexs[MAX_N_VERTEXS];

void addEdge(Vertex*u, Vertex*v) {
	Edge*uv = new Edge(v, u-&gt;begin, u-&gt;begin-&gt;next);
	Edge*vu = new Edge(u, v-&gt;begin, v-&gt;begin-&gt;next);
	uv-&gt;op = vu;
	vu-&gt;op = uv;
}

void readInput() {
	scanf("%d%d", &amp;nVertexs, &amp;patLen);
	for (int i = 0; i &lt; nVertexs - 1; ++i) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		Vertex*u = vertexs + --a, *v = vertexs + --b;
		addEdge(u, v);
	}

	for (int i = 0; i &lt; nVertexs; ++i) {
		char ch;
		while (ch = getchar(), !isalpha(ch))
			;
		vertexs[i].ch = ch;
	}
	scanf(" ");
	scanf("%s", pat);
}
int dfsCur;

void dfs(Trie* t, int _depth) {
	if (!t)
		return;
	t-&gt;depth = _depth;
	t-&gt;begin = dfsCur++;
	for (int i = 0; i &lt; MAX_N_ALPHA; ++i) {
		dfs(t-&gt;ch[i], t-&gt;depth + 1);
	}
	t-&gt;end = dfsCur - 1;
}

Vertex*que[MAX_N_VERTEXS];
int qh, qt;

void doBFS(Vertex*root) {
	qh = qt = 0;
	que[qt++] = root;
	root-&gt;father = 0;
	for (; qh &lt; qt;) {
		Vertex*u = que[qh++];
		for (Edge*e = u-&gt;begin-&gt;next; e != u-&gt;end; e = e-&gt;next) {
			Vertex*v = e-&gt;dst;
			if (v == u-&gt;father)
				continue;
			que[qt++] = v;
			v-&gt;father = u;
		}
	}
}

Vertex* findSplitVertex(Vertex*root) {
	doBFS(root);
	for (int i = qt - 1; i &gt;= 0; --i) {
		Vertex*u = que[i];
		u-&gt;size = 1;
		for (Edge*e = u-&gt;begin-&gt;next; e != u-&gt;end; e = e-&gt;next) {
			Vertex*v = e-&gt;dst;
			if (v == u-&gt;father)
				continue;
			u-&gt;size += v-&gt;size;
		}
	}

	int bestOpt = INT_MAX;
	Vertex*best;

	for (int i = 0; i &lt; qt; ++i) {
		Vertex*u = que[i];
		int opt = root-&gt;size - u-&gt;size;
		for (Edge*e = u-&gt;begin-&gt;next; e != u-&gt;end; e = e-&gt;next) {
			Vertex*v = e-&gt;dst;
			if (v == u-&gt;father)
				continue;
			opt = max(opt, v-&gt;size);
		}

		if (opt &lt; bestOpt) {
			bestOpt = opt;
			best = u;
		}
	}

	return best;
}

const int MAX_N_SPLITS = MAX_N_VERTEXS * 2;

Trie*trieRoot = new Trie;
struct Split {
	vector&lt;Trie*&gt;* trieByBranch;
	int nBranch;

	void init(int nBranch) {
		trieByBranch = new vector&lt;Trie*&gt; [nBranch];
		this-&gt;nBranch = nBranch;
	}

	void add(int branch, Trie*t) {
		trieByBranch[branch].push_back(t);
	}
};

Split splits[MAX_N_SPLITS];
int splitsCur = 0;

void buildSplit(Vertex*root, Split&amp;split) {
	root-&gt;where = trieRoot-&gt;go(root-&gt;ch - 'a');
	doBFS(root);

	int curBranch = 0;
	for (Edge*e = root-&gt;begin-&gt;next; e != root-&gt;end; e = e-&gt;next) {
		e-&gt;dst-&gt;branch = curBranch++;
	}
	root-&gt;branch = curBranch++;
	split.init(curBranch);
	for (int i = 1; i &lt; qt; ++i) {
		Vertex*u = que[i];
		u-&gt;where = u-&gt;father-&gt;where-&gt;go(u-&gt;ch - 'a');
		if (u-&gt;father != root) {
			u-&gt;branch = u-&gt;father-&gt;branch;
		}
	}
	for (int i = 0; i &lt; qt; ++i) {
		split.add(que[i]-&gt;branch, que[i]-&gt;where);
	}
}

void doTreeSplit(Vertex*root) {
	int id = splitsCur++;
	root = findSplitVertex(root);
	buildSplit(root, splits[id]);
	for (Edge*e = root-&gt;begin-&gt;next; e != root-&gt;end; e = e-&gt;next) {
		e-&gt;erase();
		e-&gt;op-&gt;erase();
		doTreeSplit(e-&gt;dst);
	}
}

void getDfsOrd() {
	dfsCur = 0;
	dfs(trieRoot, 0);
}

struct Point {
	int x, y;
	int val;

	Point() {
		val = 0;
	}
	Point(int _x, int _y) :
		x(_x), y(_y) {
		val = 0;
	}

	bool operator&lt;(const Point&amp;p) const {
		return x &lt; p.x;
	}
};

bool cmpPointPtrByY(Point*a, Point*b) {
	return a-&gt;y &lt; b-&gt;y;
}

struct DataStruct {
	static const int MAX_N_POINTS = MAX_NLOGN;
	static const int MAX_SQRT_N_POINTS = 1000 + 10;

	struct Block {
		int sum[MAX_SQRT_N_POINTS];
		Point*points[MAX_SQRT_N_POINTS];

		int n;
		int addAll;

		int L, R;

		void set(int _L) {
			n = 0;
			L = _L;
		}

		void addPoint(Point*me) {
			points[n++] = me;
		}

		void start() {
			R = L + n - 1;
			sort(points, points + n, cmpPointPtrByY);
			memset(sum, 0, sizeof sum);
		}

		void applyAdd(int add) {
			addAll += add;
		}

		void relax() {
			if (!addAll)
				return;
			for (int i = 0; i &lt; n; ++i) {
				points[i]-&gt;val += addAll;
			}
			addAll = 0;
		}

		void rebuild() {
			sum[0] = 0;
			for (int i = 0; i &lt; n; ++i) {
				sum[i + 1] = sum[i] + points[i]-&gt;val;
			}
		}

		int ask(int ly, int ry) {
			static Point*tmp = new Point;
			tmp-&gt;y = ly;
			int atL = lower_bound(points, points + n, tmp, cmpPointPtrByY)
					- points;
			tmp-&gt;y = ry;
			int atR = upper_bound(points, points + n, tmp, cmpPointPtrByY)
					- points - 1;
			int cnt = atR - atL + 1;
			return sum[atR + 1] - sum[atL] + cnt * addAll;
		}
	};

	Point points[MAX_N_POINTS];
	int nPoints;

	Block blocks[MAX_SQRT_N_POINTS];
	int nBlocks;

	void clear() {
		nPoints = 0;
	}

	void addPoint(int x, int y) {
		points[nPoints++] = Point(x, y);
	}

	void start() {
		sort(points, points + nPoints);
		nBlocks = 0;
		while (nBlocks * nBlocks &lt; nPoints)
			++nBlocks;

		for (int i = 0; i &lt; nBlocks; ++i) {
			blocks[i].set(i * nBlocks);
		}
		for (int i = 0; i &lt; nPoints; ++i) {
			blocks[i / nBlocks].addPoint(points + i);
		}
		for (int i = 0; i &lt; nBlocks; ++i) {
			blocks[i].start();
		}
	}

	void doit(int lx, int rx, int d) {
		int at = lx / nBlocks;
		blocks[at].relax();
		for (int i = lx; i &lt;= rx; ++i) {
			points[i].val += d;
		}
		blocks[at].rebuild();
	}

	void change(int lx, int rx, int d) {
		lx = lower_bound(points, points + nPoints, Point(lx, -1)) - points;
		rx = upper_bound(points, points + nPoints, Point(rx, -1)) - points - 1;
		if (lx &gt; rx)
			return;
		int atL = lx / nBlocks;
		int atR = rx / nBlocks;
		if (atL == atR) {
			doit(lx, rx, d);
			return;
		}
		doit(lx, blocks[atL].R, d);
		doit(blocks[atR].L, rx, d);
		++atL;
		--atR;
		for (int i = atL; i &lt;= atR; ++i) {
			blocks[i].applyAdd(d);
		}
	}

	int ask(int ly, int ry) {
		int ret = 0;
		for (int i = 0; i &lt; nBlocks; ++i) {
			ret += blocks[i].ask(ly, ry);
		}
		return ret;
	}
};

DataStruct dataStrcut;

void calcFail() {
	static Trie*que[MAX_NLOGN];
	int qh = 0, qt = 0;
	que[qt++] = trieRoot;
	trieRoot-&gt;fail = 0;
	while (qh &lt; qt) {
		Trie*u = que[qh++];
		for (int c = 0; c &lt; MAX_N_ALPHA; ++c) {
			Trie*v = u-&gt;ch[c];
			if (v == 0)
				continue;
			Trie*p = u-&gt;fail;
			while (p != 0 &amp;&amp; p-&gt;ch[c] == 0)
				p = p-&gt;fail;
			if (p == 0)
				p = trieRoot;
			else
				p = p-&gt;ch[c];
			v-&gt;fail = p;
			que[qt++] = v;
		}
	}

	for (int i = 0; i &lt; qh; ++i) {
		Trie*t = que[i];
		memset(t-&gt;fail2k, 0, sizeof t-&gt;fail2k);
		t-&gt;fail2k[0] = t-&gt;fail;
		for (int i = 0; i &lt; MAX_LOG - 1; ++i) {
			if (t-&gt;fail2k[i] == 0)
				break;
			t-&gt;fail2k[i + 1] = t-&gt;fail2k[i]-&gt;fail2k[i];
		}
	}
}

Trie*Left[MAX_L_PAT], *Right[MAX_L_PAT];

Trie*far[MAX_L_PAT];

Trie* isInST(int l, int r) {
	if (l &gt; r)
		return trieRoot;
	Trie*at = far[r];
	Trie*cur = at;
	int len = r - l + 1;
	for (int i = MAX_LOG - 1; i &gt;= 0; --i) {
		Trie*f = cur-&gt;fail2k[i];
		if (f == 0)
			continue;
		if (f-&gt;depth &gt;= len)
			cur = f;
	}

	if (cur-&gt;depth == len)
		return cur;
	return 0;
}

void calcRight(Trie*Right[]) {
	Trie*t = trieRoot;
	for (int i = 0; i &lt; patLen; ++i) {
		int cur = pat[i] - 'a';
		while (t &amp;&amp; t-&gt;ch[cur] == 0)
			t = t-&gt;fail;
		if (t == 0)
			t = trieRoot;
		else
			t = t-&gt;ch[cur];
		far[i] = t;
	}
	for (int i = 0; i &lt; patLen; ++i) {
		int l = i - 1, r = patLen;
		while (l + 1 &lt; r) {
			int m = l + r &gt;&gt; 1;
			if (isInST(i, m) != 0)
				l = m;
			else
				r = m;
		}
		Right[i] = isInST(i, l);
	}
}

void calcLeftAndRight() {
	calcFail();
	calcRight(Right);
	reverse(pat, pat + patLen);
	calcRight(Left);
	reverse(pat, pat + patLen);
	reverse(Left, Left + patLen);
}

typedef long long int64;

int64 ans = 0;

void processSplit(const Split&amp;split) {
	for (int i = 0; i &lt; split.nBranch; ++i) {
		vector&lt;Trie*&gt;&amp;tmp = split.trieByBranch[i];
		foreach(iter,tmp) {
			Trie*u = *iter;
			dataStrcut.change(u-&gt;begin, u-&gt;end, 1);
		}
	}

	for (int i = 0; i &lt; split.nBranch; ++i) {
		vector&lt;Trie*&gt;&amp;tmp = split.trieByBranch[i];
		if (i != split.nBranch - 1) {
			foreach(iter,tmp) {
				Trie*u = *iter;
				dataStrcut.change(u-&gt;begin, u-&gt;end, -1);
			}
		}

		foreach(iter,tmp) {
			Trie*u = *iter;
			ans += dataStrcut.ask(u-&gt;begin, u-&gt;end);
		}

		if (i != split.nBranch - 1) {
			foreach(iter,tmp) {
				Trie*u = *iter;
				dataStrcut.change(u-&gt;begin, u-&gt;end, 1);
			}
		}
	}

	for (int i = 0; i &lt; split.nBranch; ++i) {
		vector&lt;Trie*&gt;&amp;tmp = split.trieByBranch[i];
		foreach(iter,tmp) {
			Trie*u = *iter;
			dataStrcut.change(u-&gt;begin, u-&gt;end, -1);
		}
	}
}

void prepareDataStruct() {
	dataStrcut.clear();
	for (int i = 0; i &lt; patLen; ++i) {
		dataStrcut.addPoint(Left[i]-&gt;begin, Right[i]-&gt;begin);
	}
	dataStrcut.start();
}

void calcAns() {
	ans = 0;
	for (int i = 0; i &lt; splitsCur; ++i) {
		processSplit(splits[i]);
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}

void work() {
	doTreeSplit(vertexs + 0);
	getDfsOrd();
	calcLeftAndRight();
	prepareDataStruct();
	calcAns();
}

void solve() {
	readInput();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem1922</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
typedef long long ll;
const int maxn=3000;
const ll inf=1LL&lt;&lt;60;
using namespace std;
struct Edge
{
    int t,c;
    Edge(int _t,int _c):t(_t),c(_c){}
};
vector&lt;Edge&gt; E[maxn];
vector&lt;int&gt; L[maxn];
typedef vector&lt;int&gt;::iterator vit;
typedef vector&lt;Edge&gt;::iterator eit;
int n,m;
ll Dp[maxn]={};
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d",&amp;n,&amp;m);int s,t,c;
    while(m--)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);s--;t--;E[t].pb(Edge(s,c));
    }
    rep(i,n)
    {
        int l,x;scanf("%d",&amp;l);while(l--)scanf("%d",&amp;x),L[i].pb(x-1);
        Dp[i]=inf;
    }
    Dp[0]=0;bool ch=true;
    while(ch)
    {
        ch=false;
        rep(i,n)
        {
            ll Max=0,Min=inf;
            for(vit e=L[i].begin();e!=L[i].end();e++)Max&gt;?=Dp[*e];
            for(eit e=E[i].begin();e!=E[i].end();e++)Min&lt;?=Dp[e-&gt;t]+e-&gt;c;
            Max&gt;?=Min;
            if(Max&lt;Dp[i])
            {
                ch=true;
                Dp[i]=Max;
            }
        }
    }
    cout&lt;&lt;Dp[n-1]&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1922</h2><pre>#include &lt;vector&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
typedef long long ll;
const int maxn=3000;
const ll inf=1LL&lt;&lt;60;
using namespace std;
struct Edge
{
    int t,c;
    Edge(int _t,int _c):t(_t),c(_c){}
};
vector&lt;Edge&gt; E[maxn];
vector&lt;int&gt; L[maxn];
typedef vector&lt;int&gt;::iterator vit;
typedef vector&lt;Edge&gt;::iterator eit;
int n,m;
ll Dp[maxn]={};
int main()
{
    scanf("%d%d",&amp;n,&amp;m);int s,t,c;
    while(m--)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);s--;t--;E[t].pb(Edge(s,c));
    }
    rep(i,n)
    {
        int l,x;scanf("%d",&amp;l);while(l--)scanf("%d",&amp;x),L[i].pb(x-1);
        Dp[i]=inf;
    }
    Dp[0]=0;bool ch=true;
    while(ch)
    {
        ch=false;
        rep(i,n)
        {
            ll Max=0,Min=inf;
            for(vit e=L[i].begin();e!=L[i].end();e++)Max&gt;?=Dp[*e];
            for(eit e=E[i].begin();e!=E[i].end();e++)Min&lt;?=Dp[e-&gt;t]+e-&gt;c;
            Max&gt;?=Min;
            if(Max&lt;Dp[i])
            {
                ch=true;
                Dp[i]=Max;
            }
        }
    }
    printf("%d\n",Dp[n-1]);
}


</pre><pre></pre><h2>Problem1923</h2><pre>/*
 * [Sdoi2010]外星千足虫.cpp
 *
 *  Created on: 2011-3-7
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;bitset&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_NCOL=1000+10;
const int MAX_NROW=2000+10;

typedef bitset&lt;MAX_NCOL&gt; Row;
Row mat[MAX_NROW];

int nInsects,nExperiment;
void inputData(){
	scanf("%d%d",&amp;nInsects,&amp;nExperiment);
	for (int row = 0; row &lt; nExperiment; ++row) {
		mat[row].reset();
		char ch;scanf(" ");
		for (int col = 0; col &lt;= nInsects; ++col) {
			while(ch=getchar(),ch!='0'&amp;&amp;ch!='1');
			mat[row][col]=ch=='1';
		}
	}
}

int whichCol[MAX_NROW];
int restCol;

int ans[MAX_NCOL];

void work(){
	restCol=nInsects;
	int when=-1;
	for (int row = 0; row &lt; nExperiment; ++row) {
		int col=-1;
		for (int ncol = 0; ncol &lt; nInsects; ++ncol) {
			if(mat[row][ncol]){
				col=ncol;
				break;
			}
		}
		whichCol[row]=col;
		if(col != -1){
			restCol--;
			for (int otherRow = 0; otherRow &lt; nExperiment; ++otherRow) {
				if(otherRow == row)continue;
				if(mat[otherRow][col])
					mat[otherRow]^=mat[row];
			}
		}
		if(restCol == 0){
			when=row;
			break;
		}
	}
	if(when == -1){
		printf("Cannot Determine");
		return;
	}
	printf("%d\n",when+1);
	for (int row = 0; row &lt;= when; ++row) {
		int col=whichCol[row];
		if(col == -1)continue;
		ans[col]=mat[row][nInsects];
	}
	for (int col = 0; col &lt; nInsects; ++col) {
		if(ans[col])
			puts("?y7M#");
		else
			puts("Earth");
	}
}

void solve(){
	inputData();
	work();
}

int main(){
	solve();
}
</pre><pre></pre><h2>Problem1924</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
using namespace std;
inline void scan(int&amp;t)
{
    char c;while(c=getchar(),c&lt;'0'||c&gt;'9');t=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
}
int n,r,c;
struct Point
{
    int x,y;
    Point(){}
    Point(int _x,int _y):
        x(_x),y(_y){}
    bool operator&lt;(const Point&amp;pnt)const
    {
        if(x!=pnt.x)return x&lt;pnt.x;
        return y&lt;pnt.y;
    }
    void read()
    {
        scan(y);scan(x);
    }
};
const int DR_MAX=100000+10;
struct Door
{
    Point loc;
    int type;
    void read()
    {
        loc.read();
        scan(type);
    }
}D[DR_MAX];
map&lt;Point,int&gt; id;
void input_data()
{
    scan(n);scan(r);scan(c);
    for(int i=0;i&lt;n;i++)
    {
        D[i].read();
        id[D[i].loc]=i;
    }
}
const int VT_MAX=DR_MAX*2,EG_MAX=VT_MAX*8;
struct Graph
{
    int head[VT_MAX],Vet;
    int next[EG_MAX],dest[EG_MAX],mnt;
    void init_graph()
    {
        memset(head,-1,sizeof head);
        mnt=0;
    }
    void add_edge(int s,int t)
    {
        next[mnt]=head[s];dest[mnt]=t;
        head[s]=mnt++;
    }
};
int Vet;
map&lt;int,int&gt; id_x,id_y;
typedef map&lt;int,int&gt;::iterator mit;
Graph G,RevG;
void add_edge(int s,int t)
{
    G.add_edge(s,t);
    RevG.add_edge(t,s);
}
void build_graph()
{
    Vet=n;G.init_graph();
    RevG.init_graph();
    for(int i=0;i&lt;n;i++)
    {
        Door&amp;dr=D[i];
        int x=dr.loc.x,y=dr.loc.y;
        int u=i;
        switch(dr.type)
        {
            case 1:
                if(!id_y.count(y))
                    id_y[y]=Vet++;
                add_edge(u,id_y[y]);
                break;
            case 2:
                if(!id_x.count(x))
                    id_x[x]=Vet++;
                add_edge(u,id_x[x]);
                break;
            case 3:
                for(int _x=x-1;_x&lt;=x+1;_x++)
                    for(int _y=y-1;_y&lt;=y+1;_y++)
                    {
                        Point np(_x,_y);
                        if(id.count(np))
                        {
                            int v=id[np];
                            if(u!=v)
                                add_edge(u,v);
                        }
                    }
                break;
        }
    }
    for(int i=0;i&lt;n;i++)
    {
        Door&amp;dr=D[i];
        int x=dr.loc.x,y=dr.loc.y,u=i;
        if(id_x.count(x))
        {
            int v=id_x[x];
            add_edge(v,u);
        }
        if(id_y.count(y))
        {
            int v=id_y[y];
            add_edge(v,u);
        }
    }
}
struct State
{
    int v,e;
    State(){}
    State(int _v,int _e):v(_v),e(_e){}
};
int seq[VT_MAX],snt;
int own[VT_MAX],cnt;
void dfs(const Graph&amp;G,int vs,bool put)
{
    static State Stack[VT_MAX];
    static int top;top=0;
    Stack[top++]=State(vs,G.head[vs]);
    while(top)
    {
        State&amp;now=Stack[top-1];
        int&amp;v=now.v;int&amp;e=now.e;
        if(e==G.head[v])//first visit
            own[v]=cnt;
        if(e==-1)//end
        {
            if(put)
                seq[snt++]=v;
            top--;
            continue;
        }
        int u=G.dest[e];
        if(own[u]==-1)
        {
            Stack[top++]=State(u,G.head[u]);
        }
        e=G.next[e];
    }
}
void calc_sc()
{
    memset(own,-1,sizeof own);snt=cnt=0;   
    for(int v=0;v&lt;Vet;v++)
        if(own[v]==-1)
            dfs(G,v,true);
    memset(own,-1,sizeof own);
    for(int idx=Vet-1;idx&gt;=0;idx--)
    {
        int v=seq[idx];
        if(own[v]==-1)
            dfs(RevG,v,false),cnt++;
    }
}
Graph NewG;
#define tr(e,G,u) for(int e=G.head[u];e!=-1;e=G.next[e])
int Val[VT_MAX];
void compress_graph()
{
    calc_sc();
    NewG.init_graph();
    NewG.Vet=cnt;
    memset(Val,0,sizeof Val);
    for(int u=0;u&lt;Vet;u++)
    {
        tr(e,G,u)
        {
            int v=G.dest[e];
            if(own[u]!=own[v])
                NewG.add_edge(own[u],own[v]);
        }
        if(u&lt;n)Val[own[u]]++;
    }
    /*
    for(int u=0;u&lt;NewG.Vet;u++)
    {
        set&lt;int&gt;to;
        tr(e,NewG,u)
        {
            int v=NewG.dest[e];
            if(!to.count(v))
            {
                cout&lt;&lt;u&lt;&lt;"-&gt;"&lt;&lt;v&lt;&lt;endl;
                to.insert(v);
            }
        }
        cout&lt;&lt;u&lt;&lt;":"&lt;&lt;Val[u]&lt;&lt;endl;
    }*/
}
void calc_ans()
{
    static int Q[VT_MAX],h,t;
    static int in[VT_MAX];
    static int dp[VT_MAX];
    h=t=0;
    memset(in,0,sizeof in);
    for(int u=0;u&lt;NewG.Vet;u++)
        tr(e,NewG,u)
            in[NewG.dest[e]]++;
    for(int u=0;u&lt;NewG.Vet;u++)
        if(!in[u])
            Q[t++]=u;
    for(;h&lt;t;h++)
    {
        int u=Q[h],v;
        tr(e,NewG,u)
        {
            v=NewG.dest[e];
            if(!--in[v])
                Q[t++]=v;
        }
    }
    int ret=0;
    for(int idx=h-1;idx&gt;=0;idx--)
    {
        int u=Q[idx],v;
        dp[u]=Val[u];
        tr(e,NewG,u)
        {
            v=NewG.dest[e];
            dp[u]=max(dp[u],dp[v]+Val[u]);
        }   
        if(dp[u]&gt;ret)
            ret=dp[u];
    }
    printf("%d\n",ret);
}
void Solve()
{
    input_data();
    build_graph();
    compress_graph();
    calc_ans();
}
int main()
{
    //freopen("in.cpp","r",stdin);
    //freopen("out.cpp","w",stdout);
    Solve();
}
</pre><pre></pre><h2>Problem1925</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
const int inf=~0U&gt;&gt;1,maxn=5000;
using namespace std;
int mod,Dp[2][maxn]={},n;
inline int Plus(int a,int b)
{
    a+=b;if(a&gt;=mod)a-=mod;
    return a;
}
int main()
{
    cin&gt;&gt;n&gt;&gt;mod;if(n==1){cout&lt;&lt;1&lt;&lt;endl;}
    int now=0,old=1;
    Dp[now][1]=1;
    for(int i=3;i&lt;=n;i++)
    {
        swap(now,old);
        for(int j=i;j&gt;=1;j--)
        {
            Dp[now][j]=Plus(Dp[now][j+1],Dp[old][i-j]);
        }
    }
    int ans=0;
    rep(i,n+1)ans=Plus(ans,Dp[now][i]);
    ans*=2;ans%=mod;cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1927</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;deque&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=2000,maxm=20000*2,inf=0x3F3F3F3F;
int mnt=0;
int c[maxm],u[maxm],t[maxm],nxt[maxm];
int head[maxn];
void AddEdge(int s,int _t,int _u,int _c)
{
    c[mnt]=_c;t[mnt]=_t;u[mnt]=_u;
    nxt[mnt]=head[s];head[s]=mnt;
    mnt++;
}
void InsEdge(int s,int t,int u,int c)
{
    AddEdge(s,t,u,c);
    AddEdge(t,s,0,-c);
}
int vis[maxn]={0},flag=0;
int piS=0,cost=0,vs,vt,v;
int aug(int no,int m)
{
    if(no==vt) return cost+=piS*m,m;
    vis[no]=flag;
    int l=m;
    for(int e=head[no];e!=-1;e=nxt[e])
        if(u[e]&amp;&amp;!c[e]&amp;&amp;vis[t[e]]!=flag)
        {
            int d=aug(t[e],min(l,u[e]));
            u[e]-=d;u[e^1]+=d;l-=d;
            if(!l)return m;
        }
    return m-l;
}
bool mod()
{
    static int D[maxn];memset(D,0x3F,sizeof D);D[vt]=0;
    static deque&lt;int&gt; Q;Q.push_back(vt);
    while(Q.size())
    {
        int dt,no=Q.front();Q.pop_front();
        for(int e=head[no];e!=-1;e=nxt[e])
            if(u[e^1]&amp;&amp;(dt=D[no]-c[e])&lt;D[t[e]])
                (D[t[e]]=dt)&lt;=D[Q.size()?Q.front():0]
                    ?Q.push_front(t[e]):Q.push_back(t[e]);
    }
    rep(i,v)
       for(int e=head[i];e!=-1;e=nxt[e])
           c[e]+=D[t[e]]-D[i];
    piS+=D[vs];
    return D[vs]&lt;inf;
}
int CalCostFlow()
{
    while(mod())
        do ++flag;
        while(aug(vs,inf));
    return cost;
}
inline int in(int v){return v*2;}
inline int out(int v){return v*2+1;}
int main()
{
    //freopen("in","r",stdin);
    int n,m,s,t,c;
    scanf("%d%d",&amp;n,&amp;m);v=2*n;
    vs=v++;vt=v++;
    memset(head,-1,sizeof head);
    rep(i,n)
    {
        scanf("%d",&amp;c);
        InsEdge(vs,in(i),1,0);
        InsEdge(vs,out(i),1,c);
        InsEdge(out(i),vt,1,0);
    }
    rep(i,m)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);--s;--t;
        if(s&gt;t)swap(s,t);
        InsEdge(in(s),out(t),1,c);
    }
    printf("%d\n",CalCostFlow());
}
</pre><pre></pre><h2>Problem1932</h2><pre>#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define All(x) x.begin(),x.end()
const int inf=~0U&gt;&gt;1,seed=13331;
using namespace std;
typedef unsigned long long ull;
typedef vector&lt;ull&gt; set;
ull Code(const set&amp;s)
{
    ull ret=0;
    rep(i,s.size())ret*=seed,ret+=s[i]+78;
    return ret;
}
void Normal(set&amp;s)
{
    sort(All(s));
    s.resize(unique(All(s))-s.begin());
}
stack&lt;set&gt; S;
void Show(const set&amp;s)
{
    puts("Show");
    rep(i,s.size())printf("%d\n",s[i]);
}
int main()
{
    //freopen("in","r",stdin);
    int n;scanf("%d",&amp;n);char cmd[10];set a,b;
    while(n--)
    {
        scanf("%s",cmd);
        switch(cmd[0])
        {
            case 'P':S.push(set());break;
            case 'D':S.push(S.top());break;
            case 'A':a=S.top();S.pop();b=S.top();S.pop();b.pb(Code(a));
                    Normal(b);S.push(b);break;
            default:a=S.top();S.pop();b=S.top();S.pop();set c(a.size()+b.size());
                if(cmd[0]=='U')c.resize(set_union(All(a),All(b),c.begin())-c.begin());
                else c.resize(set_intersection(All(a),All(b),c.begin())-c.begin());
                Normal(c);S.push(c);break;
        }
        printf("%d\n",S.top().size());
    }
}


</pre><pre></pre><h2>Problem1932</h2><pre>#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
const int seed=13331;
using namespace std;
typedef unsigned long long ull;
typedef vector&lt;ull&gt; set;
ull Code(const set&amp;s)
{
    ull ret=0;
    rep(i,s.size())ret*=seed,ret+=s[i]+78;
    return ret;
}
void Normal(set&amp;s)
{
    sort(All(s));
    s.resize(unique(All(s))-s.begin());
}
stack&lt;set&gt; S;
int main()
{
    int n;scanf("%d",&amp;n);char cmd[10];set a,b;
    while(n--)
    {
        scanf("%s",cmd);
        switch(cmd[0])
        {
            case 'P':S.push(set());break;
            case 'D':S.push(S.top());break;
            case 'A':a=S.top();S.pop();b=S.top();S.pop();b.pb(Code(a));
                    Normal(b);S.push(b);break;
            default:a=S.top();S.pop();b=S.top();S.pop();set c(a.size()+b.size());
                if(cmd[0]=='U')c.resize(set_union(All(a),All(b),c.begin())-c.begin());
                else c.resize(set_intersection(All(a),All(b),c.begin())-c.begin());
                Normal(c);S.push(c);break;
        }
        printf("%d\n",S.top().size());
    }
}


</pre><pre></pre><h2>Problem1933</h2><pre>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(register int i=0;i&lt;n;i++)
using namespace std;
const int N_MAX=70;
const int W_MAX=30;
const int V_MAX=N_MAX*W_MAX;
struct Marker
{
    int flag;
    short M[V_MAX][V_MAX];
    void clear(){memset(M,0,sizeof M);flag=1;}
    void start(){flag++;}
    inline bool marked(int a,int b){return M[a][b]==flag;}
    inline void mark(int a,int b){M[a][b]=flag;}
}marker[2];
int Ans[2][V_MAX][V_MAX];
struct Tdata
{
    int h,w;
    bool operator&lt;(const Tdata&amp;data)const
    {
        return h&gt;data.h;
    }
};
Tdata A[N_MAX];
int n;
void input_data()
{
    scanf("%d",&amp;n);rep(i,n)scanf("%d%d",&amp;A[i].h,&amp;A[i].w);
}
inline void Update(int m,int a,int b,int val)
{
    if(!marker[m].marked(a,b))
    {
        marker[m].mark(a,b);
        Ans[m][a][b]=val;
    }
    else
    {
        if(Ans[m][a][b]&gt;val)
            Ans[m][a][b]=val;
    }
}
template&lt;class T&gt;
void qsort(T*A,int l,int r)
{
    T x=A[l+rand()%(r-l+1)];
    int i=l,j=r;
    while(i&lt;=j)
    {
        while(A[i]&lt;x)i++;
        while(x&lt;A[j])j--;
        if(i&lt;=j){T c=A[i];A[i]=A[j];A[j]=c;i++;j--;}
    }
    if(i&lt;r)qsort(A,i,r);
    if(j&gt;l)qsort(A,l,j);
}
void work()
{
    qsort(A,0,n-1);
    int cur=0,next=1,sum=0;
    marker[next].start();Update(next,0,0,0);
    rep(i,n)
    {
        Tdata&amp;it=A[i];cur^=1;next^=1;
        marker[next].start();
        rep(w1,sum+1)rep(w2,sum+1-w1)if(marker[cur].marked(w1,w2))
        {
            int w3=sum-w1-w2;
            int ret=Ans[cur][w1][w2];
            //put it in w1
            if(w1)Update(next,w1+it.w,w2,ret);
            else Update(next,w1+it.w,w2,ret+it.h);
            //put it in w2
            if(w2)Update(next,w1,w2+it.w,ret);
            else Update(next,w1,w2+it.w,ret+it.h);
            //put it in w3
            if(w3)Update(next,w1,w2,ret);
            else Update(next,w1,w2,ret+it.h);
        }
        sum+=it.w;
    }
    int ans=~0U&gt;&gt;1;
    rep(w1,sum+1)rep(w2,sum+1-w1)if(marker[next].marked(w1,w2))
    {
        int w3=sum-w1-w2;
        int ret=w1;if(w2&gt;ret)ret=w2;if(w3&gt;ret)ret=w3;
        ret*=Ans[next][w1][w2];
        if(w1&amp;&amp;w2&amp;&amp;w3)
            if(ret&lt;ans)ans=ret;
    }
    printf("%d\n",ans);
}
void solve()
{
    input_data();
    work();
}
int main()
{
    //freopen("in","r",stdin);
    solve();
}
</pre><pre></pre><h2>Problem1934</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=300;
using namespace std;
int A[maxn],X[maxn],ans=inf,n,m;
bool E[maxn][maxn]={};
void Random()
{
    rep(i,n)X[i]=rand()%2;
    while(true)
    {
        int ch,Min=inf,f=-1;
        rep(i,n)
        {
            ch=0;X[i]^=1;
            if(X[i]^A[i])ch++;else ch--;
            rep(j,n)if(E[i][j])
            {
                if(X[i]^X[j])ch++;
                else ch--;
            }
            X[i]^=1;
            if(ch&lt;Min){Min=ch;f=i;}
        }
        if(Min&gt;=0)break;
        X[f]^=1;
    }
    int ret=0;
    rep(i,n)
    {
        if(X[i]^A[i])ret+=2;
        rep(j,n)if(E[i][j]&amp;&amp;X[i]^X[j])
            ret++;
    }
    ret/=2;
    ans=min(ret,ans);
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;rep(i,n)cin&gt;&gt;A[i];
    int s,t;
    rep(i,m)
    {
        scanf("%d%d",&amp;s,&amp;t);--s;--t;
        E[s][t]=E[t][s]=true;
    }
    rep(i,10)Random();
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1934</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=300;
using namespace std;
int A[maxn],X[maxn],ans=inf,n,m;
bool E[maxn][maxn]={};
void Random()
{
    rep(i,n)X[i]=rand()%2;
    while(true)
    {
        int ch,Min=inf,f=-1;
        rep(i,n)
        {
            ch=0;X[i]^=1;
            if(X[i]^A[i])ch++;else ch--;
            rep(j,n)if(E[i][j])
            {
                if(X[i]^X[j])ch++;
                else ch--;
            }
            X[i]^=1;
            if(ch&lt;Min){Min=ch;f=i;}
        }
        if(Min&gt;=0)break;
        X[f]^=1;
    }
    int ret=0;
    rep(i,n)
    {
        if(X[i]^A[i])ret+=2;
        rep(j,n)if(E[i][j]&amp;&amp;X[i]^X[j])
            ret++;
    }
    ret/=2;
    ans=min(ret,ans);
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;rep(i,n)cin&gt;&gt;A[i];
    int s,t;
    rep(i,m)
    {
        scanf("%d%d",&amp;s,&amp;t);--s;--t;
        E[s][t]=E[t][s]=true;
    }
    rep(i,3)Random();
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1939</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxn=100,maxk=6;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,k;
int Mem[maxn][maxn][maxk],A[maxn];
int Dp(int l,int r,int t)
{
    if(t&gt;k)t=k;
    if(l&gt;r)return 0;
    if(l==r) return k-t;
    int&amp;x=Mem[l][r][t];
    if(x!=-1)return x;
    if(A[l]==A[l+1])return x=Dp(l+1,r,t+1);
    if(t&lt;k)x=Dp(l,r,t+1)+1;else x=Dp(l+1,r,1);
    for(int k=l+1;k&lt;=r;k++)if(A[l]==A[k])
        x=min(x,Dp(l+1,k-1,1)+Dp(k,r,t+1));
    return x;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;k;rep(i,n)cin&gt;&gt;A[i];
    memset(Mem,-1,sizeof Mem);
    cout&lt;&lt;Dp(0,n-1,1)&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1939</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxn=100,maxk=6;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,k;
int Mem[maxn][maxn][maxk],A[maxn];
int Dp(int l,int r,int t)
{
    if(t&gt;k)t=k;
    if(l&gt;r)return 0;
    if(l==r) return k-t;
    int&amp;x=Mem[l][r][t];
    if(x!=-1)return x;
    if(A[l]==A[l+1])return x=Dp(l+1,r,t+1);
    x=Dp(l+1,r,1)+k-t;
    for(int k=l+1;k&lt;=r;k++)if(A[l]==A[k])
        x=min(x,Dp(l+1,k-1,1)+Dp(k,r,t+1));
    return x;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;k;rep(i,n)cin&gt;&gt;A[i];
    memset(Mem,-1,sizeof Mem);
    cout&lt;&lt;Dp(0,n-1,1)&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1942</h2><pre>program tiso_qs;

const MAXN = 1001001;
	   
type off = record
	      id   : longint;    {* ID ot this deparment, to be assigned during the algorithm *}
	      boss : longint;    {* index of the superior. Prime minister has 0 *}
	      e	   : qword;      {* sequence if indexes of direct employees *}
	      enum : longint;    {* number of 'not solved' direct employees *}
	   end;	   
var o	     : array[0..MAXN] of off;        {* prime minister will be 1, 0 is god *}
   zas,queue : array[0..MAXN] of longint;    {* zas[0] is god too, no gods in queue though *}
   qs,qe     : longint;
   free_id   : longint;
	   
procedure read_input;
var c	  : char;
   i,free : longint;
begin
   i:=0; zas[0]:=0; free:=1;
   repeat
      read(c);
      if c='(' then begin
	 inc(o[zas[i]].enum);
	 o[free].boss:=zas[i];
	 inc(i); zas[i]:=free; inc(free);
      end else if c=')' then begin
	 if o[zas[i]].enum=0 then begin queue[qe]:=zas[i]; inc(qe) end;
	 dec(i);
      end else begin writeln('Bad input data!'); halt end;
   until i=0;
end;

procedure collect;
var e,num,i,tmp : longint;   
begin
   num:=free_id;
   {* assign the id's and compute the number of unique *}
   for i:=qs to qe-1 do begin
      if (i=qs) or (o[queue[i-1]].e&lt;&gt;o[queue[i]].e) then begin inc(free_id) end;
      o[queue[i]].id:=free_id-1;
   end;
   writeln(free_id-num);
   
   {* propagate the id's to the parents and add them to the queue when they are ready *}
   e:=qe;
   while qs&lt;e do begin
      tmp:=o[queue[qs]].boss;
      o[tmp].e:=(o[tmp].e shl 20) or o[queue[qs]].id;
      dec(o[tmp].enum); inc(qs);
      if o[tmp].enum&gt;0 then continue;
      queue[qe]:=tmp; inc(qe);
   end;
end;

{* we must get unique off's in queue[qs..qe-1] next to each other *}
{* by unique we mean that their e's are equivalent *}
{* just now, it is stupid quicksort *}
procedure birds_of_a_feather_flock_together(l,r	: longint);
var e	   : qword;
   tmp,i,j : longint;
begin
   if l&gt;=r-5 then begin
      for i:= l to r-1 do for j:= i+1 to r do
	 if o[queue[i]].e &gt; o[queue[j]].e then begin tmp:=queue[i]; queue[i]:=queue[j]; queue[j]:=tmp end;
      exit
   end;

   i:=l; j:=r; e:=o[queue[(l+r) div 2]].e;
   repeat
      while o[queue[i]].e &lt; e do inc(i);
      while o[queue[j]].e &gt; e do dec(j);
      if i&lt;=j then begin
	 tmp:=queue[i]; queue[i]:=queue[j]; queue[j]:=tmp;
	 inc(i); dec(j);
      end;
   until i&gt;j;
   if j-l&gt;0 then birds_of_a_feather_flock_together(l,j);
   if r-i&gt;0 then birds_of_a_feather_flock_together(i,r);
end;

begin
   qs:=0; qe:=0; free_id:=1;
   read_input;
   while {*not god*} queue[qs]&lt;&gt;0 do begin
      collect;
      birds_of_a_feather_flock_together(qs,qe-1);
   end;
end.  </pre><pre></pre><h2>Problem1942</h2><pre>/*
 * [Ceoi2007]Ministry.cpp
 *
 *  Created on: 2011-6-11
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 1000000 + 10;

typedef long long int64;

char buf[MAX_N * 2];
int at, L;

char nextChar() {
	return buf[at];
}

void eatChar() {
	++at;
}

struct Tree {
	Tree*ch[3];
	int id;
	int nCh;
	int dep;
	Tree*next;
	Tree();
	int64 code;
	void getCode() {
		static int64 ids[3];
		for (int i = 0; i &lt; nCh; ++i) {
			ids[i] = ch[i]-&gt;id;
		}
		code = 1;
		sort(ids, ids + nCh);
		for (int i = 0; i &lt; nCh; ++i) {
			code &lt;&lt;= 20;
			code += ids[i];
		}
	}
}*root;

int nId, maxDep;

Tree*depFirst[MAX_N] = { };

Tree::Tree() {
	id = -1;
	nCh = 0;
	dep = 0;
	eatChar();//(
	while (nextChar() != ')') {
		Tree*c = new Tree;
		ch[nCh++] = c;
		dep = max(dep, c-&gt;dep + 1);
	}
	eatChar();//)

	next = depFirst[dep];
	depFirst[dep] = this;
	maxDep = max(maxDep, dep);
}

int64 codes[MAX_N];
int ans[MAX_N];
int nCodes;

int main() {
	scanf("%s", buf);
	at = 0;
	maxDep = 0;
	root = new Tree;
	nId = 0;
	for (int d = 0; d &lt;= maxDep; ++d) {
		nCodes = 0;
		for (Tree*t = depFirst[d]; t; t = t-&gt;next) {
			t-&gt;getCode();
			codes[nCodes++] = t-&gt;code;
		}
		sort(codes, codes + nCodes);
		nCodes = unique(codes, codes + nCodes) - codes;
		for (Tree*t = depFirst[d]; t; t = t-&gt;next) {
			int64 c = t-&gt;code;
			t-&gt;id = lower_bound(codes, codes + nCodes, c) - codes + nId;
		}
		nId += nCodes;
		ans[d] = nCodes;
	}

	for (int i = 0; i &lt;= maxDep; ++i) {
		printf("%d\n", ans[i]);
	}
}
</pre><pre></pre><h2>Problem1945</h2><pre>import java.util.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigInteger;

public class Main {
	public static void main(String[] args) {
		new Main().run();
	}

	BufferedReader reader;
	StringTokenizer tokenizer;
	PrintWriter writer;

	static class Answer {
		int nPairs;
		BigInteger ways;

		public Answer(int nPairs, BigInteger ways) {
			// TODO Auto-generated constructor stub
			this.nPairs = nPairs;
			this.ways = ways;
		}
	}

	static private Answer together(Answer a, Answer b) {
		return new Answer(a.nPairs + b.nPairs, a.ways.multiply(b.ways));
	}

	static private Answer choseOne(Answer a, Answer b) {
		if (a.nPairs &lt; b.nPairs) {
			Answer c = a;
			a = b;
			b = c;
		}
		if (a.nPairs &gt; b.nPairs)
			return a;
		return new Answer(a.nPairs, a.ways.add(b.ways));
	}

	static final Answer NONE = new Answer(0, BigInteger.ONE);
	static final Answer BAD = new Answer(-1, BigInteger.ZERO);

	static class Vertex {
		List&lt;Vertex&gt; chs = new ArrayList&lt;Vertex&gt;();

		Answer[] solve() {
			Answer[] am = new Answer[2];
			am[0] = NONE;
			am[1] = BAD;

			int nCh = chs.size();
			Answer[] first = new Answer[nCh + 1];
			Answer[] last = new Answer[nCh + 1];
			first[0] = NONE;
			Answer[][] chAm = new Answer[nCh][];
			Answer[] chBest = new Answer[nCh];
			for (int i = 0; i &lt; nCh; ++i) {
				chAm[i] = chs.get(i).solve();
				chBest[i] = choseOne(chAm[i][0], chAm[i][1]);
				am[0] = together(am[0], chBest[i]);
			}

			for (int i = 0; i &lt; nCh; ++i) {
				first[i + 1] = together(first[i], chBest[i]);
			}

			last[nCh] = NONE;
			for (int i = nCh - 1; i &gt;= 0; --i) {
				last[i] = together(last[i + 1], chBest[i]);
			}

			for (int i = 0; i &lt; nCh; ++i) {
				Answer tmp = together(first[i], last[i + 1]);
				tmp = together(tmp, chAm[i][0]);
				tmp.nPairs++;
				am[1] = choseOne(am[1], tmp);
			}

			return am;
		}
	}

	private void solve() throws IOException {
		int n = nextInt();
		Vertex[] vs = new Vertex[n + 1];
		for (int i = 1; i &lt;= n; ++i) {
			vs[i] = new Vertex();
		}
		for (int i = 0; i &lt; n; ++i) {
			int id = nextInt();
			Vertex me = vs[id];
			int cnt = nextInt();
			for (int j = 0; j &lt; cnt; ++j) {
				me.chs.add(vs[nextInt()]);
			}
		}

		Answer[] am = vs[1].solve();
		Answer ret = choseOne(am[0], am[1]);
		writer.println(ret.nPairs);
		writer.print(ret.ways);
	}

	public void run() {
		try {
			reader = new BufferedReader(new InputStreamReader(System.in));
			tokenizer = null;
			writer = new PrintWriter(System.out);
			solve();
			reader.close();
			writer.close();

		} catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	String nextToken() throws IOException {
		while (tokenizer == null || !tokenizer.hasMoreTokens())
			tokenizer = new StringTokenizer(reader.readLine());
		return tokenizer.nextToken();
	}
}
</pre><pre></pre><h2>Problem1947</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;map&gt;
#include &lt;vector&gt;

using namespace std;

map&lt;int,int&gt; map_next, map_prev;
multimap&lt;int,int&gt; L_queries, P_queries;
typedef multimap&lt;int,int&gt;::iterator mapiterator;

int next( int x ) {
   if( map_next.count( x ) ) return map_next[x];
   return x+1;
}
int prev( int x ) {
   if( map_prev.count( x ) ) return map_prev[x];
   return x-1;
}

int n, q;
const int inf = 2000000000;

void input_list() {
   scanf( "%d", &amp;n );
   for( int i = 0; i &lt; n; ++i ) {
      int a, b;
      scanf( "%d%d", &amp;a, &amp;b );
      map_next[prev(a)] = next(a);
      map_prev[next(a)] = prev(a);

      int c = prev(b);
      map_next[c] = a;
      map_prev[a] = c;
      map_next[a] = b;
      map_prev[b] = a;
   }
   map_next[inf] = inf+1;
}

void input_queries() {
   scanf( "%d", &amp;q );
   for( int i = 0; i &lt; q; ++i ) {
      char type;
      int x;
      scanf( " %c %d", &amp;type, &amp;x );
      if( type == 'L' ) L_queries.insert( pair&lt;int,int&gt;(x, i) );
      if( type == 'P' ) P_queries.insert( pair&lt;int,int&gt;(x, i) );
   }
   L_queries.insert( pair&lt;int,int&gt;(inf, q) );
   P_queries.insert( pair&lt;int,int&gt;(inf, q) );
}

int main( void ) {

   input_list();
   input_queries();

   vector&lt; int &gt; ret( q+1 );
   int label = 0, position = 0;

   while( label &lt; inf ) {
      int a = map_next.lower_bound( label )-&gt;first - label;
      int b = L_queries.lower_bound( position )-&gt;first - position;
      int c = P_queries.lower_bound( label )-&gt;first - label;

      int mini = a &lt;? b &lt;? c;

      label += mini;
      position += mini;

      if( mini == b ) {
         pair&lt;mapiterator,mapiterator&gt; eq = L_queries.equal_range( position );
         for( mapiterator it = eq.first; it != eq.second; ++it )
            ret[it-&gt;second] = label;
      }
      if( mini == c ) {
         pair&lt;mapiterator,mapiterator&gt; eq = P_queries.equal_range( label );
         for( mapiterator it = eq.first; it != eq.second; ++it )
            ret[it-&gt;second] = position;
      }

      label = next(label);
      ++position;
   }

   for( int i = 0; i &lt; q; ++i )
      printf( "%d\n", ret[i] );

   return 0;
}
</pre><pre></pre><h2>Problem1947</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define All(x) x.begin(),x.end()
const int inf=2e9,maxn=50000+10;
using namespace std;
map&lt;int,int&gt; Pre,Next;
int n,m,Ans[maxn];
int pre(int x){return Pre.count(x)?Pre[x]:x-1;}
int next(int x){return Next.count(x)?Next[x]:x+1;}
typedef pair&lt;int,int&gt; ii;
typedef vector&lt;ii&gt;::iterator it;
vector&lt;ii&gt; L,P;
void init()
{
    scanf("%d",&amp;n);int a,b;
    rep(i,n)
    {
        scanf("%d%d",&amp;a,&amp;b);
        Next[pre(a)]=next(a);
        Pre[next(a)]=pre(a);
        Next[pre(b)]=a;
        Pre[a]=pre(b);
        Next[a]=b;
        Pre[b]=a;
    }
    Next[inf]=inf+1;
    char c;scanf("%d",&amp;m);
    rep(i,m)
    {
        scanf(" %c %d",&amp;c,&amp;a);
        if(c=='P')P.pb(ii(a,i));
        else L.pb(ii(a,i));
    }
    L.pb(ii(inf,m));P.pb(ii(inf,m));
    sort(All(L));sort(All(P));
}
void Solve()
{
    int now=0,Min,pos=0;
    while(now&lt;inf)
    {
        int a=Next.lower_bound(now)-&gt;first-now;
        int b=lower_bound(All(L),ii(pos,0))-&gt;first-pos;
        int c=lower_bound(All(P),ii(now,0))-&gt;first-now;
        Min=a&lt;?b&lt;?c;
        now+=Min;pos+=Min;
        if(Min==b)
        {
            it l=lower_bound(All(L),ii(pos,0)),r=lower_bound(All(L),ii(pos+1,0));
            for(it i=l;i!=r;i++)
                Ans[i-&gt;second]=now;
        }
        if(Min==c)
        {
            it l=lower_bound(All(P),ii(now,0)),r=lower_bound(All(P),ii(now+1,0));
            for(it i=l;i!=r;i++)
                Ans[i-&gt;second]=pos;
        }
        now=next(now);
        ++pos;
    }
    rep(i,m)printf("%d\n",Ans[i]);
}
int main()
{
    init();Solve();
}


</pre><pre></pre><h2>Problem1947</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;cstdio&gt;
#include &lt;map&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
const int inf=2e9,maxn=50000+10;
using namespace std;
map&lt;int,int&gt; Pre,Next;
int n,m,Ans[maxn];
int pre(int x){return Pre.count(x)?Pre[x]:x-1;}
int next(int x){return Next.count(x)?Next[x]:x+1;}
typedef pair&lt;int,int&gt; ii;
typedef vector&lt;ii&gt;::iterator it;
vector&lt;ii&gt; L,P;
void init()
{
    scanf("%d",&amp;n);int a,b;
    rep(i,n)
    {
        scanf("%d%d",&amp;a,&amp;b);
        Next[pre(a)]=next(a);
        Pre[next(a)]=pre(a);
        Next[pre(b)]=a;
        Pre[a]=pre(b);
        Next[a]=b;
        Pre[b]=a;
    }
    Next[inf]=inf+1;
    char c;scanf("%d",&amp;m);
    rep(i,m)
    {
        scanf(" %c %d",&amp;c,&amp;a);
        if(c=='P')P.pb(ii(a,i));
        else L.pb(ii(a,i));
    }
    L.pb(ii(inf,m));P.pb(ii(inf,m));
    sort(All(L));sort(All(P));
}
void Solve()
{
    int now=0,Min,pos=0;
    while(now&lt;inf)
    {
        int a=Next.lower_bound(now)-&gt;first-now;
        int b=lower_bound(All(L),ii(pos,0))-&gt;first-pos;
        int c=lower_bound(All(P),ii(now,0))-&gt;first-now;
        Min=a&lt;?b&lt;?c;
        now+=Min;pos+=Min;
        if(Min==b)
        {
            it l=lower_bound(All(L),ii(pos,0)),r=lower_bound(All(L),ii(pos+1,0));
            for(it i=l;i!=r;i++)
                Ans[i-&gt;second]=now;
        }
        if(Min==c)
        {
            it l=lower_bound(All(P),ii(now,0)),r=lower_bound(All(P),ii(now+1,0));
            for(it i=l;i!=r;i++)
                Ans[i-&gt;second]=pos;
        }
        now=next(now);
        ++pos;
    }
    rep(i,m)printf("%d\n",Ans[i]);
}
int main()
{
    init();Solve();
}


</pre><pre></pre><h2>Problem1948</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;

using namespace std;

#define MAXN 12
#define MAXM 39

int n, m;
char a[2*MAXN+1][2*MAXM+2];
int how[MAXN][MAXM];
short memo[MAXN][MAXM][1&lt;&lt;MAXN][2];
const short inf = 10000;

char *b[3][11] = {
   { "# #", "# #", "#.#", "# #", "# #", "# #", "#.#", "#.#", "#.#", "# #", "# #" },
   { "   ", ".X ", " X ", " X.", " X ", "...", " . ", ".. ", " ..", " ..", ".. " },
   { "# #", "# #", "# #", "# #", "#.#", "# #", "#.#", "# #", "# #", "#.#", "#.#" },
};

short rec( int r, int c, int mask, int U ) {
   if( r == n ) return rec( 0, c+1, mask, 0);
   if( c == m ) return 0;

   short &amp;ret = memo[r][c][mask][U];
   if(ret &gt;= 0 ) return ret;

   ret = inf;

   int L = (mask&gt;&gt;r)&amp;1;
   int R = a[2*r+1][2*c+2] == ' ';
   int D = a[2*r+2][2*c+1] == ' ';
   int X = a[2*r+1][2*c+1] == 'X';

   int h0=0, h1=0, h2=0, h3=0;

   #define tst(t0,t1,t2,t3) { \
      int v = t1 + rec( r+1, c, t2, t3); \
      if( v &lt; ret ) { ret = v; h0=t0; h1=t1; h2=t2; h3=t3; } \
   }

   if( !X &amp;&amp; !L &amp;&amp; !U &amp;&amp; 1 &amp;&amp; 1 ) tst(  0, 0, mask &amp; ~(1&lt;&lt;r), 0 ); // empty

   if(  X &amp;&amp;  L &amp;&amp; !U &amp;&amp; 1 &amp;&amp; 1 ) tst(  1, 1, mask &amp; ~(1&lt;&lt;r), 0 ); // left
   if(  X &amp;&amp; !L &amp;&amp;  U &amp;&amp; 1 &amp;&amp; 1 ) tst(  2, 1, mask &amp; ~(1&lt;&lt;r), 0 ); // up
   if(  X &amp;&amp; !L &amp;&amp; !U &amp;&amp; R &amp;&amp; 1 ) tst(  3, 1, mask |  (1&lt;&lt;r), 0 ); // right
   if(  X &amp;&amp; !L &amp;&amp; !U &amp;&amp; 1 &amp;&amp; D ) tst(  4, 1, mask &amp; ~(1&lt;&lt;r), 1 ); // down

   if( !X &amp;&amp;  L &amp;&amp; !U &amp;&amp; R &amp;&amp; 1 ) tst(  5, 2, mask |  (1&lt;&lt;r), 0 ); // left-right
   if( !X &amp;&amp; !L &amp;&amp;  U &amp;&amp; 1 &amp;&amp; D ) tst(  6, 2, mask &amp; ~(1&lt;&lt;r), 1 ); // up-down

   if( !X &amp;&amp;  L &amp;&amp;  U &amp;&amp; 1 &amp;&amp; 1 ) tst(  7, 2, mask &amp; ~(1&lt;&lt;r), 0 ); // left-up
   if( !X &amp;&amp; !L &amp;&amp;  U &amp;&amp; R &amp;&amp; 1 ) tst(  8, 2, mask |  (1&lt;&lt;r), 0 ); // up-right
   if( !X &amp;&amp; !L &amp;&amp; !U &amp;&amp; R &amp;&amp; D ) tst(  9, 2, mask |  (1&lt;&lt;r), 1 ); // right-down
   if( !X &amp;&amp;  L &amp;&amp; !U &amp;&amp; 1 &amp;&amp; D ) tst( 10, 2, mask &amp; ~(1&lt;&lt;r), 1 ); // down-left
   return ret;
}

int main( void ) {
   scanf( "%d%d ", &amp;n, &amp;m );
   for( int r = 0; r &lt; n; ++r ) gets( a[r] );
   n /= 2; m /= 2;

   memset( memo, -1, sizeof memo );
   printf( "%d\n", rec( 0, 0, 0, 0) );
   return 0;
}
</pre><pre></pre><h2>Problem1948</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
#define MAXN 12
#define MAXM 39
int n, m;
char a[2*MAXN+1][2*MAXM+2];
int how[MAXN][MAXM];
short memo[MAXN][MAXM][1&lt;&lt;MAXN][2];
const short inf = 10000;
short rec( int r, int c, int mask, int U ) {
   if( r == n ) return rec( 0, c+1, mask, 0);
   if( c == m ) return 0;
   short &amp;ret = memo[r][c][mask][U];
   if(ret &gt;= 0 ) return ret;
   ret = inf;
   int L = (mask&gt;&gt;r)&amp;1;
   int R = a[2*r+1][2*c+2] == ' ';
   int D = a[2*r+2][2*c+1] == ' ';
   int X = a[2*r+1][2*c+1] == 'X';
   #define tst(t1,t2,t3) ret&lt;?=t1 + rec( r+1, c, t2, t3);
   if( !X &amp;&amp; !L &amp;&amp; !U &amp;&amp; 1 &amp;&amp; 1 ) tst(0, mask &amp; ~(1&lt;&lt;r), 0 );
   if(  X &amp;&amp;  L &amp;&amp; !U &amp;&amp; 1 &amp;&amp; 1 ) tst(1, mask &amp; ~(1&lt;&lt;r), 0 );
   if(  X &amp;&amp; !L &amp;&amp;  U &amp;&amp; 1 &amp;&amp; 1 ) tst(1, mask &amp; ~(1&lt;&lt;r), 0 );
   if(  X &amp;&amp; !L &amp;&amp; !U &amp;&amp; R &amp;&amp; 1 ) tst(1, mask |  (1&lt;&lt;r), 0 );
   if(  X &amp;&amp; !L &amp;&amp; !U &amp;&amp; 1 &amp;&amp; D ) tst(1, mask &amp; ~(1&lt;&lt;r), 1 );
   if( !X &amp;&amp;  L &amp;&amp; !U &amp;&amp; R &amp;&amp; 1 ) tst(2, mask |  (1&lt;&lt;r), 0 );
   if( !X &amp;&amp; !L &amp;&amp;  U &amp;&amp; 1 &amp;&amp; D ) tst(2, mask &amp; ~(1&lt;&lt;r), 1 );
   if( !X &amp;&amp;  L &amp;&amp;  U &amp;&amp; 1 &amp;&amp; 1 ) tst(2, mask &amp; ~(1&lt;&lt;r), 0 );
   if( !X &amp;&amp; !L &amp;&amp;  U &amp;&amp; R &amp;&amp; 1 ) tst(2, mask |  (1&lt;&lt;r), 0 );
   if( !X &amp;&amp; !L &amp;&amp; !U &amp;&amp; R &amp;&amp; D ) tst(2, mask |  (1&lt;&lt;r), 1 );
   if( !X &amp;&amp;  L &amp;&amp; !U &amp;&amp; 1 &amp;&amp; D ) tst(2, mask &amp; ~(1&lt;&lt;r), 1 );
   return ret;
}

int main( void ) {
   scanf( "%d%d ", &amp;n, &amp;m );
   for( int r = 0; r &lt; n; ++r ) gets( a[r] );
   n /= 2; m /= 2;
   memset( memo, -1, sizeof memo );
   printf( "%d\n", rec( 0, 0, 0, 0) );
   return 0;
}
</pre><pre></pre><h2>Problem1951</h2><pre>/*
 * [Sdoi2010]古代猪文.cpp
 *
 *  Created on: 2011-3-14
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MOD[] = { 2, 3, 4679, 35617 };
const int MAX_MOD = 36000;
const int BIG_MOD = 999911659; // it's a prime!!
int fact[4][MAX_MOD];
int rfact[4][MAX_MOD];
typedef long long int64;

int64 powMod(int64 x, int e, int mod) {
	assert(e &gt;= 0);
	if (!e)
		return 1;
	if (e &amp; 1)
		return powMod(x, e - 1, mod) * x % mod;
	return powMod(x * x % mod, e / 2, mod);
}

int64 invMod(int64 x, int mod) {
	return powMod(x, mod - 2, mod);
}

void prepare(int fact[], int rfact[], int mod) {
	fact[0] = 1;
	rfact[0] = 1;
	for (int i = 1; i &lt; mod; ++i) {
		fact[i] = fact[i - 1] * i % mod;
		rfact[i] = invMod(fact[i], mod);
	}
}

void prepare() {
	for (int which = 0; which &lt; 4; ++which) {
		prepare(fact[which], rfact[which], MOD[which]);
	}
}

int lucasCalc(int n, int m, int whichMod) {
	int mod = MOD[whichMod];
	if (n &lt; mod &amp;&amp; m &lt; mod) {
		if (m &gt; n)
			return 0;
		return fact[whichMod][n] * rfact[whichMod][m] % mod * rfact[whichMod][n
				- m] % mod;
	}
	return lucasCalc(n / mod, m / mod, whichMod) * lucasCalc(n % mod, m % mod,
			whichMod) % mod;
}

int64 extGcd(int64 a, int64 b, int64&amp;x, int64&amp;y) {
	if (!b) {
		x = 1;
		y = 0;
		return a;
	} else {
		int d = extGcd(b, a % b, y, x);
		y -= x * (a / b);
		return d;
	}
}

int calc(int n, int m) {
	//calc C(n,m) % BIG_MOD-1
	int remain[4];
	for (int which = 0; which &lt; 4; ++which) {
		remain[which] = lucasCalc(n, m, which);
	}

	int M = BIG_MOD - 1;
	int64 ans = 0;
	for (int i = 0; i &lt; 4; ++i) {
		int64 mi = MOD[i], wi = M / mi;
		int64 x, y;
		extGcd(wi, mi, x, y);
		int64 ei = (wi * x) % M;
		if (ei &lt; 0)
			ei += M;
		(ans += ei * remain[i]) %= M;
		if (ans &lt; 0)
			ans += M;
	}

	return ans;
}

int N, G;
int main() {
	prepare();
	cin &gt;&gt; N &gt;&gt; G;
	if(G == BIG_MOD){
        puts("0");
        return 0;
    }
	G %= BIG_MOD;

	int64 pow = 0;
	for (int i = 1; i * i &lt;= N; i++) {
		if (N % i == 0) {
			(pow += calc(N, i)) %= BIG_MOD - 1;
			if (i * i &lt; N)
				(pow += calc(N, N / i)) %= BIG_MOD - 1;
		}
	}

	int ans = powMod(G, pow, BIG_MOD);
	cout &lt;&lt; ans &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem1954</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1,maxn=100000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
struct Edge
{
    int t,c;
    Edge(int _t,int _c):t(_t),c(_c){}
};
vector&lt;Edge&gt; E[maxn];
typedef vector&lt;Edge&gt;::iterator it;
void AddEdge(int s,int t,int c)
{
    E[s].pb(Edge(t,c));
    E[t].pb(Edge(s,c));
}
int P[maxn],Q[maxn],n,ans=0;
bool V[maxn]={};
void BFS(int vs)
{
    int h=0,t=0;
    for(Q[t++]=vs,V[vs]=true,P[vs]=0;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,E[x])if(!V[e-&gt;t])
        {
            V[e-&gt;t]=true;
            Q[t++]=e-&gt;t;
            P[e-&gt;t]=P[x]^e-&gt;c;
        }
    }
}
struct Trie
{
    Trie*ch[2];
    Trie(){memset(ch,0,sizeof ch);}
}*root,Mem[maxn*33],*Now;
Trie* New_Trie()
{
    memset(Now-&gt;ch,0,sizeof Now-&gt;ch);
    return Now++;
}
void Init()
{
    if(scanf("%d",&amp;n)!=1)exit(1);
    int s,t,c;
    Now=Mem;root=New_Trie();
    rep(i,n)E[i].clear();
    rep(i,n-1)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);
        --s;--t;
        AddEdge(s,t,c);AddEdge(t,s,c);
    }
}
#define get(x,i) (x&gt;&gt;i&amp;1)
void Insert(int x)
{
    Trie*p=root;
    for(int i=31;i&gt;=0;i--)
    {
        int t=get(x,i);
        if(!p-&gt;ch[t])
            p-&gt;ch[t]=New_Trie();
        p=p-&gt;ch[t];
    }
}
int Find(int x)
{
    Trie*p=root;
    int ret=0;
    for(int i=31;i&gt;=0;i--)
    {
        int t=get(x,i);
        if(p-&gt;ch[!t])
            ret+=1&lt;&lt;i,p=p-&gt;ch[!t];
        else
            p=p-&gt;ch[t];
    }
    return ret;
}
void Solve()
{
    Init();
    BFS(0);
    rep(i,n)Insert(P[i]);
    rep(i,n)ans=max(ans,Find(P[i]));
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    for(;;)Solve();
}


</pre><pre></pre><h2>Problem1957</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=500;
using namespace std;
struct Point
{
    int x,y;
}Bear;
struct Interval
{
    int x[2];
    int operator[](int v)const{return x[v];}
    int&amp;operator[](int v) {return x[v];}
    void normalize()
    {
        if(x[0]&gt;x[1])swap(x[0],x[1]);
    }
    bool Contain(int a)const
    {
        return x[0]&lt;=a&amp;&amp;a&lt;=x[1];
    }
};
inline bool Intersect(const Interval&amp;a,const Interval&amp;b)
{
    return !(a[1]&lt;b[0]||b[1]&lt;a[0]);
}
struct Rect
{
    Interval x,y;
    void normalize()
    {
        x.normalize();
        y.normalize();
    }
    bool Contain(const Point&amp;p)const
    {
        return x.Contain(p.x)&amp;&amp;y.Contain(p.y);
    }
};
inline bool Intersect(const Rect&amp;a,const Rect&amp;b)
{
    return Intersect(a.x,b.x)&amp;&amp;Intersect(a.y,b.y);
}
istream&amp; operator&gt;&gt;(istream&amp;in,Rect&amp;me)
{
    rep(i,2)in&gt;&gt;me.x[i]&gt;&gt;me.y[i];
    me.normalize();
    return in;
}
inline void checkmin(int&amp;x,int c){if(x&gt;c)x=c;}
inline void checkmax(int&amp;x,int c){if(x&lt;c)x=c;}
void Merge(Rect&amp;Now,const Rect&amp;Add)
{
    if(Intersect(Now,Add))
    {
        checkmin(Now.x[0],Add.x[0]);
        checkmax(Now.x[1],Add.x[1]);
        checkmin(Now.y[0],Add.y[0]);
        checkmax(Now.y[1],Add.y[1]);
    }
}
Rect MainStreet[maxn];
int N;
bool Check(int Size)
{
    Rect Now;Now.x[0]=Now.y[0]=-Size+1;
    Now.x[1]=Now.y[1]=Size-1;
    rep(time,N)
        rep(i,N)
            Merge(Now,MainStreet[i]);
    //Debug(Size);
    //cout&lt;&lt;Now.x[0]&lt;&lt;" "&lt;&lt;Now.x[1]&lt;&lt;endl;
    //cout&lt;&lt;Now.y[0]&lt;&lt;" "&lt;&lt;Now.y[1]&lt;&lt;endl;
    return Now.Contain(Bear);
}
void Init()
{
    cin&gt;&gt;Bear.x&gt;&gt;Bear.y;
    cin&gt;&gt;N;
    rep(i,N)cin&gt;&gt;MainStreet[i];
}
void Solve()
{
    int l=0,r=max(abs(Bear.x),abs(Bear.y))+1;
    while(l+1&lt;r)
    {
        int m=l+r&gt;&gt;1;
        if(Check(m))r=m;else l=m;
    }
    cout&lt;&lt;l&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


</pre><pre></pre><h2>Problem1958</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
const int inf=~0U&gt;&gt;1,maxh=6;
using namespace std;
const int maxs=10000;
typedef long long ll;
int h;
char F[maxh][7],R[maxh][7];
struct State
{
    int M[6][6],num;
    int L[9][2];
    State()
    {
        memset(M,-1,sizeof M);
        num=0;
    }
    void operator=(const State&amp;s)
    {
        memcpy(M,s.M,sizeof M);
        num=s.num;
    }
    void doit()
    {
        int c=0;
        rep(i,5)rep(j,5)
            if(M[i][j]&amp;&amp;M[i+1][j]==M[i][j]&amp;&amp;M[i][j+1]==M[i][j])
            {
                L[c][0]=i;L[c][1]=j;
                c++;
            }
    }
    void Show()const
    {
        rep(i,6)
        {
            rep(j,6)cout&lt;&lt;M[i][j]&lt;&lt;" ";
            cout&lt;&lt;endl;
        }
    }
};
State S[maxs];
int s=0;
State now;
void Dfs()
{
    int x=-1,y=-1;
    rep(i,6)
        rep(j,6)
            if(now.M[i][j]==-1)
            {
                x=i;y=j;
                goto next;
            }
    next:
    //We Pain it All
    if(x==-1&amp;&amp;y==-1)
    {
        S[s]=now;S[s].doit();s++;
        return;
    }
    //Put Nothing
    now.M[x][y]=0;
    Dfs();
    now.M[x][y]=-1;
    //Put Something
    int s=0;
    if(x&lt;5&amp;&amp;y&lt;5)
        rep(i,2)rep(j,2)s+=now.M[x+i][y+j];
    if(s==-4)
    {
        now.num++;
        rep(i,2)rep(j,2)
            now.M[x+i][y+j]=now.num;
        Dfs();
        now.num--;
        rep(i,2)rep(j,2)
            now.M[x+i][y+j]=-1;
    }
}
const int maxt=3000;
int ids[maxh][maxt],owns[maxh][maxt],nums[maxh]={};
void Doit(int h,char*F,char*R,int id)
{
    static char MustBe[10];
    int&amp;now=nums[h];
    int ret=1;
    State&amp;st=S[id];
    memset(MustBe,0,sizeof MustBe);
    rep(j,6)
    {
        int x=0;
        for(int i=5;i&gt;=0;i--)
            if(x=st.M[i][j])
            {
                if(F[j]=='.')goto end;
                if(MustBe[x]&amp;&amp;MustBe[x]!=F[j])
                    goto end;
                MustBe[x]=F[j];
                break;
            }
        if(x==0&amp;&amp;F[j]!='.')goto end;
    }
    rep(i,6)
    {
        int x=0;
        for(int j=5;j&gt;=0;j--)
            if(x=st.M[i][j])
            {
                if(R[5-i]=='.')goto end;
                if(MustBe[x]&amp;&amp;MustBe[x]!=R[5-i])
                    goto end;
                MustBe[x]=R[5-i];
                break;
            }
        if(x==0&amp;&amp;R[5-i]!='.')goto end;
    }
    ids[h][now]=id;
    for(int i=1;i&lt;=st.num;i++)
        if(!MustBe[i])ret*=3;
    owns[h][now]=ret;
    now++;
    end:;
}
void PreCondition()
{
    rep(i,h)
        rep(j,s)
            Doit(i,F[i],R[i],j);
}
void Init()
{
    cin&gt;&gt;h;
    for(int i=h-1;i&gt;=0;i--)
    {
        scanf(" ");
        gets(F[i]);
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        scanf(" ");
        gets(R[i]);
    }
}
ll way[maxh][maxt]={};
inline bool Check(const State&amp;a,const State&amp;b)// Can a be put on top of b?
{
    rep(o,a.num)
    {
        int i=a.L[o][0],j=a.L[o][1];
        int s=b.M[i][j]+b.M[i+1][j]+b.M[i][j+1]+b.M[i+1][j+1];
        if(s==0)return false;
    }
    return true;
}
void Solve()
{
    //Set 0
    rep(i,nums[0])
        way[0][i]=owns[0][i];
    for(int i=0;i&lt;h-1;i++)
    {
        int cur,next;
        rep(curI,nums[i])
            rep(nextI,nums[i+1])
            {
                cur=ids[i][curI];
                next=ids[i+1][nextI];
                if(Check(S[next],S[cur]))
                    way[i+1][nextI]+=ll(owns[i+1][nextI])*way[i][curI];
            }
    }
    ll ans=0;
    rep(i,nums[h-1])ans+=way[h-1][i];
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    Init();
    Dfs();
    PreCondition();
    Solve();
}


</pre><pre></pre><h2>Problem1958</h2><pre>#include &lt;stdio.h&gt;
#define MAXL 6
#define MAXH 6
#define MAXN (MAXL/2)*(MAXL/2)

char view[MAXH][2][MAXL+1];
int supp[MAXH+1][10000],nb[MAXH+1];
long long cnt, np[MAXH+1][10000];
int H, pos[MAXN];
int map[MAXL][MAXL];

void MLX(int h, int nr, int lastx, int lasty) {
  int x, y, i,j,k,q,deg;
  char c[MAXN];
  for(x=lastx;x&lt;MAXL-1;x++) {
      for(y=(x==lastx)?lasty+1:0;y&lt;MAXL-1;y++) {
          if(map[x][y]==-1 &amp;&amp; map[x][y+1]==-1) {
            pos[nr]=x*(MAXL-1)+y;
            map[x][y]=map[x+1][y]=map[x][y+1]=map[x+1][y+1]=nr;
            MLX(h,nr+1,x,y);
            map[x][y]=map[x+1][y]=map[x][y+1]=map[x+1][y+1]=-1;
          }
        }
  }
  //Is this configuration consistent with indata?
  for(i=0;i&lt;nr;i++) c[i]='-';
  for(i=0;i&lt;2;i++) {
    for(j=0;j&lt;MAXL;j++) {
      q=-1;
      for(k=0;k&lt;MAXL;k++) {
        if(i==0) { x=j; y=k;}
        if(i==1) { y=j; x=MAXL-1-k;}
        if(i==2) { x=MAXL-1-j; y=MAXL-1-k;}
        if(i==3) { y=MAXL-1-j; x=k;}
        if(map[x][y]!=-1) {
          q=map[x][y];
          break;
        }
      }
      if(q==-1 &amp;&amp; view[h][i][j]!='.') return;
      if(q!=-1) {
        if(view[h][i][j]=='.') return;
        if(c[q]=='-') c[q]=view[h][i][j];
        if(c[q]!=view[h][i][j]) return;
      }
    }
  }
  //Is there any hidden pieces that can have any color?
  deg=1;
  for(i=0;i&lt;nr;i++) if(c[i]=='-') deg*=3;

  //print();
  //Sum over possibilities
  np[h+1][nb[h+1]]=0;
  for(i=0;i&lt;nb[h];i++) {
    for(j=0;j&lt;nr;j++) if(((supp[h][i] &gt;&gt; pos[j]) &amp; 1) == 0) break;
    if(j==nr) {
      np[h+1][nb[h+1]]+=np[h][i]*deg;
      cnt+=np[h][i]*deg;
    }
  }
  //Calculate its support for next layer
  if(np[h+1][nb[h+1]]&gt;0) {
    supp[h+1][nb[h+1]]=0;
    for(x=0;x&lt;MAXL-1;x++) for(y=0;y&lt;MAXL-1;y++) {
        q=x*(MAXL-1)+y;
        if(map[x][y]!=-1 || map[x][y+1]!=-1 || map[x+1][y]!=-1 || map[x+1][y+1]!=-1) {
          supp[h+1][nb[h+1]]|=(1&lt;&lt;q);
        }
      }
    nb[h+1]++;
  }
}


int main() {
  int i,j,h;
  scanf("%d",&amp;H);
  for(i=0;i&lt;2;i++) for(h=H-1;h&gt;=0;h--) {
      scanf("%s", view[h][i]);
    }
  nb[0]=1;
  np[0][0]=1;
  supp[0][0]=~0; //Full support
  for(h=0;h&lt;H;h++) {
    cnt=0;
    for(i=0;i&lt;MAXL;i++) for(j=0;j&lt;MAXL;j++) map[i][j]=-1;
    MLX(h,0,-1,-1);
  }
  printf("%I64d\n", cnt);
  return 0;
}
</pre><pre></pre><h2>Problem1959</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=100000+10;
using namespace std;
typedef pair&lt;int,int&gt; pi;
pi P[maxn];
int N,A[maxn],F[maxn];
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;N);rep(i,N)scanf("%d%d",&amp;P[i].first,&amp;P[i].second);
    sort(P,P+N);
    rep(i,N)A[i]=P[i].second;
    reverse(A,A+N);fill(F,F+N,inf);
    int ans=0;
    rep(i,N)
    {
        int tmp=lower_bound(F,F+N,A[i])-F;
        ans=max(ans,tmp+1);
        F[tmp]=A[i];
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1960</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=20000,maxm=1000+10;
using namespace std;
int Sum[1&lt;&lt;11]={},Rmax[1&lt;&lt;11]={},off=1&lt;&lt;10,N,M;
int A[maxn];
void Update(int x)
{
    Sum[x]=Sum[x*2]+Sum[x*2+1];
    Rmax[x]=max(Rmax[x*2+1],Sum[x*2+1]+Rmax[x*2]);
}
void Change(int x,int add)
{
    Rmax[x+=off]=Sum[x]+=add;
    for(x&gt;&gt;=1;x;x&gt;&gt;=1)
        Update(x);
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d",&amp;M,&amp;N);
    rep(i,N)scanf("%d",A+i);
    int ans=0;
    #define AddL(x) Change(x,1)
    #define AddR(x) Change(x-1,-1)
    #define DelR(x) Change(x-1,1)
    #define OK (Rmax[1]&lt;=0)
    rep(s,N/2)
    {
        AddL(A[s]);DelR(A[s]);
        AddR(A[s*2]);AddR(A[s*2+1]);
        if(OK)ans=s+1;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem1960</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=20000,maxm=1000+10;
using namespace std;
int Sum[1&lt;&lt;11]={},Rmax[1&lt;&lt;11]={},off=1&lt;&lt;10,N,M;
int A[maxn];
void Update(int x)
{
    Sum[x]=Sum[x*2]+Sum[x*2+1];
    Rmax[x]=max(Rmax[x*2+1],Sum[x*2+1]+Rmax[x*2]);
}
void Change(int x,int add)
{
    Rmax[x+=off]=Sum[x]+=add;
    for(x&gt;&gt;=1;x;x&gt;&gt;=1)
        Update(x);
}
int nextInt()
{
    char c;int ret;
    while(c=getchar(),c&lt;'0'||c&gt;'9');
    ret=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')ret=ret*10+c-'0';
    return ret;
}
int main()
{
    scanf("%d%d",&amp;M,&amp;N);
    rep(i,N)A[i]=nextInt();
    int ans=0;
    #define AddL(x) Change(x,1)
    #define AddR(x) Change(x-1,-1)
    #define DelR(x) Change(x-1,1)
    #define OK (Rmax[1]&lt;=0)
    rep(s,N/2)
    {
        AddL(A[s]);DelR(A[s]);
        AddR(A[s*2]);AddR(A[s*2+1]);
        if(OK)ans=s+1;
    }
    printf("%d\n",ans);
}
</pre><pre></pre><h2>Problem1960</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=20000,maxm=1000+10;
using namespace std;
int S[1&lt;&lt;11]={},R[1&lt;&lt;11]={},o=1&lt;&lt;10,N,M;
int A[maxn];
void U(int x)
{
    S[x]=S[x*2]+S[x*2+1];
    R[x]=max(R[x*2+1],S[x*2+1]+R[x*2]);
}
void C(int x,int a)
{
    R[x+=o]=S[x]+=a;
    for(x&gt;&gt;=1;x;x&gt;&gt;=1)U(x);
}
int main()
{
    scanf("%d%d",&amp;M,&amp;N);
    rep(i,N)scanf("%d",A+i);
    int ans=0;
    rep(s,N/2)
    {
        C(A[s],1);C(A[s]-1,1);
        C(A[s*2]-1,-1);C(A[s*2+1]-1,-1);
        if(R[1]&lt;=0)ans=s+1;
    }
    printf("%d\n",ans);
}
</pre><pre></pre><h2>Problem1960</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
int S[1&lt;&lt;11]={},R[1&lt;&lt;11]={},o=1&lt;&lt;10,N,M,ans=0;
int A[20000];
void U(int x){S[x]=S[x*2]+S[x*2+1];R[x]=max(R[x*2+1],S[x*2+1]+R[x*2]);}
void C(int x,int a){R[x+=o]=S[x]+=a;for(x&gt;&gt;=1;x;x&gt;&gt;=1)U(x);}
int main()
{
    scanf("%d%d",&amp;M,&amp;N);
    rep(i,N)scanf("%d",A+i);
    rep(s,N/2){C(A[s],1);C(A[s]-1,1);C(A[s*2]-1,-1);C(A[s*2+1]-1,-1);if(R[1]&lt;=0)ans=s+1;}
    printf("%d\n",ans);
}
</pre><pre></pre><h2>Problem1961</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1;
using namespace std;
const int maxn=100,maxb=7000,maxs=maxn*maxb+10;
const int mod=1000000007;
int n,A[maxn];
int Dp[maxs]={},Tmp[maxs];
int BestP,Best;
#define Add(x,c) {x+=c;if(x&gt;=mod)x-=mod;}
#define Minus(x,c) {x-=c;if(x&lt;0)x+=mod;}
int Count(int*A,int SIZE)
{
    int ans=0;
    rep(i,SIZE+1)ans+=A[i]!=0;
    return ans;
}
void Init()
{
    cin&gt;&gt;n;
    rep(i,n)cin&gt;&gt;A[i];
    sort(A,A+n);
}
void doDp()
{
    int SIZE=maxb*n;
    Dp[0]=1;
    rep(cur,n)
        for(int i=SIZE;i&gt;=A[cur];i--)
            Add(Dp[i],Dp[i-A[cur]]);
    Best=BestP=-1;
    rep(cur,n)
    {
        rep(i,SIZE+1)Tmp[i]=Dp[i];
        for(int i=A[cur];i&lt;=SIZE;i++)
            Minus(Tmp[i],Tmp[i-A[cur]]);
        int tmp=Count(Tmp,SIZE);
        if(tmp&gt;Best)
        {
            Best=tmp;
            BestP=cur;
        }
    }
}
bool Can[maxs*2]={};
int GetMinQ()
{
    int SIZE=maxb*n;
    int off=SIZE+3;
    Can[0+off]=true;
    rep(cur,n)
    {
        for(int i=SIZE;i&gt;=-SIZE+A[cur];i--)
            Can[i+off]|=Can[i-A[cur]+off];
        for(int i=-SIZE;i&lt;=SIZE-A[cur];i++)
            Can[i+off]|=Can[i+A[cur]+off];
    }
    rep(i,SIZE+1)if(!Can[i+off])return i;
    return -1;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    doDp();
    cout&lt;&lt;A[BestP];
    swap(A[BestP],A[n-1]);n--;
    cout&lt;&lt;" "&lt;&lt;GetMinQ()&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1961</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1;
using namespace std;
const int maxn=100,maxb=7000,maxs=maxn*maxb+10;
const int mod=1000000007;
int n,A[maxn];
int Dp[maxs]={},Tmp[maxs];
int BestP,Best;
#define Add(x,c) {x+=c;if(x&gt;=mod)x-=mod;}
#define Minus(x,c) {x-=c;if(x&lt;0)x+=mod;}
int Count(int*A,int SIZE)
{
    int ans=0;
    rep(i,SIZE+1)ans+=A[i]!=0;
    return ans;
}
void Init()
{
    cin&gt;&gt;n;
    rep(i,n)cin&gt;&gt;A[i];
    sort(A,A+n);
}
void doDp()
{
    int SIZE=maxb*n;
    Dp[0]=1;
    rep(cur,n)
        for(int i=SIZE;i&gt;=A[cur];i--)
            Add(Dp[i],Dp[i-A[cur]]);
    Best=BestP=-1;
    rep(cur,n)
    {
        rep(i,SIZE+1)Tmp[i]=Dp[i];
        for(int i=A[cur];i&lt;=SIZE;i++)
            Minus(Tmp[i],Tmp[i-A[cur]]);
        int tmp=Count(Tmp,SIZE);
        if(tmp&gt;Best)
        {
            Best=tmp;
            BestP=cur;
        }
    }
}
bool Can[maxs*2]={};
int GetMinQ()
{
    int SIZE=maxb*n;
    int off=SIZE+3;
    Can[0+off]=true;
    rep(cur,n)
    {
        bool*a,*b;a=Can+SIZE+off;b=a-A[cur];
        for(int i=SIZE;i&gt;=-SIZE+A[cur];i--)
            *a|=*b,a--,b--;
        a=Can-SIZE+off;b=a+A[cur];
        for(int i=-SIZE;i&lt;=SIZE-A[cur];i++)
            *a|=*b,a++,b++;
    }
    rep(i,SIZE+1)if(!Can[i+off])return i;
    return -1;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    doDp();
    cout&lt;&lt;A[BestP];
    swap(A[BestP],A[n-1]);n--;
    cout&lt;&lt;" "&lt;&lt;GetMinQ()&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1962</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;2,maxs=2000+1,maxk=100+1;
using namespace std;
int dp[maxs][maxk]={},n,k;
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;k;
    for(int i=2;;i++)
    {
        for(int j=1;j&lt;=k;j++)
        {
            if(j&gt;=2)dp[i][j]&gt;?=dp[i-2][j-2]+dp[i-1][j];
            dp[i][j]&gt;?=dp[i-2][j]+dp[i-1][j-1];
            dp[i][j]++;
        }
        if(dp[i][k]&gt;=n){cout&lt;&lt;i&lt;&lt;endl;return 0;}
    }
}


</pre><pre></pre><h2>Problem1962</h2><pre>#include &lt;iostream&gt;
const int maxs=200+1,maxk=100+1;
using namespace std;
int dp[maxs][maxk]={},n,k;
int main()
{
    cin&gt;&gt;n&gt;&gt;k;
    for(int i=2;;i++)
    {
        for(int j=1;j&lt;=k;j++)
        {
            if(j&gt;=2)dp[i][j]&gt;?=dp[i-2][j-2]+dp[i-1][j];
            dp[i][j]&gt;?=dp[i-2][j]+dp[i-1][j-1];
            dp[i][j]++;
        }
        if(dp[i][k]&gt;=n){cout&lt;&lt;i&lt;&lt;endl;return 0;}
    }
}


</pre><pre></pre><h2>Problem1963</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int C,N,xzero,xprod,xadd,xmod,yzero,yprod,yadd,ymod;
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;C&gt;&gt;N&gt;&gt;xzero&gt;&gt;xprod&gt;&gt;xadd&gt;&gt;xmod&gt;&gt;yzero&gt;&gt;yprod&gt;&gt;yadd&gt;&gt;ymod;
    vector &lt;long long&gt; x (N); vector &lt;long long&gt; y (N);
    x[0] = xzero; y[0] = yzero;
    for (int i = 1; i &lt; N; i++)
    {
        x[i] = ((x[i-1]*xprod)+xadd)%xmod;
        y[i] = ((y[i-1]*yprod)+yadd)%ymod;
    }
    long long cost[16][16];
    for (int i = 0; i &lt; C; i++)
         for (int j = 0; j &lt; C; j++)
         {
            int cnt = 0; vector &lt;int&gt; diff;
            for (int k = 0; k &lt; N; k++)
            if (x[k]%(2*C) == 2*i) { diff.push_back(x[k]-y[k]+j-i); cnt++; }
                else if (x[k]%(2*C) == 2*j+1) { diff.push_back(y[k]-x[k]+j-i-C+1); cnt++; }
            if (!cnt) { cost[i][j]=0; continue; }
            sort(diff.begin(), diff.end());
                long long value = (diff[(cnt/2)])%C; if (value &lt; 0) value += C;
                long long correction = (value-diff[(cnt/2)]);
                long long sum1 = 0LL, sum2 = 0LL;
                for (int k = 0; k &lt; cnt; k++) { diff[k] += correction; sum1 += abs(diff[k]); }
                for (int k = 0; k &lt; cnt; k++) { diff[k] -= C; sum2 += abs(diff[k]); }
                cost[i][j] = min(sum1, sum2);
            }
        long long DP[(1&lt;&lt;16)];
        for (int i = 0; i &lt; (1&lt;&lt;C); i++) DP[i] = 1000000000000000000LL;
        DP[0] = 0LL;
        for (int i = 1; i &lt; (1&lt;&lt;C); i++)
        {
            int cnt = 0;
            for (int j = 0; j &lt; C; j++) if (i&amp;(1&lt;&lt;j)) cnt++;
            // Take minimum over all possible edges for vertex 2(cnt-1)
            for (int j = 0; j &lt; C; j++) if (i&amp;(1&lt;&lt;j))
         DP[i] = min(DP[i], DP[i-(1&lt;&lt;j)] + cost[cnt-1][j]);
        }
        cout&lt;&lt;DP[(1&lt;&lt;C)-1]&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1965</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long ll;
ll N,M,L;
ll pow_mod(ll x,ll e,ll mod)
{
    if(e==0)return 1;
    ll tmp=pow_mod(x,e/2,mod);
    tmp=tmp*tmp%mod;
    if(e%2)tmp=tmp*x%mod;
    return tmp;
}
ll ext_gcd(ll a,ll b,ll&amp;x,ll&amp;y)
{
    if(!b){x=1;y=0;return a;}
    ll tmp=ext_gcd(b,a%b,y,x);
    y-=(a/b)*x;
    return tmp;
}
ll Solve(ll A,ll B,ll C)//Solve that A*x==B(mod C)..
{
    ll x,y;
    ext_gcd(A,C,x,y);
    x%=C;if(x&lt;0)x+=C;
    x*=B;x%=C;
    return x;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;N&gt;&gt;M&gt;&gt;L;
    cout&lt;&lt;Solve(pow_mod(2,M,N+1),L,N+1)&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1966</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;" ";
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxn=1000+1,maxm=500+1;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
char A[maxn],B[maxm];
bool f[maxn][maxm]={};
int main()
{
    //freopen("in","r",stdin);
    int q,n,m,ans=0;
    scanf("%s",A);n=strlen(A);
    scanf("%d",&amp;q);
    rep(cur,q)
    {
        scanf("%s",B);m=strlen(B);
        f[0][0]=true;
        if(A[0]=='*')f[1][0]=true;
        else f[1][0]=false;
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=m;j++)
            {
                if(A[i-1]=='*')
                    f[i][j]=f[i][j-1]|f[i-1][j]|f[i-1][j-1];
                else if(A[i-1]=='?')
                    f[i][j]=f[i-1][j-1];
                else f[i][j]=(A[i-1]==B[j-1])&amp;&amp;f[i-1][j-1];
            }
        ans+=!f[n][m];
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1968</h2><pre>#include &lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=1000000+1000;
using namespace std;
typedef long long ll;
int A[maxn];
int main()
{
    //freopen("in","r",stdin);
    int n;cin&gt;&gt;n;
    rep(i,maxn)A[i]=inf;A[1]=1;
    for(int now=2;now&lt;=n;)
    {
        for(int x=now;x&lt;=n;x+=now)A[x]&lt;?=now;
        now++;while(A[now]!=inf)now++;
    }
    ll ret=1;
    for(int i=2;i&lt;=n;i++)
    {
        int t=0,x=i;while(x%A[i]==0)x/=A[i],t++;
        A[i]=A[x]*(t+1);
        ret+=A[i];
    }
    cout&lt;&lt;ret&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1968</h2><pre>#include &lt;iostream&gt;
using namespace std;
int main()
{
    int n;cin&gt;&gt;n;long long ret=0;
    for(int i=1;i&lt;=n;i++)
        ret+=n/i;
    cout&lt;&lt;ret&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1968</h2><pre>#include &lt;iostream&gt;
using namespace std;
int main()
{
    int n,a=0;cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
        a+=n/i;
    cout&lt;&lt;a&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1968</h2><pre>n,a=0,i;main(){scanf("%d",&amp;n);for(i=1;i&lt;=n;i++)a+=n/i;printf("%d",a);}
</pre><pre></pre><h2>Problem1968</h2><pre>n,a,i;main(){scanf("%d",&amp;n);while(++i&lt;=n)a+=n/i;printf("%d",a);}
</pre><pre></pre><h2>Problem1969</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1,maxn=30000+10,maxm=100000+10,maxq=40000+10,Log=16;
using namespace std;
int n,m;
struct TA
{
    int A[maxn],n;
    void Set(int _n)
    {
        n=_n;rep(i,n)A[i]=0;
    }
    void Add(int l,int d)
    {
        for(l++;l&lt;=n;l+=l&amp;-l)
            A[l-1]+=d;
    }
    void Add(int l,int r,int d)
    {
        Add(l,d);Add(r+1,-d);
    }
    int Sum(int l)
    {
        int ret=0;
        for(l++;l;l-=l&amp;-l)
            ret+=A[l-1];
        return ret;
    }
}T;
struct Edge
{
    int s,t;
    Edge(){}
    Edge(int _s,int _t):
        s(_s),t(_t){}
    void Normalize()
    {
        if(s&gt;t)swap(s,t);
    }
    bool operator&lt;(const Edge&amp;e)const
    {
        if(s!=e.s)return s&lt;e.s;
        return t&lt;e.t;
    }
    int other(int v)
    {
        return v==s?t:s;
    }
}Es[maxm];
template&lt;class K,class T&gt;
struct StaticMap
{
    typedef pair&lt;K,T&gt; Data;
    vector&lt;Data&gt; A;
    void set(const K&amp;key,const T&amp;data)
    {
        A.pb(Data(key,data));
    }
    void doit()
    {
        sort(All(A));
    }
    T operator[](const K&amp;key)const
    {
        return lower_bound(All(A),Data(key,T()))-&gt;second;
    }
};
StaticMap&lt;Edge,int&gt; Map;
struct Graph
{
    vector&lt;int&gt; E[maxn];
    void AddEdge(int id)
    {
        Edge&amp;e=Es[id];
        E[e.s].pb(id);E[e.t].pb(id);
    }
}G;
bool Destroyed[maxm]={};
void Init()
{
    scanf("%d%d",&amp;n,&amp;m);int s,t;
    rep(i,m)
    {
        scanf("%d%d",&amp;s,&amp;t);--s;--t;
        Edge e(s,t);e.Normalize();
        Es[i]=e;
        Map.set(e,i);
        G.AddEdge(i);
    }
    Map.doit();
}
struct Query
{
    int type,u,v;
    Query(){}
    Query(int _type,int _u,int _v):
        type(_type),u(_u),v(_v){}
}Qs[maxq];
int q;
void ReadQuerys()
{
    int t,u,v;
    for(q=0;;q++)
    {
        scanf("%d%d%d",&amp;t,&amp;u,&amp;v);
        u--;v--;
        if(t==-1)break;
        Qs[q]=Query(t,u,v);
        Edge e(u,v);e.Normalize();
        if(t==0)Destroyed[Map[e]]=true;
    }
}
bool Vis[maxn]={};
int L[maxn],R[maxn],D[maxn],F[maxn],now=0;
int Link[maxn][Log];
void Dfs(int x,int f,int d)
{
    L[x]=now++;F[x]=f;D[x]=d;
    Link[x][0]=f;
    rep(i,Log)
    {
        int tmp=Link[x][i];
        if(tmp==-1)break;
        Link[x][i+1]=Link[tmp][i];
    }
    Vis[x]=true;
    tr(e,G.E[x])
    {
        int id=*e,to=Es[id].other(x);
        if(Destroyed[id])continue;
        if(!Vis[to])
            Dfs(to,x,d+1);
    }
    R[x]=now-1;
}
struct UF
{
    int F[maxn],n;
    void Set(int _n)
    {
        n=_n;rep(i,n)F[i]=i;
    }
    int Find(int x)
    {
        if(F[x]==x)return x;
        return F[x]=Find(F[x]);
    }
    void Union(int i,int j)
    {
        i=Find(i);j=Find(j);
        F[j]=i;
    }
}U;
int Lca(int u,int v)
{
    if(D[u]&lt;D[v])swap(u,v);// u is deeper
    for(int i=Log-1;i&gt;=0;i--)
        if(D[u]-(1&lt;&lt;i)&gt;=D[v])
            u=Link[u][i];
    if(u==v)return u;
    for(int i=Log-1;i&gt;=0;i--)
    {
        int fu=Link[u][i],fv=Link[v][i];
        if(fu==-1)continue;
        if(fu!=fv)u=fu,v=fv;
    }
    return F[u];
}
void BuildTree()
{
    memset(Link,-1,sizeof Link);
    T.Set(n);
    Dfs(0,-1,0);
    U.Set(n);
    rep(i,n)T.Add(L[i],R[i],1);
}
void MarkVertex(int u)
{
    T.Add(L[u],R[u],-1);
}
void MarkThrough(int u,int anc)
{
    for(;;)
    {
        u=U.Find(u);
        if(D[u]&lt;=D[anc])return;
        MarkVertex(u);
        U.Union(F[u],u);
        u=F[u];
    }
}
void MarkPath(int u,int v)
{
    int lca=Lca(u,v);
    MarkThrough(u,lca);
    MarkThrough(v,lca);
}
void MarkThePaths()
{
    rep(i,m)
    {
        if(Destroyed[i])continue;
        int s=Es[i].s,t=Es[i].t;
        if(D[s]&lt;D[t])swap(s,t);
        if(F[s]==t)//That Edge is a Tree-Edge
            continue;
        MarkPath(s,t);
    }
}
int CountThePath(int u,int v)
{
    int lca=Lca(u,v);
    return T.Sum(L[u])+T.Sum(L[v])-2*T.Sum(L[lca]);
}
int Ans[maxn],cntAns;
void Solve()
{
    cntAns=0;
    for(int i=q-1;i&gt;=0;i--)
    {
        int t=Qs[i].type,u=Qs[i].u,v=Qs[i].v;
        if(t==1)
            Ans[cntAns++]=CountThePath(u,v);
        else
            MarkPath(u,v);
    }
    for(int i=cntAns-1;i&gt;=0;i--)
        printf("%d\n",Ans[i]);
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    ReadQuerys();
    BuildTree();
    MarkThePaths();
    Solve();
}


</pre><pre></pre><h2>Problem1970</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int maxl=100,maxn=50+1;
int Tmp[maxl];
struct BigInt
{
    int A[maxl],l;
    BigInt(){memset(A,0,sizeof A);l=0;}
    void set(int x){A[0]=x;}
    int operator[](int v)const{return A[v];}
    int&amp;operator[](int v){return A[v];}
    BigInt&amp;operator=(const BigInt&amp;that)
    {
        memcpy(A,that.A,sizeof A);
        l=that.l;
        return *this;
    }
    BigInt&amp;operator+=(const BigInt&amp;that)
    {
        l=max(l,that.l);int d=0;
        rep(i,l+1)
        {
            d+=A[i]+that[i];
            A[i]=d%10;
            d/=10;
        }
        if(d)A[++l]=d;
        return *this;
    }
    BigInt&amp;operator-=(const BigInt&amp;that)
    {
        int d=0;
        rep(i,l+1)
        {
            if(d)A[i]--,d=0;
            A[i]-=that[i];
            if(A[i]&lt;0)A[i]+=10,d=1;
        }
        while(!A[l])l--;
        return *this;
    }
    BigInt&amp;operator*=(const BigInt&amp;that)
    {
        int d=0;
        memset(Tmp,0,sizeof Tmp);
        rep(i,l+1)rep(j,that.l+1)Tmp[i+j]+=A[i]*that[j];
        l+=that.l;
        rep(i,l+1)
        {
            d+=Tmp[i];A[i]=d%10;d/=10;
        }
        while(d)A[++l]=d%10,d/=10;
        return *this;
    }
    BigInt operator*(const BigInt&amp;that)
    {
        BigInt ret=*this;
        return ret*=that;
    }
    BigInt operator+(const BigInt&amp;that)
    {
        BigInt ret=*this;
        return ret+=that;
    }
    BigInt operator-(const BigInt&amp;that)
    {
        BigInt ret=*this;
        return ret-=that;
    }
};
ostream&amp;operator&lt;&lt;(ostream&amp;out,BigInt&amp;that)
{
    for(int i=that.l;i&gt;=0;i--)out&lt;&lt;that[i];
    return out;
}
int k;
char C[maxn*4];
BigInt Power[maxn];
void Init()
{
    scanf("%d",&amp;k);
    scanf(" ");
    gets(C);
}
void PreCondition()
{
    Power[0].set(1);
    BigInt Four;Four.set(4);
    for(int i=1;i&lt;maxn;i++)
        Power[i]=Power[i-1]*Four;
}
BigInt ans;
int now;
void Dfs(int k)
{
    char t=C[now++];
    if(t=='0')ans+=Power[k];
    if(t=='2')rep(j,4)Dfs(k-1);
}
void Solve()
{
    now=0;
    Dfs(k);
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    PreCondition();
    Solve();
}


</pre><pre></pre><h2>Problem1971</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;3,maxn=100,maxk=100;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
struct Array
{
    int A[maxn],n;
    Array():n(0){}
    void Add(int x){A[n++]=x;}
    bool Full(){return n==maxn;}
}Kth[maxn][maxn];
int Dist[maxn][maxn],n,m;
struct State
{
    int p,c;
    State(int _p,int _c):p(_p),c(_c){}
    bool operator&lt;(const State&amp;o)const
    {
        return c&gt;o.c;
    }
};
void Solve(int vs)
{
    Array* D=Kth[vs];
    priority_queue&lt;State&gt; Q;
    Q.push(State(vs,0));
    while(Q.size())
    {
        State t=Q.top();Q.pop();
        if(D[t.p].Full())continue;
        if(t.c)D[t.p].Add(t.c);
        int tmp;
        rep(i,n)if((tmp=Dist[t.p][i])!=-1)
            Q.push(State(i,t.c+tmp));
    }
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;int s,t,c;
    memset(Dist,-1,sizeof Dist);
    rep(i,m)
    {
        cin&gt;&gt;s&gt;&gt;t&gt;&gt;c;--s;--t;
        Dist[s][t]=c;
    }
    rep(i,n)Solve(i);
    int q;cin&gt;&gt;q;
    rep(i,q)
    {
        cin&gt;&gt;s&gt;&gt;t&gt;&gt;c;--s;--t;
        if(Kth[s][t].n&lt;c)
            cout&lt;&lt;-1&lt;&lt;endl;
        else
            cout&lt;&lt;Kth[s][t].A[c-1]&lt;&lt;endl;
    }
}


</pre><pre></pre><h2>Problem1971</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int maxn=100;
using namespace std;
struct Array
{
    int A[maxn],n;
    Array():n(0){}
    void Add(int x){A[n++]=x;}
    bool Full(){return n==maxn;}
}Kth[maxn][maxn];
int Dist[maxn][maxn],n,m;
struct State
{
    int p,c;
    State(int _p,int _c):p(_p),c(_c){}
    bool operator&lt;(const State&amp;o)const
    {
        return c&gt;o.c;
    }
};
void Solve(int vs)
{
    Array* D=Kth[vs];
    priority_queue&lt;State&gt; Q;
    Q.push(State(vs,0));
    while(Q.size())
    {
        State t=Q.top();Q.pop();
        if(D[t.p].Full())continue;
        if(t.c)D[t.p].Add(t.c);
        int tmp;
        rep(i,n)if((tmp=Dist[t.p][i])!=-1)
            Q.push(State(i,t.c+tmp));
    }
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;m;int s,t,c;
    memset(Dist,-1,sizeof Dist);
    rep(i,m)
    {
        cin&gt;&gt;s&gt;&gt;t&gt;&gt;c;--s;--t;
        Dist[s][t]=c;
    }
    rep(i,n)Solve(i);
    int q;cin&gt;&gt;q;
    rep(i,q)
    {
        cin&gt;&gt;s&gt;&gt;t&gt;&gt;c;--s;--t;
        if(Kth[s][t].n&lt;c)
            cout&lt;&lt;-1&lt;&lt;endl;
        else
            cout&lt;&lt;Kth[s][t].A[c-1]&lt;&lt;endl;
    }
}


</pre><pre></pre><h2>Problem1971</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int maxn=100;
using namespace std;
struct Array
{
    int A[maxn],n;
    Array():n(0){}
    void Add(int x){A[n++]=x;}
    bool Full(){return n==maxn;}
}Kth[maxn][maxn];
int Dist[maxn][maxn],n,m;
struct State
{
    int p,c;
    State(int _p,int _c):p(_p),c(_c){}
    bool operator&lt;(const State&amp;o)const
    {
        return c&gt;o.c;
    }
};
void Solve(int vs)
{
    Array* D=Kth[vs];
    priority_queue&lt;State&gt; Q;
    Q.push(State(vs,0));
    while(Q.size())
    {
        State t=Q.top();Q.pop();
        if(D[t.p].Full())continue;
        if(t.c)D[t.p].Add(t.c);
        int tmp;
        rep(i,n)if((tmp=Dist[t.p][i])!=-1)
            Q.push(State(i,t.c+tmp));
    }
}
int nextInt()
{
    char c;int ret;
    while(c=getchar(),c&lt;'0'||c&gt;'9');
    ret=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')ret=ret*10+c-'0';
    return ret;
}
int main()
{
    //freopen("in","r",stdin);
    n=nextInt();m=nextInt();int s,t,c;
    memset(Dist,-1,sizeof Dist);
    rep(i,m)
    {
        s=nextInt();t=nextInt();c=nextInt();--s;--t;
        Dist[s][t]=c;
    }
    rep(i,n)Solve(i);
    int q;q=nextInt();
    rep(i,q)
    {
        s=nextInt();t=nextInt();c=nextInt();--s;--t;
        if(Kth[s][t].n&lt;c)
            printf("-1\n");
        else
            printf("%d\n",Kth[s][t].A[c-1]);
    }
}


</pre><pre></pre><h2>Problem1975</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
namespace Solve
{
    int n,m;
    double e;
    const int VX_MAX=5000+10;
    namespace Graph
    {
        const int EG_MAX=200010*2;
        struct Graph
        {
            int Vt;
            int head[VX_MAX];
            int next[EG_MAX],dest[EG_MAX],mnt;
            double cost[EG_MAX];
            void init_graph(int v);
            void add_edge(int s,int t,double c);
        };
    }
    namespace Heap
    {
        const int HP_MAX=10000000;
        struct Heap_Item
        {
            int id;
            double v;
            Heap_Item(){}
            Heap_Item(int _id,double _v):
                id(_id),v(_v){}
        };
        struct Heap
        {
            Heap_Item Heap[HP_MAX];
            int size;
            void init_heap();
            void extract_min();
            void add_item(Heap_Item item);
            void fix_up(int x);
            void fix_down(int x);
        };
    }
    namespace Shortest_Path//use SPFA to calculate Shortest Path
    {
        const double inf=1e20;
        struct Queue
        {
            bool inQ[VX_MAX];
            int Q[VX_MAX],h,t;
            void clear();
            void inc(int&amp;x);
            void add(int x);
            int get();
            bool empty();
        };
        struct Spfa
        {
            double dist[VX_MAX];
            void do_spfa(const Graph::Graph&amp;G,int vs);
        };
    }
    Graph::Graph G,RevG;
    void input_data(FILE*in,FILE*out);
    int calc_ans();
    void solve(FILE*in,FILE*out);
}
void Solve::Graph::Graph::init_graph(int v)
{
    Vt=v;
    memset(head,-1,sizeof(int)*Vt);
    mnt=0;
}
void Solve::Graph::Graph::add_edge(int s,int t,double c)
{
    next[mnt]=head[s];dest[mnt]=t;cost[mnt]=c;
    head[s]=mnt++;
}
void Solve::Heap::Heap::init_heap()
{
    size=0;
}
void Solve::Heap::Heap::extract_min()
{
    Heap[1]=Heap[size--];
    fix_down(1);
}
void Solve::Heap::Heap::add_item(Heap_Item item)
{
    Heap[++size]=item;
    fix_up(size);
}
void Solve::Heap::Heap::fix_down(int x)
{
    int l=x*2;
    if(l&gt;size)return;
    if(l+1&lt;=size&amp;&amp;Heap[l+1].v&lt;Heap[l].v)l++;
    if(Heap[l].v&lt;Heap[x].v)
        swap(Heap[l],Heap[x]),fix_down(l);
}
void Solve::Heap::Heap::fix_up(int x)
{
    int p=x/2;
    if(!p)return;
    if(Heap[x].v&lt;Heap[p].v)
        swap(Heap[x],Heap[p]),fix_up(p);
}
void Solve::Shortest_Path::Queue::clear()
{
    memset(inQ,0,sizeof inQ);
    h=t=0;
}
void Solve::Shortest_Path::Queue::add(int x)
{
    if(inQ[x])return;
    Q[t]=x;
    inQ[x]=true;
    inc(t);
}
void Solve::Shortest_Path::Queue::inc(int&amp;x)
{
    if(++x==VX_MAX)
        x=0;
}
int Solve::Shortest_Path::Queue::get()
{
    int ret=Q[h];
    inc(h);
    inQ[ret]=false;
    return ret;
}
bool Solve::Shortest_Path::Queue::empty()
{
    return h==t;
}
void Solve::Shortest_Path::Spfa::do_spfa(const Graph::Graph&amp;G,int vs)
{
    for(int i=0;i&lt;n;i++)
        dist[i]=inf;
    static Queue Q;
    dist[vs]=0;Q.clear();Q.add(vs);
    while(!Q.empty())
    {
        int u=Q.get(),v;
        //cout&lt;&lt;u&lt;&lt;endl;
        for(int e=G.head[u];e!=-1;e=G.next[e])
        {
            v=G.dest[e];
            double new_c=dist[u]+G.cost[e];
            if(new_c&lt;dist[v])
            {
                dist[v]=new_c;
                Q.add(v);
                //cout&lt;&lt;"add "&lt;&lt;v&lt;&lt;endl;
            }
        }
    }
}
void Solve::input_data(FILE*in,FILE*out)
{
    fscanf(in,"%d%d%lf",&amp;n,&amp;m,&amp;e);
    G.init_graph(n);
    RevG.init_graph(n);
    int s,t;double c;
    for(int i=0;i&lt;m;i++)
    {
        fscanf(in,"%d%d%lf",&amp;s,&amp;t,&amp;c);
        --s;--t;
        G.add_edge(s,t,c);
        RevG.add_edge(t,s,c);
    }
}
int Solve::calc_ans()
{
    int vs=0,vt=n-1;
    static Shortest_Path::Spfa sp;
    sp.do_spfa(RevG,vt);
    //for(int i=0;i&lt;n;i++)
        //cout&lt;&lt;i&lt;&lt;":"&lt;&lt;sp.dist[i]&lt;&lt;endl;
    static Heap::Heap hp;
    #define add_vet(x,c)\
        hp.add_item(Heap::Heap_Item(x,c+sp.dist[x]))
    add_vet(vs,0);
    double left=e;int ans=0;
    while(hp.size&amp;&amp;left&gt;0)
    {
        Heap::Heap_Item it=hp.Heap[1];
        hp.extract_min();
        int u=it.id,v;
        double c=it.v-sp.dist[u];
        if(u==vt)
        {
            if(c&gt;left)break;
            else left-=c,ans++;
            continue;
        }
        for(int e=G.head[u];e!=-1;e=G.next[e])
        {
            int v=G.dest[e];
            double new_c=c+G.cost[e];
            add_vet(v,new_c);
        }
    }
    return ans;
}
void Solve::solve(FILE*in,FILE*out)
{
    input_data(in,out);
    fprintf(out,"%d\n",calc_ans());
}
int main()
{
    Solve::solve(stdin,stdout);
}
</pre><pre></pre><h2>Problem1976</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=40+1,maxv=maxn*maxn*maxn+10,maxm=maxv*12,inf=~0U&gt;&gt;1;
int N;
char A[maxn][maxn][maxn];
int Node(int a,int b,int c)
{
    return (a*N+b)*N+c;
}
int nxt[maxm],t[maxm],c[maxm],head[maxv],mnt=0;
void AddEdge(int s,int _t,int _c)
{
    t[mnt]=_t;c[mnt]=_c;
    nxt[mnt]=head[s];head[s]=mnt;
    mnt++;
}
void InsEdge(int s,int t,int c)
{
    if(s&lt;t)AddEdge(s,t,1),AddEdge(t,s,1);
}
int h[maxv],vh[maxv],vs,vt,v;
int aug(int no,int m)
{
    if(no==vt) return m;
    int l=m;
    for(int e=head[no];e!=-1;e=nxt[e])if(c[e]&amp;&amp;h[no]==h[t[e]]+1)
    {
        int d=aug(t[e],min(c[e],l));
        l-=d,c[e]-=d,c[e^1]+=d;
        if(l==0||h[vs]&gt;=v)return m-l;
    }
    int minh=v;
    for(int e=head[no];e!=-1;e=nxt[e])if(c[e]&amp;&amp;h[t[e]]+1&lt;minh)
        minh=h[t[e]]+1;
    if(--vh[h[no]]==0) h[vs]=v;vh[h[no]=minh]++;
    return m-l;
}
int CalFlow()
{
    memset(h,0,sizeof(h));
    memset(vh,0,sizeof(vh));
    vh[0]=v;
    int flow=0;while(h[vs]&lt;v)flow+=aug(vs,inf);
    return flow;
}

void Init()
{
    scanf("%d",&amp;N);
    rep(i,N)
    {
        scanf(" ");
        rep(j,N)
            scanf("%s",A[i][j]);
    }
}
void MakeGraph()
{
    //Make It Reverse
    v=N*N*N;vs=v++;vt=v++;
    memset(head,-1,sizeof head);
    rep(i,N)rep(j,N)rep(k,N)
        if((i+j+k)&amp;1)
        {
            char&amp;c=A[i][j][k];
            if(c!='?')
            {
                if(c=='N')c='P';
                else c='N';
            }
        }
    //To Build The Graph
    rep(i,N)rep(j,N)rep(k,N)
    {
        char c=A[i][j][k];
        if(c=='P')
            AddEdge(vs,Node(i,j,k),inf),AddEdge(Node(i,j,k),vs,0);
        if(c=='N')
            AddEdge(Node(i,j,k),vt,inf),AddEdge(vt,Node(i,j,k),0);
        #define expand(a,b,c) InsEdge(Node(i,j,k),Node(a,b,c),1)
        if(i)expand(i-1,j,k);if(i+1&lt;N)expand(i+1,j,k);
        if(j)expand(i,j-1,k);if(j+1&lt;N)expand(i,j+1,k);
        if(k)expand(i,j,k-1);if(k+1&lt;N)expand(i,j,k+1);
    }
}
void Solve()
{
    int ret=3*N*N*(N-1);
    ret-=CalFlow();
    printf("%d\n",ret);
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    MakeGraph();
    Solve();
}

</pre><pre></pre><h2>Problem1977</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;assert.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;(x)&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(eit e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;2,maxn=100000,maxm=300000,Log=18;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
struct Edge
{
    int s,t,c;
    Edge(){}
    Edge(int _s,int _t,int _c):s(_s),t(_t),c(_c){}
    int other(int v)const
    {
        return v==s?t:s;
    }
    bool operator&lt;(const Edge&amp;e)const
    {
        return c&lt;e.c;
    }
};
struct UF
{
    int F[maxn],n;
    void Set(int _n)
    {
        n=_n;
        rep(i,n)F[i]=i;
    }
    int Find(int x)
    {
        return F[x]==x?x:(F[x]=Find(F[x]));
    }
    bool Union(int i,int j)
    {
        i=Find(i);j=Find(j);
        F[i]=j;return i!=j;
    }
}U;
vector&lt;Edge*&gt; E[maxn];
typedef vector&lt;Edge*&gt;::iterator eit;
Edge Es[maxm];
bool BeLong[maxm]={};
int n,m;
ll total=0,ans=1LL&lt;&lt;60;
void AddEdge(Edge*e)
{
    E[e-&gt;s].pb(e);E[e-&gt;t].pb(e);
}
inline int readT(){
    int ret; char c;
    while(c = getchar(), c &lt; '0' || c &gt; '9') ;
    ret = c - '0';
    while(c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + c - '0';
    return ret;
}
void Init()
{
    n=readT(),m=readT();
    int s,t,c;
    rep(i,m)
    {
        s=readT(),t=readT(),c=readT();
        --s;--t;
        Es[i]=Edge(s,t,c);
    }
}
void MST()
{
    sort(Es,Es+m);
    U.Set(n);
    rep(i,m)
    {
        Edge*e=Es+i;
        if(U.Union(e-&gt;s,e-&gt;t))
            AddEdge(e),BeLong[i]=true,total+=e-&gt;c;
    }
}
struct info
{
    int First,Second,Name;
    bool exist(){return Name!=-1;}
    info(int x=-1,int c=-inf):First(c),Second(-inf),Name(x){}
    void Update(int x)
    {
        if(x&gt;First)Second=First,First=x;
        else if(x&gt;Second&amp;&amp;x&lt;First)Second=x;
    }
};
info Merge(const info&amp;L,const info&amp;R)
{
    info F=R;
    F.Update(L.First);F.Update(L.Second);
    return F;
}
int Q[maxn],D[maxn];
bool V[maxn]={};
info Ancestor[maxn][Log];
void BFS(int vs)
{
    int h,t;h=t=0;
    for(Q[t++]=vs,V[vs]=true,D[vs]=0;h&lt;t;h++)
    {
        int v=Q[h];
        tr(i,E[v])
        {
            Edge*e=*i;
            int w=e-&gt;other(v);
            if(!V[w])
            {
                V[w]=true;Q[t++]=w;D[w]=D[v]+1;
                Ancestor[w][0]=info(v,e-&gt;c);
                for(int i=1;i&lt;Log;i++)
                {
                    int tmp=Ancestor[w][i-1].Name;
                    if(tmp==-1)break;
                    Ancestor[w][i]=Merge(Ancestor[w][i-1],Ancestor[tmp][i-1]);
                }
            }
        }
    }
}
info Lca(int s,int t)
{
    if(D[s]&lt;D[t])swap(s,t);
    info A;
    for(int i=Log-1;i&gt;=0;i--)
        if(Ancestor[s][i].exist()&amp;&amp;D[s]-(1&lt;&lt;i)&gt;=D[t])
        {
           A=Merge(A,Ancestor[s][i]),s=Ancestor[s][i].Name;
        }
    if(s==t)return A;
    assert(D[s]==D[t]);
    for(int i=Log-1;i&gt;=0;i--)
    {
        info a=Ancestor[s][i],b=Ancestor[t][i];
        if(a.exist()&amp;&amp;b.exist())
        {
            if(a.Name!=b.Name)
            {
                A=Merge(A,a);A=Merge(A,b);
                s=a.Name;t=b.Name;
            }
        }
    }
    A=Merge(Ancestor[s][0],A);
    A=Merge(Ancestor[t][0],A);
    return A;
}
void Solve()
{
    rep(i,m)if(!BeLong[i])
    {
        Edge*e=Es+i;
        info tmp=Lca(e-&gt;s,e-&gt;t);
        int a=tmp.First,b=tmp.Second;ll ret=-1;
        if(e-&gt;c==a&amp;&amp;b!=-inf)
            ret=e-&gt;c-b;
        if(e-&gt;c&gt;a)
            ret=e-&gt;c-a;
        if(ret!=-1)
            ans=min(ans,total+ret);
    }
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("out1","w",stdout);
    Init();
    MST();
    BFS(0);
    Solve();
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1978</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxw=1000000,maxp=10000;
using namespace std;
int Dp[maxw+1]={},n,L,List[maxp];
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d",&amp;n,&amp;L);
    rep(i,n)
    {
        int x,tmp=0,c=0;
        scanf("%d",&amp;x);
        for(int i=1;i*i&lt;=x;i++)
            if(x%i==0)
            {
                if(i&gt;=L)List[c++]=i;
                if(x/i&gt;=L)List[c++]=x/i;
            }
        rep(i,c)tmp=max(tmp,Dp[List[i]]);tmp++;
        rep(i,c)Dp[List[i]]=tmp;
    }
    int ans=0;
    rep(i,maxw+1)ans=max(ans,Dp[i]);
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem1978</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxw=1000000,maxp=10000;
using namespace std;
int Dp[maxw+1]={},n,L,List[maxp];
int main()
{
    scanf("%d%d",&amp;n,&amp;L);
    rep(i,n)
    {
        int x,tmp=0,c=0;
        scanf("%d",&amp;x);
        for(int i=1;i*i&lt;=x;i++)
            if(x%i==0)
            {
                if(i&gt;=L)List[c++]=i;
                if(x/i&gt;=L)List[c++]=x/i;
            }
        rep(i,c)tmp=max(tmp,Dp[List[i]]);tmp++;
        rep(i,c)Dp[List[i]]=tmp;
    }
    int ans=0;
    rep(i,maxw+1)ans=max(ans,Dp[i]);
    printf("%d\n",ans);
}


</pre><pre></pre><h2>Problem1978</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxw=1000000,maxp=10000;
using namespace std;
int Dp[maxw+1]={},n,L,List[maxp];
int main()
{
    scanf("%d%d",&amp;n,&amp;L);
    rep(i,n)
    {
        int x,tmp=0,c=0;
        scanf("%d",&amp;x);
        if(x&lt;L)continue;
        List[c++]=x;
        for(int i=2;i*i&lt;=x;i++)
            if(x%i==0)
            {
                if(i&gt;=L)List[c++]=i;
                if(x/i&gt;=L)List[c++]=x/i;
            }
        rep(i,c)tmp=max(tmp,Dp[List[i]]);tmp++;
        rep(i,c)Dp[List[i]]=tmp;
    }
    int ans=0;
    rep(i,maxw+1)ans=max(ans,Dp[i]);
    printf("%d\n",ans);
}


</pre><pre></pre><h2>Problem1978</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxw=1000000,maxp=10000;
using namespace std;
int Dp[maxw+1]={},n,L,List[maxp];
int main()
{
    scanf("%d%d",&amp;n,&amp;L);
    rep(i,n)
    {
        int x,tmp=0,c=0;
        scanf("%d",&amp;x);
        List[c++]=x;
        for(int i=2;i*i&lt;=x;i++)
            if(x%i==0)
            {
                if(i&gt;=L)List[c++]=i;
                if(x/i&gt;=L)List[c++]=x/i;
            }
        rep(i,c)tmp=max(tmp,Dp[List[i]]);tmp++;
        rep(i,c)Dp[List[i]]=tmp;
    }
    int ans=0;
    rep(i,maxw+1)ans=max(ans,Dp[i]);
    printf("%d\n",ans);
}


</pre><pre></pre><h2>Problem1981</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int maxn=100,maxB=100000+10;
using namespace std;
int N,B[maxn],MaxB;
typedef long long ll;
ll L;
void Init()
{
    cin&gt;&gt;L&gt;&gt;N;MaxB=0;
    rep(i,N)
    {
        cin&gt;&gt;B[i];
        MaxB=max(MaxB,B[i]);
    }
}
ll Dist[maxB];
struct Queue
{
    int Q[maxB],h,t;
    bool inQ[maxB];
    void clear()
    {
        h=t;memset(inQ,0,sizeof inQ);
    }
    void inc(int&amp;i)
    {
        if(++i==maxB)i=0;
    }
    void add(int x)
    {
        if(inQ[x])return;
        Q[t]=x;inc(t);
        inQ[x]=true;
    }
    int get()
    {
        int tmp=Q[h];inc(h);
        inQ[tmp]=false;
        return tmp;
    }
    bool empty()
    {
        return h==t;
    }
}Q;
const ll inf =1LL&lt;&lt;62;
void BFS()
{
    ll P=L/MaxB;
    rep(i,MaxB)Dist[i]=inf;
    Dist[0]=P;Q.clear();
    Q.add(0);
    while(!Q.empty())
    {
        int x=Q.get();
        ll c=Dist[x];
        rep(i,N)
        {
            ll nc=(B[i]+x&gt;=MaxB)?c:c+1;
            int nx=(B[i]+x)%MaxB;
            if(Dist[nx]&gt;nc)
            {
                Dist[nx]=nc;
                Q.add(nx);
            }
        }
    }
    ll ans=Dist[L%MaxB];
    if(ans==inf)
        cout&lt;&lt;"IMPOSSIBLE"&lt;&lt;endl;
    else
        cout&lt;&lt;Dist[L%MaxB]&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    int T;cin&gt;&gt;T;
    rep(i,T)
    {
        cout&lt;&lt;"Case #"&lt;&lt;i+1&lt;&lt;": ";
        Init();
        BFS();
    }
}


</pre><pre></pre><h2>Problem1982</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
int A[100000];
int main()
{
    int n;while(scanf("%d",&amp;n)==1)
    {
        rep(i,n)scanf("%d",A+i);
        if(n&amp;1)A[n++]=0;sort(A,A+n);bool w=0;
        rep(i,n/2)if(A[i*2]!=A[i*2+1]){w=1;break;}
        w?puts("first player"):puts("second player");
    }
}


</pre><pre></pre><h2>Problem1982</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
int A[100000],n,w;
int main()
{
    while(scanf("%d",&amp;n)==1)
    {
        rep(i,n)scanf("%d",A+i);
        if(n&amp;1)A[n++]=0;sort(A,A+n);w=0;
        rep(i,n/2)if(A[i*2]!=A[i*2+1])w=1;
        w?puts("first player"):puts("second player");
    }
}


</pre><pre></pre><h2>Problem1984</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(eit e=x.begin();e!=x.end();e++)
#define OK cout&lt;&lt;"It's OK!!"&lt;&lt;endl;
#define printTime cerr&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=100000,Log=20;
using namespace std;
int n;
int Data[maxn];
#define Tree int t,int l,int r
#define This t,l,r
#define Left t*2,l,l+r&gt;&gt;1
#define Right t*2+1,l+r&gt;&gt;1,r
#define root 1,l,r
struct SegTree
{
    int*Same,*Max,*Add,l,r;
    void Build(Tree)
    {
        Add[t]=0;Same[t]=inf;
        if(l+1==r){Max[t]=Data[l];return;}
        Build(Left);Build(Right);
        Max[t]=max(Max[t*2],Max[t*2+1]);
    }
    void Mark_Add(Tree,int add)
    {
        if(Same[t]&lt;inf)
        {
            Same[t]+=add;
            Max[t]+=add;
            return;
        }
        Add[t]+=add;Max[t]+=add;
    }
    void Mark_Same(Tree,int same)
    {
        Same[t]=same;Max[t]=same;Add[t]=0;
    }
    void Push_Down(Tree)
    {
        if(Same[t]&lt;inf)
        {
            Mark_Same(Left,Same[t]);
            Mark_Same(Right,Same[t]);
            Same[t]=inf;
            return;
        }
        if(Add[t])
        {
            Mark_Add(Left,Add[t]);
            Mark_Add(Right,Add[t]);
            Add[t]=0;
        }
    }
    int Query(Tree,int a,int b)
    {
        if(a&gt;=r||b&lt;=l)return 0;
        if(l&gt;=a&amp;&amp;r&lt;=b)return Max[t];
        Push_Down(This);
        return max(Query(Left,a,b),Query(Right,a,b));
    }
    int Query(int a,int b){return Query(root,a,b);}
    void Change_Same(Tree,int a,int b,int c)
    {
        if(a&gt;=r||b&lt;=l)return;
        if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Same(This,c);return;}
        Push_Down(This);
        Change_Same(Left,a,b,c);Change_Same(Right,a,b,c);
        Max[t]=max(Max[t*2],Max[t*2+1]);
    }
    void Change_Same(int a,int b,int c){Change_Same(root,a,b,c);}
    void Change_Add(Tree,int a,int b,int c)
    {
        if(a&gt;=r||b&lt;=l)return;
        if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Add(This,c);return;}
        Push_Down(This);
        Change_Add(Left,a,b,c);Change_Add(Right,a,b,c);
        Max[t]=max(Max[t*2],Max[t*2+1]);
    }
    void Change_Add(int a,int b,int c){Change_Add(root,a,b,c);}
    void Build(int _l,int _r)
    {
        l=_l;r=_r;
        n=r-l;
        Same=new int[4*n];
        Max=new int[4*n];
        Add=new int[4*n];
        Build(root);
    }
}T[maxn];
struct Edge
{
    int t,c;
    Edge(){}
    Edge(int _t,int _c):t(_t),c(_c){}
}Mem[maxn*2];
int mnt=0;
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator eit;
void AddEdge(int s,int t,int c)
{
    Mem[mnt]=Edge(t,c);E[s].pb(mnt);mnt++;
}
void InsEdge(int s,int t,int c)
{
    AddEdge(s,t,c);AddEdge(t,s,c);
}
int own[maxn],Q[maxn],Size[maxn],w[maxn],P[maxn];
int D[maxn],anc[maxn][Log];
void BFS(int vs)
{
    int h=0,t=0;
    memset(anc,-1,sizeof anc);
    for(Q[t++]=vs,D[vs]=0,w[vs]=0;h&lt;t;h++)
    {
        int x=Q[h];
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==anc[x][0])continue;
            Q[t++]=e-&gt;t;
            D[e-&gt;t]=D[x]+1;
            w[e-&gt;t]=e-&gt;c;
            P[*it/2]=e-&gt;t;
            anc[e-&gt;t][0]=x;
            for(int i=1;i&lt;Log;i++)
            {
                int tmp=anc[e-&gt;t][i-1];
                if(tmp==-1)break;
                anc[e-&gt;t][i]=anc[tmp][i-1];
            }
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==anc[x][0])continue;
            Size[x]+=Size[e-&gt;t];
        }
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i],next;if(own[x]&gt;=0)continue;
        int a=x;
        for(;;x=next)
        {
            next=-1;own[x]=a;
            Data[D[x]]=w[x];
            tr(it,E[x])
            {
                Edge*e=Mem+*it;
                if(e-&gt;t==anc[x][0])continue;
                if(next==-1||Size[e-&gt;t]&gt;Size[next])
                    next=e-&gt;t;
            }
            if(next==-1)break;
        }
        T[a].Build(D[a],D[x]+1);
    }
}
int Lca(int s,int t)
{
    if(D[s]&lt;D[t])swap(s,t);
    for(int i=Log-1;i&gt;=0;i--)
        if(anc[s][i]!=-1&amp;&amp;D[s]-(1&lt;&lt;i)&gt;=D[t])
            s=anc[s][i];
    if(s==t)return s;
    for(int i=Log-1;i&gt;=0;i--)
    {
        int a=anc[s][i],b=anc[t][i];
        if(a&gt;=0&amp;&amp;a!=b)s=a,t=b;
    }
    return anc[s][0];
}
int Ask(int u,int v)
{
    int ret=0;
    for(;;)
    {
        if(own[u]==own[v])
        {
            ret=max(T[own[u]].Query(D[v]+1,D[u]+1),ret);
            return ret;
        }
        else
        {
            ret=max(T[own[u]].Query(D[own[u]],D[u]+1),ret);
            u=anc[own[u]][0];
        }
    }
}
int Query(int u,int v)
{
    int lca=Lca(u,v);
    return max(Ask(u,lca),Ask(v,lca));
}
void DoIt_Same(int u,int v,int c)
{
    for(;;)
        if(own[u]==own[v])
        {
            T[own[u]].Change_Same(D[v]+1,D[u]+1,c);
            return;
        }
        else
        {
            T[own[u]].Change_Same(D[own[u]],D[u]+1,c);
            u=anc[own[u]][0];
        }
}
void Change_Same(int u,int v,int c)
{
    int lca=Lca(u,v);
    DoIt_Same(u,lca,c);DoIt_Same(v,lca,c);
}
void DoIt_Add(int u,int v,int c)
{
    for(;;)
    {
        if(own[u]==own[v])
        {
            T[own[u]].Change_Add(D[v]+1,D[u]+1,c);
            return;
        }
        else
        {
            T[own[u]].Change_Add(D[own[u]],D[u]+1,c);
            u=anc[own[u]][0];
        }
    }
}
void Change_Add(int u,int v,int c)
{
    int lca=Lca(u,v);
    DoIt_Add(u,lca,c);
    DoIt_Add(v,lca,c);
}
void Change_Edge(int s,int c)
{
    s=P[s];
    T[own[s]].Change_Same(D[s],D[s]+1,c);
}
inline int readT(){
    int ret; char c;
    while(c = getchar(), c &lt; '0' || c &gt; '9') ;
    ret = c - '0';
    while(c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + c - '0';
    return ret;
}
int pre;
int main()
{
    //freopen("in","r",stdin);
    //freopen("outMy","w",stdout);
    cin&gt;&gt;n;int s,t,c;
    rep(i,n-1)
    {
        s=readT();t=readT();c=readT();--s;--t;
        InsEdge(s,t,c);
    }
    BFS(0);
    char cmd[100];
    for(;;)
    {
        scanf(" ");scanf("%s",cmd);
        int s,t,c;
        switch(cmd[1])
        {
            case 'a':s=readT(),t=readT(),printf("%d\n",Query(s-1,t-1));break;//Max
            case 'o':s=readT(),t=readT(),c=readT(),Change_Same(s-1,t-1,c);break;//Cover
            case 'd':s=readT(),t=readT(),c=readT(),Change_Add(s-1,t-1,c);break;//Add
            case 'h':s=readT(),t=readT(),Change_Edge(s-1,t);break;//Change
            case 't':return 0;//Stop
        }
    }
}
</pre><pre></pre><h2>Problem1984</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;assert.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(eit e=x.begin();e!=x.end();e++)
#define OK cout&lt;&lt;"It's OK!!"&lt;&lt;endl;
const int inf=~0U&gt;&gt;1,maxn=100000,Log=20;
using namespace std;
int n;
struct Node{
    int l,r,same,add,Max;
    Node*lc,*rc;
    Node():lc(0),rc(0){}
}Memory[maxn*4],*Now=Memory,*T[maxn];
int Data[maxn];
void Update(Node*t)
{
    t-&gt;Max=max(t-&gt;lc-&gt;Max,t-&gt;rc-&gt;Max);
}
void Mark_Same(Node*t,int same)
{
    t-&gt;same=same;
    t-&gt;Max=same;
    t-&gt;add=0;
}
void Mark_Add(Node*t,int add)
{
    if(t-&gt;same&lt;inf)
    {
        t-&gt;Max+=add;
        t-&gt;same+=add;
        return;
    }
    t-&gt;add+=add;t-&gt;Max+=add;
}
void Push_Down(Node*t)
{
    if(t-&gt;same&lt;inf)
    {
        Mark_Same(t-&gt;lc,t-&gt;same);
        Mark_Same(t-&gt;rc,t-&gt;same);
        t-&gt;same=inf;
        return;
    }
    if(t-&gt;add)
    {
        Mark_Add(t-&gt;lc,t-&gt;add);
        Mark_Add(t-&gt;rc,t-&gt;add);
        t-&gt;add=0;
    }
}
Node*Build(int l,int r)
{
    Node*t=Now++;t-&gt;l=l;t-&gt;r=r;t-&gt;same=inf;t-&gt;add=0;
    if(l+1==r){t-&gt;Max=Data[l];return t;}
    int m=l+r&gt;&gt;1;
    t-&gt;lc=Build(l,m);t-&gt;rc=Build(m,r);
    Update(t);
    return t;
}
int Query(Node*t,int a,int b)
{
    int l=t-&gt;l,r=t-&gt;r;
    if(a&gt;=r||b&lt;=l)return 0;
    if(l&gt;=a&amp;&amp;r&lt;=b)return t-&gt;Max;
    Push_Down(t);
    return max(Query(t-&gt;lc,a,b),Query(t-&gt;rc,a,b));
}
void Change_Same(Node*t,int a,int b,int c)
{
    int l=t-&gt;l,r=t-&gt;r;
    if(a&gt;=r||b&lt;=l)return;
    if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Same(t,c);return;}
    Push_Down(t);
    Change_Same(t-&gt;lc,a,b,c);Change_Same(t-&gt;rc,a,b,c);
    Update(t);
}
void Change_Add(Node*t,int a,int b,int c)
{
    int l=t-&gt;l,r=t-&gt;r;
    if(a&gt;=r||b&lt;=l)return;
    if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Add(t,c);return;}
    Push_Down(t);
    Change_Add(t-&gt;lc,a,b,c);Change_Add(t-&gt;rc,a,b,c);
    Update(t);
}
struct Edge
{
    int t,c;
    Edge(){}
    Edge(int _t,int _c):t(_t),c(_c){}
}Mem[maxn*2];
int mnt=0;
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator eit;
void AddEdge(int s,int t,int c)
{
    Mem[mnt]=Edge(t,c);E[s].pb(mnt);mnt++;
}
void InsEdge(int s,int t,int c)
{
    AddEdge(s,t,c);AddEdge(t,s,c);
}
int own[maxn],Q[maxn],Size[maxn],w[maxn],P[maxn];
int D[maxn],anc[maxn][Log];
void BFS(int vs)
{
    int h=0,t=0;
    memset(anc,-1,sizeof anc);
    for(Q[t++]=vs,D[vs]=0,w[vs]=0;h&lt;t;h++)
    {
        int x=Q[h];
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==anc[x][0])continue;
            Q[t++]=e-&gt;t;
            D[e-&gt;t]=D[x]+1;
            w[e-&gt;t]=e-&gt;c;
            P[*it/2]=e-&gt;t;
            anc[e-&gt;t][0]=x;
            for(int i=1;i&lt;Log;i++)
            {
                int tmp=anc[e-&gt;t][i-1];
                if(tmp==-1)break;
                anc[e-&gt;t][i]=anc[tmp][i-1];
            }
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==anc[x][0])continue;
            Size[x]+=Size[e-&gt;t];
        }
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i],next;if(own[x]&gt;=0)continue;
        int a=x;
        for(;;x=next)
        {
            next=-1;own[x]=a;
            Data[D[x]]=w[x];
            tr(it,E[x])
            {
                Edge*e=Mem+*it;
                if(e-&gt;t==anc[x][0])continue;
                if(next==-1||Size[e-&gt;t]&gt;Size[next])
                    next=e-&gt;t;
            }
            if(next==-1)break;
        }
        T[a]=Build(D[a],D[x]+1);
    }
}
int Lca(int s,int t)
{
    if(D[s]&lt;D[t])swap(s,t);
    for(int i=Log-1;i&gt;=0;i--)
        if(anc[s][i]!=-1&amp;&amp;D[s]-(1&lt;&lt;i)&gt;=D[t])
            s=anc[s][i];
    if(s==t)return s;
    for(int i=Log-1;i&gt;=0;i--)
    {
        int a=anc[s][i],b=anc[t][i];
        if(a&gt;=0&amp;&amp;a!=b)s=a,t=b;
    }
    return anc[s][0];
}
int Ask(int u,int v)
{
    int ret=0;
    for(;;)
    {
        if(own[u]==own[v])
        {
            ret=max(Query(T[own[u]],D[v]+1,D[u]+1),ret);
            return ret;
        }
        else
        {
            ret=max(Query(T[own[u]],D[own[u]],D[u]+1),ret);
            u=anc[own[u]][0];
        }
    }
}
int Query(int u,int v)
{
    int lca=Lca(u,v);
    return max(Ask(u,lca),Ask(v,lca));
}
void DoIt_Same(int u,int v,int c)
{
    for(;;)
        if(own[u]==own[v])
        {
            Change_Same(T[own[u]],D[v]+1,D[u]+1,c);
            return;
        }
        else
        {
            Change_Same(T[own[u]],D[own[u]],D[u]+1,c);
            u=anc[own[u]][0];
        }
}
void Change_Same(int u,int v,int c)
{
    int lca=Lca(u,v);
    DoIt_Same(u,lca,c);DoIt_Same(v,lca,c);
}
void DoIt_Add(int u,int v,int c)
{
    for(;;)
    {
        if(own[u]==own[v])
        {
            Change_Add(T[own[u]],D[v]+1,D[u]+1,c);
            return;
        }
        else
        {
            Change_Add(T[own[u]],D[own[u]],D[u]+1,c);
            u=anc[own[u]][0];
        }
    }
}
void Change_Add(int u,int v,int c)
{
    int lca=Lca(u,v);
    DoIt_Add(u,lca,c);
    DoIt_Add(v,lca,c);
}
void Change_Edge(int s,int c)
{
    s=P[s];
    Change_Same(T[own[s]],D[s],D[s]+1,c);
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("outMy","w",stdout);
    cin&gt;&gt;n;int s,t,c;
    rep(i,n-1)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);
        --s;--t;
        InsEdge(s,t,c);
    }
    BFS(0);
    char cmd[100];
    for(;;)
    {
        scanf(" ");scanf("%s",cmd);
        int s,t,c;
        switch(cmd[1])
        {
            case 'a':scanf("%d%d",&amp;s,&amp;t),printf("%d\n",Query(s-1,t-1));break;//Max
            case 'o':scanf("%d%d%d",&amp;s,&amp;t,&amp;c),Change_Same(s-1,t-1,c);break;//Cover
            case 'd':scanf("%d%d%d",&amp;s,&amp;t,&amp;c),Change_Add(s-1,t-1,c);break;//Add
            case 'h':scanf("%d%d",&amp;s,&amp;t),Change_Edge(s-1,t);break;//Change
            case 't':return 0;//Stop
        }
    }
}

</pre><pre></pre><h2>Problem1984</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(eit e=x.begin();e!=x.end();e++)
#define OK cout&lt;&lt;"It's OK!!"&lt;&lt;endl;
#define printTime cerr&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=100000,Log=20;
using namespace std;
int n;
int Data[maxn];
#define Tree int t,int l,int r
#define This t,l,r
#define Left t*2,l,l+r&gt;&gt;1
#define Right t*2+1,l+r&gt;&gt;1,r
#define root 1,l,r
struct SegTree
{
    int*Same,*Max,*Add,l,r;
    void Build(Tree)
    {
        Add[t]=0;Same[t]=inf;
        if(l+1==r){Max[t]=Data[l];return;}
        Build(Left);Build(Right);
        Max[t]=max(Max[t*2],Max[t*2+1]);
    }
    void Mark_Add(Tree,int add)
    {
        if(Same[t]&lt;inf)
        {
            Same[t]+=add;
            Max[t]+=add;
            return;
        }
        Add[t]+=add;Max[t]+=add;
    }
    void Mark_Same(Tree,int same)
    {
        Same[t]=same;Max[t]=same;Add[t]=0;
    }
    void Push_Down(Tree)
    {
        if(Same[t]&lt;inf)
        {
            Mark_Same(Left,Same[t]);
            Mark_Same(Right,Same[t]);
            Same[t]=inf;
            return;
        }
        if(Add[t])
        {
            Mark_Add(Left,Add[t]);
            Mark_Add(Right,Add[t]);
            Add[t]=0;
        }
    }
    int Query(Tree,int a,int b)
    {
        if(a&gt;=r||b&lt;=l)return 0;
        if(l&gt;=a&amp;&amp;r&lt;=b)return Max[t];
        Push_Down(This);
        return max(Query(Left,a,b),Query(Right,a,b));
    }
    int Query(int a,int b){return Query(root,a,b);}
    void Change_Same(Tree,int a,int b,int c)
    {
        if(a&gt;=r||b&lt;=l)return;
        if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Same(This,c);return;}
        Push_Down(This);
        Change_Same(Left,a,b,c);Change_Same(Right,a,b,c);
        Max[t]=max(Max[t*2],Max[t*2+1]);
    }
    void Change_Same(int a,int b,int c){Change_Same(root,a,b,c);}
    void Change_Add(Tree,int a,int b,int c)
    {
        if(a&gt;=r||b&lt;=l)return;
        if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Add(This,c);return;}
        Push_Down(This);
        Change_Add(Left,a,b,c);Change_Add(Right,a,b,c);
        Max[t]=max(Max[t*2],Max[t*2+1]);
    }
    void Change_Add(int a,int b,int c){Change_Add(root,a,b,c);}
    void Build(int _l,int _r)
    {
        l=_l;r=_r;
        n=r-l;
        Same=new int[4*n];
        Max=new int[4*n];
        Add=new int[4*n];
        Build(root);
    }
}T[maxn];
struct Edge
{
    int t,c;
    Edge(){}
    Edge(int _t,int _c):t(_t),c(_c){}
}Mem[maxn*2];
int mnt=0;
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator eit;
void AddEdge(int s,int t,int c)
{
    Mem[mnt]=Edge(t,c);E[s].pb(mnt);mnt++;
}
void InsEdge(int s,int t,int c)
{
    AddEdge(s,t,c);AddEdge(t,s,c);
}
int own[maxn],Q[maxn],Size[maxn],w[maxn],P[maxn];
int D[maxn],F[maxn];
void BFS(int vs)
{
    int h=0,t=0;
    for(Q[t++]=vs,D[vs]=0,w[vs]=0,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==F[x])continue;
            Q[t++]=e-&gt;t;
            D[e-&gt;t]=D[x]+1;
            w[e-&gt;t]=e-&gt;c;
            P[*it/2]=e-&gt;t;
            F[e-&gt;t]=x;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==F[x])continue;
            Size[x]+=Size[e-&gt;t];
        }
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i],next;if(own[x]&gt;=0)continue;
        int a=x;
        for(;;x=next)
        {
            next=-1;own[x]=a;
            Data[D[x]]=w[x];
            tr(it,E[x])
            {
                Edge*e=Mem+*it;
                if(e-&gt;t==F[x])continue;
                if(next==-1||Size[e-&gt;t]&gt;Size[next])
                    next=e-&gt;t;
            }
            if(next==-1)break;
        }
        T[a].Build(D[a],D[x]+1);
    }
}
int Ask(int u,int v)
{

}
int Query(int u,int v)
{
    int ret=0;
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            ret=max(T[own[u]].Query(D[v]+1,D[u]+1),ret);
            return ret;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            ret=max(ret,T[own[u]].Query(D[own[u]],D[u]+1));
            u=F[own[u]];
        }
    }
}
void Change_Same(int u,int v,int c)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            T[own[u]].Change_Same(D[v]+1,D[u]+1,c);
            return ;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            T[own[u]].Change_Same(D[own[u]],D[u]+1,c);
            u=F[own[u]];
        }
    }
}
void Change_Add(int u,int v,int c)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            T[own[u]].Change_Add(D[v]+1,D[u]+1,c);
            return ;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            T[own[u]].Change_Add(D[own[u]],D[u]+1,c);
            u=F[own[u]];
        }
    }
}
void Change_Edge(int s,int c)
{
    s=P[s];
    T[own[s]].Change_Same(D[s],D[s]+1,c);
}
inline int readT(){
    int ret; char c;
    while(c = getchar(), c &lt; '0' || c &gt; '9') ;
    ret = c - '0';
    while(c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + c - '0';
    return ret;
}
int pre;
int main()
{
    //freopen("in","r",stdin);
    //freopen("outMy","w",stdout);
    cin&gt;&gt;n;int s,t,c;
    rep(i,n-1)
    {
        s=readT();t=readT();c=readT();--s;--t;
        InsEdge(s,t,c);
    }
    BFS(0);
    char cmd[100];
    for(;;)
    {
        scanf(" ");scanf("%s",cmd);
        int s,t,c;
        switch(cmd[1])
        {
            case 'a':s=readT(),t=readT(),printf("%d\n",Query(s-1,t-1));break;//Max
            case 'o':s=readT(),t=readT(),c=readT(),Change_Same(s-1,t-1,c);break;//Cover
            case 'd':s=readT(),t=readT(),c=readT(),Change_Add(s-1,t-1,c);break;//Add
            case 'h':s=readT(),t=readT(),Change_Edge(s-1,t);break;//Change
            case 't':return 0;//Stop
        }
    }
}
</pre><pre></pre><h2>Problem1984</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(eit e=x.begin();e!=x.end();e++)
#define OK cout&lt;&lt;"It's OK!!"&lt;&lt;endl;
#define printTime cerr&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=100000,Log=20;
using namespace std;
int n;
int Data[maxn];
int Memory[maxn*12],*Now=Memory;
int*New(int s)
{
    Now+=s;return Now-s;
}
#define Tree int t,int l,int r
#define This t,l,r
#define Left t*2,l,l+r&gt;&gt;1
#define Right t*2+1,l+r&gt;&gt;1,r
#define root 1,l,r
struct SegTree
{
    int*Same,*Max,*Add,l,r;
    void Build(Tree)
    {
        Add[t]=0;Same[t]=inf;
        if(l+1==r){Max[t]=Data[l];return;}
        Build(Left);Build(Right);
        Max[t]=max(Max[t*2],Max[t*2+1]);
    }
    void Mark_Add(Tree,int add)
    {
        if(Same[t]&lt;inf)
        {
            Same[t]+=add;
            Max[t]+=add;
            return;
        }
        Add[t]+=add;Max[t]+=add;
    }
    void Mark_Same(Tree,int same)
    {
        Same[t]=same;Max[t]=same;Add[t]=0;
    }
    void Push_Down(Tree)
    {
        if(Same[t]&lt;inf)
        {
            Mark_Same(Left,Same[t]);
            Mark_Same(Right,Same[t]);
            Same[t]=inf;
            return;
        }
        if(Add[t])
        {
            Mark_Add(Left,Add[t]);
            Mark_Add(Right,Add[t]);
            Add[t]=0;
        }
    }
    int Query(Tree,int a,int b)
    {
        if(a&gt;=r||b&lt;=l)return 0;
        if(l&gt;=a&amp;&amp;r&lt;=b)return Max[t];
        Push_Down(This);
        return max(Query(Left,a,b),Query(Right,a,b));
    }
    int Query(int a,int b){return Query(root,a,b);}
    void Change_Same(Tree,int a,int b,int c)
    {
        if(a&gt;=r||b&lt;=l)return;
        if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Same(This,c);return;}
        Push_Down(This);
        Change_Same(Left,a,b,c);Change_Same(Right,a,b,c);
        Max[t]=max(Max[t*2],Max[t*2+1]);
    }
    void Change_Same(int a,int b,int c){Change_Same(root,a,b,c);}
    void Change_Add(Tree,int a,int b,int c)
    {
        if(a&gt;=r||b&lt;=l)return;
        if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Add(This,c);return;}
        Push_Down(This);
        Change_Add(Left,a,b,c);Change_Add(Right,a,b,c);
        Max[t]=max(Max[t*2],Max[t*2+1]);
    }
    void Change_Add(int a,int b,int c){Change_Add(root,a,b,c);}
    void Build(int _l,int _r)
    {
        l=_l;r=_r;
        n=r-l;
        Same=New(4*n);
        Max=New(4*n);
        Add=New(4*n);
        Build(root);
    }
}T[maxn];
struct Edge
{
    int t,c;
    Edge(){}
    Edge(int _t,int _c):t(_t),c(_c){}
}Mem[maxn*2];
int mnt=0;
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator eit;
void AddEdge(int s,int t,int c)
{
    Mem[mnt]=Edge(t,c);E[s].pb(mnt);mnt++;
}
void InsEdge(int s,int t,int c)
{
    AddEdge(s,t,c);AddEdge(t,s,c);
}
int own[maxn],Q[maxn],Size[maxn],w[maxn],P[maxn];
int D[maxn],F[maxn];
void BFS(int vs)
{
    int h=0,t=0;
    for(Q[t++]=vs,D[vs]=0,w[vs]=0,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==F[x])continue;
            Q[t++]=e-&gt;t;
            D[e-&gt;t]=D[x]+1;
            w[e-&gt;t]=e-&gt;c;
            P[*it/2]=e-&gt;t;
            F[e-&gt;t]=x;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==F[x])continue;
            Size[x]+=Size[e-&gt;t];
        }
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i],next;if(own[x]&gt;=0)continue;
        int a=x;
        for(;;x=next)
        {
            next=-1;own[x]=a;
            Data[D[x]]=w[x];
            tr(it,E[x])
            {
                Edge*e=Mem+*it;
                if(e-&gt;t==F[x])continue;
                if(next==-1||Size[e-&gt;t]&gt;Size[next])
                    next=e-&gt;t;
            }
            if(next==-1)break;
        }
        T[a].Build(D[a],D[x]+1);
    }
}
int Query(int u,int v)
{
    int ret=0;
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            ret=max(T[own[u]].Query(D[v]+1,D[u]+1),ret);
            return ret;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            ret=max(ret,T[own[u]].Query(D[own[u]],D[u]+1));
            u=F[own[u]];
        }
    }
}
void Change_Same(int u,int v,int c)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            T[own[u]].Change_Same(D[v]+1,D[u]+1,c);
            return ;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            T[own[u]].Change_Same(D[own[u]],D[u]+1,c);
            u=F[own[u]];
        }
    }
}
void Change_Add(int u,int v,int c)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            T[own[u]].Change_Add(D[v]+1,D[u]+1,c);
            return ;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            T[own[u]].Change_Add(D[own[u]],D[u]+1,c);
            u=F[own[u]];
        }
    }
}
void Change_Edge(int s,int c)
{
    s=P[s];
    T[own[s]].Change_Same(D[s],D[s]+1,c);
}
inline int readT(){
    int ret; char c;
    while(c = getchar(), c &lt; '0' || c &gt; '9') ;
    ret = c - '0';
    while(c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + c - '0';
    return ret;
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("outMy","w",stdout);
    cin&gt;&gt;n;int s,t,c;
    rep(i,n-1)
    {
        s=readT();t=readT();c=readT();--s;--t;
        InsEdge(s,t,c);
    }
    BFS(0);
    char cmd[100];
    for(;;)
    {
        scanf(" ");scanf("%s",cmd);
        int s,t,c;
        switch(cmd[1])
        {
            case 'a':s=readT(),t=readT(),printf("%d\n",Query(s-1,t-1));break;//Max
            case 'o':s=readT(),t=readT(),c=readT(),Change_Same(s-1,t-1,c);break;//Cover
            case 'd':s=readT(),t=readT(),c=readT(),Change_Add(s-1,t-1,c);break;//Add
            case 'h':s=readT(),t=readT(),Change_Edge(s-1,t);break;//Change
            case 't':return 0;//Stop
        }
    }
}
</pre><pre></pre><h2>Problem1984</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(eit e=x.begin();e!=x.end();e++)
#define OK cout&lt;&lt;"It's OK!!"&lt;&lt;endl;
#define printTime cerr&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=100000,Log=20;
using namespace std;
int n;
int Data[maxn];
int Memory[maxn*12],*Now=Memory;
int*New(int s)
{
    Now+=s;return Now-s;
}
#define Tree int t,int l,int r
#define This t,l,r
#define Left t*2,l,l+r&gt;&gt;1
#define Right t*2+1,l+r&gt;&gt;1,r
#define root 1,l,r
struct SegTree
{
    int*Same,*Max,*Add,l,r;
    void Build(Tree)
    {
        Add[t]=0;Same[t]=inf;
        if(l+1==r){Max[t]=Data[l];return;}
        Build(Left);Build(Right);
        Max[t]=Max[t*2]&gt;?Max[t*2+1];
    }
    void Mark_Add(Tree,int add)
    {
        if(Same[t]&lt;inf)
        {
            Same[t]+=add;
            Max[t]+=add;
            return;
        }
        Add[t]+=add;Max[t]+=add;
    }
    void Mark_Same(Tree,int same)
    {
        Same[t]=same;Max[t]=same;Add[t]=0;
    }
    void Push_Down(Tree)
    {
        if(Same[t]&lt;inf)
        {
            Mark_Same(Left,Same[t]);
            Mark_Same(Right,Same[t]);
            Same[t]=inf;
            return;
        }
        if(Add[t])
        {
            Mark_Add(Left,Add[t]);
            Mark_Add(Right,Add[t]);
            Add[t]=0;
        }
    }
    int Query(Tree,int a,int b)
    {
        if(a&gt;=r||b&lt;=l)return 0;
        if(l&gt;=a&amp;&amp;r&lt;=b)return Max[t];
        Push_Down(This);
        return Query(Left,a,b)&gt;?Query(Right,a,b);
    }
    int Query(int a,int b){return Query(root,a,b);}
    void Change_Same(Tree,int a,int b,int c)
    {
        if(a&gt;=r||b&lt;=l)return;
        if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Same(This,c);return;}
        Push_Down(This);
        Change_Same(Left,a,b,c);Change_Same(Right,a,b,c);
        Max[t]=Max[t*2]&gt;?Max[t*2+1];
    }
    void Change_Same(int a,int b,int c){Change_Same(root,a,b,c);}
    void Change_Add(Tree,int a,int b,int c)
    {
        if(a&gt;=r||b&lt;=l)return;
        if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Add(This,c);return;}
        Push_Down(This);
        Change_Add(Left,a,b,c);Change_Add(Right,a,b,c);
        Max[t]=Max[t*2]&gt;?Max[t*2+1];
    }
    void Change_Add(int a,int b,int c){Change_Add(root,a,b,c);}
    void Build(int _l,int _r)
    {
        l=_l;r=_r;
        n=r-l;
        Same=New(4*n);
        Max=New(4*n);
        Add=New(4*n);
        Build(root);
    }
}T[maxn];
struct Edge
{
    int t,c;
    Edge(){}
    Edge(int _t,int _c):t(_t),c(_c){}
}Mem[maxn*2];
int mnt=0;
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator eit;
void AddEdge(int s,int t,int c)
{
    Mem[mnt]=Edge(t,c);E[s].pb(mnt);mnt++;
}
void InsEdge(int s,int t,int c)
{
    AddEdge(s,t,c);AddEdge(t,s,c);
}
int own[maxn],Q[maxn],Size[maxn],w[maxn],P[maxn];
int D[maxn],F[maxn];
void BFS(int vs)
{
    int h=0,t=0;
    for(Q[t++]=vs,D[vs]=0,w[vs]=0,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==F[x])continue;
            Q[t++]=e-&gt;t;
            D[e-&gt;t]=D[x]+1;
            w[e-&gt;t]=e-&gt;c;
            P[*it/2]=e-&gt;t;
            F[e-&gt;t]=x;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==F[x])continue;
            Size[x]+=Size[e-&gt;t];
        }
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i],next;if(own[x]&gt;=0)continue;
        int a=x;
        for(;;x=next)
        {
            next=-1;own[x]=a;
            Data[D[x]]=w[x];
            tr(it,E[x])
            {
                Edge*e=Mem+*it;
                if(e-&gt;t==F[x])continue;
                if(next==-1||Size[e-&gt;t]&gt;Size[next])
                    next=e-&gt;t;
            }
            if(next==-1)break;
        }
        T[a].Build(D[a],D[x]+1);
    }
}
int Query(int u,int v)
{
    int ret=0;
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            ret&gt;?=T[own[u]].Query(D[v]+1,D[u]+1);
            return ret;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            ret&gt;?=T[own[u]].Query(D[own[u]],D[u]+1);
            u=F[own[u]];
        }
    }
}
void Change_Same(int u,int v,int c)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            T[own[u]].Change_Same(D[v]+1,D[u]+1,c);
            return ;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            T[own[u]].Change_Same(D[own[u]],D[u]+1,c);
            u=F[own[u]];
        }
    }
}
void Change_Add(int u,int v,int c)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            T[own[u]].Change_Add(D[v]+1,D[u]+1,c);
            return ;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            T[own[u]].Change_Add(D[own[u]],D[u]+1,c);
            u=F[own[u]];
        }
    }
}
void Change_Edge(int s,int c)
{
    s=P[s];
    T[own[s]].Change_Same(D[s],D[s]+1,c);
}
inline int readT(){
    int ret; char c;
    while(c = getchar(), c &lt; '0' || c &gt; '9') ;
    ret = c - '0';
    while(c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + c - '0';
    return ret;
}
int main()
{
    cin&gt;&gt;n;int s,t,c;
    rep(i,n-1)
    {
        s=readT();t=readT();c=readT();--s;--t;
        InsEdge(s,t,c);
    }
    BFS(0);
    char cmd[100];
    for(;;)
    {
        scanf(" ");scanf("%s",cmd);
        int s,t,c;
        switch(cmd[1])
        {
            case 'a':s=readT(),t=readT(),printf("%d\n",Query(s-1,t-1));break;//Max
            case 'o':s=readT(),t=readT(),c=readT(),Change_Same(s-1,t-1,c);break;//Cover
            case 'd':s=readT(),t=readT(),c=readT(),Change_Add(s-1,t-1,c);break;//Add
            case 'h':s=readT(),t=readT(),Change_Edge(s-1,t);break;//Change
            case 't':return 0;//Stop
        }
    }
}
</pre><pre></pre><h2>Problem1984</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;assert.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(eit e=x.begin();e!=x.end();e++)
#define OK cout&lt;&lt;"It's OK!!"&lt;&lt;endl;
const int inf=~0U&gt;&gt;1,maxn=100000;
using namespace std;
int n;
struct Node{
    int l,r,same,add,Max;
    Node*lc,*rc;
    Node():lc(0),rc(0){}
}Memory[maxn*4],*Now=Memory,*T[maxn];
int Data[maxn];
void Update(Node*t)
{
    t-&gt;Max=max(t-&gt;lc-&gt;Max,t-&gt;rc-&gt;Max);
}
void Mark_Same(Node*t,int same)
{
    t-&gt;same=same;
    t-&gt;Max=same;
    t-&gt;add=0;
}
void Mark_Add(Node*t,int add)
{
    if(t-&gt;same&lt;inf)
    {
        t-&gt;Max+=add;
        t-&gt;same+=add;
        return;
    }
    t-&gt;add+=add;t-&gt;Max+=add;
}
void Push_Down(Node*t)
{
    if(t-&gt;same&lt;inf)
    {
        Mark_Same(t-&gt;lc,t-&gt;same);
        Mark_Same(t-&gt;rc,t-&gt;same);
        t-&gt;same=inf;
        return;
    }
    if(t-&gt;add)
    {
        Mark_Add(t-&gt;lc,t-&gt;add);
        Mark_Add(t-&gt;rc,t-&gt;add);
        t-&gt;add=0;
    }
}
Node*Build(int l,int r)
{
    Node*t=Now++;t-&gt;l=l;t-&gt;r=r;t-&gt;same=inf;t-&gt;add=0;
    if(l+1==r){t-&gt;Max=Data[l];return t;}
    int m=l+r&gt;&gt;1;
    t-&gt;lc=Build(l,m);t-&gt;rc=Build(m,r);
    Update(t);
    return t;
}
int Query(Node*t,int a,int b)
{
    int l=t-&gt;l,r=t-&gt;r;
    if(a&gt;=r||b&lt;=l)return 0;
    if(l&gt;=a&amp;&amp;r&lt;=b)return t-&gt;Max;
    Push_Down(t);
    return max(Query(t-&gt;lc,a,b),Query(t-&gt;rc,a,b));
}
void Change_Same(Node*t,int a,int b,int c)
{
    int l=t-&gt;l,r=t-&gt;r;
    if(a&gt;=r||b&lt;=l)return;
    if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Same(t,c);return;}
    Push_Down(t);
    Change_Same(t-&gt;lc,a,b,c);Change_Same(t-&gt;rc,a,b,c);
    Update(t);
}
void Change_Add(Node*t,int a,int b,int c)
{
    int l=t-&gt;l,r=t-&gt;r;
    if(a&gt;=r||b&lt;=l)return;
    if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Add(t,c);return;}
    Push_Down(t);
    Change_Add(t-&gt;lc,a,b,c);Change_Add(t-&gt;rc,a,b,c);
    Update(t);
}
struct Edge
{
    int t,c;
    Edge(){}
    Edge(int _t,int _c):t(_t),c(_c){}
}Mem[maxn*2];
int mnt=0;
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator eit;
void AddEdge(int s,int t,int c)
{
    Mem[mnt]=Edge(t,c);E[s].pb(mnt);mnt++;
}
void InsEdge(int s,int t,int c)
{
    AddEdge(s,t,c);AddEdge(t,s,c);
}
int own[maxn],Q[maxn],Size[maxn],w[maxn],P[maxn];
int D[maxn],F[maxn];
void BFS(int vs)
{
    int h=0,t=0;
    for(Q[t++]=vs,D[vs]=0,w[vs]=0,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==F[x])continue;
            Q[t++]=e-&gt;t;
            D[e-&gt;t]=D[x]+1;
            w[e-&gt;t]=e-&gt;c;
            P[*it/2]=e-&gt;t;
            F[e-&gt;t]=x;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==F[x])continue;
            Size[x]+=Size[e-&gt;t];
        }
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i],next;if(own[x]&gt;=0)continue;
        int a=x;
        for(;;x=next)
        {
            next=-1;own[x]=a;
            Data[D[x]]=w[x];
            tr(it,E[x])
            {
                Edge*e=Mem+*it;
                if(e-&gt;t==F[x])continue;
                if(next==-1||Size[e-&gt;t]&gt;Size[next])
                    next=e-&gt;t;
            }
            if(next==-1)break;
        }
        T[a]=Build(D[a],D[x]+1);
    }
}
#define Update(x,c) if(x&lt;c)x=c;
int Query(int u,int v)
{
    int ret=0;
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            Update(ret,Query(T[own[u]],D[v]+1,D[u]+1));
            return ret;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            Update(ret,Query(T[own[u]],D[own[u]],D[u]+1));
            u=F[own[u]];
        }
    }
}
void Change_Same(int u,int v,int c)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            Change_Same(T[own[u]],D[v]+1,D[u]+1,c);
            return ;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            Change_Same(T[own[u]],D[own[u]],D[u]+1,c);
            u=F[own[u]];
        }
    }
}
void Change_Add(int u,int v,int c)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            Change_Add(T[own[u]],D[v]+1,D[u]+1,c);
            return ;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            Change_Add(T[own[u]],D[own[u]],D[u]+1,c);
            u=F[own[u]];
        }
    }
}
void Change_Edge(int s,int c)
{
    s=P[s];
    Change_Same(T[own[s]],D[s],D[s]+1,c);
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("outMy","w",stdout);
    cin&gt;&gt;n;int s,t,c;
    rep(i,n-1)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);
        --s;--t;
        InsEdge(s,t,c);
    }
    BFS(0);
    char cmd[100];
    for(;;)
    {
        scanf(" ");scanf("%s",cmd);
        int s,t,c;
        switch(cmd[1])
        {
            case 'a':scanf("%d%d",&amp;s,&amp;t),printf("%d\n",Query(s-1,t-1));break;//Max
            case 'o':scanf("%d%d%d",&amp;s,&amp;t,&amp;c),Change_Same(s-1,t-1,c);break;//Cover
            case 'd':scanf("%d%d%d",&amp;s,&amp;t,&amp;c),Change_Add(s-1,t-1,c);break;//Add
            case 'h':scanf("%d%d",&amp;s,&amp;t),Change_Edge(s-1,t);break;//Change
            case 't':return 0;//Stop
        }
    }
}
</pre><pre></pre><h2>Problem1984</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;assert.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(eit e=x.begin();e!=x.end();e++)
#define OK cout&lt;&lt;"It's OK!!"&lt;&lt;endl;
const int inf=~0U&gt;&gt;1,maxn=100000+10;
using namespace std;
int n;
struct Node{
    int l,r,same,add,Max;
    Node*lc,*rc;
    Node():lc(0),rc(0){}
}Memory[maxn*4],*Now=Memory,*T[maxn];
int Data[maxn],Sum[maxn];
void Update(Node*t)
{
    t-&gt;Max=max(t-&gt;lc-&gt;Max,t-&gt;rc-&gt;Max);
}
void Mark_Same(Node*t,int same)
{
    t-&gt;same=same;
    t-&gt;Max=same;
    t-&gt;add=0;
}
void Mark_Add(Node*t,int add)
{
    if(t-&gt;same&lt;inf)
    {
        t-&gt;Max+=add;
        t-&gt;same+=add;
        return;
    }
    t-&gt;add+=add;t-&gt;Max+=add;
}
void Push_Down(Node*t)
{
    if(t-&gt;same&lt;inf)
    {
        Mark_Same(t-&gt;lc,t-&gt;same);
        Mark_Same(t-&gt;rc,t-&gt;same);
        t-&gt;same=inf;
        return;
    }
    if(t-&gt;add)
    {
        Mark_Add(t-&gt;lc,t-&gt;add);
        Mark_Add(t-&gt;rc,t-&gt;add);
        t-&gt;add=0;
    }
}
Node*Build(int l,int r)
{
    Node*t=Now++;t-&gt;l=l;t-&gt;r=r;t-&gt;same=inf;t-&gt;add=0;
    if(l+1==r){t-&gt;Max=Data[l];return t;}
    int tmp=(Sum[r-1]+Sum[l-1])/2;
    int m=lower_bound(Sum+l,Sum+r,tmp)-Sum+1;
    if(m==r)m--;
    t-&gt;lc=Build(l,m);t-&gt;rc=Build(m,r);
    Update(t);
    return t;
}
int Query(Node*t,int a,int b)
{
    int l=t-&gt;l,r=t-&gt;r;
    if(a&gt;=r||b&lt;=l)return 0;
    if(l&gt;=a&amp;&amp;r&lt;=b)return t-&gt;Max;
    Push_Down(t);
    return max(Query(t-&gt;lc,a,b),Query(t-&gt;rc,a,b));
}
void Change_Same(Node*t,int a,int b,int c)
{
    int l=t-&gt;l,r=t-&gt;r;
    if(a&gt;=r||b&lt;=l)return;
    if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Same(t,c);return;}
    Push_Down(t);
    Change_Same(t-&gt;lc,a,b,c);Change_Same(t-&gt;rc,a,b,c);
    Update(t);
}
void Change_Add(Node*t,int a,int b,int c)
{
    int l=t-&gt;l,r=t-&gt;r;
    if(a&gt;=r||b&lt;=l)return;
    if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Add(t,c);return;}
    Push_Down(t);
    Change_Add(t-&gt;lc,a,b,c);Change_Add(t-&gt;rc,a,b,c);
    Update(t);
}
struct Edge
{
    int t,c;
    Edge(){}
    Edge(int _t,int _c):t(_t),c(_c){}
}Mem[maxn*2];
int mnt=0;
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator eit;
void AddEdge(int s,int t,int c)
{
    Mem[mnt]=Edge(t,c);E[s].pb(mnt);mnt++;
}
void InsEdge(int s,int t,int c)
{
    AddEdge(s,t,c);AddEdge(t,s,c);
}
int own[maxn],Q[maxn],Size[maxn],w[maxn],P[maxn];
int D[maxn],F[maxn];
void BFS(int vs)
{
    int h=0,t=0;
    for(Q[t++]=vs,D[vs]=1,w[vs]=0,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==F[x])continue;
            Q[t++]=e-&gt;t;
            D[e-&gt;t]=D[x]+1;
            w[e-&gt;t]=e-&gt;c;
            P[*it/2]=e-&gt;t;
            F[e-&gt;t]=x;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==F[x])continue;
            Size[x]+=Size[e-&gt;t];
        }
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i],next;if(own[x]&gt;=0)continue;
        int a=x;Sum[D[a]-1]=0;
        for(;;x=next)
        {
            next=-1;own[x]=a;
            Data[D[x]]=w[x];
            tr(it,E[x])
            {
                Edge*e=Mem+*it;
                if(e-&gt;t==F[x])continue;
                if(next==-1||Size[e-&gt;t]&gt;Size[next])
                    next=e-&gt;t;
            }
            if(next&gt;=0)Size[x]-=Size[next];
            Sum[D[x]]=Sum[D[x]-1]+Size[x];
            if(next==-1)break;
        }
        T[a]=Build(D[a],D[x]+1);
    }
}
#define Update(x,c) if(x&lt;c)x=c;
int Query(int u,int v)
{
    int ret=0;
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            Update(ret,Query(T[own[u]],D[v]+1,D[u]+1));
            return ret;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            Update(ret,Query(T[own[u]],D[own[u]],D[u]+1));
            u=F[own[u]];
        }
    }
}
void Change_Same(int u,int v,int c)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            Change_Same(T[own[u]],D[v]+1,D[u]+1,c);
            return ;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            Change_Same(T[own[u]],D[own[u]],D[u]+1,c);
            u=F[own[u]];
        }
    }
}
void Change_Add(int u,int v,int c)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            Change_Add(T[own[u]],D[v]+1,D[u]+1,c);
            return ;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            Change_Add(T[own[u]],D[own[u]],D[u]+1,c);
            u=F[own[u]];
        }
    }
}
void Change_Edge(int s,int c)
{
    s=P[s];
    Change_Same(T[own[s]],D[s],D[s]+1,c);
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("outMy","w",stdout);
    cin&gt;&gt;n;int s,t,c;
    rep(i,n-1)
    {
        scanf("%d%d%d",&amp;s,&amp;t,&amp;c);
        --s;--t;
        InsEdge(s,t,c);
    }
    BFS(0);
    char cmd[100];
    for(;;)
    {
        scanf(" ");scanf("%s",cmd);
        int s,t,c;
        switch(cmd[1])
        {
            case 'a':scanf("%d%d",&amp;s,&amp;t),printf("%d\n",Query(s-1,t-1));break;//Max
            case 'o':scanf("%d%d%d",&amp;s,&amp;t,&amp;c),Change_Same(s-1,t-1,c);break;//Cover
            case 'd':scanf("%d%d%d",&amp;s,&amp;t,&amp;c),Change_Add(s-1,t-1,c);break;//Add
            case 'h':scanf("%d%d",&amp;s,&amp;t),Change_Edge(s-1,t);break;//Change
            case 't':return 0;//Stop
        }
    }
}
</pre><pre></pre><h2>Problem1984</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(eit e=x.begin();e!=x.end();e++)
#define OK cout&lt;&lt;"It's OK!!"&lt;&lt;endl;
#define printTime cerr&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=100000,Log=20;
using namespace std;
int n;
int Data[maxn];
int Memory[maxn*12],*Now=Memory;
int*New(int s)
{
    Now+=s;return Now-s;
}
#define Tree int t,int l,int r
#define This t,l,r
#define Left t*2,l,l+r&gt;&gt;1
#define Right t*2+1,l+r&gt;&gt;1,r
#define root 1,l,r
struct SegTree
{
    int*Same,*Max,*Add,l,r;
    void Build(Tree)
    {
        Add[t]=0;Same[t]=inf;
        if(l+1==r){Max[t]=Data[l];return;}
        Build(Left);Build(Right);
        Max[t]=Max[t*2]&gt;?Max[t*2+1];
    }
    void Mark_Add(Tree,int add)
    {
        if(Same[t]&lt;inf)
        {
            Same[t]+=add;
            Max[t]+=add;
            return;
        }
        Add[t]+=add;Max[t]+=add;
    }
    void Mark_Same(Tree,int same)
    {
        Same[t]=same;Max[t]=same;Add[t]=0;
    }
    void Push_Down(Tree)
    {
        if(Same[t]&lt;inf)
        {
            Mark_Same(Left,Same[t]);
            Mark_Same(Right,Same[t]);
            Same[t]=inf;
            return;
        }
        if(Add[t])
        {
            Mark_Add(Left,Add[t]);
            Mark_Add(Right,Add[t]);
            Add[t]=0;
        }
    }
    int Query(Tree,int a,int b)
    {
        if(a&gt;=r||b&lt;=l)return 0;
        if(l&gt;=a&amp;&amp;r&lt;=b)return Max[t];
        Push_Down(This);
        return Query(Left,a,b)&gt;?Query(Right,a,b);
    }
    int Query(int a,int b){return Query(root,a,b);}
    void Change_Same(Tree,int a,int b,int c)
    {
        if(a&gt;=r||b&lt;=l)return;
        if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Same(This,c);return;}
        Push_Down(This);
        Change_Same(Left,a,b,c);Change_Same(Right,a,b,c);
        Max[t]=Max[t*2]&gt;?Max[t*2+1];
    }
    void Change_Same(int a,int b,int c){Change_Same(root,a,b,c);}
    void Change_Add(Tree,int a,int b,int c)
    {
        if(a&gt;=r||b&lt;=l)return;
        if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Add(This,c);return;}
        Push_Down(This);
        Change_Add(Left,a,b,c);Change_Add(Right,a,b,c);
        Max[t]=Max[t*2]&gt;?Max[t*2+1];
    }
    void Change_Add(int a,int b,int c){Change_Add(root,a,b,c);}
    void Build(int _l,int _r)
    {
        l=_l;r=_r;
        n=r-l;
        Same=New(4*n);
        Max=New(4*n);
        Add=New(4*n);
        Build(root);
    }
}T[maxn];
struct Edge
{
    int t,c;
    Edge(){}
    Edge(int _t,int _c):t(_t),c(_c){}
}Mem[maxn*2];
int mnt=0;
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator eit;
void AddEdge(int s,int t,int c)
{
    Mem[mnt]=Edge(t,c);E[s].pb(mnt);mnt++;
}
void InsEdge(int s,int t,int c)
{
    AddEdge(s,t,c);AddEdge(t,s,c);
}
int own[maxn],Q[maxn],Size[maxn],w[maxn],P[maxn];
int D[maxn],F[maxn];
void BFS(int vs)
{
    int h=0,t=0;
    for(Q[t++]=vs,D[vs]=0,w[vs]=0,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==F[x])continue;
            Q[t++]=e-&gt;t;
            D[e-&gt;t]=D[x]+1;
            w[e-&gt;t]=e-&gt;c;
            P[*it/2]=e-&gt;t;
            F[e-&gt;t]=x;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==F[x])continue;
            Size[x]+=Size[e-&gt;t];
        }
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i],next;if(own[x]&gt;=0)continue;
        int a=x;
        for(;;x=next)
        {
            next=-1;own[x]=a;
            Data[D[x]]=w[x];
            tr(it,E[x])
            {
                Edge*e=Mem+*it;
                if(e-&gt;t==F[x])continue;
                if(next==-1||Size[e-&gt;t]&gt;Size[next])
                    next=e-&gt;t;
            }
            if(next==-1)break;
        }
        T[a].Build(D[a],D[x]+1);
    }
}
int Query(int u,int v)
{
    int ret=0;
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            ret&gt;?=T[own[u]].Query(D[v]+1,D[u]+1);
            return ret;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            ret&gt;?=T[own[u]].Query(D[own[u]],D[u]+1);
            u=F[own[u]];
        }
    }
}
void Change_Same(int u,int v,int c)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            T[own[u]].Change_Same(D[v]+1,D[u]+1,c);
            return ;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            T[own[u]].Change_Same(D[own[u]],D[u]+1,c);
            u=F[own[u]];
        }
    }
}
void Change_Add(int u,int v,int c)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            T[own[u]].Change_Add(D[v]+1,D[u]+1,c);
            return ;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            T[own[u]].Change_Add(D[own[u]],D[u]+1,c);
            u=F[own[u]];
        }
    }
}
void Change_Edge(int s,int c)
{
    s=P[s];
    T[own[s]].Change_Same(D[s],D[s]+1,c);
}
#define BUFSIZE 1000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
#define read() \
	do{ \
		if (pt &gt;= pend) \
		{ \
			pt = buf; \
			fread(buf, 1, BUFSIZE, stdin); \
		} \
	} while(0)

#define scan(t) \
{ \
	t = 0; \
	read(); \
	while (!((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {pt ++; read();} \
	while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
}
#define scan_str(s) \
{ \
	int p = 0; \
	read(); \
	while ((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\r') {pt ++; read();}\
	while (!((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\n')) {s[p ++] = (*(pt ++)); read();} \
	s[p] = 0; \
}
int main()
{
    scan(n);int s,t,c;
    rep(i,n-1)
    {
        scan(s);scan(t);scan(c);--s;--t;
        InsEdge(s,t,c);
    }
    BFS(0);
    char cmd[100];
    for(;;)
    {
        scan_str(cmd);
        int s,t,c;
        switch(cmd[1])
        {
            case 'a':scan(s);scan(t);printf("%d\n",Query(s-1,t-1));break;//Max
            case 'o':scan(s);scan(t);scan(c);Change_Same(s-1,t-1,c);break;//Cover
            case 'd':scan(s);scan(t);scan(c);Change_Add(s-1,t-1,c);break;//Add
            case 'h':scan(s);scan(t);Change_Edge(s-1,t);break;//Change
            case 't':return 0;//Stop
        }
    }
}
</pre><pre></pre><h2>Problem1984</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(eit e=x.begin();e!=x.end();e++)
#define OK cout&lt;&lt;"It's OK!!"&lt;&lt;endl;
#define printTime cerr&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=100000,Log=20;
using namespace std;
int n;
int Data[maxn];
int Memory[maxn*12],*Now=Memory;
int*New(int s)
{
    Now+=s;return Now-s;
}
#define Tree int t,int l,int r
#define This t,l,r
#define Left t*2,l,l+r&gt;&gt;1
#define Right t*2+1,l+r&gt;&gt;1,r
#define root 1,l,r
struct SegTree
{
    int*Same,*Max,*Add,l,r;
    void Build(Tree)
    {
        Add[t]=0;Same[t]=inf;
        if(l+1==r){Max[t]=Data[l];return;}
        Build(Left);Build(Right);
        Max[t]=Max[t*2]&gt;?Max[t*2+1];
    }
    void Mark_Add(Tree,int add)
    {
        if(Same[t]&lt;inf)
        {
            Same[t]+=add;
            Max[t]+=add;
            return;
        }
        Add[t]+=add;Max[t]+=add;
    }
    void Mark_Same(Tree,int same)
    {
        Same[t]=same;Max[t]=same;Add[t]=0;
    }
    void Push_Down(Tree)
    {
        if(Same[t]&lt;inf)
        {
            Mark_Same(Left,Same[t]);
            Mark_Same(Right,Same[t]);
            Same[t]=inf;
            return;
        }
        if(Add[t])
        {
            Mark_Add(Left,Add[t]);
            Mark_Add(Right,Add[t]);
            Add[t]=0;
        }
    }
    int Query(Tree,int a,int b)
    {
        if(a&gt;=r||b&lt;=l)return 0;
        if(l&gt;=a&amp;&amp;r&lt;=b)return Max[t];
        Push_Down(This);
        return Query(Left,a,b)&gt;?Query(Right,a,b);
    }
    int Query(int a,int b){return Query(root,a,b);}
    void Change_Same(Tree,int a,int b,int c)
    {
        if(a&gt;=r||b&lt;=l)return;
        if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Same(This,c);return;}
        Push_Down(This);
        Change_Same(Left,a,b,c);Change_Same(Right,a,b,c);
        Max[t]=Max[t*2]&gt;?Max[t*2+1];
    }
    void Change_Same(int a,int b,int c){Change_Same(root,a,b,c);}
    void Change_Add(Tree,int a,int b,int c)
    {
        if(a&gt;=r||b&lt;=l)return;
        if(l&gt;=a&amp;&amp;r&lt;=b){Mark_Add(This,c);return;}
        Push_Down(This);
        Change_Add(Left,a,b,c);Change_Add(Right,a,b,c);
        Max[t]=Max[t*2]&gt;?Max[t*2+1];
    }
    void Change_Add(int a,int b,int c){Change_Add(root,a,b,c);}
    void Build(int _l,int _r)
    {
        l=_l;r=_r;
        n=r-l;
        Same=New(4*n);
        Max=New(4*n);
        Add=New(4*n);
        Build(root);
    }
}T[maxn];
struct Edge
{
    int t,c;
    Edge(){}
    Edge(int _t,int _c):t(_t),c(_c){}
}Mem[maxn*2];
int mnt=0;
vector&lt;int&gt; E[maxn];
typedef vector&lt;int&gt;::iterator eit;
void AddEdge(int s,int t,int c)
{
    Mem[mnt]=Edge(t,c);E[s].pb(mnt);mnt++;
}
void InsEdge(int s,int t,int c)
{
    AddEdge(s,t,c);AddEdge(t,s,c);
}
int own[maxn],Q[maxn],Size[maxn],w[maxn],P[maxn];
int D[maxn],F[maxn];
void BFS(int vs)
{
    int h=0,t=0;
    for(Q[t++]=vs,D[vs]=0,w[vs]=0,F[vs]=-1;h&lt;t;h++)
    {
        int x=Q[h];
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==F[x])continue;
            Q[t++]=e-&gt;t;
            D[e-&gt;t]=D[x]+1;
            w[e-&gt;t]=e-&gt;c;
            P[*it/2]=e-&gt;t;
            F[e-&gt;t]=x;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];Size[x]=1;
        tr(it,E[x])
        {
            Edge*e=Mem+*it;
            if(e-&gt;t==F[x])continue;
            Size[x]+=Size[e-&gt;t];
        }
    }
    memset(own,-1,sizeof own);
    for(int i=0;i&lt;h;i++)
    {
        int x=Q[i],next;if(own[x]&gt;=0)continue;
        int a=x;
        for(;;x=next)
        {
            next=-1;own[x]=a;
            Data[D[x]]=w[x];
            tr(it,E[x])
            {
                Edge*e=Mem+*it;
                if(e-&gt;t==F[x])continue;
                if(next==-1||Size[e-&gt;t]&gt;Size[next])
                    next=e-&gt;t;
            }
            if(next==-1)break;
        }
        T[a].Build(D[a],D[x]+1);
    }
}
int Query(int u,int v)
{
    int ret=0;
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            ret&gt;?=T[own[u]].Query(D[v]+1,D[u]+1);
            return ret;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            ret&gt;?=T[own[u]].Query(D[own[u]],D[u]+1);
            u=F[own[u]];
        }
    }
}
void Change_Same(int u,int v,int c)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            T[own[u]].Change_Same(D[v]+1,D[u]+1,c);
            return ;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            T[own[u]].Change_Same(D[own[u]],D[u]+1,c);
            u=F[own[u]];
        }
    }
}
void Change_Add(int u,int v,int c)
{
    for(;;)
    {
        if(D[u]&lt;D[v])swap(u,v);
        if(own[u]==own[v])
        {
            T[own[u]].Change_Add(D[v]+1,D[u]+1,c);
            return ;
        }
        else
        {
            if(D[own[u]]&lt;D[own[v]])swap(u,v);
            T[own[u]].Change_Add(D[own[u]],D[u]+1,c);
            u=F[own[u]];
        }
    }
}
void Change_Edge(int s,int c)
{
    s=P[s];
    T[own[s]].Change_Same(D[s],D[s]+1,c);
}
#define BUFSIZE 1000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
#define read() \
	do{ \
		if (pt &gt;= pend) \
		{ \
			pt = buf; \
			fread(buf, 1, BUFSIZE, stdin); \
		} \
	} while(0)

#define scan(t) \
{ \
	t = 0; \
	read(); \
	while (!((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {pt ++; read();} \
	while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
}
#define scan_str(s) \
{ \
	int p = 0; \
	read(); \
	while ((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\r') {pt ++; read();}\
	while (!((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\n')) {s[p ++] = (*(pt ++)); read();} \
	s[p] = 0; \
}
int A[20],k;
inline void print_int(int x)
{
    k=0;while(x)A[k++]=x%10,x/=10;
    for(int i=k-1;i&gt;=0;i--)putchar('0'+A[i]);
    putchar('\n');
}
int main()
{
    scan(n);int s,t,c;
    rep(i,n-1)
    {
        scan(s);scan(t);scan(c);--s;--t;
        InsEdge(s,t,c);
    }
    BFS(0);
    char cmd[100];
    for(;;)
    {
        scan_str(cmd);
        int s,t,c;
        switch(cmd[1])
        {
            case 'a':scan(s);scan(t);print_int(Query(s-1,t-1));break;//Max
            case 'o':scan(s);scan(t);scan(c);Change_Same(s-1,t-1,c);break;//Cover
            case 'd':scan(s);scan(t);scan(c);Change_Add(s-1,t-1,c);break;//Add
            case 'h':scan(s);scan(t);Change_Edge(s-1,t);break;//Change
            case 't':return 0;//Stop
        }
    }
}
</pre><pre></pre><h2>Problem1989</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxn=10000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef vector&lt;int&gt;::iterator it;
vector&lt;int&gt; E[maxn];
int n,Size[maxn];
double Ans,Sum[maxn];
void Clear()
{
    rep(i,maxn)E[i].clear();
}

void AddEdge(int s,int t)
{
    E[s].pb(t);E[t].pb(s);
}

bool Init()
{
    Clear();
    if(scanf("%d",&amp;n)!=1)return false;

    int s,t;
    rep(i,n-1)
    {
        scanf("%d%d",&amp;s,&amp;t);
        --s;--t;
        AddEdge(s,t);
    }

    return true;
}
void Dfs(int x,int f)
{
    Size[x]=1;Sum[x]=0;
    tr(e,E[x])if(*e!=f)
    {
        Dfs(*e,x);
        Size[x]+=Size[*e];
    }
    tr(e,E[x])if(*e!=f)
    {
        double c=double(Size[*e])*(n-Size[*e])/(n*(n-1)/2);
        //cout&lt;&lt;(*e)&lt;&lt;"&lt;-&gt;"&lt;&lt;x&lt;&lt;":"&lt;&lt;c&lt;&lt;endl;
        Sum[x]+=Size[*e]*c+Sum[*e];
        Ans+=(Size[x]-Size[*e])*(Sum[*e]+c*Size[*e]);
    }
}

void Solve()
{
    Ans=0;
    Dfs(0,-1);
    printf("%0.6lf\n",Ans/((n-1)*n/2));
}
int main()
{
    //freopen("in","r",stdin);
    while(Init())Solve();
}


</pre><pre></pre><h2>Problem1989</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define tr(e,x) for(it e=x.begin();e!=x.end();e++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxn=10000;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef vector&lt;int&gt;::iterator it;
vector&lt;int&gt; E[maxn];
int n,Size[maxn];
double Ans,Sum[maxn];
void Clear()
{
    rep(i,maxn)E[i].clear();
}

void AddEdge(int s,int t)
{
    E[s].pb(t);E[t].pb(s);
}

bool Init()
{
    Clear();
    if(scanf("%d",&amp;n)!=1)return false;

    int s,t;
    rep(i,n-1)
    {
        scanf("%d%d",&amp;s,&amp;t);
        --s;--t;
        AddEdge(s,t);
    }

    return true;
}
void Dfs(int x,int f)
{
    Size[x]=1;Sum[x]=0;
    tr(e,E[x])if(*e!=f)
    {
        Dfs(*e,x);
        Size[x]+=Size[*e];
        double c=double(Size[*e])*(n-Size[*e])/(n*(n-1)/2);
        Ans+=c*c;
    }
}

void Solve()
{
    Ans=0;
    Dfs(0,-1);
    printf("%0.6lf\n",Ans);
}
int main()
{
    //freopen("in","r",stdin);
    while(Init())Solve();
}


</pre><pre></pre><h2>Problem1996</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=1000,mod=19650827;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int Dp[maxn][maxn][2]={};
int A[maxn],n;
inline void Update(int&amp;x,int c)
{
    x+=c;if(x&gt;=mod)x-=mod;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n;rep(i,n)scanf("%d",A+i),Dp[i][i][0]=1;
    for(int s=1;s&lt;n;s++)
        for(int l=0;l+s&lt;=n;l++)
        {
            int r=s+l;
            {
                int&amp;ret=Dp[l][r][0];
                if(A[l]&lt;A[l+1])Update(ret,Dp[l+1][r][0]);
                if(A[l]&lt;A[r])Update(ret,Dp[l+1][r][1]);
            }
            {
                int&amp;ret=Dp[l][r][1];
                if(A[r]&gt;A[r-1])Update(ret,Dp[l][r-1][1]);
                if(A[r]&gt;A[l])Update(ret,Dp[l][r-1][0]);
            }
        }
    int ans=0;Update(ans,Dp[0][n-1][0]);
    Update(ans,Dp[0][n-1][1]);
    printf("%d\n",ans);
}


</pre><pre></pre><h2>Problem1997</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=200+10,maxm=10000+10;
using namespace std;
struct Edge
{
    int s,t;
};
Edge E[maxm];
vector&lt;int&gt; Begin[maxn];
int n,m;
int Map[maxn+1],color[maxm];
void Init()
{
    scanf("%d%d",&amp;n,&amp;m);int u,v;
    rep(i,n)Begin[i].clear();
    rep(id,m)
    {
        color[id]=-1;
        scanf("%d%d",&amp;E[id].s,&amp;E[id].t);
    }
    int x;
    rep(i,n)scanf("%d",&amp;x),Map[x]=i;
    rep(id,m)
    {
        u=E[id].s;v=E[id].t;
        u=Map[u];v=Map[v];
        if(u&gt;v)swap(u,v);
        E[id].s=u;E[id].t=v;
        Begin[u].pb(id);Begin[v].pb(id);
    }
}
bool dfs(int id)
{
    int l=E[id].s,r=E[id].t;
    //Check Right Intersect
    for(int t=l+1;t&lt;=r-1;t++)
        tr(e,Begin[t])
        {
            Edge&amp;that=E[*e];
            if(that.s&lt;l||that.t&gt;r)
                if(color[*e]==-1)
                {
                    color[*e]=!color[id];
                    if(!dfs(*e))return false;
                }
                else
                {
                    if(color[*e]==color[id])
                        return false;
                }
        }
    return true;
}
bool Check_Bipart()
{
    rep(i,m)if(color[i]==-1)
    {
        color[i]=0;
        if(!dfs(i))return false;
    }
    return true;
}
int main()
{
    //freopen("in","r",stdin);
    int ncase;
    scanf("%d",&amp;ncase);
    rep(i,ncase)
    {
        Init();
        if(Check_Bipart())
            puts("YES");
        else
            puts("NO");
    }
}



</pre><pre></pre><h2>Problem1999</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(vector&lt;Edge&gt;::iterator e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=500000+10;
using namespace std;
int F[maxn],D[maxn],h,t,n,L;
struct Edge
{
    int t,c;
    Edge(int _t,int _c):
        t(_t),c(_c){}
};
vector&lt;Edge&gt; E[maxn];
void AddEdge(int s,int t,int c)
{
    E[s].pb(Edge(t,c));
    E[t].pb(Edge(s,c));
}
int MaxD[maxn];
void BFS(int vs)
{
    h=t=0;
    static int Q[maxn];
    for(Q[t++]=vs,F[vs]=-1,D[vs]=0;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,E[x])if(e-&gt;t!=F[x])
        {
            Q[t++]=e-&gt;t;
            F[e-&gt;t]=x;
            D[e-&gt;t]=D[x]+e-&gt;c;
        }
    }
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];MaxD[x]=D[x];
        tr(e,E[x])if(F[e-&gt;t]==x)
        {
            MaxD[x]=max(MaxD[x],MaxD[e-&gt;t]);
        }
    }
}
int FindMax(int vs)
{
    BFS(vs);int u=0;
    rep(i,n)if(D[i]&gt;D[u])u=i;
    return u;
}
void scan(int&amp;ret)
{
    char c;
    while(c=getchar(),c&lt;'0'||c&gt;'9');
    ret=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')ret=ret*10+c-'0';
}
void Init()
{
    scan(n);scan(L);int s,t,c;
    rep(i,n-1)
    {
        scan(s);scan(t);scan(c);
        --s;--t;
        AddEdge(s,t,c);
    }
}
struct node
{
    int l,r;
    node(){}
    node(int _l,int _r):
        l(_l),r(_r){}
};
node Q[maxn];
int Dist[maxn],Max[maxn],Line[maxn],s;
void Solve()
{
    int u=FindMax(0);
    int v=FindMax(u),x=v;
    s=0;
    while(x!=-1)Line[s++]=x,x=F[x];
    reverse(Line,Line+s);Line[s]=-1;
    for(int i=0;i&lt;s;i++)
    {
        int x=Line[i];
        Max[i]=0;Dist[i]=D[x];
        tr(e,E[x])if(e-&gt;t!=Line[i+1]&amp;&amp;e-&gt;t!=F[x])
        {
            Max[i]=max(Max[i],MaxD[e-&gt;t]-Dist[i]);
        }
        //cout&lt;&lt;x+1&lt;&lt;" "&lt;&lt;Max[i]&lt;&lt;" "&lt;&lt;Dist[i]&lt;&lt;endl;
    }
    multiset&lt;int&gt; S;
    #define Cal(x) (max(Max[Q[x].r],Dist[Q[x].l]))
    int Ans=inf;h=t=0;
    for(int i=0;i&lt;s;i++)
    {
        while(h&lt;t&amp;&amp;Dist[i]-Dist[Q[h].l]&gt;L)
        {
            int od=Cal(h);
            Q[h].l++;
            S.erase(S.find(od));
            if(Q[h].l&gt;Q[h].r)h++;
            else
                S.insert(Cal(h));
        }
        node nx(i,i);
        while(h&lt;t&amp;&amp;Max[Q[t-1].r]&lt;=Max[nx.r])
        {
            nx.l=Q[t-1].l;
            S.erase(S.find(Cal(t-1)));
            t--;
        }
        Q[t++]=nx;
        S.insert(Cal(t-1));
        int ret=max(*S.begin(),Dist[s-1]-Dist[i]);
        if(ret&lt;Ans)Ans=ret;
    }
    printf("%d\n",Ans);
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}
</pre><pre></pre><h2>Problem1999</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(vector&lt;Edge&gt;::iterator e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;clock()-pre&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=500000+10;
using namespace std;
int F[maxn],D[maxn],h,t,n,L;
struct Edge
{
    int t,c;
    Edge(int _t,int _c):
        t(_t),c(_c){}
};
vector&lt;Edge&gt; E[maxn];
void AddEdge(int s,int t,int c)
{
    E[s].pb(Edge(t,c));
    E[t].pb(Edge(s,c));
}
int MaxD[maxn];
void BFS(int vs,bool need)
{
    h=t=0;
    static int Q[maxn];
    for(Q[t++]=vs,F[vs]=-1,D[vs]=0;h&lt;t;h++)
    {
        int x=Q[h];
        tr(e,E[x])if(e-&gt;t!=F[x])
        {
            Q[t++]=e-&gt;t;
            F[e-&gt;t]=x;
            D[e-&gt;t]=D[x]+e-&gt;c;
        }
    }
    if(!need)return;
    for(int i=h-1;i&gt;=0;i--)
    {
        int x=Q[i];MaxD[x]=D[x];
        tr(e,E[x])if(F[e-&gt;t]==x)
        {
            MaxD[x]=max(MaxD[x],MaxD[e-&gt;t]);
        }
    }
}
void scan(int&amp;ret)
{
    char c;
    while(c=getchar(),c&lt;'0'||c&gt;'9');
    ret=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')ret=ret*10+c-'0';
}
void Init()
{
    scan(n);scan(L);int s,t,c;
    rep(i,n-1)
    {
        scan(s);scan(t);scan(c);
        --s;--t;
        AddEdge(s,t,c);
    }
}
struct node
{
    int l,r;
    node(){}
    node(int _l,int _r):
        l(_l),r(_r){}
};
node Q[maxn];
int Dist[maxn],Max[maxn],Line[maxn],s;
int FindMax(int vs,bool need)
{
    BFS(vs,need);int u=0;
    rep(i,n)if(D[i]&gt;D[u])u=i;
    return u;
}
void Solve()
{
    int u=FindMax(0,false);
    int v=FindMax(u,true),x=v;
    s=0;
    while(x!=-1)Line[s++]=x,x=F[x];
    reverse(Line,Line+s);Line[s]=-1;
    for(int i=0;i&lt;s;i++)
    {
        int x=Line[i];
        Max[i]=0;Dist[i]=D[x];
        tr(e,E[x])if(e-&gt;t!=Line[i+1]&amp;&amp;e-&gt;t!=F[x])
        {
            Max[i]=max(Max[i],MaxD[e-&gt;t]-Dist[i]);
        }
        //cout&lt;&lt;x+1&lt;&lt;" "&lt;&lt;Max[i]&lt;&lt;" "&lt;&lt;Dist[i]&lt;&lt;endl;
    }
    #define Cal(x) (max(Max[Q[x].r],Dist[Q[x].l]))
    int Ans=inf;h=t=0;
    for(int i=0;i&lt;s;i++)
    {
        while(h&lt;t&amp;&amp;Dist[i]-Dist[Q[h].l]&gt;L)
        {
            Q[h].l++;
            if(Q[h].l&gt;Q[h].r)h++;
            else
            {
                if(h+1&lt;t&amp;&amp;Cal(h)&gt;=Cal(h+1))
                    h++;
            }
        }
        node nx(i,i);
        while(h&lt;t&amp;&amp;Max[Q[t-1].r]&lt;=Max[nx.r])
        {
            nx.l=Q[t-1].l;
            t--;
        }
        Q[t++]=nx;
        while(h+1&lt;t&amp;&amp;Cal(t-2)&gt;=Cal(t-1))
            Q[t-2]=Q[t-1],t--;
        int ret=max(Cal(h),Dist[s-1]-Dist[i]);
        if(ret&lt;Ans)Ans=ret;
    }
    printf("%d\n",Ans);
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}
</pre><pre></pre><h2>Problem2001</h2><pre>/*
 * City.cpp
 *
 *  Created on: 2011-7-2
 *      Author: mac
 */

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;
#include &lt;string&gt;
using namespace std;

const int MAX_N_VERTICES = 20000 + 10;
const int MAX_N_EDGES = 50000 + 10;
const int MAX_N_OPERATIONES = 50000 + 10;

typedef long long int64;
int nVertices, nEdges, nOperations;

struct DisJointSet {
	int father[MAX_N_VERTICES];
	int rank[MAX_N_VERTICES];

	void init(int vertices[], int nVertices) {
		for (int i = 0; i &lt; nVertices; ++i) {
			int u = vertices[i];
			father[u] = u;
			rank[u] = 0;
		}
	}

	int find(int x) {
		if (x == father[x])
			return x;
		return father[x] = find(father[x]);
	}

	bool unite(int a, int b) {
		a = find(a), b = find(b);
		if (a == b)
			return false;
		if (rank[a] &lt; rank[b]) {
			father[a] = b;
		} else {
			father[b] = a;
			rank[a] += rank[a] == rank[b];
		}
		return true;
	}
};
const int MAX_STACK_DEPTH = MAX_N_OPERATIONES * 4;
DisJointSet disJointSet;
int64 ans[MAX_N_OPERATIONES];
int cur;
int vs[MAX_STACK_DEPTH];
int a[MAX_STACK_DEPTH], b[MAX_STACK_DEPTH], c[MAX_STACK_DEPTH];
int id[MAX_STACK_DEPTH], nc[MAX_STACK_DEPTH];

void readInput() {
	cin &gt;&gt; nVertices &gt;&gt; nEdges &gt;&gt; nOperations;
	for (int i = 0; i &lt; nEdges; ++i) {
		scanf("%d%d%d", a + i, b + i, c + i);
		--a[i], --b[i];
	}
	for (int i = 0; i &lt; nOperations; ++i) {
		scanf("%d%d", id + i, nc + i);
		--id[i];
	}
}

struct Comparator {
	int*ref;
	Comparator(int*_ref) :
			ref(_ref) {
	}
	bool operator()(int a, int b) {
		return ref[a] &lt; ref[b];
	}
};

void recursive(int vs[], int nVs, int a[], int b[], int c[], int nEs, int id[],
		int nc[], int nOp, int64 ans) {
	static int ord[MAX_N_EDGES];
	if (nOp == 1) {
		c[id[0]] = nc[0];
		for (int i = 0; i &lt; nEs; ++i) {
			ord[i] = i;
		}
		sort(ord, ord + nEs, Comparator(c));
		disJointSet.init(vs, nVs);
		for (int i = 0; i &lt; nEs; ++i) {
			int o = ord[i];
			if (disJointSet.unite(a[o], b[o]))
				ans += c[o];
		}
		::ans[cur++] = ans;
		return;
	}
	static bool mark[MAX_N_EDGES];
	fill(mark, mark + nEs, false);
	for (int i = 0; i &lt; nOp; ++i) {
		mark[id[i]] = true;
	}
	for (int i = 0; i &lt; nEs; ++i) {
		ord[i] = i;
	}
	sort(ord, ord + nEs, Comparator(c));
	static int newId[MAX_N_EDGES];
	int cnt = 0;
	disJointSet.init(vs, nVs);
	{
		static int na[MAX_N_EDGES], nb[MAX_N_EDGES], nc[MAX_N_EDGES];
		static bool nm[MAX_N_EDGES];
		for (int i = 0; i &lt; nEs; ++i) {
			int o = ord[i];
			if (mark[o]) {
				newId[o] = cnt;
				na[cnt] = a[o], nb[cnt] = b[o], nc[cnt] = c[o], nm[cnt] =
						mark[o];
				++cnt;
			}
			if (!mark[o] &amp;&amp; disJointSet.unite(a[o], b[o])) {
				na[cnt] = a[o], nb[cnt] = b[o], nc[cnt] = c[o], nm[cnt] =
						mark[o];
				++cnt;
			}
		}
		memcpy(a, na, sizeof(int) * cnt);
		memcpy(b, nb, sizeof(int) * cnt);
		memcpy(c, nc, sizeof(int) * cnt);
		memcpy(mark, nm, sizeof(bool) * cnt);
	}

	for (int i = 0; i &lt; nOp; ++i) {
		id[i] = newId[id[i]];
//		assert(mark[id[i]]);
	}
	nEs = cnt;

	static bool used[MAX_N_EDGES];

	disJointSet.init(vs, nVs);

	for (int i = 0; i &lt; nEs; ++i) {
		if (mark[i]) {
			used[i] = disJointSet.unite(a[i], b[i]);
		}
	}

	for (int i = 0; i &lt; nEs; ++i) {
		if (!mark[i]) {
			used[i] = disJointSet.unite(a[i], b[i]);
		}
	}

	disJointSet.init(vs, nVs);

	for (int i = 0; i &lt; nEs; ++i) {
		if (!mark[i] &amp;&amp; used[i]) {
			disJointSet.unite(a[i], b[i]);
			ans += c[i];
		}
	}

	for (int i = 0; i &lt; nEs; ++i) {
		a[i] = disJointSet.find(a[i]);
		b[i] = disJointSet.find(b[i]);
	}

	cnt = 0;
	for (int i = 0; i &lt; nVs; ++i) {
		int u = vs[i];
		if (disJointSet.father[u] == u)
			vs[cnt++] = u;
	}
	nVs = cnt;

	int*newVs = vs + nVs;
	for (int i = 0; i &lt; nVs; ++i) {
		newVs[i] = vs[i];
	}
	int*newa = a + nEs, *newb = b + nEs, *newc = c + nEs;
	for (int i = 0; i &lt; nEs; ++i) {
		newa[i] = a[i], newb[i] = b[i], newc[i] = c[i];
	}
	int*nid = id + nOp, *newnc = nc + nOp;
	int mid = nOp / 2;
	for (int i = 0; i &lt; mid; ++i) {
		nid[i] = id[i], newnc[i] = nc[i];
	}

	recursive(newVs, nVs, newa, newb, newc, nEs, nid, newnc, mid, ans);

	for (int i = 0; i &lt; mid; ++i) {
		c[id[i]] = nc[i];
	}
	for (int i = 0; i &lt; nVs; ++i) {
		newVs[i] = vs[i];
	}
	for (int i = 0; i &lt; nEs; ++i) {
		newa[i] = a[i], newb[i] = b[i], newc[i] = c[i];
	}
	for (int i = mid; i &lt; nOp; ++i) {
		nid[i - mid] = id[i], newnc[i - mid] = nc[i];
	}

	recursive(newVs, nVs, newa, newb, newc, nEs, nid, newnc, nOp - mid, ans);
}

template&lt;class T&gt; void print(T a) {
	static int digits[100];
	int cnt = 0;
	if (!a) {
		printf("0");
		return;
	}
	while (a) {
		digits[cnt++] = a % 10;
		a /= 10;
	}
	for (int i = cnt - 1; i &gt;= 0; --i) {
		putchar('0' + digits[i]);
	}
}

void work() {
	cur = 0;
	for (int i = 0; i &lt; nVertices; ++i) {
		vs[i] = i;
	}
	recursive(vs, nVertices, a, b, c, nEdges, id, nc, nOperations, 0);
}

void solve() {
	readInput();
	work();
	for (int i = 0; i &lt; cur; ++i) {
		print(ans[i]);
		printf("\n");
	}
}

int64 ansBrute[MAX_N_OPERATIONES];
void workBrute() {
	static int ord[MAX_N_EDGES];
	for (int i = 0; i &lt; nEdges; ++i) {
		ord[i] = i;
	}
	for (int i = 0; i &lt; nVertices; ++i) {
		vs[i] = i;
	}
	static int oldC[MAX_N_EDGES];
	memcpy(oldC, c, sizeof oldC);
	for (int i = 0; i &lt; nOperations; ++i) {
		c[id[i]] = nc[i];
		sort(ord, ord + nEdges, Comparator(c));
		disJointSet.init(vs, nVertices);
		int64 ans = 0;
		for (int j = 0; j &lt; nEdges; ++j) {
			int o = ord[j];
			if (disJointSet.unite(a[o], b[o]))
				ans += c[o];
		}
		ansBrute[i] = ans;
	}
	memcpy(c, oldC, sizeof oldC);
}

void runTest() {
	nVertices = 1000;
	nEdges = 5000;
	nOperations = 1000;
	for (int i = 0; i &lt; nVertices; ++i) {
		a[i] = i, b[i] = (i + 1) % nVertices, c[i] = rand();
	}
	for (int i = nVertices; i &lt; nEdges; ++i) {
		a[i] = rand() % nVertices, b[i] = rand() % nVertices, c[i] = rand();
	}
	for (int i = 0; i &lt; nOperations; ++i) {
		id[i] = rand() % nEdges;
		nc[i] = rand();
	}

	workBrute();
	work();

	for (int i = 0; i &lt; nOperations; ++i) {
		assert(ans[i]==ansBrute[i]);
	}

	cout &lt;&lt; "good" &lt;&lt; endl;
}

void setIO() {
	string name = "City";
	string inFile = name + ".in";
	string outFile = name + ".out";
	freopen(inFile.c_str(), "r", stdin);
	freopen(outFile.c_str(), "w", stdout);
}

void runSpeedTest() {
	nVertices = 20000;
	nEdges = 50000;
	nOperations = 50000;

	for (int i = 0; i &lt; nVertices; ++i) {
		a[i] = i, b[i] = (i + 1) % nVertices, c[i] = rand();
	}
	for (int i = nVertices; i &lt; nEdges; ++i) {
		a[i] = rand() % nVertices, b[i] = rand() % nVertices, c[i] = rand();
	}
	for (int i = 0; i &lt; nOperations; ++i) {
		id[i] = rand() % nEdges;
		nc[i] = rand();
	}

	work();
}

int main() {
	solve();
	return 0;
}
</pre><pre></pre><h2>Problem2001</h2><pre>/*
 * 2001: [Hnoi2010]City 城市建设.cpp
 *
 *  Created on: 2011-7-4
 *      Author: mac
 */

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;
using namespace std;
const int MAX_N_VERTICES = 20000 + 10;
const int MAX_N_EDGES = 50000 + 10;
const int MAX_N_OPERATIONES = 50000 + 10;
const int MAX_N_STORAGE = 2000000 + 10;

struct Edge {
	int a, b, c;
	Edge*next;
	bool modified;
	bool used;
	bool merged;
	void read() {
		scanf("%d%d%d", &amp;a, &amp;b, &amp;c);
		--a, --b;
	}
	void set(int _a, int _b, int _c) {
		a = _a, b = _b, c = _c;
	}
	bool operator&lt;(const Edge&amp;e) const {
		return c &lt; e.c;
	}
};
Edge edges[MAX_N_STORAGE];

struct Operation {
	int c;
	Edge*e;
	void read() {
		int eid;
		scanf("%d%d", &amp;eid, &amp;c);
		e = edges + --eid;
	}
};

Operation operations[MAX_N_STORAGE];
int nOperations, nVertices, nEdges;
int vertices[MAX_N_STORAGE];

void readInput() {
	scanf("%d%d%d", &amp;nVertices, &amp;nEdges, &amp;nOperations);
	for (int i = 0; i &lt; nVertices; ++i) {
		vertices[i] = i;
	}
	for (int i = 0; i &lt; nEdges; ++i) {
		edges[i].read();
	}
	for (int i = 0; i &lt; nOperations; ++i) {
		operations[i].read();
	}
}

int indexs[MAX_N_STORAGE];
typedef long long int64;
int64 ans[MAX_N_OPERATIONES];
int cur;

const int MAX_N_INDEXS = MAX_N_EDGES + MAX_N_OPERATIONES;
Edge*first[MAX_N_INDEXS];

struct DisjointSet {
	int father[MAX_N_VERTICES];
	int rank[MAX_N_VERTICES];

	void init(int vertices[], int nVertices) {
		for (int i = 0; i &lt; nVertices; ++i) {
			int u = vertices[i];
			father[u] = u;
			rank[u] = 0;
		}
	}

	int find(int x) {
		if (x == father[x])
			return x;
		return father[x] = find(father[x]);
	}

	bool unite(int a, int b) {
		a = find(a), b = find(b);
		if (a == b)
			return false;
		if (rank[a] &lt; rank[b]) {
			father[a] = b;
		} else {
			father[b] = a;
			rank[a] += rank[a] == rank[b];
		}
		return true;
	}
};

void sortEdges(Edge edges[], int nEdges, int nIndexs) {
	memset(first, 0, sizeof(Edge*) * nIndexs);
	for (int i = 0; i &lt; nEdges; ++i) {
		Edge*e = edges + i;
		e-&gt;next = first[e-&gt;c];
		first[e-&gt;c] = e;
	}
}

DisjointSet disjointSet;

void makeNextIndexs(int nextIndexs[], int&amp;nNextIndexs, Edge edges[],
		int nEdges, Edge nextEdges[], int indexs[], int nIndexs,
		Operation operations[], int nOperations) {
	static int nextId[MAX_N_INDEXS];
	static bool indexUsed[MAX_N_INDEXS];

	memset(indexUsed, false, sizeof(bool) * nIndexs);
	for (int i = 0; i &lt; nOperations; ++i) {
		indexUsed[operations[i].c] = true;
	}
	for (int i = 0; i &lt; nEdges; ++i) {
		indexUsed[edges[i].c] = true;
	}
	nNextIndexs = 0;
	for (int i = 0; i &lt; nIndexs; ++i) {
		if (indexUsed[i]) {
			nextId[i] = nNextIndexs;
			nextIndexs[nNextIndexs++] = indexs[i];
		}
	}

	for (int i = 0; i &lt; nEdges; ++i) {
		edges[i].next = nextEdges + i;
		nextEdges[i] = edges[i];
		nextEdges[i].c = nextId[nextEdges[i].c];
	}

	for (int i = 0; i &lt; nOperations; ++i) {
		operations[i].e = operations[i].e-&gt;next;
		operations[i].c = nextId[operations[i].c];
	}
}

void rec(int vertices[], int nVertices, Edge edges[], int nEdges,
		Operation operations[], int nOperations, int indexs[], int nIndexs,
		int64 ans) {
	if (nOperations == 1) {
		Operation&amp;op = operations[0];
		op.e-&gt;c = op.c;
		sortEdges(edges, nEdges, nIndexs);
		disjointSet.init(vertices, nVertices);
		for (int i = 0; i &lt; nIndexs; ++i) {
			for (Edge*e = first[i]; e; e = e-&gt;next) {
				if (disjointSet.unite(e-&gt;a, e-&gt;b))
					ans += indexs[e-&gt;c];
			}
		}
		::ans[cur++] = ans;
		return;
	}
	for (int i = 0; i &lt; nEdges; ++i) {
		Edge&amp;e = edges[i];
		e.modified = false;
		e.merged = false;
		e.used = false;
	}
	for (int i = 0; i &lt; nOperations; ++i) {
		operations[i].e-&gt;modified = true;
	}
	sortEdges(edges, nEdges, nIndexs);
	disjointSet.init(vertices, nVertices);
	for (int i = 0; i &lt; nIndexs; ++i) {
		for (Edge*e = first[i]; e; e = e-&gt;next) {
			if (!e-&gt;modified) {
				e-&gt;used = disjointSet.unite(e-&gt;a, e-&gt;b);
			}
		}
	}

	disjointSet.init(vertices, nVertices);
	for (int i = 0; i &lt; nEdges; ++i) {
		if (edges[i].modified)
			disjointSet.unite(edges[i].a, edges[i].b);
	}

	for (int i = 0; i &lt; nIndexs; ++i) {
		for (Edge*e = first[i]; e; e = e-&gt;next)
			if (!e-&gt;modified) {
				e-&gt;merged = disjointSet.unite(e-&gt;a, e-&gt;b);
				if (e-&gt;merged)
					assert(e-&gt;used);
			}
	}

	disjointSet.init(vertices, nVertices);

	for (int i = 0; i &lt; nEdges; ++i) {
		Edge&amp;e = edges[i];
		if (e.merged) {
			disjointSet.unite(e.a, e.b);
			ans += indexs[e.c];
		}
	}

	Edge*tmpEdges = edges + nEdges;
	int nTmpEdges = 0;

	for (int i = 0; i &lt; nEdges; ++i) {
		Edge&amp;e = edges[i];
		if (e.modified || (e.used == 1 &amp;&amp; !e.merged)) {
			e.next = tmpEdges + nTmpEdges;
			tmpEdges[nTmpEdges++] = e;
		}
	}

	for (int i = 0; i &lt; nOperations; ++i) {
		operations[i].e = operations[i].e-&gt;next;
	}

	for (int i = 0; i &lt; nTmpEdges; ++i) {
		Edge&amp;e = tmpEdges[i];
		e.a = disjointSet.find(e.a);
		e.b = disjointSet.find(e.b);
	}

	int*nextVertices = vertices + nVertices;
	int nNextVertices = 0;

	for (int i = 0; i &lt; nVertices; ++i) {
		int u = vertices[i];
		if (disjointSet.father[u] == u)
			nextVertices[nNextVertices++] = u;
	}

	int*nextIndexs = indexs + nIndexs;
	int nNextIndexs;
	Edge*nextEdges = tmpEdges + nTmpEdges;

	Operation*nextOperations = operations + nOperations;
	int mid = nOperations / 2;
	for (int i = 0; i &lt; mid; ++i) {
		nextOperations[i] = operations[i];
	}
	makeNextIndexs(nextIndexs, nNextIndexs, tmpEdges, nTmpEdges, nextEdges,
			indexs, nIndexs, nextOperations, mid);
	rec(nextVertices, nNextVertices, nextEdges, nTmpEdges, nextOperations, mid,
			nextIndexs,
			nNextIndexs, ans);
	for (int i = mid; i &lt; nOperations; ++i) {
		nextOperations[i - mid] = operations[i];
	}
	for (int i = 0; i &lt; mid; ++i) {
		operations[i].e-&gt;c = operations[i].c;
	}
	makeNextIndexs(nextIndexs, nNextIndexs, tmpEdges, nTmpEdges, nextEdges,
			indexs, nIndexs, nextOperations, nOperations - mid);
	rec(nextVertices, nNextVertices, nextEdges, nTmpEdges, nextOperations,
			nOperations - mid, nextIndexs,
			nNextIndexs, ans);
}

void work() {
	int n = 0;
	for (int i = 0; i &lt; nEdges; ++i) {
		indexs[n++] = edges[i].c;
	}
	for (int i = 0; i &lt; nOperations; ++i) {
		indexs[n++] = operations[i].c;
	}
	sort(indexs, indexs + n);
	n = unique(indexs, indexs + n) - indexs;
	for (int i = 0; i &lt; nEdges; ++i) {
		edges[i].c = lower_bound(indexs, indexs + n, edges[i].c) - indexs;
	}
	for (int i = 0; i &lt; nOperations; ++i) {
		operations[i].c = lower_bound(indexs, indexs + n, operations[i].c)
				- indexs;
	}
	cur = 0;
	rec(vertices, nVertices, edges, nEdges, operations, nOperations, indexs, n,
			0);

}

int64 ansBrute[MAX_N_OPERATIONES];
Edge tmp[MAX_N_EDGES];
void workBrute() {
	for (int i = 0; i &lt; nEdges; ++i) {
		tmp[i] = edges[i];
	}
	for (int i = 0; i &lt; nOperations; ++i) {
		operations[i].e-&gt;c = operations[i].c;
		static Edge ord[MAX_N_EDGES];
		memcpy(ord, edges, sizeof(Edge) * nEdges);
		sort(ord, ord + nEdges);
		disjointSet.init(vertices, nVertices);
		int64 ans = 0;
		for (int j = 0; j &lt; nEdges; ++j) {
			if (disjointSet.unite(ord[j].a, ord[j].b))
				ans += ord[j].c;
		}
		ansBrute[i] = ans;
	}
	for (int i = 0; i &lt; nEdges; ++i) {
		edges[i] = tmp[i];
	}
}

void solve() {
	readInput();
	work();
	for (int i = 0; i &lt; nOperations; ++i) {
		printf("%lld\n", ans[i]);
	}
}

void runTest() {
	nVertices = 10;
	for (int i = 0; i &lt; nVertices; ++i) {
		vertices[i] = i;
	}
	nEdges = 2000;
	for (int i = 0; i &lt; nVertices; ++i) {
		edges[i].a = i, edges[i].b = (i + 1) % nVertices, edges[i].c = rand();
	}
	for (int i = nVertices; i &lt; nEdges; ++i) {
		edges[i].a = rand() % nVertices, edges[i].b = rand() % nVertices, edges[i].c =
				rand();
	}
	nOperations = 1000;
	for (int i = 0; i &lt; nOperations; ++i) {
		operations[i].e = edges + rand() % nOperations;
		operations[i].c = rand();
	}

	workBrute();
	work();
	for (int i = 0; i &lt; nOperations; ++i) {
		cout &lt;&lt; ans[i] &lt;&lt; " " &lt;&lt; ansBrute[i] &lt;&lt; endl;
		assert(ans[i] == ansBrute[i]);
	}
}

int main() {
	solve();
	return 0;
}
</pre><pre></pre><h2>Problem2002</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=200000;
using namespace std;
int next[maxn],reach[maxn],len[maxn],s,n,m,x;
void ReMark(int t)
{
    int l=t*s,r=l+s-1;if(r&gt;=n)r=n-1;
    for(int i=r;i&gt;=l;i--)
    {
        len[i]=1;int&amp;rch=reach[i];rch=next[i];
        if(rch&lt;=r)len[i]+=len[rch],rch=reach[rch];
    }
}
void Query(int st)
{
    int ret=0;
    while(st&lt;n)ret+=len[st],st=reach[st];
    printf("%d\n",ret);
}
void Change(int p,int nxt)
{
    next[p]=nxt;
    ReMark(p/s);
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);
    rep(i,n)scanf("%d",&amp;x),next[i]=i+x;
    scanf("%d",&amp;m);
    s=sqrt(n)+1;rep(i,s)ReMark(i);
    int k,a,b;
    rep(i,m)
    {
        scanf("%d%d",&amp;k,&amp;a);
        if(k==1)Query(a);
        else scanf("%d",&amp;b),Change(a,b+a);
    }
}


</pre><pre></pre><h2>Problem2002</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxn=200000;
using namespace std;
int next[maxn],reach[maxn],len[maxn],s,n,m,x;
void ReMark(int t)
{
    int l=t*s,r=l+s-1;if(r&gt;=n)r=n-1;
    for(int i=r;i&gt;=l;i--)
    {
        len[i]=1;int&amp;rch=reach[i];rch=next[i];
        if(rch&lt;=r)len[i]+=len[rch],rch=reach[rch];
    }
}
void Query(int st)
{
    int ret=0;
    while(st&lt;n)ret+=len[st],st=reach[st];
    printf("%d\n",ret);
}
void Change(int p,int nxt)
{
    next[p]=nxt;
    ReMark(p/s);
}
inline int nextInt(){
    int ret; char c;
    while(c = getchar(), c &lt; '0' || c &gt; '9') ;
    ret = c - '0';
    while(c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + c - '0';
    return ret;
}
int main()
{
    //freopen("in","r",stdin);
    scanf("%d",&amp;n);
    rep(i,n)next[i]=i+nextInt();
    scanf("%d",&amp;m);
    s=sqrt(n)+1;rep(i,s)ReMark(i);
    int k,a,b;
    rep(i,m)
    {
        k=nextInt();a=nextInt();
        if(k==1)Query(a);
        else b=nextInt(),Change(a,b+a);
    }
}


</pre><pre></pre><h2>Problem2005</h2><pre>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int maxn=100000+10;
using namespace std;
typedef long long ll;
int P[maxn]={};
int get(int i)
{
    int s=1;
    for(int x=2;x*x&lt;=i;x++)if(i%x==0)
    {
        i/=x;if(i%x==0)return 0;
        s*=-1;
    }
    if(i&gt;1)s*=-1;
    return s;
}
inline int Min(int a,int b){return a&lt;b?a:b;}
ll Cal(int a,int b,int k)
{
    a/=k;b/=k;
    if(a&gt;b)a^=b^=a^=b;
    ll ans=0;
    for(int t=1;t&lt;=a;t++)
    {
        int m=Min(a/(a/t),b/(b/t))-t;
        ans+=ll(P[t+m]-P[t-1])*(a/t)*(b/t);
        t+=m;
    }
    return ans;
}
int main()
{
    //freopen("energy.in","r",stdin);
    //freopen("energy.out","w",stdout);
    for(int i=1;i&lt;=maxn;i++)P[i]=P[i-1]+get(i);
    int n,m;cin&gt;&gt;n&gt;&gt;m;
    if(n&lt;m)n^=m^=n^=m;ll ans=0;
    for(int i=1;i&lt;=n;i++)
        ans+=Cal(n,m,i)*(2*i-1);
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem2006</h2><pre>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
const int inf=~0U&gt;&gt;1,maxn=500000+10,maxv=2100;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
int n,k,L,R;
struct Seg_Tree{
	int left,right;
	int mid() {
		return (left + right) &gt;&gt; 1;
	}
}tt[maxn*4];
int sorted[maxn];
int toLeft[20][maxn];
int val[20][maxn];
int S[maxn];
#define LL(t) 2*t
#define RR(t) 2*t+1
void build(int l,int r,int d,int idx) {
	tt[idx].left = l;
	tt[idx].right = r;
	if(tt[idx].left == tt[idx].right)	return ;
	int mid = tt[idx].mid();
	int lsame = mid - l + 1;//lsame表示和val_mid相等且分到左边的
	for(int i = l ; i &lt;= r ; i ++) {
		if(val[d][i] &lt; sorted[mid]) {
			lsame --;//先假设左边的数(mid - l + 1)个都等于val_mid,然后把实际上小于val_mid的减去
		}
	}
	int lpos = l;
	int rpos = mid+1;
	int same = 0;
	for(int i = l ; i &lt;= r ; i ++) {
		if(i == l) {
			toLeft[d][i] = 0;//toLeft[i]表示[ tt[idx].left , i ]区域里有多少个数分到左边
		} else {
			toLeft[d][i] = toLeft[d][i-1];
		}
		if(val[d][i] &lt; sorted[mid]) {
			toLeft[d][i] ++;
			val[d+1][lpos++] = val[d][i];
		} else if(val[d][i] &gt; sorted[mid]) {
			val[d+1][rpos++] = val[d][i];
		} else {
			if(same &lt; lsame) {//有lsame的数是分到左边的
				same ++;
				toLeft[d][i] ++;
				val[d+1][lpos++] = val[d][i];
			} else {
				val[d+1][rpos++] = val[d][i];
			}
		}
	}
	build(l,mid,d+1,LL(idx));
	build(mid+1,r,d+1,RR(idx));
}

int query(int l,int r,int k,int d,int idx) {
	if(l == r) {
		return val[d][l];
	}
	int s;//s表示[ l , r ]有多少个分到左边
	int ss;//ss表示 [tt[idx].left , l-1 ]有多少个分到左边
	if(l == tt[idx].left) {
		s = toLeft[d][r];
		ss = 0;
	} else {
		s = toLeft[d][r] - toLeft[d][l-1];
		ss = toLeft[d][l-1];
	}
	if(s &gt;= k) {//有多于k个分到左边,显然去左儿子区间找第k个
		int newl = tt[idx].left + ss;
		int newr = tt[idx].left + ss + s - 1;//计算出新的映射区间
		return query(newl,newr,k,d+1,LL(idx));
	} else {
		int mid = tt[idx].mid();
		int bb = l - tt[idx].left - ss;//bb表示 [tt[idx].left , l-1 ]有多少个分到右边
		int b = r - l + 1 - s;//b表示 [l , r]有多少个分到右边
		int newl = mid + bb + 1;
		int newr = mid + bb + b;
		return query(newl,newr,k-s,d+1,RR(idx));
	}
}
inline int readT(){
    int ret; char c;
    while(c = getchar(), c &lt; '0' || c &gt; '9') ;
    ret = c - '0';
    while(c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + c - '0';
    return ret;
}
void init()
{
    cin&gt;&gt;n&gt;&gt;k&gt;&gt;L&gt;&gt;R;int x;
    S[0]=0;
    for(int i=1;i&lt;=n;i++)
    {
        scanf("%d",&amp;x);
        S[i]=S[i-1]+x;
    }
    rep(i,n+1)val[0][i+1]=sorted[i+1]=S[i];
}
template&lt;class T&gt;
inline void Swap(T&amp;a,T&amp;b)
{
    T tmp=a;a=b;b=tmp;
}
inline int kth(int l,int r,int k)
{
    k++;l++;r++;
    if(r-l+1&lt;k)return inf;
    return query(l,r,k,0,1);
}
inline int Max(int a,int b){return a&gt;b?a:b;}
inline int Min(int a,int b){return a&lt;b?a:b;}
struct State
{
    int p,c;
    State(){}
    State(int _p,int _c):p(_p),c(_c){}
    bool operator&lt;(const State&amp;s)const
    {
        return c&gt;s.c;
    }
};
template&lt;class State&gt;
struct Heap
{
    State A[maxn];
    int n;
    Heap(){n=0;}
    void FixUp(int x)
    {
        if(x/2&amp;&amp;A[x]&lt;A[x/2])Swap(A[x],A[x/2]),FixUp(x/2);
    }
    void FixDown(int x)
    {
        int p=x*2;if(p&gt;n)return;
        if(p+1&lt;=n&amp;&amp;A[p+1]&lt;A[p])p++;
        if(A[p]&lt;A[x])Swap(A[p],A[x]),FixDown(p);
    }
    void put(const State&amp;s)
    {
        A[++n]=s;FixUp(n);
    }
    State get()
    {
        State tmp=A[1];
        A[1]=A[n];n--;
        FixDown(1);
        return tmp;
    }
};
Heap&lt;State&gt; heap;
Heap&lt;int&gt; Sort;
void sort(int A[maxn],int l,int r)
{
    for(int i=l;i&lt;=r;i++)Sort.put(A[i]);
    for(int i=l;i&lt;=r;i++)A[i]=Sort.get();
}
int Now[maxn];
int main()
{
    //freopen("piano.in","r",stdin);
    //freopen("piano.out","w",stdout);
    init();
    sort(sorted,1,n+1);
    build(1,n+1,0,1);
    For(i,1,n)
    {
        int l=i-R,r=i-L;
        if(r&lt;0){Now[i]=inf;continue;}
        Now[i]=0;
        l=Max(l,0);
        heap.put(State(i,S[i]-kth(l,r,0)));
    }
    ll ans=0;
    rep(i,k)
    {
        State tmp=heap.get();
        ans+=tmp.c;
        int p=tmp.p;
        if(Now[p]==inf)continue;
        int l=p-R,r=p-L;l=Max(l,0);
        Now[p]++;
        int c=kth(l,r,Now[p]);
        if(c==inf){Now[p]=inf;continue;}
        heap.put(State(p,S[p]-c));
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem2006</h2><pre>#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define PQ priority_queue
const int inf=~0U&gt;&gt;1,maxn=500000+10,Log=19;
using namespace std;
typedef long long ll;
int S[maxn],n,k,L,R;
int Min[maxn][Log],Log2[maxn];
void Init()
{
    scanf("%d%d%d%d",&amp;n,&amp;k,&amp;L,&amp;R);int x;S[0]=0;
    rep(i,n)scanf("%d",S+i+1),S[i+1]+=S[i];
}
inline int MinIndex(int i,int j)
{
    return S[i]&lt;S[j]?i:j;
}
void PrePareRMQ()
{
    rep(log,Log)
        rep(i,n)if(i+(1&lt;&lt;log)&lt;=n+1)
            if(log==0)Min[i][log]=i;
            else Min[i][log]=MinIndex(Min[i][log-1],Min[i+(1&lt;&lt;(log-1))][log-1]);
    Log2[1]=0;
    for(int i=2;i&lt;=n+1;i++)
        Log2[i]=Log2[i&gt;&gt;1]+1;
}
int RMQ(int l,int r)
{
    int s=r-l+1,k=Log2[s];
    return MinIndex(Min[l][k],Min[r-(1&lt;&lt;k)+1][k]);
}
struct state
{
    int l,m,r;
    state(int _l,int _r):l(_l),r(_r)
    {
        m=RMQ(l,r);
    }
    bool operator&lt;(const state&amp;st)const
    {
        return S[m]&gt;S[st.m];
    }
};
struct Data
{
    PQ&lt;state&gt; H;
    int Max,R;
    void doit(){Max=S[R]-S[H.top().m];}
    void set(int l,int r,int _R)
    {
        R=_R;
        H.push(state(l,r));doit();
    }
    void pop()
    {
        state st=H.top();H.pop();
        if(st.l&lt;st.m)H.push(state(st.l,st.m-1));
        if(st.m&lt;st.r)H.push(state(st.m+1,st.r));
        doit();
    }
}end[maxn];
struct cmp
{
    bool operator()(int i,int j)
    {
        return end[i].Max&lt;end[j].Max;
    }
};
PQ&lt;int,vector&lt;int&gt;,cmp&gt; Heap;
int main()
{
    //freopen("in","r",stdin);
    Init();
    PrePareRMQ();
    for(int r=1;r&lt;=n;r++)
    {
        int ll=r-R,rr=r-L;
        if(ll&lt;0)ll=0;
        if(ll&lt;=rr)end[r].set(ll,rr,r),Heap.push(r);
    }
    ll ans=0;
    rep(i,k)
    {
        int t=Heap.top();ans+=end[t].Max;Heap.pop();
        end[t].pop();if(!end[t].H.empty())Heap.push(t);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem2006</h2><pre>#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define PQ priority_queue
const int inf=~0U&gt;&gt;1,maxn=500000+10,Log=19;
using namespace std;
typedef long long ll;
int S[maxn],n,k,L,R;
int Min[maxn*4]={},m;
void Init()
{
    scanf("%d%d%d%d",&amp;n,&amp;k,&amp;L,&amp;R);int x;S[0]=0;
    rep(i,n)scanf("%d",S+i+1),S[i+1]+=S[i];
}
inline int MinIndex(int i,int j)
{
    return S[i]&lt;S[j]?i:j;
}
void PrePareRMQ()
{
    m=1;while(m&lt;=(n+3))m&lt;&lt;=1;
    for(int i=0;i&lt;=n;i++)
        Min[i+1+m]=i;
    for(int i=m-1;i&gt;=0;i--)
        Min[i]=MinIndex(Min[i*2],Min[i*2+1]);
}
int RMQ(int l,int r)
{
    int M=l;l--;r++;
    for(l+=m+1,r+=m+1;l^r^1;l&gt;&gt;=1,r&gt;&gt;=1)
    {
        if(~l&amp;1)M=MinIndex(M,Min[l^1]);
        if(r&amp;1)M=MinIndex(M,Min[r^1]);
    }
    return M;
}
struct state
{
    int l,m,r;
    state(int _l,int _r):l(_l),r(_r)
    {
        m=RMQ(l,r);
    }
    bool operator&lt;(const state&amp;st)const
    {
        return S[m]&gt;S[st.m];
    }
};
struct Data
{
    PQ&lt;state&gt; H;
    int Max,R;
    void doit(){Max=S[R]-S[H.top().m];}
    void set(int l,int r,int _R)
    {
        R=_R;
        H.push(state(l,r));doit();
    }
    void pop()
    {
        state st=H.top();H.pop();
        if(st.l&lt;st.m)H.push(state(st.l,st.m-1));
        if(st.m&lt;st.r)H.push(state(st.m+1,st.r));
        doit();
    }
}end[maxn];
struct cmp
{
    bool operator()(int i,int j)
    {
        return end[i].Max&lt;end[j].Max;
    }
};
PQ&lt;int,vector&lt;int&gt;,cmp&gt; Heap;
int main()
{
    //freopen("in","r",stdin);
    Init();
    PrePareRMQ();
    for(int r=1;r&lt;=n;r++)
    {
        int ll=r-R,rr=r-L;
        if(ll&lt;0)ll=0;
        if(ll&lt;=rr)end[r].set(ll,rr,r),Heap.push(r);
    }
    ll ans=0;
    rep(i,k)
    {
        int t=Heap.top();ans+=end[t].Max;Heap.pop();
        end[t].pop();if(!end[t].H.empty())Heap.push(t);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem2006</h2><pre>#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define PQ priority_queue
const int inf=~0U&gt;&gt;1,maxn=500000+10,Log=19;
using namespace std;
typedef long long ll;
int S[maxn],n,k,L,R;
int Min[maxn*4]={},m;
int nextInt()
{
    char c;c=getchar();
    while(c!='-'&amp;&amp;(c&lt;'0'||c&gt;'9'))c=getchar();
    int n=0,s=1;if(c=='-')s=-1,c=getchar();
    while(c&gt;='0'&amp;&amp;c&lt;='9')n*=10,n+=c-'0',c=getchar();
    return n*s;
}
void Init()
{
    scanf("%d%d%d%d",&amp;n,&amp;k,&amp;L,&amp;R);int x;S[0]=0;
    rep(i,n)S[i+1]=S[i]+nextInt();
}
inline int MinIndex(int i,int j)
{
    return S[i]&lt;S[j]?i:j;
}
void PrePareRMQ()
{
    m=1;while(m&lt;=(n+3))m&lt;&lt;=1;
    for(int i=0;i&lt;=n;i++)
        Min[i+1+m]=i;
    for(int i=m-1;i&gt;=0;i--)
        Min[i]=MinIndex(Min[i*2],Min[i*2+1]);
}
int RMQ(int l,int r)
{
    int M=l;l--;r++;
    for(l+=m+1,r+=m+1;l^r^1;l&gt;&gt;=1,r&gt;&gt;=1)
    {
        if(~l&amp;1)M=MinIndex(M,Min[l^1]);
        if(r&amp;1)M=MinIndex(M,Min[r^1]);
    }
    return M;
}
struct state
{
    int l,m,r;
    state(int _l,int _r):l(_l),r(_r)
    {
        m=RMQ(l,r);
    }
    bool operator&lt;(const state&amp;st)const
    {
        return S[m]&gt;S[st.m];
    }
};
struct Data
{
    PQ&lt;state&gt; H;
    int Max,R;
    void doit(){Max=S[R]-S[H.top().m];}
    void set(int l,int r,int _R)
    {
        R=_R;
        H.push(state(l,r));doit();
    }
    void pop()
    {
        state st=H.top();H.pop();
        if(st.l&lt;st.m)H.push(state(st.l,st.m-1));
        if(st.m&lt;st.r)H.push(state(st.m+1,st.r));
        doit();
    }
}end[maxn];
struct cmp
{
    bool operator()(int i,int j)
    {
        return end[i].Max&lt;end[j].Max;
    }
};
PQ&lt;int,vector&lt;int&gt;,cmp&gt; Heap;
int main()
{
    //freopen("in","r",stdin);
    Init();
    PrePareRMQ();
    for(int r=1;r&lt;=n;r++)
    {
        int ll=r-R,rr=r-L;
        if(ll&lt;0)ll=0;
        if(ll&lt;=rr)end[r].set(ll,rr,r),Heap.push(r);
    }
    ll ans=0;
    rep(i,k)
    {
        int t=Heap.top();ans+=end[t].Max;Heap.pop();
        end[t].pop();if(!end[t].H.empty())Heap.push(t);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem2007</h2><pre>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define tr(e,x) for(Edge* e=x.begin();e!=x.end();e++)
using namespace std;
const int maxn=502,maxv=maxn*maxn,inf=~0U&gt;&gt;2;
int n,vs,vt,v;
int Dist[maxv];
template&lt;class T&gt;
struct Vector
{
    T*Mem,*MemEnd,*End;
    T*begin(){return Mem;}
    T*end(){return End;}
    Vector()
    {
        Mem=new T[1];
        MemEnd=Mem+1;
        End=Mem;
    }
    void Grow()
    {
        T*OldMem=Mem;
        int n=MemEnd-Mem,p=End-Mem;
        Mem=new T[n*2];
        MemEnd=Mem+n*2;
        memcpy(Mem,OldMem,sizeof(T)*n);
        End=Mem+p;
    }
    void Require(int size)
    {
        for(;;)
        {
            int n=MemEnd-End;
            if(n&gt;=size)return;
            Grow();
        }
    }
    void add(T a)
    {
        if(End==MemEnd)Grow();
        *(End++)=a;
    }
    T&amp;operator[](int v){return *(Mem+v);}
};
struct Edge
{
    int t,c;
    Edge(){}
    Edge(int _t,int _c):t(_t),c(_c){}
};
struct State
{
    int p,c;
    State(){}
    State(int _p,int _c):p(_p),c(_c){}
    bool operator&lt;(const State&amp;o)const
    {
        return c&lt;o.c;
    }
};
template&lt;class T&gt;
inline void Swap(T&amp;a,T&amp;b)
{
    T tmp=a;a=b;b=tmp;
}
template&lt;class State&gt;
struct Heap
{
    Vector&lt;State&gt; A;
    int n;
    Heap(){A.add(State());n=0;}
    void FixUp(int x)
    {
        if(x/2&amp;&amp;A[x]&lt;A[x/2])Swap(A[x],A[x/2]),FixUp(x/2);
    }
    void FixDown(int x)
    {
        int p=x*2;if(p&gt;n)return;
        if(p+1&lt;=n&amp;&amp;A[p+1]&lt;A[p])p++;
        if(A[p]&lt;A[x])Swap(A[p],A[x]),FixDown(p);
    }
    void put(const State&amp;s)
    {
        ++n;
        A.Require(n+1);A[n]=s;
        FixUp(n);
    }
    State get()
    {
        State tmp=A[1];
        A[1]=A[n];n--;
        FixDown(1);
        return tmp;
    }
    int size(){return n;}
};
Vector&lt;Edge&gt; E[maxv];
Heap&lt;State&gt; Q;
int Dijstra()
{
    rep(i,v)Dist[i]=inf;Q.put(State(vs,0));Dist[vs]=0;
    while(Q.size())
    {
        State t=Q.get();;if(t.c&gt;Dist[t.p])continue;
        if(t.p==vt)return t.c;
        tr(e,E[t.p])
        {
            int ncost=t.c+e-&gt;c;
            if(ncost&lt;Dist[e-&gt;t])
            {
                Dist[e-&gt;t]=ncost;
                Q.put(State(e-&gt;t,ncost));
            }
        }
    }
}
void AddEdge(int s,int t,int c)
{
    E[s].add(Edge(t,c));
}
int node(int i,int j){return i*n+j;}
int main()
{
    //freopen("altitude.in","r",stdin);
    //freopen("altitude.out","w",stdout);
    scanf("%d",&amp;n);v=n*n;vs=v++;vt=v++;
    int c;
    rep(i,n)scanf("%d",&amp;c),AddEdge(vs,node(0,i),c);
    rep(i,n-1)
    {
        rep(j,n)scanf("%d",&amp;c),AddEdge(node(i,j),node(i+1,j),c);
    }
    rep(i,n)scanf("%d",&amp;c),AddEdge(node(n-1,i),vt,c);
    rep(i,n)
    {
        scanf("%d",&amp;c);AddEdge(node(i,0),vt,c);
        rep(j,n-1)scanf("%d",&amp;c),AddEdge(node(i,j+1),node(i,j),c);
        scanf("%d",&amp;c);AddEdge(vs,node(i,n-1),c);
    }
    //
    rep(i,n)scanf("%d",&amp;c),AddEdge(node(0,i),vs,c);
    rep(i,n-1)
    {
        rep(j,n)scanf("%d",&amp;c),AddEdge(node(i+1,j),node(i,j),c);
    }
    rep(i,n)scanf("%d",&amp;c),AddEdge(vt,node(n-1,i),c);
    rep(i,n)
    {
        scanf("%d",&amp;c);AddEdge(vt,node(i,0),c);
        rep(j,n-1)scanf("%d",&amp;c),AddEdge(node(i,j),node(i,j+1),c);
        scanf("%d",&amp;c);AddEdge(node(i,n-1),vs,c);
    }
    cout&lt;&lt;Dijstra()&lt;&lt;endl;
}

</pre><pre></pre><h2>Problem2009</h2><pre>/*
 * [Noi2010]旅行路线.cpp
 *
 *  Created on: 2011-6-20
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;cassert&gt;
#include &lt;bitset&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MOD = 11192869;
int nR, nC;
const int MAX_N_ROWS = 50;
const int MAX_N_COLS = 3;
const int MAX_L_TRAVEL = MAX_N_ROWS * MAX_N_COLS;
int map[MAX_N_ROWS][MAX_N_COLS];
int what[MAX_L_TRAVEL], L;

typedef unsigned int uint;

int nextToken() {
	char ch;
	while (ch = getchar(), ch != '0' &amp;&amp; ch != '1')
		;
	return ch - '0';
}

void readInput() {
	cin &gt;&gt; nC &gt;&gt; nR;
	for (int c = 0; c &lt; nC; ++c) {
		for (int r = 0; r &lt; nR; ++r) {
			map[r][c] = nextToken();
		}
	}
	L = nR * nC;
	for (int i = 0; i &lt; L; ++i) {
		what[i] = nextToken();
	}
}

int NONE;

const int ADD = 2, SUB = 0, EMPTY = 1, BAD = 3;

uint codeState(int nums[MAX_N_COLS], int plugs[MAX_N_COLS + 1]) {
	uint ret = 0;
	for (int i = 0; i &lt; nC; ++i) {
		ret = (ret &lt;&lt; 8) + nums[i];
	}
	for (int i = 0; i &lt;= nC; ++i) {
		ret = (ret &lt;&lt; 2) + plugs[i];
	}
	return ret;
}

uint hashCode(uint code, int r, int c) {
	uint h = code;
	h = h * 131 + r;
	h = h * 131 + c;
	return h;
}

inline void addIt(int&amp;x, int c) {
	x += c;
	if (x &gt;= MOD)
		x -= MOD;
}

typedef bitset&lt;MAX_L_TRAVEL&gt; BitSet;

struct State {
	uint code;
	State*next;
	int r, c, ans;
	BitSet visited;
	bool inQ;
	State() {
		next = 0;
		ans = 0;
		inQ = false;
		visited.reset();
	}
	void decode(int nums[MAX_N_COLS], int plugs[MAX_N_COLS + 1]) {
		uint x = code;
		for (int i = nC; i &gt;= 0; --i) {
			plugs[i] = x &amp; 3;
			x &gt;&gt;= 2;
		}
		for (int i = nC - 1; i &gt;= 0; --i) {
			nums[i] = x &amp; 255;
			x &gt;&gt;= 8;
		}
	}

	void debug() {
		static int nums[MAX_N_COLS], plugs[MAX_N_COLS + 1];
		decode(nums, plugs);
		cout &lt;&lt; "DEBUG" &lt;&lt; endl;
		cout &lt;&lt; r &lt;&lt; " " &lt;&lt; c &lt;&lt; endl;
		for (int i = 0; i &lt; nC; ++i) {
			cout &lt;&lt; nums[i] &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
		for (int i = 0; i &lt;= nC; ++i) {
			cout &lt;&lt; plugs[i] &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
		cout &lt;&lt; ans &lt;&lt; endl;
	}
};

const int MAX_N_HASH = 1000007;
const int N_STATE_BUFFER = 10000;
State*hashFirst[MAX_N_HASH] = { };

State*phead = 0, *pend = 0;
State*freeList = 0;

State*allocState(uint code, int r, int c, const BitSet&amp;visited) {
	State*p;
	if (freeList != 0) {
		p = freeList;
		freeList = p-&gt;next;
	} else {
		if (phead == pend) {
			phead = new State[N_STATE_BUFFER];
			pend = phead + N_STATE_BUFFER;
		}
		p = phead++;
	}
	p-&gt;code = code;
	p-&gt;next = 0;
	p-&gt;ans = 0;
	p-&gt;r = r;
	p-&gt;c = c;
	p-&gt;visited = visited;
	p-&gt;inQ = false;
	return p;
}

void freeState(State*p) {
	uint hash = hashCode(p-&gt;code, p-&gt;r, p-&gt;c);
	int at = hash % MAX_N_HASH;
	State*prev = 0;
	bool check = false;
	for (State*it = hashFirst[at]; it; it = it-&gt;next) {
		if (it-&gt;code == p-&gt;code &amp;&amp; it-&gt;r == p-&gt;r &amp;&amp; it-&gt;c == p-&gt;c) {
			check = true;
			break;
		}
		prev = it;
	}
	assert(check);
	if (prev)
		prev-&gt;next = p-&gt;next;
	else {
		hashFirst[at] = p-&gt;next;
	}

	p-&gt;next = freeList;
	freeList = p;
}

State*getState(int nums[MAX_N_COLS], int plugs[MAX_N_COLS + 1], int r, int c,
		const BitSet&amp;visited) {
	uint code = codeState(nums, plugs);
	uint hash = hashCode(code, r, c);
	int at = hash % MAX_N_HASH;
	for (State*p = hashFirst[at]; p; p = p-&gt;next) {
		if (p-&gt;code == code &amp;&amp; p-&gt;r == r &amp;&amp; p-&gt;c == c)
			return p;
	}
	State*p = allocState(code, r, c, visited);
	p-&gt;next = hashFirst[at];
	hashFirst[at] = p;
	return p;
}

queue&lt;State*&gt; que;

void insQueue(int nums[MAX_N_COLS], int plugs[MAX_N_COLS + 1], int r, int c,
		int add, const BitSet&amp;visited) {
	static int nplugs[MAX_N_COLS + 1];
	static int nnums[MAX_N_COLS];
	memcpy(nplugs, plugs, sizeof nplugs);
	memcpy(nnums, nums, sizeof nnums);
	if (c == 0) {
		//move to next line
		assert(nplugs[nC]==EMPTY);
		for (int i = nC; i &gt;= 1; --i) {
			nplugs[i] = nplugs[i - 1];
		}
		nplugs[0] = EMPTY;
	}
	State*s = getState(nnums, nplugs, r, c, visited);
	addIt(s-&gt;ans, add);
	if (!s-&gt;inQ) {
		s-&gt;inQ = true;
		que.push(s);
	}
}

bool atBorder(int r, int c) {
	return r == 0 || r == nR - 1 || c == 0 || c == nC - 1;
}

int adjType(int a, int b) {
	if (a == NONE)
		return EMPTY;
	if (a + 1 == b)
		return ADD;
	if (a - 1 == b)
		return SUB;
	if (a == b)
		return BAD;
	return EMPTY;
}

int get(int a, int type) {
	return a + type - 1;
}

int work() {
	NONE = L + 2;
	int nums[MAX_N_COLS], plugs[MAX_N_COLS + 1];
	int listALL[MAX_L_TRAVEL];
	for (int i = 0; i &lt; L; ++i) {
		listALL[i] = i;
	}
	fill(nums, nums + nC, NONE);
	fill(plugs, plugs + nC + 1, EMPTY);
	BitSet visited;
	visited.reset();
	int FIRST = 0, LAST = L - 1;
	insQueue(nums, plugs, 0, 0, 1, visited);
	int ans = 0;
	while (!que.empty()) {
		State *s = que.front();
		que.pop();
		if (s-&gt;r == nR) {
			addIt(ans, s-&gt;ans);
			continue;
		}
		s-&gt;decode(nums, plugs);
		visited = s-&gt;visited;
		int r = s-&gt;r, c = s-&gt;c;
		int nr = r, nc = c + 1;
		if (nc == nC)
			nr++, nc = 0;
		int p1 = plugs[c], p2 = plugs[c + 1];
		int can[2];
		int*list, num = 0;
		if (p1 != EMPTY) {
			assert(nums[c-1]!=NONE);
			can[num++] = get(nums[c - 1], p1);
		}
		if (p2 != EMPTY) {
			assert(nums[c]!=NONE);
			can[num++] = get(nums[c], p2);
		}
		if (num == 2) {
			if (can[0] != can[1])
				continue;
			num = 1;
		}
		if (num == 0) {
			list = listALL;
			num = L;
		} else {
			list = can;
		}
		for (int it = 0; it &lt; num; ++it) {
			int i = list[it];
			if (visited[i])
				continue;
			if (what[i] != map[r][c])
				continue;
			if (i == FIRST &amp;&amp; !atBorder(r, c))
				continue;
			if (c &gt; 0 &amp;&amp; adjType(nums[c - 1], i) != p1)
				continue;
			if (adjType(nums[c], i) != p2)
				continue;
			int rp1 = 2 - p1, rp2 = 2 - p2;
			bool has[3] = { };
			has[rp1] = has[rp2] = true;
			for (int np1 = 0; np1 &lt;= 2; ++np1) {
				if (np1 != EMPTY &amp;&amp; has[np1])
					continue;
				if (r == nR - 1 &amp;&amp; np1 != EMPTY)
					continue;
				has[np1] = true;
				for (int np2 = 0; np2 &lt;= 2; ++np2) {
					if (np2 != EMPTY &amp;&amp; has[np2])
						continue;
					if (c == nC - 1 &amp;&amp; np2 != EMPTY)
						continue;
					has[np2] = true;
					do {
						if (i == FIRST &amp;&amp; (has[SUB] || !has[ADD]))
							break;
						if (i == LAST &amp;&amp; (has[ADD] || !has[SUB]))
							break;
						if (i != FIRST &amp;&amp; i != LAST &amp;&amp; (!has[ADD] || !has[SUB]))
							break;
						plugs[c] = np1;
						plugs[c + 1] = np2;
						int copy = nums[c];
						nums[c] = i;
						visited[i] = true;
						insQueue(nums, plugs, nr, nc, s-&gt;ans, visited);
						visited[i] = false;
						nums[c] = copy;
					} while (0);
					has[np2] = false;
				}
				has[np1] = false;
			}
		}
		freeState(s);
	}
	return ans;
}

void solve() {
	readInput();
	cout &lt;&lt; work() &lt;&lt; endl;
}

void runTest() {
	nR = 50;
	nC = 3;
	for (int r = 0; r &lt; nR; ++r) {
		for (int c = 0; c &lt; nC; ++c) {
			map[r][c] = 0;
		}
	}
	L = nR * nC;
	for (int i = 0; i &lt; L; ++i) {
		what[i] = 0;
	}
	cout &lt;&lt; work() &lt;&lt; endl;
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2012</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int NSTR_MAX=50000+100,LEN=4;
char strs[NSTR_MAX][LEN+1];
int nstrs,diff;
int dp[1&lt;&lt;LEN];
typedef long long int64;

const int seed=133331;
int getHash(char*str,int mask)
{
    int ret=0;
    rep(it,LEN)
        if(mask&gt;&gt;it&amp;1)
            ret=ret*seed+str[it];
    return ret;
}

int C2(int n)
{
    return int64(n)*(n-1)/2;
}

int countStr(int mask)
{
    static int hashs[NSTR_MAX];
    rep(cur,nstrs)
        hashs[cur]=getHash(strs[cur],mask);
    sort(hashs,hashs+nstrs);
    int cnt=0,last=-1;
    int res=0;
    for(int cur=0;cur&lt;nstrs;cur++)
    {
        if(hashs[cur]==last)
            cnt++;
        else
        {
            res+=C2(cnt);
            last=hashs[cur];cnt=1;
        }
    }
    res+=C2(cnt);
    return res;
}

int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;nstrs&gt;&gt;diff;
    rep(it,nstrs)
        scanf("%s",strs[it]);

    int64 ans=0;
    for(int mask=((1&lt;&lt;LEN)-1);mask&gt;=0;--mask)
    {
        dp[mask]=countStr(mask);
        for(int fa=mask+1;fa&lt;(1&lt;&lt;LEN);fa++)
            if((fa&amp;mask)==mask)
                dp[mask]-=dp[fa];
        int bitCnt=0;
        rep(it,LEN)if(mask&gt;&gt;it&amp;1)bitCnt++;
        if(bitCnt==LEN-diff)
            ans+=dp[mask];
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem2013</h2><pre>/*
 * [Ceoi2010]A huge tower.cpp
 *
 *  Created on: 2011-6-11
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MOD = 1000000009;
const int MAX_N = 620000 + 10;
int n, D;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

int hs[MAX_N];

typedef long long int64;

int main() {
	cin &gt;&gt; n &gt;&gt; D;
	for (int i = 0; i &lt; n; ++i) {
		scanInt(hs[i]);
	}
	sort(hs, hs + n);
	int64 ret = 1;
	int j = 0;
	for (int i = 0; i &lt; n; ++i) {
		while (hs[j] &lt; hs[i] - D)
			++j;
		int cnt = i - j + 1;
		(ret *= cnt) %= MOD;
	}
	cout &lt;&lt; ret &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem2020</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1,maxK=120;
using namespace std;
struct Heap
{
    int A[maxK],n;
    void clear()
    {
        n=0;
    }
    void fixup(int x)
    {
        if(x/2&amp;&amp;A[x]&gt;A[x/2])swap(A[x],A[x/2]),fixup(x/2);
    }
    void fixdown(int x)
    {
        int p=x*2;if(p&gt;n)return;
        if(p&lt;n&amp;&amp;A[p+1]&gt;A[p])p++;
        if(A[p]&gt;A[x])swap(A[x],A[p]),fixdown(p);
    }
    void add(int x)
    {
        A[++n]=x;fixup(n);
    }
    int pop()
    {
        int tmp=A[1];A[1]=A[n--];
        fixdown(1);
        return tmp;
    }
    int size()
    {
        return n;
    }
}heap;
void Solve()
{
    int K,E,N,X,F,C;
    cin&gt;&gt;K&gt;&gt;E&gt;&gt;N;
    heap.clear();
    rep(i,N)
    {
        cin&gt;&gt;X&gt;&gt;F&gt;&gt;C;
        C+=E-X;
        rep(t,F)
        {
            heap.add(C);
            if(heap.size()&gt;K)
                heap.pop();
        }
    }
    int ans=0;
    while(heap.size())ans+=heap.pop();
    cout&lt;&lt;ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Solve();
}


</pre><pre></pre><h2>Problem2021</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
#define For(i,l,r) for(int i=l;i&lt;=r;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
#define printTime cout&lt;&lt;"Time:"&lt;&lt;pre-clock()&lt;&lt;endl;pre=clock();
const int inf=~0U&gt;&gt;1,maxt=1000+1,maxn=100;
using namespace std;
int N,T,K,V[maxn],H[maxn];
int P[maxn];
int Dp[maxt][2];
inline void Update(int&amp;x,int c)
{
    if(x&lt;c)x=c;
}
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;N&gt;&gt;T&gt;&gt;K;
    rep(i,N)cin&gt;&gt;V[i]&gt;&gt;H[i];
    memset(Dp,-1,sizeof Dp);
    Dp[0][0]=0;
    int c;
    rep(t,T+1)
        rep(j,2)
        if((c=Dp[t][j])!=-1)
        {
            rep(i,N)
            {
                int w=j?H[i]/5*4:H[i];
                if(w+t&lt;=T)
                    Update(Dp[w+t][j||(H[i]&gt;=K)],c+V[i]);
            }
        }
    int ans=-1;
    rep(i,maxt)rep(j,2)Update(ans,Dp[i][j]);
    cout&lt;&lt;ans&lt;&lt;endl;
}


</pre><pre></pre><h2>Problem2024</h2><pre>import java.math.BigInteger;
import java.util.Arrays;
import java.util.Scanner;

import static java.math.BigInteger.*;

public class Main {
	static enum Sex {
		BOY, GIRL;
	}

	static class Student implements Comparable&lt;Student&gt; {
		Sex sex;
		int height;

		public Student(Sex sex, int height) {
			// TODO Auto-generated constructor stub
			this.sex = sex;
			this.height = height;
		}

		@Override
		public int compareTo(Student s) {
			if (height != s.height)
				return height - s.height;
			if (sex != s.sex)
				return sex == Sex.BOY ? 1 : -1;
			return 0;
		}
	}

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int nPairs = scan.nextInt(), nOver = scan.nextInt();

		Student[] students = new Student[nPairs * 2];
		for (int i = 0; i &lt; nPairs; ++i) {
			students[i] = new Student(Sex.BOY, scan.nextInt());
		}
		for (int i = 0; i &lt; nPairs; ++i) {
			students[nPairs + i] = new Student(Sex.GIRL, scan.nextInt());
		}
		Arrays.sort(students);

		BigInteger[] am = new BigInteger[nPairs + 1];
		Arrays.fill(am, ZERO);
		am[0] = ONE;

		for (int at = students.length - 1; at &gt;= 0; --at) {
			BigInteger[] nam = new BigInteger[nPairs + 1];
			Arrays.fill(nam, ZERO);
			if (students[at].sex == Sex.GIRL) {
				for (int i = 0; i &lt; am.length; ++i) {
					if (am[i].equals(ZERO))
						continue;
					nam[i + 1] = nam[i + 1].add(am[i]);
				}
			} else {
				for (int i = 0; i &lt; am.length; i++) {
					if (am[i].equals(ZERO))
						continue;
					// don't care
					nam[i] = nam[i].add(am[i]);
					if (i &gt; 0)
						nam[i - 1] = nam[i - 1].add(am[i].multiply(valueOf(i)));
				}
			}

			am = nam;
		}

		BigInteger[] fact = new BigInteger[nPairs + 1];
		fact[0] = ONE;
		for (int i = 1; i &lt;= nPairs; ++i)
			fact[i] = fact[i - 1].multiply(valueOf(i));

		for (int i = 0; i &lt; am.length; ++i) {
			am[i] = am[i].multiply(fact[i]);
//			System.out.println(i + ":" + am[i]);
		}

		BigInteger[][] C = new BigInteger[nPairs + 1][nPairs + 1];
		for (int i = 0; i &lt;= nPairs; ++i) {
			C[i][0] = C[i][i] = ONE;
			for (int j = 1; j &lt; i; ++j)
				C[i][j] = C[i - 1][j].add(C[i - 1][j - 1]);
		}

		BigInteger[] ans = new BigInteger[nPairs + 1];
		for (int i = nPairs; i &gt;= 0; --i) {
			ans[i] = am[nPairs - i];
			for (int j = i + 1; j &lt; ans.length; ++j)
				ans[i] = ans[i].subtract(ans[j].multiply(C[j][i]));
		}

		BigInteger ret = ZERO;
		for (int i = 0; i &lt;= nOver; ++i) {
			ret = ret.add(ans[i]);
		}

		System.out.println(ret);
	}
}
</pre><pre></pre><h2>Problem2028</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef pair&lt;int,int&gt; seg;
#define l first
#define r second
set&lt;seg&gt; S;
typedef set&lt;seg&gt;::iterator sit;
bool inter(seg a,seg b)
{
    return !(a.l&gt;b.r||b.l&gt;a.r);
}
int main()
{
    //freopen("in","r",stdin);
    char t;int l,r;
    int n;scanf("%d",&amp;n);
    rep(i,n)
    {
        scanf(" ");char c=getchar();
        if(c=='A')
        {
            scanf("%d%d",&amp;l,&amp;r);
            seg a(l,r);
            int ret=0;
            for(;;)
            {
                sit it=S.lower_bound(a);
                if(inter(*it,a)){ret++;S.erase(it);continue;}
                it=S.lower_bound(a);
                if(it!=S.begin())
                {
                    --it;if(inter(*it,a)){ret++;S.erase(it);continue;}
                }
                break;
            }
            cout&lt;&lt;ret&lt;&lt;endl;
            S.insert(a);
        }
        else
            printf("%d\n",S.size());
    }
}


</pre><pre></pre><h2>Problem2028</h2><pre>#include &lt;utility&gt;
#include &lt;cstdio&gt;
#include &lt;set&gt;
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef pair&lt;int,int&gt; seg;
#define l first
#define r second
set&lt;seg&gt; S;
typedef set&lt;seg&gt;::iterator sit;
bool inter(seg a,seg b)
{
    return !(a.l&gt;b.r||b.l&gt;a.r);
}
int main()
{
    char t;int l,r;
    int n;scanf("%d",&amp;n);
    while(n--)
    {
        scanf(" ");char c=getchar();
        if(c=='A')
        {
            scanf("%d%d",&amp;l,&amp;r);
            seg a(l,r);
            int ret=0;
            for(;;)
            {
                sit it=S.lower_bound(a);
                if(inter(*it,a)){ret++;S.erase(it);continue;}
                it=S.lower_bound(a);
                if(it!=S.begin())
                {
                    --it;if(inter(*it,a)){ret++;S.erase(it);continue;}
                }
                break;
            }
            printf("%d\n",ret);
            S.insert(a);
        }
        else
            printf("%d\n",S.size());
    }
}


</pre><pre></pre><h2>Problem2034</h2><pre>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=5000;
typedef long long ll;
int n;
struct Task
{
    int l,r,v;
    bool operator&lt;(const Task&amp;t)const
    {
        return v&gt;t.v;
    }
}A[maxn];
int X[maxn];
void Input_Data()
{
    cin&gt;&gt;n;
    rep(i,n)cin&gt;&gt;A[i].l&gt;&gt;A[i].r&gt;&gt;A[i].v;
    sort(A,A+n);
}
const int size=27771;
struct Hash
{
    int A[size];
    Hash(){memset(A,-1,sizeof A);}
    void inc(int&amp;t){if(++t==maxn)t=0;}
    bool insert(int x)
    {
        int h;
        for(h=x%size;A[h]!=-1&amp;&amp;A[h]!=x;inc(h));
        if(A[h]==-1)return A[h]=x,true;
        return false;
    }
}H;
void Generate_Point()
{
    int p=0;
    rep(i,n)
    {
        int x;
        for(x=A[i].l;!H.insert(x);x++);
        X[p++]=x;
    }
    sort(X,X+n);
}
int Link[maxn];
bool Find(int i,int p)
{
    if(p&gt;=n||X[p]&gt;A[i].r)return false;
    if(X[p]&lt;A[i].l)return Find(i,p+1);
    if(Link[p]==-1)
    {
        Link[p]=i;
        return true;
    }
    int j=Link[p];
    if(A[i].r&gt;A[j].r)
        return Find(i,p+1);
    else
    {
        if(Find(j,p+1))
            return Link[p]=i,true;
    }
    return false;
}
void Solve()
{
    memset(Link,-1,sizeof Link);
    ll Ans=0;
    rep(i,n)
    {
        if(Find(i,0))
            Ans+=A[i].v;
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
}
int main()
{
    Input_Data();
    Generate_Point();
    Solve();
}
</pre><pre></pre><h2>Problem2036</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1,maxn=1000+10,maxt=12;
using namespace std;
int Dp[maxn][maxt+1][maxn]={},n;
int main()
{
    //freopen("in","r",stdin);
    Dp[0][0][0]=1;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;maxt;j++)
            for(int k=0;k&lt;=n;k++)
                if(int c=Dp[i][j][k])
                {
                    Dp[i+1][j][k]+=c;
                    int l=0+i+1,r=k+i+1;
                    if(l&lt;=k+1&amp;&amp;j+1&lt;maxt)
                    {
                        Dp[i+1][j+1][min(r,n)]+=c;
                    }
                }
    for(int t=0;t&lt;maxt;t++)
    {
        if(Dp[n][t][n])
        {
            cout&lt;&lt;t&lt;&lt;" "&lt;&lt;Dp[n][t][n]&lt;&lt;endl;
            return 0;
        }
    }
}


</pre><pre></pre><h2>Problem2038</h2><pre>#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
const int inf=~0U&gt;&gt;1;
using namespace std;
typedef long long ll;
const int maxn=50000+10;
struct pnt
{
    int x,y;
    pnt(){}
    pnt(int _x,int _y):
        x(_x),y(_y){}
}P[maxn];
int n,m,A[maxn];
const int maxc=100;
struct Edge
{
    int s,t,c;
    Edge(){}
    Edge(int _s,int _t,int _c):
        s(_s),t(_t),c(_c){}
}E[maxn*(maxc+1)];
int Ent;
inline int Abs(int x){return x&gt;0?x:-x;}
int dist(pnt a,pnt b)
{
    return Abs(a.x-b.x)+Abs(a.y-b.y);
}
void Init()
{
    scanf("%d%d",&amp;n,&amp;m);
    rep(i,n)scanf("%d",A+i);
    int l,r;
    rep(i,m)
    {
        scanf("%d%d",&amp;l,&amp;r);
        --l;--r;
        P[i]=pnt(l,r);
    }
    Ent=0;
    int Sqrt=12*sqrt(n)+1;
    rep(i,m)
    {
        int times=3*maxc-1,to,added=0;
        while(times--&amp;&amp;added&lt;maxc)
        {
            to=rand()%m;
            if(dist(P[i],P[to])&lt;Sqrt)
                E[Ent++]=Edge(i,to,dist(P[i],P[to]));
        }
        to=(i+1)%m;
        E[Ent++]=Edge(i,to,dist(P[i],P[to]));
    }
}
struct UF
{
    int F[maxn],n;
    void MakeUse(int _n)
    {
        n=_n;
        rep(i,n)F[i]=i;
    }
    int Find(int x)
    {
        if(F[x]==x)return x;
        return F[x]=Find(F[x]);
    }
    bool Union(int i,int j)
    {
        i=Find(i);j=Find(j);
        F[i]=j;return i!=j;
    }
}U;
vector&lt;int&gt; Adj[maxn];
void AddEdge(int s,int t)
{
    Adj[s].pb(t);
    Adj[t].pb(s);
}
const int MaxC=maxn*2;
int S[MaxC];
Edge Es[maxc*maxn];
void CountSort()
{
    int L=n*2;
    rep(i,Ent)S[E[i].c]++;
    rep(i,L)S[i+1]+=S[i];
    rep(i,Ent)
        Es[--S[E[i].c]]=E[i];
}
void BuildMST()
{
    CountSort();
    U.MakeUse(m);
    int mnt=m;
    rep(i,Ent)
    {
        if(mnt==1)break;
        Edge&amp;e=Es[i];
        if(U.Union(e.s,e.t))
            AddEdge(e.s,e.t),mnt--;
    }
}
int C[maxn]={},Num=0,Ans=0;
int way(int t)
{
    return ll(t)*(t-1)/2;
}
inline void Update(int c,int add)
{
    Num+=add;
    if(add==1)
        Ans+=C[c];
    else
        Ans-=C[c]-1;
    C[c]+=add;
}
void insert(int l,int r)
{
    for(int i=l;i&lt;=r;i++)
        Update(A[i],1);
}
void remove(int l,int r)
{
    for(int i=l;i&lt;=r;i++)
        Update(A[i],-1);
}
void move(pnt a,pnt b)//can improve
{
    if(a.y-a.x+1+b.y-b.x+1&lt;dist(a,b))//if it's better to delete and insert
    {
        remove(a.x,a.y);
        insert(b.x,b.y);
        return;
    }
    if(a.x&lt;b.x)
        remove(a.x,b.x-1);
    else
        insert(b.x,a.x-1);
    if(a.y&lt;b.y)
        insert(a.y+1,b.y);
    else
        remove(b.y+1,a.y);
}
int gcd(int a,int b){return b?gcd(b,a%b):a;}
bool Vis[maxn]={};
struct Frac
{
    int a,b;
    Frac(){}
    Frac(int _a,int _b):a(_a),b(_b)
    {
        int d=gcd(a,b);
        a/=d;b/=d;
    }
}Ret[maxn];
void dfs(int x)
{
    Vis[x]=true;
    Ret[x]=Frac(Ans,way(Num));
    tr(e,Adj[x])if(!Vis[*e])
    {
        move(P[x],P[*e]);
        dfs(*e);
        move(P[*e],P[x]);
    }
}
void Solve()
{
    int vs=0;
    insert(P[vs].x,P[vs].y);
    dfs(vs);
    rep(i,m)
        printf("%d/%d\n",Ret[i].a,Ret[i].b);
}
int main()
{
    Init();
    BuildMST();
    Solve();
}


</pre><pre></pre><h2>Problem2038</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
typedef long long ll;
const int maxn=50000+10,maxSqrt=800;
struct TA
{
    int A[maxn],n;
    void SetSize(int _n)
    {
        n=_n;
        memset(A,0,sizeof A);
    }
    int Sum(int p)
    {
        int ret=0;
        for(p++;p;p-=p&amp;-p)
            ret+=A[p-1];
        return ret;
    }
    int Sum(int l,int r)
    {
        return Sum(r)-Sum(l-1);
    }
    void Update(int p,int d)
    {
        int ret=0;
        for(p++;p&lt;=n;p+=p&amp;-p)
            A[p-1]+=d;
    }
}T;
struct List
{
    vector&lt;int&gt;A;
    void add(int x)
    {
        A.pb(x);
    }
    void doit()
    {
        sort(All(A));
    }
    int get(int l,int r)
    {
        return upper_bound(All(A),r)-lower_bound(All(A),l);
    }
    int id(int x)
    {
        return lower_bound(All(A),x)-A.begin();
    }
    int operator[](int v)
    {
        return A[v];
    }
}List_C[maxn],Id;
int SqrtN,N,M,Seq[maxn];
int Count[maxn];
int BigC[maxn],BigNum=0;
void Input_Data()
{
    scanf("%d%d",&amp;N,&amp;M);
    SqrtN=sqrt(N);
    rep(i,N)
    {
        scanf("%d",Seq+i);
        Count[--Seq[i]]++;
    }
}
void PrePare_Data()
{
    rep(i,N)
    {
        if(Count[i]&gt;SqrtN)
        {
            BigC[BigNum++]=i;
        }
    }
    rep(i,N)
    {
        int c=Seq[i];
        List_C[c].add(i);
    }
}
const int maxm=50000+10;
int head[maxn],mnt;
int gcd(int a,int b){return b?gcd(b,a%b):a;}
struct Ans_Type
{
    int A,B;
    void Set(int _A,int _B)
    {
        A=_A;
        B=_B;
        int d=gcd(A,B);
        A/=d;B/=d;
    }
    void OutPut()
    {
        printf("%d/%d\n",A,B);
    }
}Ans[maxm];
int Left[maxm],nxt[maxm];
void Clear_List()
{
    memset(head,-1,sizeof head);
    mnt=0;
}
void Add_Query(int l,int r)
{
    Left[mnt]=l;nxt[mnt]=head[r];
    head[r]=mnt++;
}
void ReadIn_Query()
{
    int l,r;
    Clear_List();
    rep(i,M)
    {
        scanf("%d%d",&amp;l,&amp;r);
        --l;--r;
        Add_Query(l,r);
    }
}
inline int way(int x)
{
    return ll(x)*(x-1)/2;
}
void Solve()
{
    T.SetSize(N);
    for(int r=0;r&lt;N;r++)
    {
        int c=Seq[r];
        if(Count[c]&lt;=SqrtN)
        {
            int p=List_C[c].id(r);
            for(int j=0;j&lt;p;j++)
                T.Update(List_C[c][j],1);
        }
        for(int e=head[r];e!=-1;e=nxt[e])
        {
            int l=Left[e];int B=way(r-l+1);
            int A=0;
            rep(i,BigNum)
            {
                A+=way(List_C[BigC[i]].get(l,r));
            }
            A+=T.Sum(l,r);
            Ans[e].Set(A,B);
        }
    }
    rep(i,M)
    {
        Ans[i].OutPut();
    }
}
int main()
{
    //freopen("in","r",stdin);
    Input_Data();
    PrePare_Data();
    ReadIn_Query();
    Solve();
}
</pre><pre></pre><h2>Problem2038</h2><pre>/*
    Author: WJMZBMR
    Time Complexity: N*LogN*SqrtN
    Data: Sep 28
*/
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
typedef long long ll;
const int maxn=50000+10,maxSqrt=800;
struct TA
{
    int A[maxn],n;
    void SetSize(int _n)
    {
        n=_n;
        memset(A,0,sizeof A);
    }
    int Sum(int p)
    {
        int ret=0;
        for(p++;p;p-=p&amp;-p)
            ret+=A[p-1];
        return ret;
    }
    int Sum(int l,int r)
    {
        return Sum(r)-Sum(l-1);
    }
    void Update(int p,int d)
    {
        int ret=0;
        for(p++;p&lt;=n;p+=p&amp;-p)
            A[p-1]+=d;
    }
}T;
int SqrtN,N,M,Seq[maxn];
int Prev[maxn],Last[maxn];
void Input_Data()
{
    scanf("%d%d",&amp;N,&amp;M);
    memset(Last,-1,sizeof Last);
    rep(i,N)
    {
        int c;
        scanf("%d",&amp;c);Seq[i]=c;
        Prev[i]=Last[c];
        Last[c]=i;
    }
}
const int maxm=50000+10;
int head[maxn],mnt;
int gcd(int a,int b){return b?gcd(b,a%b):a;}
struct Ans_Type
{
    int A,B;
    void Set(int _A,int _B)
    {
        A=_A;
        B=_B;
        int d=gcd(A,B);
        A/=d;B/=d;
    }
    void OutPut()
    {
        printf("%d/%d\n",A,B);
    }
}Ans[maxm];
int Left[maxm],nxt[maxm];
void Clear_List()
{
    memset(head,-1,sizeof head);
    mnt=0;
}
void Add_Query(int l,int r)
{
    Left[mnt]=l;nxt[mnt]=head[r];
    head[r]=mnt++;
}
void ReadIn_Query()
{
    int l,r;
    Clear_List();
    rep(i,M)
    {
        scanf("%d%d",&amp;l,&amp;r);
        --l;--r;
        Add_Query(l,r);
    }
}
inline int way(int x)
{
    return ll(x)*(x-1)/2;
}
void Solve()
{
    T.SetSize(N);
    for(int r=0;r&lt;N;r++)
    {
        int c=Seq[r];
        for(int p=Prev[r];p!=-1;p=Prev[p])
            T.Update(p,1);
        for(int e=head[r];e!=-1;e=nxt[e])
        {
            int l=Left[e];int B=way(r-l+1);
            int A=T.Sum(l,r);
            Ans[e].Set(A,B);
        }
    }
    rep(i,M)
    {
        Ans[i].OutPut();
    }
}
int main()
{
    //freopen("in","r",stdin);
    Input_Data();
    ReadIn_Query();
    Solve();
}
</pre><pre></pre><h2>Problem2038</h2><pre>/*
    Author: WJMZBMR
    Time Complexity: N*LogN*SqrtN
    Data: Sep 28
*/
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
typedef long long ll;
const int maxn=50000+10,maxSqrt=800;
struct TA
{
    int A[maxn],n;
    void SetSize(int _n)
    {
        n=_n;
        memset(A,0,sizeof A);
    }
    int Sum(int p)
    {
        int ret=0;
        for(p++;p;p-=p&amp;-p)
            ret+=A[p-1];
        return ret;
    }
    int Sum(int l,int r)
    {
        return Sum(r)-Sum(l-1);
    }
    void Update(int p,int d)
    {
        int ret=0;
        for(p++;p&lt;=n;p+=p&amp;-p)
            A[p-1]+=d;
    }
}T;
struct List
{
    int*A,n;
    int RetR;
    void SetSize(int _n)
    {
        n=0;RetR=0;
        A=new int[_n];
        memset(A,0,sizeof(int)*_n);
    }
    void add(int x)
    {
        A[n++]=x;
    }
    int get(int l,int r)
    {
        return A+RetR-lower_bound(A,A+n,l);
    }
    void getR(int Pos)
    {
        while(RetR&lt;n&amp;&amp;A[RetR]&lt;=Pos)RetR++;
    }
}List_C[maxSqrt];
int SqrtN,N,M,Seq[maxn];
int Count[maxn],Id[maxn];
int BigNum=0;
int Prev[maxn],Last[maxn];
#define BUFSIZE 1000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
#define read() \
	do{ \
		if (pt &gt;= pend) \
		{ \
			pt = buf; \
			fread(buf, 1, BUFSIZE, stdin); \
		} \
	} while(0)

#define scan(t) \
{ \
	t = 0; \
	read(); \
	while (!((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {pt ++; read();} \
	while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
}
int A[20],k;
char p[10000000];
char*opt=p;
inline void print_int(int x)
{
    if(x&lt;0)*opt++='-',x=-x;
    if(!x)*opt++='0';
    k=0;while(x)A[k++]=x%10,x/=10;
    for(int i=k-1;i&gt;=0;i--)*opt++='0'+A[i];
}
void Input_Data()
{
    scan(N);scan(M);
    memset(Last,-1,sizeof Last);
    SqrtN=sqrt(N)*3;
    rep(i,N)
    {
        int c;
        scan(c);
        Count[--c]++;
        Prev[i]=Last[c];
        Last[c]=i;
        Seq[i]=c;
    }
}
void PrePare_Data()
{
    rep(i,N)
    {
        if(Count[i]&gt;SqrtN)
        {
            List_C[BigNum].SetSize(Count[i]);
            Id[i]=BigNum++;
        }
        else
        {
            Id[i]=-1;
        }
    }
    rep(i,N)
    {
        int c=Seq[i];
        if(Id[c]&gt;=0)
            List_C[Id[c]].add(i);
    }
}
const int maxm=50000+10;
int head[maxn],mnt;
int gcd(int a,int b){return b?gcd(b,a%b):a;}
struct Ans_Type
{
    int A,B;
    void Set(int _A,int _B)
    {
        A=_A;
        B=_B;
        int d=gcd(A,B);
        A/=d;B/=d;
    }
    void OutPut()
    {
        print_int(A);
        *opt++='/';
        print_int(B);
        *opt++='\n';
    }
}Ans[maxm];
int Left[maxm],nxt[maxm];
void Clear_List()
{
    memset(head,-1,sizeof head);
    mnt=0;
}
void Add_Query(int l,int r)
{
    Left[mnt]=l;nxt[mnt]=head[r];
    head[r]=mnt++;
}
void ReadIn_Query()
{
    int l,r;
    Clear_List();
    rep(i,M)
    {
        scan(l);scan(r);
        --l;--r;
        Add_Query(l,r);
    }
}
inline int way(int x)
{
    return ll(x)*(x-1)/2;
}
void Solve()
{
    T.SetSize(N);
    for(int r=0;r&lt;N;r++)
    {
        int c=Seq[r];
        if(Count[c]&lt;=SqrtN)
        {
            for(int p=Prev[r];p!=-1;p=Prev[p])
                T.Update(p,1);
        }
        for(int e=head[r];e!=-1;e=nxt[e])
        {
            int l=Left[e];int B=way(r-l+1);
            int A=0;
            rep(i,BigNum)
                List_C[i].getR(r),
                A+=way(List_C[i].get(l,r));
            A+=T.Sum(l,r);
            Ans[e].Set(A,B);
        }
    }

    rep(i,M)
        Ans[i].OutPut();
    *opt++='\0';
    puts(p);
}
int main()
{
    //freopen("in","r",stdin);
    Input_Data();
    PrePare_Data();
    ReadIn_Query();
    Solve();
}
</pre><pre></pre><h2>Problem2038</h2><pre>/*
    Author: WJMZBMR
    Time Complexity: N*LogN*SqrtN
    Data: Sep 28
*/
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
typedef long long ll;
const int maxn=50000+10,maxSqrt=800;
struct TA
{
    int A[maxn],n;
    void SetSize(int _n)
    {
        n=_n;
        memset(A,0,sizeof A);
    }
    int Sum(register int p)
    {
        int ret=0;
        for(p++;p;p-=p&amp;-p)
            ret+=A[p-1];
        return ret;
    }
    int Sum(int l,int r)
    {
        return Sum(r)-Sum(l-1);
    }
    void Update(register int p,int d)
    {
        int ret=0;
        for(p++;p&lt;=n;p+=p&amp;-p)
            A[p-1]+=d;
    }
}T;
struct List
{
    int*A,n;
    int RetR;
    void SetSize(int _n)
    {
        n=0;RetR=0;
        A=new int[_n];
        memset(A,0,sizeof(int)*_n);
    }
    void add(int x)
    {
        A[n++]=x;
    }
    int get(int l,int r)
    {
        return A+RetR-lower_bound(A,A+RetR,l);
    }
    void getR(int Pos)
    {
        while(RetR&lt;n&amp;&amp;A[RetR]&lt;=Pos)RetR++;
    }
}List_C[maxSqrt];
int SqrtN,N,M,Seq[maxn];
int Count[maxn],Id[maxn];
int BigNum=0;
int Prev[maxn],Last[maxn];
#define BUFSIZE 1000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
#define read() \
	do{ \
		if (pt &gt;= pend) \
		{ \
			pt = buf; \
			fread(buf, 1, BUFSIZE, stdin); \
		} \
	} while(0)

#define scan(t) \
{ \
	t = 0; \
	read(); \
	while (!((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {pt ++; read();} \
	while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
}
int A[20],k;
char p[10000000];
char*opt=p;
inline void print_int(int x)
{
    if(x&lt;0)*opt++='-',x=-x;
    if(!x)*opt++='0';
    k=0;while(x)A[k++]=x%10,x/=10;
    for(int i=k-1;i&gt;=0;i--)*opt++='0'+A[i];
}
void Input_Data()
{
    scan(N);scan(M);
    memset(Last,-1,sizeof Last);
    SqrtN=sqrt(N)*3;
    rep(i,N)
    {
        int c;
        scan(c);
        Count[--c]++;
        Prev[i]=Last[c];
        Last[c]=i;
        Seq[i]=c;
    }
}
void PrePare_Data()
{
    rep(i,N)
    {
        if(Count[i]&gt;SqrtN)
        {
            List_C[BigNum].SetSize(Count[i]);
            Id[i]=BigNum++;
        }
        else
        {
            Id[i]=-1;
        }
    }
    rep(i,N)
    {
        int c=Seq[i];
        if(Id[c]&gt;=0)
            List_C[Id[c]].add(i);
    }
}
const int maxm=50000+10;
int head[maxn],mnt;
int gcd(int a,int b){return b?gcd(b,a%b):a;}
struct Ans_Type
{
    int A,B;
    void Set(int _A,int _B)
    {
        A=_A;
        B=_B;
        int d=gcd(A,B);
        A/=d;B/=d;
    }
    void OutPut()
    {
        print_int(A);
        *opt++='/';
        print_int(B);
        *opt++='\n';
    }
}Ans[maxm];
int Left[maxm],nxt[maxm];
void Clear_List()
{
    memset(head,-1,sizeof head);
    mnt=0;
}
void Add_Query(int l,int r)
{
    Left[mnt]=l;nxt[mnt]=head[r];
    head[r]=mnt++;
}
void ReadIn_Query()
{
    int l,r;
    Clear_List();
    rep(i,M)
    {
        scan(l);scan(r);
        --l;--r;
        Add_Query(l,r);
    }
}
inline int way(int x)
{
    return ll(x)*(x-1)/2;
}
void Solve()
{
    T.SetSize(N);
    for(int r=0;r&lt;N;r++)
    {
        int c=Seq[r];
        if(Count[c]&lt;=SqrtN)
        {
            for(int p=Prev[r];p!=-1;p=Prev[p])
                T.Update(p,1);
        }
        for(int e=head[r];e!=-1;e=nxt[e])
        {
            int l=Left[e];int B=way(r-l+1);
            int A=0;
            rep(i,BigNum)
                List_C[i].getR(r),
                A+=way(List_C[i].get(l,r));
            A+=T.Sum(l,r);
            Ans[e].Set(A,B);
        }
    }

    rep(i,M)
        Ans[i].OutPut();
    *opt++='\0';
    puts(p);
}
int main()
{
    //freopen("in","r",stdin);
    Input_Data();
    PrePare_Data();
    ReadIn_Query();
    Solve();
}
</pre><pre></pre><h2>Problem2038</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int maxn=50000+10;
int A[maxn]={};
int N,M,S[maxn];
int P[maxn],L[maxn];
int Sum(int p){int ret=0;for(p++;p;p-=p&amp;-p)ret+=A[p-1];return ret;}
int Sum(int l,int r){return Sum(r)-Sum(l-1);}
void Update(int p,int d){for(p++;p&lt;=N;p+=p&amp;-p)A[p-1]+=d;}
int h[maxn];
int g(int a,int b){return b?g(b,a%b):a;}
int X[maxn],Y[maxn];
int T[maxn],nx[maxn];
int main()
{
    scanf("%d%d",&amp;N,&amp;M);
    memset(L,-1,sizeof L);
    int c;
    rep(i,N)scanf("%d",&amp;c),S[i]=c,P[i]=L[c],L[c]=i;
    int l,r;
    memset(h,-1,sizeof h);
    rep(i,M)
        scanf("%d%d",&amp;l,&amp;r),T[i]=--l,nx[i]=h[--r],h[r]=i;
    for(int r=0;r&lt;N;r++)
    {
        int c=S[r];
        for(int p=P[r];p!=-1;p=P[p])
            Update(p,1);
        for(int e=h[r];e!=-1;e=nx[e])
        {
            int l=T[e];X[e]=(long long)(r-l+1)*(r-l)/2;
            Y[e]=Sum(l,r);
            int d=g(X[e],Y[e]);X[e]/=d;Y[e]/=d;
        }
    }
    rep(i,M)
        printf("%d/%d\n",Y[i],X[i]);
}
</pre><pre></pre><h2>Problem2038</h2><pre>#include&lt;string.h&gt;
#define rep(i,n) for(i=0;i&lt;n;i++)
#define Q 50010
g(int a,int b){return b?g(b,a%b):a;}A[Q]={},N,M,S[Q],P[Q],L[Q],h[Q],X[Q],Y[Q],T[Q],nx[Q],i,c,l,r;
u(int p){int r=0;for(p++;p;p-=p&amp;-p)r+=A[p-1];return r;};
U(int p,int d){for(p++;p&lt;=N;p+=p&amp;-p)A[p-1]+=d;}
main()
{
    scanf("%d%d",&amp;N,&amp;M);
    memset(L,-1,sizeof L);
    rep(i,N)scanf("%d",&amp;c),S[i]=c,P[i]=L[c],L[c]=i;
    memset(h,-1,sizeof h);
    rep(i,M)scanf("%d%d",&amp;l,&amp;r),T[i]=--l,nx[i]=h[--r],h[r]=i;
    for(r=0;r&lt;N;r++)
    {
        c=S[r];for(i=P[r];i!=-1;i=P[i])U(i,1);
        for(i=h[r];i!=-1;i=nx[i])
        {
            int l=T[i];X[i]=(long long)(r-l+1)*(r-l)/2;
            Y[i]=u(r)-u(l-1);int d=g(X[i],Y[i]);X[i]/=d;Y[i]/=d;
        }
    }
    rep(i,M)printf("%d/%d\n",Y[i],X[i]);
}
</pre><pre></pre><h2>Problem2038</h2><pre>#include&lt;string.h&gt;
#define rep(i,n) for(i=1;i&lt;=n;i++)
#define Q 50010
g(int a,int b){return b?g(b,a%b):a;}A[Q]={},N,M,S[Q],P[Q],L[Q]={},h[Q]={},X[Q],Y[Q],T[Q],nx[Q],i,c,l,r;
u(int p){int r=0;for(;p;p-=p&amp;-p)r+=A[p];return r;};
U(int p,int d){for(;p&lt;=N;p+=p&amp;-p)A[p]+=d;}
main()
{
    scanf("%d%d",&amp;N,&amp;M);
    rep(i,N)scanf("%d",&amp;c),S[i]=c,P[i]=L[c],L[c]=i;
    rep(i,M)scanf("%d%d",&amp;l,&amp;r),T[i]=l,nx[i]=h[r],h[r]=i;
    for(r=1;r&lt;=N;r++)
    {
        c=S[r];for(i=P[r];i;i=P[i])U(i,1);
        for(i=h[r];i;i=nx[i])
        {
            l=T[i];X[i]=(long long)(r-l+1)*(r-l)/2;
            Y[i]=u(r)-u(l-1);c=g(X[i],Y[i]);X[i]/=c;Y[i]/=c;
        }
    }
    rep(i,M)printf("%d/%d\n",Y[i],X[i]);
}
</pre><pre></pre><h2>Problem2038</h2><pre>#define rep(i,n) for(i=1;i&lt;=n;i++)
#define Q 50010
g(int a,int b){return b?g(b,a%b):a;}A[Q]={},N,M,S[Q],P[Q],L[Q]={},h[Q]={},X[Q],Y[Q],T[Q],nx[Q],i,c,l,r;
u(int p){int r=0;for(;p;p-=p&amp;-p)r+=A[p];return r;};
U(int p,int d){for(;p&lt;=N;p+=p&amp;-p)A[p]+=d;}
J(a){scanf("%d",a);}
main()
{
    J(&amp;N);J(&amp;M);
    rep(i,N)J(&amp;c),S[i]=c,P[i]=L[c],L[c]=i;
    rep(i,M)J(&amp;l),J(&amp;r),T[i]=l,nx[i]=h[r],h[r]=i;
    rep(r,N)
    {
        for(i=P[r];i;i=P[i])U(i,1);
        for(i=h[r];i;i=nx[i])
        {
            l=T[i];X[i]=(long long)(r-l+1)*(r-l)/2;
            Y[i]=u(r)-u(l-1);c=g(X[i],Y[i]);X[i]/=c;Y[i]/=c;
        }
    }
    rep(i,M)printf("%d/%d\n",Y[i],X[i]);
}
</pre><pre></pre><h2>Problem2038</h2><pre>#define rep(i,n) for(i=1;i&lt;=n;i++)
#define Q 50010
g(int a,int b){return b?g(b,a%b):a;}A[Q]={},N,M,S[Q],P[Q],L[Q]={},h[Q]={},X[Q],Y[Q],T[Q],x[Q],i,c,l,r;
u(int p){int r=0;for(;p;p-=p&amp;-p)r+=A[p];return r;};
J(a){scanf("%d",a);}
main()
{
    J(&amp;N);J(&amp;M);
    rep(i,N)J(&amp;c),S[i]=c,P[i]=L[c],L[c]=i;
    rep(i,M)J(&amp;l),J(&amp;r),T[i]=l,x[i]=h[r],h[r]=i;
    rep(r,N)
    {
        for(i=P[r];i;i=P[i])for(c=i;c&lt;=N;c+=c&amp;-c)A[c]++;
        for(i=h[r];i;i=x[i])
        {
            l=T[i];X[i]=(long long)(r-l+1)*(r-l)/2;
            Y[i]=u(r)-u(l-1);c=g(X[i],Y[i]);X[i]/=c;Y[i]/=c;
        }
    }
    rep(i,M)printf("%d/%d\n",Y[i],X[i]);
}
</pre><pre></pre><h2>Problem2038</h2><pre>#define rep(i,n) for(i=1;i&lt;=n;i++)
#define Q 50010
g(int a,int b){return b?g(b,a%b):a;}A[Q],N,M,S[Q],P[Q],L[Q],h[Q],X[Q],Y[Q],T[Q],x[Q],i,c,l,r;u(int p){int r=0;for(;p;p-=p&amp;-p)r+=A[p];return r;}J(a){scanf("%d",a);}main(){J(&amp;N);J(&amp;M);rep(i,N)J(&amp;c),S[i]=c,P[i]=L[c],L[c]=i;rep(i,M)J(&amp;l),J(&amp;r),T[i]=l,x[i]=h[r],h[r]=i;rep(r,N){for(i=P[r];i;i=P[i])for(c=i;c&lt;=N;c+=c&amp;-c)A[c]++;for(i=h[r];i;i=x[i]){l=T[i];X[i]=(long long)(r-l+1)*(r-l)/2;Y[i]=u(r)-u(l-1);c=g(X[i],Y[i]);X[i]/=c;Y[i]/=c;}}rep(i,M)printf("%d/%d\n",Y[i],X[i]);}
</pre><pre></pre><h2>Problem2038</h2><pre>/*
    Author: WJMZBMR
    Time Complexity: N*LogN*SqrtN
    Data: Sep 28
*/
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
typedef long long ll;
const int maxn=50000+10,maxSqrt=800;
int N,M,SqrtN;
int Prev[maxn],Last[maxn];
#define BUFSIZE 1000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
#define read() \
	do{ \
		if (pt &gt;= pend) \
		{ \
			pt = buf; \
			fread(buf, 1, BUFSIZE, stdin); \
		} \
	} while(0)

#define scan(t) \
{ \
	t = 0; \
	read(); \
	while (!((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {pt ++; read();} \
	while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
}
int A[20],k;
char p[10000000];
char*opt=p;
inline void print_int(int x)
{
    if(x&lt;0)*opt++='-',x=-x;
    if(!x)*opt++='0';
    k=0;while(x)A[k++]=x%10,x/=10;
    for(int i=k-1;i&gt;=0;i--)*opt++='0'+A[i];
}
void Input_Data()
{
    scan(N);scan(M);
    SqrtN=sqrt(N)+1;
    memset(Last,-1,sizeof Last);
    rep(i,N)
    {
        int c;
        scan(c);
        Prev[i]=Last[c];
        Last[c]=i;
    }
}
const int maxm=50000+10;
int head[maxn],mnt;
int gcd(int a,int b){return b?gcd(b,a%b):a;}
struct Ans_Type
{
    int A,B;
    void Set(int _A,int _B)
    {
        A=_A;
        B=_B;
        int d=gcd(A,B);
        A/=d;B/=d;
    }
    void OutPut()
    {
        print_int(A);
        *opt++='/';
        print_int(B);
        *opt++='\n';
    }
}Ans[maxm];
int Left[maxm],nxt[maxm];
void Clear_List()
{
    memset(head,-1,sizeof head);
    mnt=0;
}
void Add_Query(int l,int r)
{
    Left[mnt]=l;nxt[mnt]=head[r];
    head[r]=mnt++;
}
void ReadIn_Query()
{
    int l,r;
    Clear_List();
    rep(i,M)
    {
        scan(l);scan(r);
        --l;--r;
        Add_Query(l,r);
    }
}
inline int way(int x)
{
    return ll(x)*(x-1)/2;
}
int S[maxSqrt],C[maxn];
inline void Update(int p,int d)
{
    C[p]+=d;
    S[p/SqrtN]+=d;
}
int Sum(int l,int r)
{
    int L=l/SqrtN,R=r/SqrtN,ret=0;
    #define pass(l,r) for(int i=l;i&lt;=r;i++)ret+=C[i]
    if(L==R)
    {
        pass(l,r);
        return ret;
    }
    pass(l,(L+1)*SqrtN-1);
    pass(R*SqrtN,r);
    for(int i=L+1;i&lt;=R-1;i++)ret+=S[i];
    return ret;
}
void Solve()
{
    for(int r=0;r&lt;N;r++)
    {
        for(int p=Prev[r];p!=-1;p=Prev[p])
            Update(p,1);
        for(int e=head[r];e!=-1;e=nxt[e])
        {
            int l=Left[e];int B=way(r-l+1);
            int A=Sum(l,r);
            Ans[e].Set(A,B);
        }
    }
    rep(i,M)
    {
        Ans[i].OutPut();
    }
    *opt++='\0';
    puts(p);
}
int main()
{
    //freopen("in","r",stdin);
    Input_Data();
    ReadIn_Query();
    Solve();
}
</pre><pre></pre><h2>Problem2039</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
using namespace std;
const int maxv=1000+10,maxe=maxv*maxv*2;
typedef long long ll;
const ll inf=1LL&lt;&lt;60,dt=1LL&lt;&lt;50;
int head[maxv];
int nxt[maxe],to[maxe],mnt;
ll c[maxe],E[maxv][maxv],A[maxv];
int n;
int vs,vt,v;
void Clear_List()
{
    memset(head,-1,sizeof head);
    mnt=0;
}
void AddEdge(int s,int _t,ll _c)
{
    to[mnt]=_t;c[mnt]=_c;nxt[mnt]=head[s];
    head[s]=mnt++;
}
void InsEdge(int s,int t,ll c,bool bi=false)
{
    AddEdge(s,t,c);
    AddEdge(t,s,bi?c:0);
}
template&lt;class T&gt;
inline void scan(T&amp;t)
{
    char c;
    while(c=getchar(),c&lt;'0'||c&gt;'9');t=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
}
void Input_Data()
{
    scan(n);
    rep(i,n)scan(A[i]);
    rep(i,n)rep(j,n)scan(E[i][j]);
}
void Build_Graph()
{
    v=n;vs=v++;vt=v++;
    Clear_List();
    rep(i,n)
    {
        ll S=A[i];
        rep(j,n)
        {
            if(i&lt;j)InsEdge(i,j,2*E[i][j],true);
            S-=E[i][j];
        }
        InsEdge(vs,i,0+dt);
        InsEdge(i,vt,S+dt);
    }
}
int D[maxv];
ll Flow=0;
bool Dinic_ReLabel()
{
    static int Q[maxv],h,t;
    memset(D,-1,sizeof D);
    for(h=t=0,Q[t++]=vs,D[vs]=0;h&lt;t;h++)
    {
        int x=Q[h];
        for(int e=head[x];e!=-1;e=nxt[e])
            if(c[e]&amp;&amp;D[to[e]]==-1)
            {
                Q[t++]=to[e];
                D[to[e]]=D[x]+1;
                if(to[e]==vt)return true;
            }
    }
    return false;
}
void Dinic_Aug()
{
    static int Stack[maxv],top;
    static int P[maxv],E[maxv];
    memcpy(E,head,sizeof E);
    top=0;Stack[top++]=vs;
    while(top)
    {
        int x=Stack[top-1];
        if(x==vt)
        {
            ll dt=inf;
            for(int i=top-1;i&gt;=1;i--)
                dt=min(dt,c[P[i]]);
            Flow+=dt;
            for(int i=top-1;i&gt;=1;i--)
            {
                c[P[i]]-=dt;
                c[P[i]^1]+=dt;
                if(!c[P[i]])top=i;
            }
        }
        else
        {
            int&amp;e=E[x];
            for(;e!=-1;e=nxt[e])
                if(c[e]&amp;&amp;D[x]+1==D[to[e]])break;
            if(e==-1)D[x]=-1,top--;
            else
            {
                Stack[top]=to[e];
                P[top]=e;
                top++;
            }
        }
    }
}
ll Cal_MaxFlow()
{
    while(Dinic_ReLabel())
        Dinic_Aug();
    return Flow;
}
void Solve()
{
    ll Ans=n*dt-Cal_MaxFlow();
    cout&lt;&lt;Ans&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    Input_Data();
    Build_Graph();
    Solve();
}
</pre><pre></pre><h2>Problem2044</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1,maxn=1000+10;
using namespace std;
typedef long long ll;
int n;
struct Point
{
    int x[3];
    bool operator&lt;(const Point&amp;a)const
    {
        return x[0]&lt;a.x[0];
    }
    bool CanReach(const Point&amp;a)const
    {
        rep(i,3)if(x[i]&gt;=a.x[i])return false;
        return true;
    }
    void read()
    {
        rep(i,3)scanf("%d",x+i);
    }
}A[maxn];
void Init()
{
    cin&gt;&gt;n;
    rep(i,n)A[i].read();
    sort(A,A+n);
}
void CalMax()
{
    static int Dp[maxn];
    Dp[0]=1;
    for(int i=1;i&lt;n;i++)
    {
        int ret=0;
        for(int j=0;j&lt;i;j++)
            if(A[j].CanReach(A[i]))
                ret=max(ret,Dp[j]);
        Dp[i]=ret+1;
    }
    int ret=0;
    rep(i,n)ret=max(ret,Dp[i]);
    cout&lt;&lt;ret&lt;&lt;endl;
}
bool E[maxn][maxn]={};
int Link[maxn];
bool Vis[maxn];
bool dfs(int x)
{
    if(Vis[x])return false;
    Vis[x]=true;
    rep(i,n)if(E[x][i])
    {
        if(Link[i]==-1||dfs(Link[i]))
            return Link[i]=x,true;
    }
    return false;
}
void BuildGraph()
{
    rep(i,n)rep(j,n)
        E[i][j]=A[i].CanReach(A[j]);
}
void CalNum()
{
    BuildGraph();
    int ans=0;
    memset(Link,-1,sizeof Link);
    rep(i,n)
    {
        memset(Vis,0,sizeof Vis);
        if(dfs(i))ans++;
    }
    cout&lt;&lt;n-ans&lt;&lt;endl;
}
void Solve()
{
    CalMax();
    CalNum();
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


</pre><pre></pre><h2>Problem2044</h2><pre>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define All(x) x.begin(),x.end()
#define pb push_back
#define OK puts("OK")
const int inf=~0U&gt;&gt;1,maxn=1000+10;
using namespace std;
typedef long long ll;
int n;
struct Point
{
    int x[3];
    bool operator&lt;(const Point&amp;a)const
    {
        return x[0]&lt;a.x[0];
    }
    bool CanReach(const Point&amp;a)const
    {
        rep(i,3)if(x[i]&gt;=a.x[i])return false;
        return true;
    }
    void read()
    {
        rep(i,3)scanf("%d",x+i);
    }
}A[maxn];
void Init()
{
    cin&gt;&gt;n;
    rep(i,n)A[i].read();
    sort(A,A+n);
}
void CalMax()
{
    static int Dp[maxn];
    Dp[0]=1;
    for(int i=1;i&lt;n;i++)
    {
        int ret=0;
        for(int j=0;j&lt;i;j++)
            if(A[j].CanReach(A[i]))
                ret=max(ret,Dp[j]);
        Dp[i]=ret+1;
    }
    int ret=0;
    rep(i,n)ret=max(ret,Dp[i]);
    cout&lt;&lt;ret&lt;&lt;endl;
}
bool E[maxn][maxn]={};
int Link[maxn];
bool Vis[maxn];
bool dfs(int x)
{
    if(Vis[x])return false;
    Vis[x]=true;
    for(int i=x+1;i&lt;n;i++)if(E[x][i])
    {
        if(Link[i]==-1||dfs(Link[i]))
            return Link[i]=x,true;
    }
    return false;
}
void BuildGraph()
{
    rep(i,n)for(int j=i+1;j&lt;n;j++)
        E[i][j]=A[i].CanReach(A[j]);
}
void CalNum()
{
    BuildGraph();
    int ans=0;
    memset(Link,-1,sizeof Link);
    rep(i,n)
    {
        memset(Vis,0,sizeof Vis);
        if(dfs(i))ans++;
    }
    cout&lt;&lt;n-ans&lt;&lt;endl;
}
void Solve()
{
    CalMax();
    CalNum();
}
int main()
{
    //freopen("in","r",stdin);
    Init();
    Solve();
}


</pre><pre></pre><h2>Problem2045</h2><pre>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int maxn=1000000+10;
using namespace std;
typedef long long ll;
int P[maxn]={},N;
bool notP[maxn]={};
void getPrime()
{
    for(int i=1;i&lt;=N;i++)P[i]=1;
    for(int x=2;x&lt;=N;)
    {
        if(ll(x)*x&lt;=N)
        {
            int t=x*x;
            for(int i=t;i&lt;=N;i+=t)P[i]=0;
        }
        for(int i=x;i&lt;=N;i+=x)
            P[i]*=-1,notP[i]=true;
        x++;
        while(x&lt;=N&amp;&amp;notP[x])x++;
    }
}
int main()
{
    //freopen("in","r",stdin);
    int a,b,k;
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;k;
    a/=k;b/=k;
    if(a&gt;b)swap(a,b);
    N=b;
    getPrime();
    P[0]=0;
    for(int i=1;i&lt;=N;i++)P[i]+=P[i-1];
    ll ans=0;
    for(int t=1;t&lt;=a;t++)
    {
        int m=min(a/(a/t),b/(b/t))-t;
        ans+=ll(P[t+m]-P[t-1])*(a/t)*(b/t);
        t+=m;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem2049</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int maxn=10000+10;
int F[maxn],n,m;
void Clear_List()
{
    rep(i,n)F[i]=i;
}
int Find_Root(int u)
{
    while(u!=F[u])u=F[u];
    return u;
}
bool Query(int u,int v)
{
    return Find_Root(u)==Find_Root(v);
}
void Mark_Root(int u)
{
    int v=F[u],t;F[u]=u;
    while(u!=v)
    {
        t=F[v];F[v]=u;
        u=v;v=t;
    }
}
void Connect(int u,int v)
{
    Mark_Root(u);
    Mark_Root(v);
    F[v]=u;
}
void Destroy(int u,int v)
{
    Mark_Root(u);
    F[v]=v;
}
char c[100];
int main()
{
    //freopen("in","r",stdin);
    scanf("%d%d",&amp;n,&amp;m);int u,v;
    Clear_List();
    rep(i,m)
    {
        scanf(" ");scanf("%s%d%d",c,&amp;u,&amp;v);
        u--;v--;
        switch(c[0])
        {
            case 'Q':Query(u,v)?puts("Yes"):puts("No");break;
            case 'C':Connect(u,v);break;
            case 'D':Destroy(u,v);break;
        }
    }
}
</pre><pre></pre><h2>Problem2051</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define tr(e,G,u) for(int e=G.head[u];e!=-1;e=G.next[e])
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define OK puts("OK")
using namespace std;
const int N_MAX=50000+10;
const int VT_MAX=N_MAX*2;
const int EG_MAX=VT_MAX*2;
const int DP_MAX=30;
const int W_MAX=10000+10;
namespace IO
{
    namespace Scanner
    {
        inline void scan(int&amp;t)
        {
            int sign=1;char c;
            while(c=getchar(),c&lt;'0'||c&gt;'9')
                if(c=='-')break;
            if(c=='-')t=0,sign=-1;
            else t=c-'0';
            while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')t=t*10+c-'0';
            t*=sign;
        }
    }
    namespace Printer
    {
        inline void print_int(int t)
        {
            static int A[20];int p=0;
            if(!t){putchar('0');putchar('\n');return;}
            while(t)A[p++]=t%10,t/=10;
            for(int i=p-1;i&gt;=0;i--)
                putchar('0'+A[i]);
            putchar('\n');
        }
    }
}
namespace Data_Struct
{
    struct Array
    {
        int*Data,n;
        void init_size(int Size){n=0;Data=new int[Size];}
        void add_item(int x){Data[n++]=x;}
        void doit(){sort(Data,Data+n);}
        int count_less(int t){return lower_bound(Data,Data+n,t)-Data;}
        void operator=(const Array&amp;arr)
        {
            n=arr.n;
            memcpy(Data,arr.Data,sizeof(int)*n);
        }
    };
    struct TSplit
    {
        Array Orig[2],Sorted[2];
        int sp_cost;
        int id;
        void set_Size(int s[2])
        {
            rep(dir,2)
                Orig[dir].init_size(s[dir]),
                Sorted[dir].init_size(s[dir]);
        }
        int add_item(bool side,int dep)//return id
        {
            Orig[side].add_item(dep);
            return Orig[side].n-1;
        }
        void doit()
        {
            rep(dir,2)
                Sorted[dir]=Orig[dir],
                Sorted[dir].doit();
        }
        int count_less(int u,bool side,int L)
        {
            L-=Orig[side].Data[u]+sp_cost;
            return Sorted[!side].count_less(L);
        }
        int get_max(int u,bool side)
        {
            return Orig[side].Data[u]+sp_cost+Sorted[side].Data[Sorted[side].n-1];
        }
    };
    struct Town
    {
        int idx,owner;
        bool side;
    };
    struct Towns
    {
        Town A[DP_MAX];
        int Cnt;
        void init(){Cnt=0;}
        void add(Town a){A[Cnt++]=a;}
    };
    struct TGraph
    {
        int head[VT_MAX],vet;
        int dest[EG_MAX],next[EG_MAX],cost[EG_MAX],mnt;
        bool exist[EG_MAX];
        void init_graph(int _vet=VT_MAX)
        {
            vet=_vet;
            memset(head,-1,vet*sizeof(int));
            mnt=0;
        }
        void add_edge(int s,int t,int c)
        {
            dest[mnt]=t;cost[mnt]=c;next[mnt]=head[s];exist[mnt]=true;
            head[s]=mnt++;
        }
        void ins_edge(int s,int t,int c)
        {
            add_edge(s,t,c);
            add_edge(t,s,c);
        }
        int find_edge(int s,int t)
        {
            tr(e,(*this),s)if(dest[e]==t)
                return e;
            return -1;
        }
        void clear_edge(int s,int t)
        {
            int e=find_edge(s,t);
            if(e&gt;=0)exist[e]=false;
        }
        void del_edge(int s,int t)
        {
            clear_edge(s,t);
            clear_edge(t,s);
        }
    };
}
namespace Global_Data
{
    using namespace Data_Struct;
    int Ans[N_MAX];
    int Id[VT_MAX];
    int Kth;
    TGraph Tree;
    Towns Owns[VT_MAX];
    TSplit Splits[VT_MAX*2];
    int CurSplitId=0;
}
namespace Solve
{
    using namespace IO::Scanner;
    using namespace IO::Printer;
    using namespace Global_Data;
    int Count[N_MAX],vet;
    namespace Vet_Split
    {
        int Sum[N_MAX];
        int Match[VT_MAX];
        int New_Vet;
        int get_id(int v,int id)
        {
            return Match[(v?Sum[v-1]:0)+id];
        }
        void init()
        {
            Sum[0]=Count[0];
            rep(i,vet-1)Sum[i+1]=Count[i+1]+Sum[i];
            int Pos=0,Cur=0;
            rep(i,vet)
            {
                if(Count[i]&lt;=3)
                {
                    rep(j,Count[i])
                        Match[Pos++]=Cur;
                    Cur++;
                }
                else
                {
                    rep(j,Count[i])
                        Match[Pos++]=Cur++;
                }
            }
            New_Vet=Cur;
        }
    }
    struct Edge_Data
    {
        int s,t,c,ids,idt;
        void input()
        {
            scan(s);scan(t);scan(c);
            --s;--t;
            ids=Count[s]++;idt=Count[t]++;
        }
    }E[N_MAX];
    void input_data()
    {
        scan(vet);scan(Kth);
        int s,t,c;
        memset(Count,0,sizeof Count);
        rep(i,vet-1)
        {
            E[i].input();
        }
    }
    void init_Tree()
    {
        using namespace Vet_Split;
        //cout&lt;&lt;New_Vet&lt;&lt;endl;
        Tree.init_graph(New_Vet);
        memset(Id,-1,sizeof(int)*New_Vet);
        rep(i,vet)
        {
            Id[get_id(i,0)]=i;
            if(Count[i]&gt;3)
            {
                rep(j,Count[i]-1)
                {
                    Tree.ins_edge(get_id(i,j),get_id(i,j+1),0);
                }
            }
        }
        rep(i,vet-1)
        {
            Edge_Data e=E[i];
            Tree.ins_edge(get_id(e.s,e.ids),get_id(e.t,e.idt),e.c);
        }
    }
    namespace Tree_Split
    {
        int Q[VT_MAX],F[VT_MAX],Size[VT_MAX],h,t;
        struct TVis
        {
            int Flag;
            int Data[VT_MAX];
            void init(){Flag=0;memset(Data,0,sizeof Data);}
            TVis(){init();}
            void start(){++Flag;}
            bool marked(int u){return Data[u]==Flag;}
            void mark(int u){Data[u]=Flag;}
        };
        TVis Vis;
        void Find_Split_Edge(int root,int&amp;a,int&amp;b)
        {
            h=t=0;Vis.start();
            Q[t++]=root;F[root]=-1;Vis.mark(root);
            for(;h&lt;t;h++)
            {
                int u=Q[h];
                tr(e,Tree,u)if(Tree.exist[e])
                {
                    int v=Tree.dest[e];
                    if(!Vis.marked(v))
                    {
                        Q[t++]=v;
                        F[v]=u;
                        Vis.mark(v);
                    }
                }
            }
            //OK;
            for(int i=h-1;i&gt;=0;i--)
            {
                int u=Q[i];Size[u]=Id[u]&gt;=0;
                tr(e,Tree,u)if(Tree.exist[e])
                {
                    int v=Tree.dest[e];
                    if(v!=F[u])
                    {
                        Size[u]+=Size[v];
                    }
                }
            }
            int best=VT_MAX;
            rep(i,h)
            {
                int u=Q[i];
                int ret=max(Size[root]-Size[u],Size[u]);
                if(ret&lt;best)
                {
                    best=ret;
                    a=u;b=F[u];
                }
            }
        }
        int Dep[VT_MAX];
        void Add_Vets(int vs,TSplit&amp;sp,bool side)
        {
            h=t=0;Vis.start();
            Q[t++]=vs;Dep[vs]=0;Vis.mark(vs);
            for(;h&lt;t;h++)
            {
                int u=Q[h];
                if(Id[u]&gt;=0)
                {
                    Town own;
                    own.idx=sp.add_item(side,Dep[u]);
                    own.owner=sp.id;
                    own.side=side;
                    Owns[u].add(own);
                }
                tr(e,Tree,u)if(Tree.exist[e])
                {
                    int v=Tree.dest[e];
                    if(Vis.marked(v))continue;
                    Dep[v]=Dep[u]+Tree.cost[e];
                    Vis.mark(v);Q[t++]=v;
                }
            }
        }
        void init_Structure()
        {
            rep(i,Tree.vet)
            {
                Owns[i].init();
            }
        }
        void Split_Tree(int root)
        {
            int a,b;
            Find_Split_Edge(root,a,b);
            if(Size[root]==1)return;
            TSplit&amp;sp=Splits[CurSplitId];
            int e=Tree.find_edge(a,b);
            sp.sp_cost=Tree.cost[e];
            sp.id=CurSplitId++;
            Tree.del_edge(a,b);
            int S[2]={Size[a],Size[root]-Size[a]};
            sp.set_Size(S);
            Add_Vets(a,sp,0);
            Add_Vets(b,sp,1);
            sp.doit();
            Split_Tree(a);
            Split_Tree(b);
        }
    }
    int count_less(int st,int L)
    {
        Towns&amp;Own=Owns[st];
        int ret=0;
        rep(p,Own.Cnt)
        {
            Town it=Own.A[p];
            ret+=Splits[it.owner].count_less(it.idx,it.side,L);
        }
        return ret;
    }
    int get_max_len(int st)
    {
        Towns&amp;Own=Owns[st];
        int ret=0;
        rep(p,Own.Cnt)
        {
            Town it=Own.A[p];
            ret=max(ret,Splits[it.owner].get_max(it.idx,it.side));
        }
        return ret;
    }
    int find_kth(int st)
    {
        int l=0,r=get_max_len(st)+1;
        while(l+1&lt;r)
        {
            int m=l+r&gt;&gt;1;
            if(count_less(st,m)&gt;=Kth)
                r=m;
            else
                l=m;
        }
        return r-1;
    }
    void solve()
    {
        input_data();//OK;
        Vet_Split::init();//OK;
        init_Tree();//OK;
        Tree_Split::init_Structure();//OK;
        Tree_Split::Split_Tree(0);//OK;
        rep(i,Tree.vet)
        {
            if(Id[i]&gt;=0)
            {
                Ans[Id[i]]=find_kth(i);
            }
        }
        rep(i,vet)
        {
            print_int(Ans[i]);
        }
    }
}
int main()
{
    Solve::solve();
}
</pre><pre></pre><h2>Problem2053</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define OK puts("OK")
using namespace std;
typedef long long ll;
const int inf=1000000000,PT_MAX=150000+10;
const int Limit=50;
int n,range,seed;
int next()
{
    seed=int((seed*16807LL)%((1LL&lt;&lt;31)-1));
    return seed%(2*range)-range;
}
struct Point
{
    int v[3];
    Point(int all=inf){rep(d,3)v[d]=all;}
    bool operator&lt;(const Point&amp;p)const
    {
        rep(i,3)
        {
            if(v[i]&lt;p.v[i])return true;
            if(v[i]&gt;p.v[i])return false;
        }
        return false;
    }
    bool operator==(const Point&amp;p)const
    {
        rep(i,3)if(v[i]!=p.v[i])return false;
        return true;
    }
    void output()
    {
        rep(d,3)cout&lt;&lt;v[d]&lt;&lt;" ";
        cout&lt;&lt;endl;
    }
}P[PT_MAX];
#define cmin(x,c) if(x&gt;c)x=c
#define cmax(x,c) if(x&lt;c)x=c
struct Node
{
    Node*ch[2];
    Node(){ch[0]=ch[1]=0;}
    Point lo,hi;
    int l,r;
    void doit(int _l,int _r)
    {
        l=_l;r=_r;
        lo=Point(inf);hi=Point(-inf);
        for(int i=l;i&lt;=r;i++)
        {
            rep(d,3)
            {
                cmin(lo.v[d],P[i].v[d]);
                cmax(hi.v[d],P[i].v[d]);
            }
        }
    }
    int cnt;
}*root;
inline ll sqr(ll a){return a*a;}
ll Dist(const Point&amp;a,const Point&amp;b)
{
    ll ret=0;
    rep(d,3)ret+=sqr(a.v[d]-b.v[d]);
    return ret;
}
inline int dist(int l,int r,int x)
{
    if(x&gt;r)return x-r;
    if(x&lt;l)return l-x;
    return 0;
}
inline int dist(int l1,int r1,int l2,int r2)
{
    if(l1&gt;r2)return l1-r2;
    if(l2&gt;r1)return l2-r1;
    return 0;
}
ll Dist(const Node*a,const Point&amp;b)
{
    ll ret=0;
    rep(d,3)ret+=sqr(dist(a-&gt;lo.v[d],a-&gt;hi.v[d],b.v[d]));
    return ret;
}
ll Dist(const Node*a,const Node*b)
{
    ll ret=0;
    rep(d,3)ret+=sqr(dist(a-&gt;lo.v[d],a-&gt;hi.v[d],b-&gt;lo.v[d],b-&gt;hi.v[d]));
    return ret;
}
void build(Node*&amp;t,int l,int r)
{
    //cout&lt;&lt;P.size()&lt;&lt;endl;
    t=new Node;
    t-&gt;cnt=r-l+1;
    t-&gt;doit(l,r);
    if(t-&gt;cnt&lt;Limit)
    {
        return;
    }
    else
    {
        int di[3];
        rep(d,3)di[d]=t-&gt;hi.v[d]-t-&gt;lo.v[d];
        int Maxd=0;
        rep(d,3)if(di[d]&gt;di[Maxd])Maxd=d;
        int mi=t-&gt;hi.v[Maxd]+t-&gt;lo.v[Maxd]&gt;&gt;1;
        int p=l;
        for(int i=l;i&lt;=r;i++)
        {
            if(P[i].v[Maxd]&lt;=mi)
                swap(P[p++],P[i]);
        }
        build(t-&gt;ch[0],l,p-1);
        build(t-&gt;ch[1],p,r);
    }
}
int ans,cnt,d;
void Input_Data()
{
    cin&gt;&gt;n&gt;&gt;range&gt;&gt;seed;
    rep(id,n)
    {
        Point p;
        rep(d,3)
            p.v[d]=next();
        P[id]=p;
    }
    sort(P,P+n);
    n=unique(P,P+n)-P;
}
struct TAns
{
    ll ans;
    int cnt;
    TAns(){}
    TAns(ll _ans,int _cnt):ans(_ans),cnt(_cnt){}
    void Update(const TAns&amp;t)
    {
        if(t.ans&lt;ans){ans=t.ans;cnt=0;}
        if(t.ans==ans){cnt+=t.cnt;}
    }
};
inline void Update(int _ans,int _cnt)
{
    if(_ans&lt;ans){ans=_ans;cnt=0;}
    if(_ans==ans){cnt+=_cnt;}
}
Point L[PT_MAX],R[PT_MAX];
void add_point(Node*from,Node*to,int bound,Point*&amp;out)
{
    ll cur=Dist(from,to);if(cur&gt;bound)return;
    if(from-&gt;ch[0]==0)
    {
        for(int i=from-&gt;l;i&lt;=from-&gt;r;i++)
        {
            ll d=Dist(to,P[i]);
            if(d&lt;=bound)*out++=P[i];
        }
    }
    else
    {
        rep(d,2)
            add_point(from-&gt;ch[d],to,bound,out);
    }
}
TAns Calc_Ans(Node*t,ll bound)
{
    TAns ret(bound,0);
    if(t-&gt;ch[0]==0)
    {
        for(int i=t-&gt;l;i&lt;=t-&gt;r;i++)
            for(int j=i+1;j&lt;=t-&gt;r;j++)
                ret.Update(TAns(Dist(P[i],P[j]),1));
        return ret;
    }
    rep(d,2)
    {
        TAns get=Calc_Ans(t-&gt;ch[d],ret.ans);
        ret.Update(get);
    }
    Point*endL=L,*endR=R;
    add_point(t-&gt;ch[0],t-&gt;ch[1],ret.ans,endL);
    add_point(t-&gt;ch[1],t-&gt;ch[0],ret.ans,endR);
    rep(l,endL-L)
        rep(r,endR-R)
        {
            ret.Update(TAns(Dist(L[l],R[r]),1));
        }
    return ret;
}
int main()
{
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    Input_Data();
    build(root,0,n-1);
    TAns ret=Calc_Ans(root,inf);
    cout&lt;&lt;ret.ans&lt;&lt;endl;
    cout&lt;&lt;ret.cnt&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem2053</h2><pre>#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
typedef long long ll;
const int inf=1000000000;
int n,range,seed;
int next()
{
    seed=int((seed*16807LL)%((1LL&lt;&lt;31)-1));
    return seed%(2*range)-range;
}
typedef set&lt;int&gt; si;
typedef map&lt;int,si&gt; msi;
typedef map&lt;int,msi&gt; mmsi;
typedef si::iterator sit;
typedef msi::iterator msit;
typedef mmsi::iterator mmsit;
#define tr(T,it,b,e) for(T it=b;it!=e;it++)
#define All(x) x.begin(),x.end()
#define sqr(x) (x)*(x)
mmsi M;
int ans,cnt;
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;n&gt;&gt;range&gt;&gt;seed;
    while(n--)
    {
        int x=next(),y=next(),z=next();
        M[x][y].insert(z);
    }
    ans=inf;cnt=0;
    int d=sqrt(ans)+1;
    int x,y,z,nx,ny,nz,tmp;
    tr(mmsit,itx,M.begin(),M.end())
        tr(msit,ity,itx-&gt;second.begin(),itx-&gt;second.end())
            tr(sit,itz,ity-&gt;second.begin(),ity-&gt;second.end())
            {
                tmp=0;
                x=itx-&gt;first,y=ity-&gt;first,z=*itz;
                mmsit lx=M.lower_bound(x-d);
                mmsit rx=M.upper_bound(x+d);
                tr(mmsit,tx,lx,rx)
                {
                    nx=tx-&gt;first;tmp+=sqr(nx-x);
                    if(tmp&gt;ans){tmp-=sqr(nx-x);continue;}
                    msit ly=tx-&gt;second.lower_bound(y-d);
                    msit ry=tx-&gt;second.upper_bound(y+d);
                    tr(msit,ty,ly,ry)
                    {
                        ny=ty-&gt;first;tmp+=sqr(ny-y);
                        if(tmp&gt;ans){tmp-=sqr(ny-y);continue;}
                        sit lz=ty-&gt;second.lower_bound(z-d);
                        sit rz=ty-&gt;second.upper_bound(z+d);
                        tr(sit,tz,lz,rz)
                        {
                            nz=*tz;tmp+=sqr(nz-z);
                            /*cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;" "&lt;&lt;z&lt;&lt;endl;
                            cout&lt;&lt;nx&lt;&lt;" "&lt;&lt;ny&lt;&lt;" "&lt;&lt;nz&lt;&lt;endl;
                            cout&lt;&lt;tmp&lt;&lt;endl;
                            cout&lt;&lt;"End"&lt;&lt;endl;*/
                            if(!tmp)continue;
                            if(tmp&lt;ans)ans=tmp,cnt=0,d=sqrt(ans)+1;
                            if(tmp==ans)cnt++;
                            tmp-=sqr(nz-z);
                        }
                        tmp-=sqr(ny-y);
                    }
                    tmp-=sqr(nx-x);
                }
            }
    cout&lt;&lt;ans&lt;&lt;endl;
    cout&lt;&lt;cnt/2&lt;&lt;endl;
}</pre><pre></pre><h2>Problem2055</h2><pre>/*
 * 80人环游世界.cpp
 *
 *  Created on: 2011-3-5
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int INF = ~0U &gt;&gt; 1;
const int MAX_NCITIES = 100 + 10;
const int MAX_NVETS = MAX_NCITIES * 2;
const int LARGE = 100000;

struct Queue {
	bool inQ[MAX_NVETS];
	int que[MAX_NVETS];
	int qh, qt;

	Queue() {
		memset(inQ, false, sizeof inQ);
	}

	void clear() {
		qh = qt = 0;
	}

	void inc(int&amp;it) {
		if (++it == MAX_NVETS)
			it = 0;
	}

	void add(int x) {
		if (inQ[x])
			return;
		que[qt] = x;
		inQ[x] = true;
		inc(qt);
	}

	int get() {
		int x = que[qh];
		inQ[x] = false;
		inc(qh);
		return x;
	}

	bool isEmpty() {
		return qh == qt;
	}
};

struct Network {
	static const int MAX_NEDGES = MAX_NVETS * MAX_NVETS;
	int head[MAX_NVETS];
	int dest[MAX_NEDGES], next[MAX_NEDGES], cap[MAX_NEDGES], cost[MAX_NEDGES];
	int minCost;
	int nVets, nEdges;

	void init(int _nVets) {
		nVets = _nVets;
		nEdges=0;
		memset(head, -1, sizeof head);
	}

	void makeEdge(int s, int t, int f, int c) {
		int id = nEdges++;
		dest[id] = t;
		next[id] = head[s];
		cap[id] = f;
		cost[id] = c;
		head[s]=id;
	}

	void addEdge(int s, int t, int f, int c) {
		makeEdge(s, t, f, c);
		makeEdge(t, s, 0, -c);
	}

	int vs, vt;

	bool spfa() {
		static int dist[MAX_NVETS];
		static int prev[MAX_NVETS];
		fill(dist, dist + nVets, INF);
		dist[vs] = 0;

		static Queue que;
		que.clear();
		que.add(vs);
		while (!que.isEmpty()) {
			int u = que.get();
			for (int e = head[u]; e != -1; e = next[e])
				if (cap[e]) {
					int v = dest[e];
//					cout&lt;&lt;u&lt;&lt;"-&gt;"&lt;&lt;v&lt;&lt;endl;
					int nc = dist[u] + cost[e];
					if (nc &lt; dist[v]) {
						dist[v] = nc;
						prev[v] = e;
						que.add(v);
					}
				}
		}

		if (dist[vt] == INF)
			return false;
		int minCap = INF;
		int at = vt;
		while (at != vs) {
			minCap = min(minCap, cap[prev[at]]);
			at = dest[prev[at] ^ 1];
		}
		minCost += minCap * dist[vt];
		at = vt;
		while (at != vs) {
			cap[prev[at]] -= minCap;
			cap[prev[at] ^ 1] += minCap;
			at = dest[prev[at] ^ 1];
		}

		return true;
	}

	int calcMinCostFlow(int _vs, int _vt) {
		vs = _vs;
		vt = _vt;
		minCost = 0;
		while (spfa());
		return minCost;
	}
};

Network network;

int nCities, nPeoples;

void solve() {
	scanf("%d%d", &amp;nCities, &amp;nPeoples);
	int nVets = nCities * 2;
	int vs = nVets++, vs1 = nVets++, vt = nVets++, vt1 = nVets++;
	network.init(nVets);
	network.addEdge(vs, vs1, nPeoples, 0);
	network.addEdge(vt1, vt, nPeoples, 0);
	int ans = 0;

	for (int city = 0; city &lt; nCities; ++city) {
		int exact;
		scanf("%d", &amp;exact);
		network.addEdge(city, city + nCities, exact, -LARGE);
		ans -= exact * (-LARGE);
	}

	for (int srcCity = 0; srcCity &lt; nCities; ++srcCity) {
		for (int dstCity = srcCity + 1; dstCity &lt; nCities; ++dstCity) {
			int cost;
			scanf("%d", &amp;cost);
			if (cost != -1) {
				network.addEdge(srcCity + nCities, dstCity, INF, cost);
			}
		}
	}

	for (int startCity = 0; startCity &lt; nCities; ++startCity) {
		network.addEdge(vs1, startCity, INF, 0);
	}

	for (int endCity = 0; endCity &lt; nCities; ++endCity) {
		network.addEdge(endCity + nCities, vt1, INF, 0);
	}

	ans += network.calcMinCostFlow(vs, vt);
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2061</h2><pre>/**************************************************************
    Problem: 2061
    User: nimendongde
    Language: C++
    Result: Accepted
    Time:105 ms
    Memory:480 kb
****************************************************************/
 
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int N_MAX=26,AP_MAX=N_MAX*2;
const int P_MAX=100+10;
const int Mod=10000;
namespace Hash_Data
{
    const int seed=133331;
    int power(int e)
    {
        if(!e)return 1;
        int tmp=power(e/2);tmp*=tmp;
        if(e&amp;1)tmp*=seed;return tmp;
    }
    struct Str
    {
        int hash,pow,len;
        Str(){}
        Str(int _hash,int _len=1):
            hash(_hash),len(_len)
            {
                pow=power(len);
            }
        bool operator==(const Str&amp;str)const
        {
            return hash==str.hash&amp;&amp;len==str.len;
        }
    }none(0,0);
    Str operator+(const Str&amp;l,const Str&amp;r)
    {
        Str ret;ret.hash=l.hash*r.pow+r.hash;
        ret.len=l.len+r.len;
        ret.pow=l.pow*r.pow;
        return ret;
    }
    Str trans(string s)
    {
        Str ret=none;
        rep(i,s.size())
            ret=ret+Str(s[i]);
        return ret;
    }
}
namespace Solve
{
    using namespace Hash_Data;
    int N,P;char root;
    string Sent[N_MAX];
    Str Pet;
    struct Data
    {
        int n;
        Str Suf[P_MAX],Pre[P_MAX];
        Str all;
        Data()
        {
            n=0;all=none;
            rep(i,P_MAX)Suf[i]=Pre[i]=none;
        }
        void set(int val)
        {
            n=1;
            all=Suf[1]=Pre[1]=Str(val);
        }
        void operator=(const Data&amp;data)
        {
            memcpy(Suf,data.Suf,sizeof Suf);
            memcpy(Pre,data.Pre,sizeof Pre);
            all=data.all;
            n=data.n;
        }
    };
    Data operator+(const Data&amp;l,const Data&amp;r)
    {
        Data ret;
        ret.n=l.n+r.n;if(ret.n&gt;P)ret.n=P;
        for(int i=0;i&lt;=ret.n;i++)
        {
            if(i&lt;=l.n)ret.Pre[i]=l.Pre[i];
            else ret.Pre[i]=l.all+r.Pre[i-l.n];
            if(i&lt;=r.n)ret.Suf[i]=r.Suf[i];
            else ret.Suf[i]=l.Suf[i-r.n]+r.all;
        }
        ret.all=l.all+r.all;
        return ret;
    }
    int encode(char c)
    {
        if(c&gt;='A'&amp;&amp;c&lt;='Z')return c-'A';
        return c-'a'+N_MAX;
    }
    namespace Calc_Data
    {
        Data Mem[AP_MAX];
        bool Done[AP_MAX]={};
        Data Calc(char it)
        {
            int code=encode(it);
            Data&amp;ret=Mem[code];
            if(Done[code])return ret;
            Done[code]=true;
            if(code&gt;=N_MAX)
            {
                ret.set(it);
                return ret;
            }
            else
            {
                rep(i,Sent[code].size())
                {
                    ret=ret+Calc(Sent[code][i]);
                }
            }
            return ret;
        }
    }
    namespace Calc_Ans
    {
        using Calc_Data::Calc;
        int Count_Data(const Data&amp;l,const Data&amp;r)
        {
            int ret=0;
            for(int L=1;L&lt;P;L++)
            {
                Str tmp=l.Suf[L]+r.Pre[P-L];
                if(tmp==Pet)ret++;
            }
            ret%=Mod;
            return ret;
        }
        bool Done_Dp[AP_MAX];
        int Ret_DP[AP_MAX];
        int Dp(char it)
        {
            int code=encode(it);
            int&amp;ret=Ret_DP[code];
            if(Done_Dp[code])return ret;
            ret=0;Done_Dp[code]=true;
            if(code&gt;=N_MAX)
            {
                ret=(Str(it)==Pet);
                return ret;
            }
            else
            {
                Data tmp;
                for(int i=0;i&lt;Sent[code].size();i++)
                {
                    ret+=Count_Data(tmp,Calc(Sent[code][i]));
                    ret+=Dp(Sent[code][i]);
                    tmp=tmp+Calc(Sent[code][i]);
                }
                if(Calc(it).all==Pet)
                    ret++;
                ret%=Mod;
            }
            return ret;
        }
    }
    void input_data()
    {
        cin&gt;&gt;N;cin&gt;&gt;root;
        rep(i,N)
        {
            string tmp;cin&gt;&gt;tmp;
            Sent[tmp[0]-'A']=tmp.substr(2);
        }
        string pet;cin&gt;&gt;pet;
        P=pet.size();Pet=trans(pet);
    }
    void work()
    {
        cout&lt;&lt;Calc_Ans::Dp(root)&lt;&lt;endl;
    }
    void solve()
    {
        input_data();
        work();
    }
}
int main()
{
    //freopen("in","r",stdin);
    Solve::solve();
}</pre><pre></pre><h2>Problem2062</h2><pre>/**************************************************************
    Problem: 2062
    User: nimendongde
    Language: C++
    Result: Accepted
    Time:4714 ms
    Memory:44992 kb
****************************************************************/
 
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int VT_MAX=100000+10,Q_MAX=30;
const int LG_MAX=28;
const int LN_MAX=5000+10;
namespace Hash_Data
{
    const int seed=13331;
    int Power(int e)
    {
        if(!e)return 1;
        int tmp=Power(e/2);tmp*=tmp;
        if(e&amp;1)tmp*=seed;
        return tmp;
    }
    struct Tstr
    {
        int hash,len,pow;
        Tstr(){}
        Tstr(int _hash,int _len=1):
            hash(_hash),len(_len)
        {
            pow=Power(len);
        }
        bool operator==(const Tstr&amp;str)
        {
            return len==str.len&amp;&amp;hash==str.hash;
        }
    }none(0,0);
    Tstr operator+(const Tstr&amp;l,const Tstr&amp;r)
    {
        Tstr ret;
        ret.len=l.len+r.len;
        ret.hash=l.hash*r.pow+r.hash;
        ret.pow=l.pow*r.pow;
        return ret;
    }
}
namespace Pre2K_Data
{
    using namespace Hash_Data;
    struct Tlink
    {
        Tstr str;
        int dest;
        Tlink(){}
        Tlink(Tstr _str,int _dest):
            str(_str),dest(_dest){}
    };
    Tlink operator+(const Tlink&amp;l,const Tlink&amp;r)
    {
        Tlink ret;ret.dest=r.dest;
        ret.str=l.str+r.str;
        return ret;
    }
    struct Pre2K
    {
        Tlink Link[VT_MAX][LG_MAX];
        char*val;
        int*next;
        int n;
        void doit(int _n,char*_val,int*_next)
        {
            n=_n;val=_val;next=_next;
            rep(i,n)
                Link[i][0]=Tlink(Tstr(val[i]),next[i]);
            for(int i=1;i&lt;LG_MAX;i++)
            {
                rep(v,n)
                {
                    int go=Link[v][i-1].dest;
                    Link[v][i]=Link[v][i-1]+Link[go][i-1];
                }
            }
        }
        int cmp(int u,int v)
        {
            int L=0;
            for(int i=LG_MAX-1;i&gt;=0;i--)
            {
                if(Link[u][i].str==Link[v][i].str)
                    u=Link[u][i].dest,v=Link[v][i].dest;
            }
            if(val[u]==val[v])return 0;
            return val[u]&lt;val[v]?-1:1;
        }
    };
}
namespace Solve
{
    using namespace Hash_Data;
    using namespace Pre2K_Data;
    Pre2K p2K;
    char val[VT_MAX];
    int next[VT_MAX],N,Q;
    void input_data()
    {
        cin&gt;&gt;N;rep(i,N)scanf(" "),scanf("%c",val+i);
        rep(i,N)scanf("%d",next+i),next[i]--;
    }
    bool cmp(int u,int v)
    {
        int tmp=p2K.cmp(u,v);
        if(tmp!=0)return tmp==-1;
        return u&lt;v;
    }
    void work()
    {
        static int rank[VT_MAX];
        rep(i,N)rank[i]=i;
        sort(rank,rank+N,cmp);
        rep(i,N)printf("%d\n",rank[i]+1);
    }
    void solve()
    {
        input_data();//puts("OK");
        p2K.doit(N,val,next);//puts("OK");
        work();
    }
}
int main()
{
    //freopen("in","r",stdin);
    Solve::solve();
}</pre><pre></pre><h2>Problem2063</h2><pre>#include&lt;iostream&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
typedef long long ll;
const int LH_MAX=20,D_MAX=9,K_MAX=1000+10,P_MAX=LH_MAX*D_MAX;
bool saved[P_MAX][K_MAX][LH_MAX]={};// prefix_sum,rest,long
ll L,R,K;
struct Tret
{
    ll cnt;
    int rest;
    Tret(int val=0)
    {
        if(val&gt;=K)rest=0,cnt=1;
        else rest=val,cnt=0;
    }
}none;
Tret operator+(const Tret&amp;a,const Tret&amp;b)
{
    Tret ret;ret.cnt=a.cnt+b.cnt;
    ret.rest=b.rest;
    return ret;
}
Tret memo[P_MAX][K_MAX][LH_MAX];
Tret Calc(int psum,int rest,int L)
{
    if(psum&gt;K)psum=K;
    Tret&amp;ret=memo[psum][rest][L];
    if(saved[psum][rest][L])
        return ret;
    saved[psum][rest][L]=true;
    if(!L)//it's a single digit
    {
        int val=psum+rest;
        ret=Tret(val);
        return ret;
    }
    ret=Tret(rest);
    rep(nextd,10)
        ret=ret+Calc(psum+nextd,ret.rest,L-1);
    return ret;
}
int digit_sum(ll a)
{
    int sum=0;while(a)sum+=a%10,a/=10;
    return sum;
}
void Calc_All(ll l,ll r)
{
    Tret ans;
    while(l&lt;=r)
    {
        int p=0;ll pow=1;
        for(;;)
        {
            ll n_pow=pow*10;
            if(l+n_pow-1&lt;=r&amp;&amp;l%n_pow==0)
                pow=n_pow,p++;
            else
                break;
        }
        /*
        cout&lt;&lt;"Start"&lt;&lt;endl;
        cout&lt;&lt;l&lt;&lt;" "&lt;&lt;r&lt;&lt;" "&lt;&lt;p&lt;&lt;endl;
        cout&lt;&lt;digit_sum(l/pow)&lt;&lt;endl;
        cout&lt;&lt;ans.cnt&lt;&lt;" "&lt;&lt;ans.rest&lt;&lt;endl;
        */
        ans=ans+Calc(digit_sum(l/pow),ans.rest,p);
        l+=pow;
    }
    cout&lt;&lt;ans.cnt&lt;&lt;endl;
}
int main()
{
    cin&gt;&gt;L&gt;&gt;R&gt;&gt;K;
    Calc_All(L,R);
} 
</pre><pre></pre><h2>Problem2064</h2><pre>/**************************************************************
    Problem: 2064
    User: nimendongde
    Language: C++
    Result: Accepted
    Time:1465 ms
    Memory:4376 kb
****************************************************************/
 
#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define All(x) x.begin(),x.end()
#define tr(e,x) for(VVI::iterator e=x.begin();e!=x.end();e++)
using namespace std;
typedef vector&lt;int&gt; VI;
typedef vector&lt;VI&gt; VVI;
map&lt;VI,int&gt; Map[2];
VVI Qs[2],tmp;
int main()
{
    VI start,end;int n,x;
    cin&gt;&gt;n;rep(i,n)cin&gt;&gt;x,start.pb(x);
    cin&gt;&gt;n;rep(i,n)cin&gt;&gt;x,end.pb(x);
    sort(All(start));sort(All(end));
    if(start==end)
    {
        cout&lt;&lt;0&lt;&lt;endl;
        return 0;
    }
    Map[0][start]=Map[1][end]=0;
    Qs[0].pb(start);Qs[1].pb(end);
    int res=0;
    for(;;)
    {
        res++;
        rep(dir,2)
        {
            tmp.clear();swap(tmp,Qs[dir]);
            tr(it,tmp)
            {
                VI v=*it;
                int n=v.size();
                rep(i,n)rep(j,i)
                {
                    VI next=v;
                    next[i]+=next[j];
                    swap(next[j],next.back());
                    next.pop_back();
                    sort(All(next));
                    if(Map[1^dir].count(next))
                    {
                        cout&lt;&lt;res+Map[1^dir][next]&lt;&lt;endl;
                        return 0;
                    }
                    if(Map[dir].count(next)==0)
                    {
                        Map[dir][next]=res;
                        Qs[dir].pb(next);
                    }
                }
            }
        }
    }
}</pre><pre></pre><h2>Problem2065</h2><pre>/*
 * 1807. Cartridges for Maxim.cpp
 *
 *  Created on: 2011-7-25
 *      Author: mac
 */

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
int n;

//n=A*B,A&gt;=2,B&gt;=100

const int MAX_N = int(1e9);
const int MAX_SQRT_N = 31624;
const int MAX_N_PRIMES = 3403;

int ans[MAX_SQRT_N], nAns;
bool is[MAX_SQRT_N];
int primes[MAX_N_PRIMES], nPrimes;

const int MAX_N_USED_PRIMES = 114;
const int MAX_N_BIG_POWER_PRIMES = 8;

typedef long double Double;

Double dp[MAX_N_USED_PRIMES + 1][MAX_SQRT_N];

int how[MAX_N_USED_PRIMES + 1][MAX_SQRT_N];

void solve(int n) {
	fill(is, is + n + 1, true);
	for (int i = 2; i * i &lt;= n;) {
		for (int j = i + i; j &lt;= n; j += i)
			is[j] = false;
		++i;
		while (i * i &lt;= n &amp;&amp; !is[i])
			++i;
	}
	nPrimes = 0;
	for (int i = 2; i &lt;= n; ++i) {
		if (is[i])
			primes[nPrimes++] = i;
	}

	for (int i = 0; i &lt; min(MAX_N_USED_PRIMES, nPrimes); ++i) {
		int p = primes[i];
		Double logp = logl(Double(p));

		int pow = 1;
		Double powLog = 0;
		for (int power = 1;; ++power) {
			if (i &gt;= MAX_N_BIG_POWER_PRIMES &amp;&amp; power &gt; 1)
				break;
			pow *= p;
			powLog += logp;
			if (pow &gt;= n)
				break;
			for (int j = 0; j &lt;= n - pow; ++j) {
				Double tmp = dp[i][j] + powLog;
				if (tmp &gt; dp[i + 1][j + pow]) {
					dp[i + 1][j + pow] = tmp;
					how[i + 1][j + pow] = pow;
				}
			}
		}

		for (int j = 0; j &lt;= n; ++j) {
			if (dp[i][j] &gt; dp[i + 1][j]) {
				dp[i + 1][j] = dp[i][j];
				how[i + 1][j] = 0;
			}
		}
	}

	int atP = min(nPrimes, MAX_N_USED_PRIMES);
	int have = n;

	nAns = 0;
	for (int i = atP; i &gt;= 1; --i) {
		int by = how[i][have];
		if (by &gt; 0)
			ans[nAns++] = by;
		have -= by;
	}
	while (have)
		ans[nAns++] = 1, --have;
}

int main() {
	cin &gt;&gt; n;
	for (int i = 2; i * i &lt;= n; ++i) {
		if (n % i == 0) {
			int A = i, B = n / i;
			solve(A);
//			cout &lt;&lt; nAns &lt;&lt; endl;
			for (int i = 0; i &lt; nAns; ++i) {
				printf("%d ", ans[i] * B);
			}
			printf("\n");
			return 0;
		}
	}
	return 0;
}
</pre><pre></pre><h2>Problem2066</h2><pre>/**************************************************************
    Problem: 2066
    User: nimendongde
    Language: C++
    Result: Accepted
    Time:2918 ms
    Memory:13912 kb
****************************************************************/
 
/*
 * Game.cpp
 *
 *  Created on: 2011-1-30
 *      Author: wjmzbmr
 */
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int MAX_N=1000000+10;
const int INF=~0U&gt;&gt;1;
int m,n;
int a[MAX_N];
struct PawnsSeg{
    int l,r;
    int startId;
    int rightWhite;
    PawnsSeg*nextSeg;
 
    void write()const{
        printf("[%d,%d]:%d,right:%d\n",l,r,startId,rightWhite);
    }
    int size()const{
        return r-l+1;
    }
 
    int xorVal()const{
        if(rightWhite%2)
            return size();
        else
            return 0;
    }
 
    int getId(int xorSum)const{
        if(rightWhite%2){
            int needXor=xorSum^xorVal();
            if(needXor&lt;size()){
                int remainSize=needXor;
                return startId+remainSize;
            }
        } else if(rightWhite!=0){
            int nextSum;
            if(nextSeg&amp;&amp;nextSeg-&gt;rightWhite==rightWhite-1)
                nextSum=nextSeg-&gt;size();
            else
                nextSum=0;
            int needNextSum=xorSum^nextSum;
            if(needNextSum&gt;nextSum){
                int needToSend=needNextSum-nextSum;
                if(needToSend&lt;=size()){
                    int remainSize=size()-needToSend;
                    return startId+remainSize;
                }
            }
        }
        return -1;
    }
};
 
PawnsSeg segs[MAX_N];
int nSegs;
 
void outputSegs(){
    for(int i=0;i&lt;nSegs;i++)
        segs[i].write();
}
 
void parseSegs(){
    PawnsSeg curSeg;
    curSeg.l=INF;
    nSegs=0;
    for(int i=n-1;i&gt;=0;i--){
        if(a[i]+1!=curSeg.l){
            if(curSeg.l!=INF){
                segs[nSegs++]=curSeg;
            }
            curSeg.l=curSeg.r=a[i];
            curSeg.startId=i;
            curSeg.rightWhite=(m-2-a[i])-(n-1-i);
        }
        curSeg.l=a[i];
        curSeg.startId=i;
    }
    segs[nSegs++]=curSeg;
    reverse(segs,segs+nSegs);
    for(int i=0;i&lt;nSegs;i++){
        if(i+1&lt;nSegs)
            segs[i].nextSeg=segs+i+1;
        else
            segs[i].nextSeg=0;
    }
}
 
void inputData(){
    scanf("%d%d",&amp;m,&amp;n);
    for(int i=0;i&lt;n;i++)
        scanf("%d",a+i);
}
 
void solve(){
    int xorSum=0;
    if(segs[nSegs-1].rightWhite==-1){
        //already wins
        printf("%d\n",segs[nSegs-1].size());
        return;
    }
    for(int i=0;i&lt;nSegs;i++){
        xorSum^=segs[i].xorVal();
    }
//  int ans[MAX_N];
    int ansCnt=0;
    for(int i=0;i&lt;nSegs;i++){
        int it=segs[i].getId(xorSum);
        if(it!=-1){
            ansCnt++;
//          cout&lt;&lt;it&lt;&lt;endl;
        }
    }
    printf("%d\n",ansCnt);
}
int main(){
    inputData();
    parseSegs();
    solve();
}</pre><pre></pre><h2>Problem2068</h2><pre>/*
 * Spies.cpp
 *
 *  Created on: 2011-1-30
 *      Author: wjmzbmr
 */
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;
const int MAX_N=1000000+10;
int shadowTo[MAX_N];
int nSpies;
void inputData(){
	scanf("%d",&amp;nSpies);
	for(int i=0;i&lt;nSpies;i++){
		scanf("%d",shadowTo+i);
		shadowTo[i]--;
//		cout&lt;&lt;i&lt;&lt;"-&gt;"&lt;&lt;shadowTo[i]&lt;&lt;endl;
	}
}

bool chose[MAX_N]={};
int que[MAX_N],qh,qt;
void solve(){
	static int inDeg[MAX_N]={};
	for(int i=0;i&lt;nSpies;i++)
		inDeg[shadowTo[i]]++;

	qh=qt=0;
	for(int i=0;i&lt;nSpies;i++)
		if(!inDeg[i])
			que[qt++]=i;

	int ans=0;
	for(;qh&lt;qt;){
		int u=que[qh++];
		int nu=shadowTo[u];
		int nu2=shadowTo[nu];
		if(!chose[nu]){
			chose[nu]=chose[u]=true;
			ans++;
			inDeg[nu2]--;
			if(!chose[nu2]&amp;&amp;!inDeg[nu2])
				que[qt++]=nu2;
		}
	}

	for(int i=0;i&lt;nSpies;i++)if(!chose[i]){
		int u=i,nu=shadowTo[u];
		while(!chose[u]&amp;&amp;!chose[nu]){
			chose[u]=chose[nu]=true;
			ans++;
			u=shadowTo[nu];nu=shadowTo[u];
		}
	}

	printf("%d\n",ans);
}
int main(){
	inputData();
	solve();
}
</pre><pre></pre><h2>Problem2070</h2><pre>/*
 * Gates.cpp
 *
 *  Created on: 2011-2-2
 *      Author: wjmzbmr
 */
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();e++)
using namespace std;
const int MAX_N=10000+100;
const int INF=~0U&gt;&gt;2;
vector&lt;int&gt; edge[MAX_N];
vector&lt;int&gt; revEdge[MAX_N];
void addEdge(int s,int t){
	edge[s].push_back(t);
	revEdge[t].push_back(s);
}
int nVertexs;
void inputData(){
	scanf("%d",&amp;nVertexs);
	for(int it=2;it&lt;nVertexs;it++){
		int nInputs;
		scanf("%d",&amp;nInputs);
		for(int cur=0;cur&lt;nInputs;cur++){
			int input;scanf("%d",&amp;input);
			addEdge(input,it);
		}
	}
}

const int One=1,Zero=0,Half=2;
int inputCount[MAX_N][3];
int curState(int u){
	for(int it=0;it&lt;2;it++)
		if(inputCount[u][it]&gt;inputCount[u][!it])
			return it;
	return Half;
}

void whenAllSame(int want,int state[MAX_N]){
	for(int i=0;i&lt;nVertexs;i++)
		state[i]=want;

	static int que[MAX_N*2],qh,qt;
	static bool inQue[MAX_N]={};

	memset(inputCount,0,sizeof inputCount);
	for(int i=0;i&lt;nVertexs;i++){
		if(i&lt;2)
			inputCount[i][i]=INF;
		else
			inputCount[i][want]=revEdge[i].size();
	}
	qh=qt=0;int vs=!want;
	que[qt++]=vs;
	for(;qh&lt;qt;){
		int u=que[qh++];inQue[u]=false;
		int oldState=state[u];
		int newState=curState(u);
		state[u]=newState;
		foreach(e,edge[u]){
			int v=*e;
			inputCount[v][oldState]--;
			inputCount[v][newState]++;
			int newStateV=curState(v);
			if(newStateV!=state[v]){
				if(!inQue[v]){
					que[qt++]=v;
					inQue[v]=true;
				}
			}
		}
	}
}

int whenWant[2][MAX_N];
void outputState(int state){
	if(state==Zero||state==One)
		printf("%d\n",state);
	else
		printf("1/2\n");
}
void work(){
	for(int it=0;it&lt;2;it++)
		whenAllSame(it,whenWant[it]);
	for(int it=0;it&lt;nVertexs;it++){
//		cout&lt;&lt;it&lt;&lt;" ";
//		outputState(whenWant[0][it]);
//		outputState(whenWant[1][it]);
//		cout&lt;&lt;endl;
		if(whenWant[0][it]==whenWant[1][it])
			outputState(whenWant[0][it]);
		else
			printf("?\n");
	}
	printf("\n");
}

void solve(){
	inputData();
	work();
}

int main(){
	solve();
}
</pre><pre></pre><h2>Problem2071</h2><pre>/*
 * Cave.cpp
 *
 *  Created on: 2011-2-5
 *      Author: wjmzbmr
 */
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();e++)
using namespace std;
const int MAX_VERTEX=50000+10;
const int MAX_BIT=1&lt;&lt;16;
int nVertexs;
int log2[MAX_BIT];
vector&lt;int&gt; edge[MAX_VERTEX];
void addEdge(int s,int t){
	edge[s].push_back(t);
	edge[t].push_back(s);
}
void inputData(){
	scanf("%d",&amp;nVertexs);
	for(int it=0;it&lt;nVertexs-1;it++){
		int s,t;
		scanf("%d%d",&amp;s,&amp;t);
		--s;--t;
		addEdge(s,t);
	}
}
void preCondition(){
	log2[1]=0;log2[0]=-1;
	for(int i=2;i&lt;MAX_BIT;i++)
		log2[i]=log2[i&gt;&gt;1]+1;
}

int dfs(int u,int f){
	int sameSet=0;
	int prevSet=0;
	foreach(e,edge[u]){
		int v=*e;if(v==f)continue;
		int curSet=dfs(v,u);
		sameSet|=(prevSet&amp;curSet);
		prevSet|=curSet;
	}
	int canSet=(~prevSet)&amp;(~((1&lt;&lt;log2[sameSet]+1)-1));
	int itsMark=log2[canSet&amp;(-canSet)];
	int ansSet=1&lt;&lt;itsMark;
	ansSet|=prevSet;
	ansSet&amp;=~((1&lt;&lt;itsMark)-1);
	return ansSet;
}
int main(){
	inputData();
	preCondition();
	int ansSet=dfs(0,-1);
	cout&lt;&lt;log2[ansSet]&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem2072</h2><pre>/*
 * The Bridge.cpp
 *
 *  Created on: 2011-2-3
 *      Author: wjmzbmr
 */
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
const int MAX_TOURISTS=100000+100;
const int INF=~0U&gt;&gt;2;
int crossTime[MAX_TOURISTS];
int nTourists;

void inputData(){
	scanf("%d",&amp;nTourists);
	for(int it=0;it&lt;nTourists;it++)
		scanf("%d",crossTime+it);
}

int dp[MAX_TOURISTS];//nCrossed
void work(){
	sort(crossTime,crossTime+nTourists);
	for(int nCrossed=1;nCrossed&lt;=nTourists;nCrossed++){
		if(nCrossed&lt;=2){
			dp[nCrossed]=crossTime[nCrossed-1];
		} else {
			dp[nCrossed]=min(dp[nCrossed-1]+crossTime[0]+crossTime[nCrossed-1],
							 dp[nCrossed-2]+crossTime[0]+crossTime[nCrossed-1]+crossTime[1]*2);
		}
	}
	printf("%d\n",dp[nTourists]);
}

int main(){
	inputData();
	work();
}
</pre><pre></pre><h2>Problem2073</h2><pre>/*
 * Passage.cpp
 *
 *  Created on: 2011-2-1
 *      Author: wjmzbmr
 */
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int MAX_N=16;
const int MAX_SET=1&lt;&lt;MAX_N;
const int INF=~0U&gt;&gt;2;
int maxCrossTime[MAX_SET];
int sumWeight[MAX_SET];
int weight[MAX_N],crossTime[MAX_N];
int maxWeight,nPeople;

void inputData(){
	cin&gt;&gt;maxWeight&gt;&gt;nPeople;
	for(int i=0;i&lt;nPeople;i++)
		cin&gt;&gt;crossTime[i]&gt;&gt;weight[i];
}

void preCondition(){
	for(int set=0;set&lt;(1&lt;&lt;nPeople);set++){
		sumWeight[set]=maxCrossTime[set]=0;
		for(int it=0;it&lt;nPeople;it++)
			if(set&gt;&gt;it&amp;1){
				sumWeight[set]+=weight[it];
				maxCrossTime[set]=max(maxCrossTime[set],crossTime[it]);
			}
	}
}

int dp[MAX_SET];
void doDp(){
	dp[0]=0;
	for(int set=1;set&lt;(1&lt;&lt;nPeople);set++){
		dp[set]=INF;
		for(int subSet=set;subSet;subSet=(subSet-1)&amp;set){
			if(sumWeight[subSet]&lt;=maxWeight){
				dp[set]=min(dp[set],dp[set^subSet]+maxCrossTime[subSet]);
			}
		}
	}
	printf("%d\n",dp[(1&lt;&lt;nPeople)-1]);
}

int main(){
	inputData();
	preCondition();
	doDp();
}
</pre><pre></pre><h2>Problem2074</h2><pre>/*
 * The Tournament_other.cpp
 *
 *  Created on: 2011-2-2
 *      Author: wjmzbmr
 */
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin() ;e!=x.end();e++)
using namespace std;
const int MAX_N=100000+10;
vector&lt;int&gt; edge[MAX_N];
void addEdge(int a,int b){
	edge[a].push_back(b);
}
int nCompetitor;
void inputData(){
	scanf("%d",&amp;nCompetitor);
	for(int i=0;i&lt;nCompetitor;i++){
		int cnt;
		scanf("%d",&amp;cnt);
		for(int j=0;j&lt;cnt;j++){
			int it;scanf("%d",&amp;it);--it;
			addEdge(i,it);
		}
	}
}

int aWinner;
void getAWinner(){
	aWinner=0;
	for(int cur=1;cur&lt;nCompetitor;cur++){
		if(find(edge[cur].begin(),edge[cur].end(),aWinner)!=edge[cur].end())
			aWinner=cur;
	}
}

int beatCount[MAX_N];
int curWinners[MAX_N],nCurWinners;
int curSet[MAX_N],nCurSet;
void work(){
	memset(beatCount,0,sizeof beatCount);
	nCurWinners=nCurSet=0;
	for(int i=0;i&lt;nCompetitor;i++)
		if(i==aWinner)
			curWinners[nCurWinners++]=i;
		else
			curSet[nCurSet++]=i;

	while(nCurWinners&gt;0){
		for(int it=0;it&lt;nCurWinners;it++){
			int u=curWinners[it];
			foreach(e,edge[u])
				beatCount[*e]++;
		}
		int oldSet=nCurSet;
		nCurSet=nCurWinners=0;
		int needCount=nCompetitor-oldSet;
		for(int it=0;it&lt;oldSet;it++){
			int u=curSet[it];
			if(beatCount[u]==needCount)
				curSet[nCurSet++]=u;
			else
				curWinners[nCurWinners++]=u;
		}
	}
}

bool isWinner[MAX_N];
void outputAnswer(){
	fill(isWinner,isWinner+nCompetitor,true);
	for(int it=0;it&lt;nCurSet;it++)
		isWinner[curSet[it]]=false;

	int nWinners=count(isWinner,isWinner+nCompetitor,true);
	printf("%d ",nWinners);
	for(int it=0;it&lt;nCompetitor;it++)
		if(isWinner[it])
			printf("%d ",it+1);
	printf("\n");
}

void solve(){
	inputData();
	getAWinner();
	work();
	outputAnswer();
}
int main(){
	solve();
}
</pre><pre></pre><h2>Problem2077</h2><pre>/*
 * East-West.cpp
 *
 *  Created on: 2011-2-2
 *      Author: wjmzbmr
 */
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
using namespace std;
const int MAX_CITIES=1000000+100;
const int MAX_EDGE=MAX_CITIES*2;
const int MAX_ARRIVES=MAX_CITIES/2;

struct MemoryStack{
	int*stack[3];
	int top;
	int memory[3][MAX_CITIES];
	void add(int*arr){
		stack[top++]=arr;
	}
	void clear(){
		top=0;
		for(int i=0;i&lt;3;i++)
			add(memory[i]);
	}

	MemoryStack(){
		clear();
	}
	int*get(){
		return stack[--top];
	}
};
MemoryStack memStack;

struct Memory{
	int mem[MAX_EDGE];
	int curMem;
	void clear(){
		curMem=0;
	}
	int New(int size){
		curMem+=size;
		return curMem-size;
	}
	inline int&amp;operator[](int at){
		return mem[at];
	}
};
Memory mem;

struct Array{
	int first,n;
	void initSize(int size){
		n=0;
		first=mem.New(size);
	}
	inline int&amp;operator[](int at){
		return mem[first+at];
	}

	void add(int x){
		operator [](n++)=x;
	}
};

Array adj[MAX_CITIES];
int*deg;

int curEdge;
int*edgeS,*edgeT;

int nWestCities,nEastCities,nCities;
int nWhereArrive;
bool isArrive[MAX_CITIES];

void inputData(){
	scanf("%d%d%d",&amp;nCities,&amp;nEastCities,&amp;nWestCities);
	memStack.clear();
	edgeS=memStack.get();edgeT=memStack.get();
	deg=memStack.get();
	memset(deg,0,sizeof(int)*nCities);
	curEdge=0;

	for(int it=0;it&lt;nCities-1;it++){
		int a,b;
		scanf("%d%d",&amp;a,&amp;b);
		--a;--b;
		edgeS[it]=a;edgeT[it]=b;
		deg[a]++;deg[b]++;
	}

	for(int it=0;it&lt;nCities-1;it++){
		assert(edgeS[it]!=edgeT[it]);
	}

	mem.clear();

	for(int u=0;u&lt;nCities;u++){
		adj[u].initSize(deg[u]);
	}

	for(int it=0;it&lt;nCities-1;it++){
		int a=edgeS[it],b=edgeT[it];
		adj[a].add(b);
		adj[b].add(a);
	}

	memStack.clear();

	scanf("%d",&amp;nWhereArrive);
	memset(isArrive,false,sizeof isArrive);
	for(int it=0;it&lt;nWhereArrive;it++){
		int arrive;scanf("%d",&amp;arrive);
		--arrive;
		isArrive[arrive]=true;
	}
}

//east:0..nEastCities-1
//west:nCities-nWestCities..nCities-1
inline bool isEast(int u){
	return u&lt;nEastCities;
}

inline bool isWest(int u){
	return u&gt;=nCities-nWestCities;
}

int*dist,*que,*countWest;

void bfs(int vs){
	dist=memStack.get();
	que=memStack.get();
	memset(dist,-1,sizeof(int)*nCities);
	dist[vs]=0;
	int qh=0,qt=0;
	que[qt++]=vs;
	for(;qh&lt;qt;){
		int u=que[qh++];
		for(int it=0;it&lt;adj[u].n;it++){
			int v=adj[u][it];
			if(dist[v]==-1){
				dist[v]=dist[u]+1;
				que[qt++]=v;
			}
		}
	}
}

int eastSide,westSide;
void getBlockEdge(){
	bfs(0);
	countWest=memStack.get();

	int westSide=-1;
	for(int it=nCities-1;it&gt;=0;it--){
		int u=que[it],fa;
		countWest[u]=isWest(u);
		for(int cur=0;cur&lt;adj[u].n;cur++){
			int v=adj[u][cur];
			if(dist[v]&lt;dist[u]){
				fa=v;
				continue;
			}
			countWest[u]+=countWest[v];
		}
		if(countWest[u]==nWestCities){
			if(westSide==-1||dist[u]&gt;dist[westSide]){
				westSide=u;
				eastSide=fa;
			}
		}
	}
	memStack.clear();
}

int*arrvieDist;
int*westDist;

void calcMinTime(){
	bfs(eastSide);
	memStack.add(que);
	westDist=memStack.get();
	arrvieDist=memStack.get();
	int curWest=0;
	for(int u=nCities-nWestCities;u&lt;nCities;u++)
		westDist[curWest++]=dist[u];
	int curArrive=0;
	for(int u=0;u&lt;nCities;u++)
		if(isArrive[u])
			arrvieDist[curArrive++]=dist[u];

	sort(arrvieDist,arrvieDist+nWhereArrive);
	sort(westDist,westDist+nWestCities);

	for(int it=1;it&lt;nWhereArrive;it++)
		arrvieDist[it]=max(arrvieDist[it],arrvieDist[it-1]+1);

	int maxDist=0;
	for(int it=0;it&lt;nWhereArrive;it++)
		maxDist=max(maxDist,arrvieDist[it]+westDist[nWhereArrive-1-it]);

	printf("%d\n",maxDist);
}

void work(){
	getBlockEdge();
	calcMinTime();
}

void solve(){
	inputData();
	work();
}

double allMem=0;
#define outputMemory(a) {\
	double itsMem=double(sizeof(a))/(1024*1024);\
	cout&lt;&lt;itsMem&lt;&lt;"MB"&lt;&lt;endl;\
	allMem+=itsMem;\
}

int main(){
//	freopen("wsc13.in","r",stdin);
//	allMem=0;
//	outputMemory(memStack);
//	outputMemory(mem);
//	outputMemory(adj);
//	outputMemory(isArrive);
//	cout&lt;&lt;allMem&lt;&lt;endl;
	solve();
}
</pre><pre></pre><h2>Problem2078</h2><pre>/*
 * The Islands.cpp
 *
 *  Created on: 2011-2-5
 *      Author: wjmzbmr
 */
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
using namespace std;
const int MAX_POINT=200000+10;
const int MAX_OBJ=40000+10;
struct Point{
	int x,y;
	bool isLeft;
	int id;
	bool operator&lt;(const Point&amp;p)const{
		if(x!=p.x)return x&lt;p.x;
		return y&lt;p.y;
	}
	void write(){
		cout&lt;&lt;"("&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;") ";
	}
};
Point ps[MAX_POINT];
int nPs;
int nObj;
int deg[MAX_OBJ];
void inputData(){
	nPs=0;
	scanf("%d",&amp;nObj);
	for(int it=0;it&lt;nObj;it++){
		int nCoastline;
		scanf("%d",&amp;nCoastline);
		int z[2],s;
		scanf("%d",&amp;s);z[0]=s;
		while(nCoastline--){
			if(nCoastline)scanf("%d",z+(nCoastline&amp;1));
			else z[0]=s;
			Point p;p.x=z[0];p.y=z[1];p.id=it;p.isLeft=nCoastline&amp;1;
			ps[nPs++]=p;
		}
	}
}
map&lt;int,Point*&gt; yToPoint;
Point*get(map&lt;int,Point*&gt;::iterator it){
	if(it==yToPoint.end())
		return 0;
	return it-&gt;second;
}

void work(){
	memset(deg,0,sizeof deg);
	sort(ps,ps+nPs);
	for(int it=0;it&lt;nPs;it++){
		Point&amp;p=ps[it];
		Point*pt=get(yToPoint.find(p.y));
		if(pt)yToPoint.erase(p.y);
		else {
			yToPoint[p.y]=&amp;p;
			if(!deg[p.id]){
				pt=get(yToPoint.upper_bound(p.y));
				if(pt)
					if(pt-&gt;isLeft) deg[p.id]=deg[pt-&gt;id];
					else deg[p.id]=deg[pt-&gt;id]+1;
				else
					deg[p.id]=1;
			}
		}
	}

	int maxDeg=0;
	for(int it=0;it&lt;nObj;it++){
//		cout&lt;&lt;it&lt;&lt;":"&lt;&lt;deg[it]&lt;&lt;endl;
		if(deg[it]&gt;maxDeg){
			maxDeg=deg[it];
		}
	}
	printf("%d\n",maxDeg);
}
int main(){
	inputData();
	work();
}
</pre><pre></pre><h2>Problem2079</h2><pre>#include &lt;cstdio&gt;
using namespace std;
int cnt[200001];
int main() {
	int n, m;
	scanf("%d%d", &amp;n, &amp;m);
	for (int i = 0; i &lt; m; ++i) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		cnt[a]++, cnt[b]++;
	}
	for (int i = 1; i &lt;= n; ++i) {
		if (!cnt[i]) {
			puts("NIE");
			return 0;
		}
	}
	puts("TAK");
}
</pre><pre></pre><h2>Problem2081</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int Max_Num=200000+100,seed=133331;
int Cnt,Data[Max_Num];

int Pow[Max_Num];
void init_Power()
{
    Pow[0]=1;
    for(int i=1;i&lt;Max_Num;i++)
        Pow[i]=Pow[i-1]*seed;
}

struct Hasher
{
    int H[Max_Num];

    void doit(int*Data,int Cnt)
    {
        int ret=0;
        rep(i,Cnt)
        {
            ret*=seed;ret+=Data[i];
            H[i]=ret;
        }
    }

    int Hash(int l,int r)//[l,r]
    {
        int ret=H[r]-(l?H[l-1]:0)*Pow[r-l+1];
        return ret;
    }

}For,Back;

void Input_Data()
{
    scanf("%d",&amp;Cnt);
    rep(i,Cnt)scanf("%d",Data+i);
}

void PrePare()
{
    init_Power();
    For.doit(Data,Cnt);
    reverse(Data,Data+Cnt);
    Back.doit(Data,Cnt);
}

int Ans=0,CAns=0,AnsSet[Max_Num];

inline int Inv(int Pos)
{
    return Cnt-1-Pos;
}

inline int HashVal(int l,int r)
{
    int a=For.Hash(l,r);
    int b=Back.Hash(Inv(r),Inv(l));
    return min(a,b);
}

struct Counter
{
    int A[Max_Num],Cnt;

    void clear()
    {
        Cnt=0;
    }

    Counter()
    {
        clear();
    }

    void add(int x)
    {
        A[Cnt++]=x;
    }

    int Count()
    {
        sort(A,A+Cnt);
        Cnt=unique(A,A+Cnt)-A;
        return Cnt;
    }
};

void Doit(int L)
{
    if(Cnt/L&lt;Ans)return;
    static Counter C;
    C.clear();
    for(int start=0;start+L&lt;=Cnt;start+=L)
    {
        int value=HashVal(start,start+L-1);
        C.add(value);
    }
    int ret=C.Count();
    if(ret&gt;Ans)Ans=ret,CAns=0;
    if(ret==Ans)AnsSet[CAns++]=L;
}

void Work()
{
    for(int L=1;L&lt;=Cnt;L++)
        Doit(L);
    printf("%d %d\n",Ans,CAns);
    rep(i,CAns)printf("%d ",AnsSet[i]);printf("\n");
}

void Solve()
{
    Input_Data();
    PrePare();
    Work();
}
int main()
{
    //freopen("in","r",stdin);
    Solve();
}
</pre><pre></pre><h2>Problem2082</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(typeof(x.begin()) e=x.begin();e!=x.end();e++)
using namespace std;
typedef long long ll;
const int Len_Max=1000000+1;
bool notP[Len_Max+1000]={};
int Ps[Len_Max],pnt=0;
void gen_Primes()
{
	int now=2;
	while(now*now&lt;Len_Max)
	{
		while(notP[now])now++;
		for(int x=now*2;x&lt;Len_Max;x+=now)
			notP[x]=true;
		now++;
	}
	for(int x=2;x&lt;Len_Max;x++)
		if(!notP[x])Ps[pnt++]=x;
}
inline void fast_mod(ll&amp;x,ll p)
{
	if(x&gt;=p)x-=p;
}
ll mul_mod(ll x,ll y,ll p)//cal a*b mod p
{
	ll T=floor(sqrt(p)+0.5);
	ll t=T*T-p;
	ll a=x/T,b=x%T,c=y/T,d=y%T;
	ll e=a*c/T;ll f=a*c%T;
	ll v=((a*d+b*c)%p+e*t)%p;
	ll g=v/T;ll h=v%T;
	ll ans=(((f+g)*t%p+b*d)%p+h*T)%p;
	while(ans&lt;0)ans+=p;
	return ans;
}
ll pow_mod(ll a,ll b,ll p)//cal a^b mod p
{
	if(!b)return 1;
	ll tmp=pow_mod(a,b/2,p);tmp=mul_mod(tmp,tmp,p);
	if(b&amp;1)tmp=mul_mod(tmp,a,p);
	return tmp;
}
bool miller_rabin(ll a,ll n)//return true if it is prime
{
	int r=0;ll s=n-1;
	while(!(s&amp;1)){s&gt;&gt;=1;r++;}
	ll x=pow_mod(a,s,n);
	if(x==1)return true;
	while(r--)
	{
		if(x==n-1)return true;
		x=mul_mod(x,x,n);
	}
	return false;
}
bool isPrime(ll n)
{
	/*
	for(int i=0;i&lt;pnt&amp;&amp;Ps[i]&lt;n;i++)
		if(n%Ps[i]==0)return false;
	*/
	rep(test,5)
	{
		int p=Ps[rand()%pnt];
		if(!miller_rabin(p,n))
			return false;
	}
	return true;
}
ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
const int Max_Size=1000;
struct BigInt
{
	int A[Max_Size],l;
	void clear(){memset(A,0,sizeof A);l=0;}
	void set(int x){A[l]=x;}
	BigInt(){clear();}
	BigInt&amp;operator*=(int x)
	{
		int d=0;
		for(int i=0;i&lt;=l;i++)
		{
			d+=A[i]*x;
			A[i]=d%10;d/=10;
		}
		while(d)A[++l]=d%10,d/=10;
		return *this;
	}
	BigInt&amp;operator-=(int x)
	{
		A[0]-=x;
		for(int i=0;i&lt;=l;i++)
		{
			if(A[i]&gt;=0)return *this;
			A[i]+=10;A[i+1]-=10;
		}
		while(l&gt;0&amp;&amp;!A[l])l--;
		return *this;
	}
	void output()
	{
		for(int i=l;i&gt;=0;i--)
			printf("%d",A[i]);
		printf("\n");
	}
};
const int Max_Num=600+10;
ll A[Max_Num];int N;
int Ans=0,CAns=0;
void doit(ll div,bool must_prime=true)
{
    int cnt=0;
    rep(i,N)
    {
        while(A[i]%div==0)
            cnt++,A[i]/=div;
    }
    int ret=(must_prime||isPrime(div))?1:2;
    if(cnt&gt;Ans)Ans=cnt,CAns=0;
    if(cnt==Ans)CAns+=ret;
}
void work()
{
	cin&gt;&gt;N;
	rep(i,N)cin&gt;&gt;A[i];
	rep(i,pnt)doit(Ps[i]);
	rep(i,N)rep(j,i)
	{
	    ll d=gcd(A[i],A[j]);
	    if(d&gt;1&amp;&amp;(d&lt;A[i]||d&lt;A[j]))
            doit(d);
	}
	rep(i,N)if(A[i]&gt;1)
	{
	    ll c=floor(sqrt(A[i])+0.5);
	    if(c*c==A[i])
            doit(c);
	}
	rep(i,N)if(A[i]&gt;1)
        doit(A[i],false);
	cout&lt;&lt;Ans&lt;&lt;endl;
	BigInt ans;ans.set(1);
	rep(i,CAns)ans*=2;
	ans-=1;
	ans.output();
}
void solve()
{
	gen_Primes();
	work();
}
int main()
{
	//freopen("in","r",stdin);
	//freopen("out","w",stdout);
	solve();
}
</pre><pre></pre><h2>Problem2084</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
typedef long long ll;
const int Max_Len=500000+100;
const int seed=133331;
int A[Max_Len],N;
struct PSqr
{
    int Hash[4][Max_Len],n;
    int Step[4];
    int*A;
    void Calc(int*H,int L)
    {
        int ret=0;int p=1;rep(i,L)ret*=seed,ret+=A[i],p*=seed;
        H[0]=ret;
        rep(i,n-L)
        {
            ret*=seed;ret+=A[i+L];ret-=p*A[i];
            H[i+1]=ret;
        }
    }
    void doit(int*_A,int _n)
    {
        A=_A;
        n=_n;int sq=sqrt(sqrt(n))+1;
        int t=1;
        rep(i,4)
        {
            if(t&gt;n)t=n;
            Step[i]=t;
            Calc(Hash[i],t);
            t*=sq;
        }
    }
    int Ask(int i,int sp,bool&amp;ok)
    {
        if(i+Step[sp]-1&gt;=n)return ok=false,-1;
        return ok=true,Hash[sp][i];
    }
}RevBack,For;
inline int Rev(int i)
{
    return N-1-i;
}
void prepare()
{
    For.doit(A,N);
    rep(i,N)A[i]=1-A[i];
    reverse(A,A+N);
    RevBack.doit(A,N);
}
int Calc_Max(int i)
{
    int u=i,v=i+1;
    int ret=0;
    for(int sp=3;sp&gt;=0;)
    {
        bool ok;
        int hu=RevBack.Ask(Rev(u),sp,ok);if(!ok){sp--;continue;}
        int hv=For.Ask(v,sp,ok);if(!ok){sp--;continue;}
        if(hu==hv)
        {
            int gone=For.Step[sp];
            u-=gone;
            v+=gone;
            ret+=gone;
        }
        else
        {
            sp--;
        }
    }
    return ret;
}
void input_data()
{
    scanf("%d",&amp;N);
    scanf(" ");
    rep(i,N)A[i]=getchar()-'0';
}
void work()
{
    ll ans=0;
    rep(i,N-1)
        ans+=Calc_Max(i);
    cout&lt;&lt;ans&lt;&lt;endl;
}
void solve()
{
    input_data();
    prepare();
    work();
}
int main()
{
    //freopen("in","r",stdin);
    solve();
}
</pre><pre></pre><h2>Problem2085</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
typedef long long ll;
const int Max_Num=200+10,seed=1333331;
const int Max_Mem=200000+10000;
const ll inf=1LL&lt;&lt;60;
using namespace std;
struct Hash
{
    int hash,pow;
    Hash(){hash=0;pow=1;}
    Hash(int val)
    {
        hash=val;pow=seed;
    }
    bool operator==(const Hash&amp;h)const
    {
        return hash==h.hash;
    }
};
Hash operator+(const Hash&amp;L,const Hash&amp;R)
{
    Hash ret;ret.hash=L.hash*R.pow+R.hash;
    ret.pow=L.pow*R.pow;
    return ret;
}
struct Memory
{
    Hash Mem[Max_Mem],*Now;
    void clear(){Now=Mem;}
    Memory(){clear();}
    Hash*New(int s){Now+=s;return Now-s;}
}Mem;
struct String
{
    string str;
    int L;
    Hash*Pre,*Suf;
    void doit()
    {
        Pre=Mem.New(L+1);Suf=Mem.New(L+1);
        for(int len=1;len&lt;=L;len++)
            Pre[len]=Pre[len-1]+Hash(str[len-1]);
        for(int len=1;len&lt;=L;len++)
            Suf[len]=Hash(str[L-len])+Suf[len-1];
    }
    void input()
    {
        cin&gt;&gt;str;L=str.size();
        doit();
    }
    int size()const
    {
        return L;
    }
};
String Str[Max_Num];
int n,m;
ll tmp[Max_Num][Max_Num];
struct Mat
{
    ll D[Max_Num][Max_Num];
    Mat&amp;operator=(const Mat&amp;mat)
    {
        memcpy(D,mat.D,sizeof D);
        return *this;
    }
    Mat&amp;operator*=(const Mat&amp;mat)
    {
        rep(i,n)rep(j,n)
        {
            tmp[i][j]=inf;
            rep(k,n)tmp[i][j]=min(tmp[i][j],D[i][k]+mat.D[k][j]);
        }
        memcpy(D,tmp,sizeof D);
        return *this;
    }
    void clear()
    {
        memset(D,0,sizeof D);
    }
    void set_Unit()
    {
        rep(i,n)rep(j,n)
            if(i==j)D[i][j]=0;
            else D[i][j]=inf;
    }
}Orig;
void input_data()
{
    cin&gt;&gt;n&gt;&gt;m;
    rep(i,n)Str[i].input();
}
int Cost(const String&amp;l,const String&amp;r)
{
    int up=min(l.size(),r.size())-1;
    for(int size=up;size&gt;=0;size--)
    {
        if(l.Suf[size]==r.Pre[size])
            return r.size()-size;
    }
}
void build_Mat()
{
    Orig.clear();
    rep(i,n)rep(j,n)
        Orig.D[i][j]=Cost(Str[i],Str[j]);
}
void work()
{
    build_Mat();
    Mat ret;ret.set_Unit();
    Mat tmp=Orig;int pow=1;
    m--;
    while(pow&lt;=m)
    {
        if(m&amp;pow)
            ret*=tmp;
        tmp*=tmp;
        pow*=2;
    }
    ll ans=inf;
    rep(i,n)rep(j,n)
    {
        ll tmp=Str[i].size()+ret.D[i][j];
        if(tmp&lt;ans)ans=tmp;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
void solve()
{
    input_data();
    work();
}
int main()
{
    //freopen("in","r",stdin);
    solve();
}
</pre><pre></pre><h2>Problem2086</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int Max_Num=1000000+100;
typedef long long ll;
int T[Max_Num],n,m,k;
void input_data()
{
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)scanf("%d",T+i);
}
ll A[Max_Num];
void work()
{
    scanf("%d",&amp;k);
    A[0]=0;for(int i=1;i&lt;=n;i++)A[i]=A[i-1]+T[i]-k;
    static int Up[Max_Num];int Unt=0;
    static int Down[Max_Num];int Dnt=0;
    Down[Dnt++]=0;
    for(int i=1;i&lt;=n;i++)
        if(A[i]&lt;A[Down[Dnt-1]])
            Down[Dnt++]=i;
    Up[Unt++]=n;
    for(int i=n-1;i&gt;=0;i--)
        if(A[i]&gt;A[Up[Unt-1]])
            Up[Unt++]=i;
    int c=Unt-1,ans=0;
    rep(i,Dnt)
    {
        while(c&gt;=0&amp;&amp;A[Up[c]]&gt;=A[Down[i]])c--;
        if(c+1&lt;Unt&amp;&amp;A[Up[c+1]]&gt;=A[Down[i]])
            ans=max(ans,Up[c+1]-Down[i]);
    }
    printf("%d ",ans);
}
void solve()
{
    input_data();
    while(m--)work();printf("\n");
}
int main()
{
    //freopen("in","r",stdin);
    solve();
}
</pre><pre></pre><h2>Problem2088</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int Max_Vet=40000+100;
const int Max_Edge=1000000*2+1000;
int n,m,vs,vt;
struct TGraph
{
    int head[Max_Vet],vet;
    int next[Max_Edge],dest[Max_Edge],mnt;
    void clear(int _vet)
    {
        vet=_vet;memset(head,-1,sizeof(int)*vet);
        mnt=0;
    }
    void add_edge(int s,int t)
    {
        dest[mnt]=t;next[mnt]=head[s];
        head[s]=mnt++;
    }
    void ins_edge(int s,int t)
    {
        add_edge(s,t);add_edge(t,s);
    }
}G;
#define tr(e,G,u) for(int e=G.head[u];e!=-1;e=G.next[e])
void input_data()
{
    scanf("%d%d",&amp;n,&amp;m);vs=0;vt=1;
    G.clear(n);
    int s,t;
    rep(i,m)
    {
        scanf("%d%d",&amp;s,&amp;t);
        --s;--t;
        G.ins_edge(s,t);
    }
}
void bfs(int vs,int Dist[Max_Vet])
{
    static int Q[Max_Vet],h,t;
    rep(i,G.vet)Dist[i]=Max_Vet;
    Dist[vs]=0;
    for(h=t=0,Q[t++]=vs;h&lt;t;h++)
    {
        int u=Q[h];
        tr(e,G,u)
        {
            int v=G.dest[e];
            if(Dist[v]==Max_Vet)
            {
                Dist[v]=Dist[u]+1;
                if(Dist[v]&lt;2)
                    Q[t++]=v;
            }
        }
    }
}
const int Max_Lay=6+10;
int A[Max_Lay];
int Calc_Edge()
{
    int ret=0;
    for(int i=1;i&lt;6;i++)
    {
        ret+=A[i-1]*A[i];
        ret+=A[i]*(A[i]-1)/2;
    }
    ret-=m;
    return ret;
}
void work()
{
    static int Dist[Max_Vet];
    memset(A,0,sizeof A);
    bfs(vs,Dist);
    rep(u,G.vet)
    {
        if(Dist[u]==1)
            A[1]++;
        if(Dist[u]==2)
            A[2]++;
    }
    A[0]++;
    bfs(vt,Dist);
    rep(u,G.vet)
    {
        if(Dist[u]==2)
            A[3]++;
        if(Dist[u]==1)
            A[4]++;
    }
    A[5]++;
    int left=n;rep(i,6)left-=A[i];
    int ans=0;
    A[2]+=left;ans=max(ans,Calc_Edge());A[2]-=left;
    A[3]+=left;ans=max(ans,Calc_Edge());A[3]-=left;
    cout&lt;&lt;ans&lt;&lt;endl;
}
void solve()
{
    input_data();
    work();
}
int main()
{
    //freopen("in","r",stdin);
    solve();
}
</pre><pre></pre><h2>Problem2089</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define update(x,c) if(x&lt;c)x=c;
using namespace std;
const int Max_Num=20000+100,Max_K=200+100;
const int Max_Range=1&lt;&lt;17;
struct Seg_Tree
{
    int Max[Max_Range],m;
    void init(int N)
    {
        m=1;while(m+3&lt;=N)m&lt;&lt;=1;
        memset(Max,0,sizeof Max);
    }
    void Change(int p,int v)
    {
        for(p+=m+1;p;p&gt;&gt;=1)update(Max[p],v);
    }
    int Ask(int l,int r)
    {
        if(l&gt;r)return 0;
        int ret=0;
        for(l+=m,r+=m+2;l^r^1;l&gt;&gt;=1,r&gt;&gt;=1)
        {
            if(~l&amp;1)update(ret,Max[l^1]);
            if(r&amp;1)update(ret,Max[r^1]);
        }
        return ret;
    }
}Les,Gre;
const int Equal=0,Less=-1,Greater=1;
int N,K,A[Max_Num];
int Type[Max_K];
int Eq[Max_Num]={};
void input_data()
{
    scanf("%d%d",&amp;N,&amp;K);
    rep(i,N)scanf("%d",A+i);char c;
    rep(i,K)
    {
        scanf(" "),scanf("%c",&amp;c);
        switch(c)
        {
            case '&gt;':Type[i]=Greater;break;
            case '=':Type[i]=Equal;break;
            case '&lt;':Type[i]=Less;break;
        }
    }
}
int Cnt;
int tmp[Max_Num];
void Discretization()
{
    memcpy(tmp,A,sizeof tmp);
    sort(tmp,tmp+N);
    Cnt=unique(tmp,tmp+N)-tmp;
    rep(i,N)A[i]=lower_bound(tmp,tmp+Cnt,A[i])-tmp;
}
bool check(int a,int b,int op)
{
    switch(op)
    {
        case Equal:return a==b;
        case Less:return a&lt;b;
        case Greater:return a&gt;b;
    }
}
int Dp[Max_Num]={};
void work()
{
    int ret=0,pos=0;
    Discretization();
    Gre.init(Cnt);Les.init(Cnt);
    rep(i,N)
    {
        update(Dp[i],Eq[A[i]]+1);
        update(Dp[i],Les.Ask(0,A[i]-1)+1);
        update(Dp[i],Gre.Ask(A[i]+1,Cnt-1)+1);
        if(Dp[i]&gt;ret)
        {
            ret=Dp[i];pos=i;
        }
        int type=Type[(Dp[i]-1)%K];
        switch(type)
        {
            case Equal:Eq[A[i]]=Dp[i];break;
            case Less:Les.Change(A[i],Dp[i]);break;
            case Greater:Gre.Change(A[i],Dp[i]);break;
        }
    }
    printf("%d\n",ret);
    Dp[pos]=-1;
    ret--;
    while(ret)
    {
        int last=pos;
        pos--;
        while(Dp[pos]!=ret||!check(A[pos],A[last],Type[(ret-1)%K]))
            pos--;
        Dp[pos]=-1;
        ret--;
    }
}
void solve()
{
    input_data();
    work();
}
int main()
{
    //freopen("in","r",stdin);
    solve();
}
</pre><pre></pre><h2>Problem2091</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
typedef long long ll;

const int Max_Num=1000000+10;
int A[Max_Num],n;
ll Dp[Max_Num];

void input_data()
{
    scanf("%d",&amp;n);
    rep(i,n)scanf("%d",A+i+1);
}

void work()
{
    sort(A+1,A+n+1);
    Dp[0]=0;
    for(int i=1;i&lt;=n;i++)
        Dp[i]=max(Dp[i-1],A[i]-Dp[i-1]);
    cout&lt;&lt;Dp[n]&lt;&lt;endl;
}
int main()
{
    //freopen("in","r",stdin);
    input_data();
    work();
}
</pre><pre></pre><h2>Problem2093</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;ctime&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
typedef long long ll;
const int Max_Num=1000000+10;
const ll inf=ll(1e18)+100;
ll A[Max_Num],m;
int n,k,pre;
template&lt;class T&gt;
inline void scan(T&amp;a)
{
    a=0;char c;while(c=getchar(),c&lt;'0'||c&gt;'9');a=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')a=a*10+c-'0';
}
void input_data()
{
    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;
    rep(i,n)scan(A[i]);
}
int Link[2][Max_Num];
int At[Max_Num];
void work()
{
    int now=0,next=1;
    int l=0,r=0;
    rep(i,n)
    {
        while(r&lt;i)r++;
        while(r-l+1&lt;k+1)r++;
        while(r-l+1&gt;k+1)l++;
        while(r+1&lt;n&amp;&amp;i&gt;l)
        {
            ll now=max(A[r]-A[i],A[i]-A[l]);
            ll next=max(A[r+1]-A[i],A[i]-A[l+1]);
            if(next&lt;now)l++,r++;
            else break;
        }
        if(A[i]-A[l]&gt;=A[r]-A[i])
            Link[next][i]=l;
        else
            Link[next][i]=r;
    }
    rep(i,n)At[i]=i;
    ll pow=1;
    while(pow&lt;=m)
    {
        swap(now,next);
        if(pow&amp;m)
            rep(i,n)At[i]=Link[now][At[i]];
        rep(i,n)
            Link[next][i]=Link[now][Link[now][i]];
        pow*=2;
    }
    rep(i,n)printf("%d ",At[i]+1);printf("\n");
}
void solve()
{
    input_data();
    work();
}
int main()
{
    //freopen("in","r",stdin);
    solve();
}
</pre><pre></pre><h2>Problem2095</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int Max_Vet=1000+10;
const int Max_Edge=(2000+10)*2;
const int Max_Value=1000+10;
struct TGraph
{
    int head[Max_Vet],vet;
    int next[Max_Edge],dest[Max_Edge],cost[Max_Edge],mnt;
    bool exist[Max_Edge];
    void clear(int _vet)
    {
        vet=_vet;memset(head,-1,sizeof(int)*vet);
        mnt=0;
    }
    void add_edge(int s,int t,int c=0)
    {
        next[mnt]=head[s];dest[mnt]=t;cost[mnt]=c;exist[mnt]=true;
        head[s]=mnt++;
    }
    void reset()
    {
        memset(exist,true,sizeof exist);
    }
}G;
#define tr(e,G,u) for(int e=G.head[u];e!=-1;e=G.next[e])
int n,m;
int low=0;
void input_data()
{
    scanf("%d%d",&amp;n,&amp;m);
    G.clear(n);
    int s,t,cs,ct;
    rep(i,m)
    {
        scanf("%d%d%d%d",&amp;s,&amp;t,&amp;cs,&amp;ct);
        --s;--t;
        G.add_edge(s,t,cs);
        G.add_edge(t,s,ct);
        low=max(low,min(cs,ct));
    }
}
int Deg[Max_Vet],In[Max_Vet],Out[Max_Vet];
bool Vis[Max_Vet]={};
int L;
bool Check_Degs()
{
    int t=0;
    rep(u,n)
    {
        tr(e,G,u)
            Deg[u]++;
    }
    rep(u,n)if(Deg[u]%2)return false;
    return true;
}
int Type(int u)
{
    if(Out[u]&gt;In[u])return 1;
    if(Out[u]&lt;In[u])return -1;
    return 0;
}
bool bi(int e)
{
    return G.cost[e]&lt;=L&amp;&amp;G.cost[e^1]&lt;=L;
}
void rev(int s,int t,int e)
{
    G.exist[e]=false;G.exist[e^1]=true;
    Out[s]--;In[t]--;
    In[s]++;Out[t]++;
}
bool search(int u)
{
    //cout&lt;&lt;u&lt;&lt;":"&lt;&lt;Type(u)&lt;&lt;endl;
    Vis[u]=true;
    if(Type(u)==-1)return true;
    tr(e,G,u)if(G.exist[e]&amp;&amp;bi(e))
    {
        int v=G.dest[e];if(Vis[v])continue;
        if(search(v))
            return rev(u,v,e),true;
    }
    return false;
}
bool Check_Second()
{
    G.reset();
    rep(u,n)
    {
        tr(e,G,u)
            if(G.exist[e]&amp;&amp;bi(e))//is bi-directional
            {
                G.exist[e^1]=false;
                Out[u]++;In[G.dest[e]]++;
            }
            else if(G.cost[e]&gt;L)
                G.exist[e]=false;
    }
    for(bool ch=true;ch;)
    {
        ch=false;
        rep(u,n)
        {
            while(Type(u)==1)
            {
                ch=true;
                memset(Vis,0,sizeof Vis);
                //cout&lt;&lt;"Start"&lt;&lt;endl;
                if(!search(u))
                    return false;
            }
        }
    }
    return true;
}
bool Check(int _L)
{
    L=_L;memset(In,0,sizeof In);
    memset(Out,0,sizeof Out);
    rep(u,n)
    {
        tr(e,G,u)if(G.cost[e]&lt;=L&amp;&amp;G.cost[e^1]&gt;L)
        {
            int v=G.dest[e];
            Out[u]++;In[v]++;
        }
    }
    rep(u,n)if(Out[u]&gt;Deg[u]/2||In[u]&gt;Deg[u]/2)return false;
    return Check_Second();
}
int Find_Ans()
{
    int l=low-1,r=Max_Value;
    while(l+1&lt;r)
    {
        int m=l+r&gt;&gt;1;
        if(Check(m))r=m;
        else l=m;
    }
    return r;
}
int P[Max_Edge],pnt=0;
void Make_Route(int u=0)
{
    tr(e,G,u)if(G.exist[e])
    {
        G.exist[e]=false;
        Make_Route(G.dest[e]);
        P[pnt++]=e/2;
    }
}
void Output()
{
    if(pnt&lt;m)
    {
        puts("NIE");
        return;
    }
    for(int i=pnt-1;i&gt;=0;i--)printf("%d ",P[i]+1);
}
void Show_Graph()
{
    rep(u,n)
    {
        tr(e,G,u)
        {
            int v=G.dest[e];
            if(G.exist[e])
                cout&lt;&lt;u+1&lt;&lt;"-&gt;"&lt;&lt;v+1&lt;&lt;" "&lt;&lt;G.cost[e]&lt;&lt;endl;
        }
    }
}
void work()
{
    if(!Check_Degs())
    {
        puts("NIE");
        return;
    }
    int L=Find_Ans();
    if(L==Max_Value)
    {
        puts("NIE");
        return;
    }
    else
    {
        cout&lt;&lt;L&lt;&lt;endl;
    }
}
void solve()
{
    input_data();
    work();
}
int main()
{
    //freopen("in","r",stdin);
    solve();
}
</pre><pre></pre><h2>Problem2096</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;deque&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int Max_Num=3000000+100,inf=~0U&gt;&gt;1;
int n,t;
int A[Max_Num];
struct Data
{
    int val,pos;
    Data(int _val,int _pos):
        val(_val),pos(_pos){}
};
struct MQueue//get the min
{
    deque&lt;Data&gt;D;
    void matain_front(int now)
    {
        while(D.size()&amp;&amp;D.front().pos==now)
            D.pop_front();
    }
    void matain_back()
    {
        int n;
        while(n=D.size(),n&gt;=2&amp;&amp;D[n-2].val&gt;=D[n-1].val)
            D[n-2]=D[n-1],D.pop_back();
    }
    int ask(){return D.front().val;}
    void add(Data a)
    {
        D.push_back(a);
        matain_back();
    }
}Max,Min;
template&lt;class T&gt;
inline void scan(T&amp;a)
{
    a=0;char c;while(c=getchar(),c&lt;'0'||c&gt;'9');a=c-'0';
    while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')a=a*10+c-'0';
}
int main()
{
    //freopen("in","r",stdin);
    scan(t);scan(n);
    rep(i,n)scan(A[i]);A[n]=-inf;
    int r=-1;
    int ans=0;
    #define add(r) Max.add(Data(-A[r],r)),Min.add(Data(A[r],r))
    rep(i,n)
    {
        while(r&lt;i)++r,add(r);
        while(r&lt;n)
        {
            int dif=-Max.ask()-Min.ask();
            if(dif&gt;t)break;
            ++r;add(r);
        }
        //cout&lt;&lt;i&lt;&lt;","&lt;&lt;r&lt;&lt;endl;
        int ret=r-i;if(ret&gt;ans)ans=ret;
        Max.matain_front(i);Min.matain_front(i);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem2097</h2><pre>/*
    PROG: exercise
    LANG: C++
    ID: LiJie Chen
*/
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define tr(e,x) for(vector&lt;int&gt;::iterator e=x.begin();e!=x.end();e++)
#define pb push_back
#define ALL(x) x.begin(),x.end()
using namespace std;
const int Max_Vet=100000+100;
int VetCnt,S;
vector&lt;int&gt; E[Max_Vet];
void Add_Edge(int s,int t)
{
    E[s].pb(t);E[t].pb(s);
}
void Input_Data()
{
    scanf("%d%d",&amp;VetCnt,&amp;S);
    int s,t;
    rep(i,VetCnt-1)
    {
        scanf("%d%d",&amp;s,&amp;t);
        --s;--t;
        Add_Edge(s,t);
    }
}

int L,Cnt=0;
int Ret[Max_Vet];
int A[Max_Vet],Ant;
void Dfs(int u,int f)
{
    tr(e,E[u])if(*e!=f)
        Dfs(*e,u);
    Ant=0;
    tr(e,E[u])if(*e!=f)
        A[Ant++]=Ret[*e]+1;
    A[Ant++]=0;
    sort(A,A+Ant);
    int x=Ant-1;
    while(x&gt;=1&amp;&amp;A[x-1]+A[x]&gt;L)--x;
    Cnt+=Ant-x-1;
    Ret[u]=A[x];
}

bool Check(int _L)
{
    Cnt=0;
    L=_L;
    Dfs(0,-1);
    return Cnt&lt;=S;
}

void Work()
{
    int l=-1,r=VetCnt+1;
    while(l+1&lt;r)
    {
        int m=l+r&gt;&gt;1;
        if(Check(m))r=m;
        else l=m;
    }
    cout&lt;&lt;r&lt;&lt;endl;
}

void Solve()
{
    Input_Data();
    Work();
}

int main()
{
    Solve();
}
</pre><pre></pre><h2>Problem2099</h2><pre>/*
    PROG: letter
    LANG: C++
    ID: LiJie Chen
*/
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int Max_Len=50000+100,seed=13331;

char Get_Char()
{
    char c;
    while(c=getchar(),c==' '||c=='\n');
    return c;
}

void Read_Str(char*S,int N)
{
    while(N--)
        *S++=Get_Char();
    *S++='\0';
}

int Pow[Max_Len];
void init_Power()
{
    Pow[0]=1;
    for(int pow=1;pow&lt;Max_Len;pow++)
        Pow[pow]=Pow[pow-1]*seed;
}

struct Hasher
{
    int H[Max_Len],Cnt;

    void doit(char*A,int _Cnt)
    {
        Cnt=_Cnt;int ret=0;
        for(int i=0;i&lt;Cnt;i++)
        {
            ret*=seed;ret+=A[i];
            H[i]=ret;
        }
    }

    int Ask(int l,int r)
    {
        int ret=H[r]-(l?H[l-1]:0)*Pow[r-l+1];
        return ret;
    }

    int Get(int at)
    {
        return Ask(at,at);
    }
}NHash,MHash;

int NCnt,MCnt;
char A[Max_Len],B[Max_Len];

struct Stuff
{
    Hasher*own;
    int p;
    Stuff(){}
    Stuff(Hasher*_own,int _p):
        own(_own),p(_p){}
    int Max_Len()const
    {
        return own-&gt;Cnt-p;
    }
    int Hash(int Len)const
    {
        return own-&gt;Ask(p,p+Len-1);
    }
    int Get(int Len)const
    {
        return own-&gt;Get(p+Len);
    }
};

int Lcp(const Stuff&amp;a,const Stuff&amp;b)//i and j's lcp in A
{
    int l=0,r=min(a.Max_Len(),b.Max_Len())+1;
    while(l+1&lt;r)
    {
        int m=l+r&gt;&gt;1;
        if(a.Hash(m)==b.Hash(m))
            l=m;
        else
            r=m;
    }
    return l;
}

bool operator&lt;(const Stuff&amp;a,const Stuff&amp;b)
{
    int lcp=Lcp(a,b);
    return a.Get(lcp)&lt;b.Get(lcp);
}

Stuff Sa[Max_Len];

void PrePare()
{
    init_Power();
    A[NCnt++]=0;
    NHash.doit(A,NCnt);
    MHash.doit(B,MCnt);
    rep(i,NCnt)Sa[i]=Stuff(&amp;NHash,i);
    sort(Sa,Sa+NCnt);
}

void Input_Data()
{
    scanf("%d%d",&amp;NCnt,&amp;MCnt);
    Read_Str(A,NCnt);
    Read_Str(B,MCnt);
}

void Work()
{
    int at=0,Ans=0;
    while(at&lt;MCnt)
    {
        Stuff it(&amp;MHash,at);
        int p=lower_bound(Sa,Sa+NCnt,it)-Sa;
        int go=0;
        if(p&lt;NCnt)go=max(go,Lcp(Sa[p],it));
        if(p)go=max(go,Lcp(Sa[p-1],it));
        Ans++;at+=go;
    }
    cout&lt;&lt;Ans&lt;&lt;endl;
}

void Solve()
{
    Input_Data();
    PrePare();
    Work();
}

int main()
{
    Solve();
}
</pre><pre></pre><h2>Problem2100</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
#define foreach(it,x) for(vector&lt;ipair&gt;::iterator it=x.begin();it!=x.end();it++)
using namespace std;
const int N_MAX=100000+100;
const int INF=~0U&gt;&gt;1;
typedef pair&lt;int,int&gt; ipair;
#define FI first
#define SE second
vector&lt;ipair&gt; E[N_MAX];
void addEdge(int s,int t,int c)
{
     E[s].pb(ipair(t,c));
     E[t].pb(ipair(s,c));
}
priority_queue&lt;ipair&gt; PQ;
int n,m,st,ta,tb;
void inputData()
{
    cin&gt;&gt;m&gt;&gt;n&gt;&gt;st&gt;&gt;ta&gt;&gt;tb;--st;--ta;--tb;
    rep(it,m)
    {
        int s,t,c;scanf("%d%d%d",&amp;s,&amp;t,&amp;c);
        addEdge(s-1,t-1,c);
    }
}
int dist[N_MAX];
void calcDist(int vs)
{
    rep(i,n)dist[i]=INF;
    PQ.push(ipair(0,vs));
    while(PQ.size())
    {
        ipair it=PQ.top();PQ.pop();
        int d=-it.FI;int u=it.SE;
        if(dist[u]&lt;=d)continue;
        dist[u]=d;
        foreach(e,E[u])
        {
            int nc=d+e-&gt;SE;
            if(nc&lt;dist[e-&gt;FI])
            {
                PQ.push(ipair(-nc,e-&gt;FI));
            }
        }
    }
}
int main()
{
    //freopen("in.cpp","r",stdin);
    //freopen("out.cpp","w",stdout);
    inputData();
    int ans=~0U&gt;&gt;1;
    calcDist(st);
    int pa=dist[ta],pb=dist[tb];
    int res=pa+(calcDist(ta),dist[tb]);
    ans=min(ans,res);
    res=pb+(calcDist(tb),dist[ta]);
    ans=min(ans,res);
    cout&lt;&lt;ans&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem2101</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define pb push_back
using namespace std;
const int N_MAX=5000+100;
int dp[2][N_MAX];
int a[N_MAX],n;
int sum(int l,int r)
{
    return a[r]-(l?a[l-1]:0);
}
int main()
{
    //freopen("in.cpp","r",stdin);
    //freopen("out.cpp","w",stdout);
    cin&gt;&gt;n;rep(i,n)cin&gt;&gt;a[i];
    int now=0,next=1;
    rep(i,n) dp[next][i]=a[i];
    rep(i,n-1)a[i+1]+=a[i];
    
    for(int s=1;s&lt;n;s++)
    {
        swap(now,next);
        memset(dp[next],0,sizeof dp[next]);
        for(int l=0;l+s&lt;n;l++)
        {
            int r=l+s;
            dp[next][l]=sum(l,r)-min(dp[now][l],dp[now][l+1]);
        }
    }
    cout&lt;&lt;dp[next][0]&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem2102</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;bitset&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int N_MAX=20,M_MAX=100;
int bitCount[1&lt;&lt;N_MAX];
int num,nqry;
void prepareCount()
{
    bitCount[0]=0;
    for(int set=1;set&lt;(1&lt;&lt;num);set++)
        bitCount[set]=bitCount[set&gt;&gt;1]+(set&amp;1);
}
bitset&lt;20&gt; bit;
int mask[M_MAX],cnts[M_MAX];
int main()
{
    //freopen("in","r",stdin);
    cin&gt;&gt;num&gt;&gt;nqry;
    prepareCount();
    rep(cur,nqry)
    {
        cin&gt;&gt;bit&gt;&gt;cnts[cur];
        mask[cur]=bit.to_ulong();
    }
    int ansCnt=0,ans;
    for(int set=0;set&lt;(1&lt;&lt;num);set++)
    {
        bool ok=true;
        rep(it,nqry)
        {
            int m=mask[it]&amp;set;
            if(bitCount[m]!=cnts[it])
            {
                ok=false;break;
            }
        }
        if(ok)
        {
            ansCnt++;ans=set;
            if(ansCnt&gt;1)break;
        }
    }
    if(ansCnt==0)
        puts("IMPOSSIBLE");
    else if(ansCnt&gt;1)
        puts("NOT UNIQUE");
    else
    {
        bit=bitset&lt;20&gt;(ans);
        for(int at=num-1;at&gt;=0;--at)
            cout&lt;&lt;bit[at];
        cout&lt;&lt;endl;
    }
}
</pre><pre></pre><h2>Problem2104</h2><pre>/*
 *  [Wc2009]shortest.cpp
 *
 *  Created on: 2011-6-23
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_COLS = 100000 + 10;
int w[MAX_N_COLS][6];

struct Tree {
	int lr[6][6], ll[6][6], rr[6][6], mm[6][6];
	int l, r;
	Tree*ch[2];
	bool update() {
		Tree*L = ch[0], *R = ch[1];
		static int d1[6][6];
		bool updated = false;
		int m = l + r &gt;&gt; 1;
		for (int i = 0; i &lt; 6; ++i) {
			for (int j = 0; j &lt; 6; ++j) {
				d1[i][j] = min(L-&gt;rr[i][j] + w[m][i] + w[m][j], R-&gt;ll[i][j]);
			}
		}
		for (int k = 0; k &lt; 6; ++k) {
			for (int i = 0; i &lt; 6; ++i) {
				for (int j = 0; j &lt; 6; ++j) {
					d1[i][j] = min(d1[i][j], d1[i][k] + d1[k][j] - w[m][k]);
				}
			}
		}
		for (int i = 0; i &lt; 6; ++i) {
			for (int j = 0; j &lt; 6; ++j) {
				if (d1[i][j] != mm[i][j]) {
					updated = true;
					mm[i][j] = d1[i][j];
				}
			}
		}
		static int d2[6];
		for (int i = 0; i &lt; 6; ++i) {
			for (int j = 0; j &lt; 6; ++j) {
				d2[j] = INT_MAX;
				for (int k = 0; k &lt; 6; ++k) {
					d2[j] = min(d2[j], L-&gt;lr[i][k] + d1[k][j]);
				}
			}
			for (int j = 0; j &lt; 6; ++j) {
				int d = L-&gt;ll[i][j];
				for (int k = 0; k &lt; 6; ++k) {
					d = min(d, L-&gt;lr[j][k] + d2[k]);
				}
				if (d != ll[i][j])
					updated = true, ll[i][j] = d;
			}
			for (int j = 0; j &lt; 6; ++j) {
				int d = INT_MAX;
				for (int k = 0; k &lt; 6; ++k) {
					d = min(d, d2[k] + R-&gt;lr[k][j] - w[m][k]);
				}
				if (d != lr[i][j])
					updated = true, lr[i][j] = d;
			}
			for (int j = 0; j &lt; 6; ++j) {
				d2[j] = INT_MAX;
				for (int k = 0; k &lt; 6; ++k) {
					d2[j] = min(d2[j], R-&gt;lr[k][i] + d1[k][j] - w[m][k]);
				}
			}
			for (int j = 0; j &lt; 6; ++j) {
				int d = R-&gt;rr[i][j];
				for (int k = 0; k &lt; 6; ++k) {
					d = min(d, d2[k] + R-&gt;lr[k][j] - w[m][k]);
				}
				if (d != rr[i][j])
					updated = true, rr[i][j] = d;
			}
		}
		return updated;
	}

	void setLeaf() {
		static int sum[7];
		int*w = ::w[l];
		sum[0] = 0;
		for (int i = 0; i &lt; 6; ++i) {
			sum[i + 1] = sum[i] + w[i];
		}
		for (int i = 0; i &lt; 6; ++i) {
			for (int j = 0; j &lt; 6; ++j) {
				int L = min(i, j), R = max(i, j);
				int d = sum[R + 1] - sum[L];
				ll[i][j] = rr[i][j] = lr[i][j] = mm[i][j] = d;
			}
		}
	}

	Tree(int _l, int _r) :
		l(_l), r(_r) {
		if (l + 1 == r) {
			setLeaf();
			return;
		}
		ch[0] = new Tree(l, l + r &gt;&gt; 1);
		ch[1] = new Tree(l + r &gt;&gt; 1, r);
		update();
	}

	bool change(int c) {
		if (c &lt; l || c &gt;= r)
			return false;
		if (l + 1 == r) {
			setLeaf();
			return true;
		}
		bool updated = false;
		for (int i = 0; i &lt; 2; ++i) {
			updated |= ch[i]-&gt;change(c);
		}
		if (updated)
			updated |= update();
		return updated;
	}

	void updateWithLeft(int dl[], int dr[]) {
		Tree*L = ch[0], *R = ch[1];
		int m = l + r &gt;&gt; 1;
		static int d[6];
		for (int i = 0; i &lt; 6; ++i) {
			d[i] = INT_MAX;
			for (int j = 0; j &lt; 6; ++j) {
				d[i] = min(d[i], dr[j] + mm[j][i]);
			}
		}
		for (int i = 0; i &lt; 6; ++i) {
			for (int j = 0; j &lt; 6; ++j) {
				dl[i] = min(dl[i], L-&gt;lr[i][j] + d[j]);
			}
		}
		for (int i = 0; i &lt; 6; ++i) {
			dr[i] = INT_MAX;
			for (int j = 0; j &lt; 6; ++j) {
				dr[i] = min(dr[i], d[j] + R-&gt;lr[j][i] - w[m][j]);
			}
		}
	}

	void updateWithRight(int dl[], int dr[]) {
		Tree*L = ch[0], *R = ch[1];
		int m = l + r &gt;&gt; 1;
		static int d[6];
		for (int i = 0; i &lt; 6; ++i) {
			d[i] = INT_MAX;
			for (int j = 0; j &lt; 6; ++j) {
				d[i] = min(d[i], dl[j] + mm[j][i] - w[m][j]);
			}
		}
		for (int i = 0; i &lt; 6; ++i) {
			for (int j = 0; j &lt; 6; ++j) {
				dr[i] = min(dr[i], d[j] + R-&gt;lr[j][i] - w[m][j]);
			}
		}
		for (int i = 0; i &lt; 6; ++i) {
			dl[i] = INT_MAX;
			for (int j = 0; j &lt; 6; ++j) {
				dl[i] = min(dl[i], d[j] + L-&gt;lr[i][j]);
			}
		}
	}

	void solveSinglePoint(int r1, int c1, int dl[], int dr[]) {
		if (l + 1 == r) {
			for (int i = 0; i &lt; 6; ++i) {
				dl[i] = dr[i] = mm[r1][i];
			}
			return;
		}
		int m = l + r &gt;&gt; 1;
		if (c1 &lt; m) {
			ch[0]-&gt;solveSinglePoint(r1, c1, dl, dr);
			updateWithLeft(dl, dr);
		} else {
			ch[1]-&gt;solveSinglePoint(r1, c1, dl, dr);
			updateWithRight(dl, dr);
		}
	}

	int solveTwoPoint(int r1, int c1, int r2, int c2, int dl1[], int dr1[],
			int dl2[], int dr2[]) {
		//c1&lt;=c2
		if (l + 1 == r) {
			for (int i = 0; i &lt; 6; ++i) {
				dl1[i] = dr1[i] = mm[r1][i];
				dl2[i] = dr2[i] = mm[r2][i];
			}
			return mm[r1][r2];
		}
		int m = l + r &gt;&gt; 1;
		if (c2 &lt; m) {
			int ret = ch[0]-&gt;solveTwoPoint(r1, c1, r2, c2, dl1, dr1, dl2, dr2);
			for (int i = 0; i &lt; 6; ++i) {
				for (int j = 0; j &lt; 6; ++j) {
					ret = min(ret, dr1[i] + mm[i][j] + dr2[j]);
				}
			}
			updateWithLeft(dl1, dr1);
			updateWithLeft(dl2, dr2);
			return ret;
		} else if (c1 &gt;= m) {
			int ret = ch[1]-&gt;solveTwoPoint(r1, c1, r2, c2, dl1, dr1, dl2, dr2);
			for (int i = 0; i &lt; 6; ++i) {
				for (int j = 0; j &lt; 6; ++j) {
					ret = min(ret, dl1[i] + dl2[j] + mm[i][j] - w[m][i]
							- w[m][j]);
				}
			}
			updateWithRight(dl1, dr1);
			updateWithRight(dl2, dr2);
			return ret;
		} else {
			ch[0]-&gt;solveSinglePoint(r1, c1, dl1, dr1);
			ch[1]-&gt;solveSinglePoint(r2, c2, dl2, dr2);
			int ret = INT_MAX;
			for (int i = 0; i &lt; 6; ++i) {
				for (int j = 0; j &lt; 6; ++j) {
					ret = min(ret, dr1[i] + mm[i][j] + dl2[j] - w[m][j]);
				}
			}
			updateWithLeft(dl1, dr1);
			updateWithRight(dl2, dr2);
			return ret;
		}
	}
}*root;

int main() {
	int n;
	scanf("%d", &amp;n);
	for (int i = 0; i &lt; 6; ++i) {
		for (int j = 0; j &lt; n; ++j) {
			scanf("%d", &amp;w[j][i]);
		}
	}
	root = new Tree(0, n);
	int nQ;
	scanf("%d", &amp;nQ);
	while (nQ--) {
		int cmd;
		scanf("%d", &amp;cmd);
		if (cmd == 1) {
			int r, c, v;
			scanf("%d%d%d", &amp;r, &amp;c, &amp;v);
			--r, --c;
			w[c][r] = v;
			root-&gt;change(c);
		} else {
			int r1, c1, r2, c2;
			scanf("%d%d%d%d", &amp;r1, &amp;c1, &amp;r2, &amp;c2);
			--r1, --c1, --r2, --c2;
			if (c1 &gt; c2) {
				swap(c1, c2);
				swap(r1, r2);
			}
			static int dl1[6], dr1[6], dl2[6], dr2[6];
			printf("%d\n", root-&gt;solveTwoPoint(r1, c1, r2, c2, dl1, dr1, dl2,
					dr2));
		}
	}
}
</pre><pre></pre><h2>Problem2105</h2><pre>/*
 *  增强型LCP.cpp
 *
 *  Created on: 2011-6-27
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_L_STR = 200000 + 10;
const int SEED = 13331;
char str[MAX_L_STR], buf[MAX_L_STR];
int hash[MAX_L_STR] = { }, L;
int pow[MAX_L_STR];

void rebuild(int at) {
	for (int i = at; i &lt; L; ++i) {
		hash[i + 1] = hash[i] * SEED + str[i];
	}
}

void initPow() {
	pow[0] = 1;
	for (int i = 1; i &lt; MAX_L_STR; ++i) {
		pow[i] = pow[i - 1] * SEED;
	}
}

int ask(int l, int r) {
	return hash[r + 1] - hash[l] * pow[r - l + 1];
}

int lcp(int a, int b) {
	int L = 0, R = min(::L - a, ::L - b) + 1;
	while (L + 1 &lt; R) {
		int M = L + R &gt;&gt; 1;
		if (ask(a, a + M - 1) == ask(b, b + M - 1))
			L = M;
		else
			R = M;
	}
	return L;
}

void add(int at, char buf[]) {
	int n = strlen(buf);
	memmove(str + at + n, str + at, sizeof(char) * (L - at));
	L += n;
	for (int i = 0; i &lt; n; ++i) {
		str[at + i] = buf[i];
	}
	rebuild(at);
}

void replace(int l, int r, char buf[]) {
	for (int i = l; i &lt;= r; ++i) {
		str[i] = buf[i - l];
	}
	rebuild(l);
}

void erase(int l, int r) {
	memmove(str + l, str + r + 1, sizeof(char) * (L - 1 - r));
	L -= r - l + 1;
	rebuild(l);
}

int main() {
	initPow();
	int nQ;
	scanf("%d%d", &amp;L, &amp;nQ);
	scanf("%s", str);
	rebuild(0);
	for (int i = 0; i &lt; nQ; ++i) {
		char cmd;
		scanf(" ");
		scanf("%c", &amp;cmd);
		switch (cmd) {
			case 'L': {
				int a, b;
				scanf("%d%d", &amp;a, &amp;b);
				printf("%d\n", lcp(--a, --b));
				break;
			}
			case 'A': {
				int at;
				scanf("%d%s", &amp;at, buf);
				add(--at, buf);
				break;
			}
			case 'C': {
				int l, r;
				scanf("%d%d%s", &amp;l, &amp;r, buf);
				replace(--l, --r, buf);
				break;
			}
			case 'D': {
				int l, r;
				scanf("%d%d", &amp;l, &amp;r);
				erase(--l, --r);
				break;
			}
		}
	}
}
</pre><pre></pre><h2>Problem2109</h2><pre>/*
 * [Noi2010]Plane 航空管制.cpp
 *
 *  Created on: 2011-3-5
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_NAIR = 2000 + 10;

int lastTime[MAX_NAIR];
vector&lt;int&gt; before[MAX_NAIR];
vector&lt;int&gt; airByLastTime[MAX_NAIR];
int memoDoneAfter[MAX_NAIR];

int nAir;

void inputData() {
	int nEdges;
	scanf("%d%d", &amp;nAir, &amp;nEdges);
	for (int it = 0; it &lt; nAir; ++it) {
		scanf("%d", lastTime + it);
		--lastTime[it];
		airByLastTime[lastTime[it]].push_back(it);
	}
	for (int it = 0; it &lt; nEdges; ++it) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		--a;
		--b;
		before[b].push_back(a);
	}
}

int calcLastTime(int me) {
	static int curCan[MAX_NAIR];
	static int doneAfter[MAX_NAIR];
	memcpy(doneAfter,memoDoneAfter,sizeof doneAfter);
	int nCurCan = 0;
	for (int curTime = nAir - 1; curTime &gt;= 0; --curTime) {
		foreach(e,airByLastTime[curTime])
			if (doneAfter[*e] == 0)
				curCan[nCurCan++] = *e;
		if (nCurCan == 1 &amp;&amp; curCan[0] == me)
			return curTime;
		int where = 0;
		if (curCan[where] == me)
			++where;
		int what = curCan[where];
		swap(curCan[where], curCan[--nCurCan]);
		foreach(e,before[what]) {
			doneAfter[*e]--;
			if (doneAfter[*e] == 0 &amp;&amp; lastTime[*e] &gt;= curTime)
				curCan[nCurCan++] = *e;
		}
	}
}

void work() {
	for (int where = 0; where &lt; nAir; ++where) {
		printf("%d ", calcLastTime(where) + 1);
	}
	printf("\n");
}

void solve() {
	inputData();
	memset(memoDoneAfter,0,sizeof memoDoneAfter);
	for (int am = 0; am &lt; nAir; ++am) {
		foreach(e,before[am])
			memoDoneAfter[*e]++;
	}
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2111</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int VAL_MAX=1000000+10;
int mod,n;
bool notPrime[VAL_MAX]={};
int primes[VAL_MAX],nPrimes;

void getPrimes(){
	for(int now=2;now*now&lt;=n;now++){
		while(notPrime[now])
			now++;
		for(int mult=now*now;mult&lt;=n;mult+=now)
			notPrime[mult]=true;
	}

	nPrimes=0;
	for(int i=2;i&lt;=n;i++)
		if(!notPrime[i])
			primes[nPrimes++]=i;
}

int getPrimeId(int p){
	return lower_bound(primes,primes+nPrimes,p)-primes;
}
int cof[VAL_MAX]={};
void changed(int x,int d){
	for(int pId=0;;pId++){
		int p=primes[pId];
		if(p*p&gt;x)break;
		while(x%p==0)
			cof[pId]+=d,x/=p;
	}
	if(x&gt;1){
		int pId=getPrimeId(x);
		cof[pId]+=d;
	}
}

void multFact(int n){
	for(int pId=0;pId&lt;nPrimes;pId++){
		int p=primes[pId];
		int x=n;
		while(x)
			x/=p,cof[pId]+=x;
	}
}

typedef long long int64;
int64 powMod(int64 x,int e){
	int64 res=1,pow=1;int64 tmp=x;
	while(pow&lt;=e){
		if(e&amp;pow)
			res=(res*tmp)%mod;
		pow&lt;&lt;=1;tmp=(tmp*tmp)%mod;
	}
	return res;
}

int getVal(){
	int64 res=1;
	for(int pId=0;pId&lt;nPrimes;pId++){
		res=(res*powMod(primes[pId],cof[pId]))%mod;
	}
	return res;
}

int size[VAL_MAX];
int ocr[VAL_MAX]={};

int main(){
	scanf("%d%d",&amp;n,&amp;mod);
	getPrimes();
	multFact(n);
	for(int i=n;i&gt;=1;i--){
		size[i]++;
		ocr[size[i]]++;
		size[i/2]+=size[i];
	}

	for(int i=1;i&lt;=n;i++)
		if(ocr[i])
			changed(i,-ocr[i]);
	int res=getVal();
	printf("%d\n",res);
}
</pre><pre></pre><h2>Problem2115</h2><pre>/*
 * [Wc2011] Xor.cpp
 *
 *  Created on: 2011-3-7
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;bitset&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_NVETS = 50000;
const int MAX_NEDGES = 200000 + 10;
typedef long long int64;
struct Edge {
	int dest;
	int64 val;
	bool isTreeEdge;
	Edge*next, *op;
	Edge(int _dest, int64 _val, Edge*_next) :
		dest(_dest), val(_val), next(_next) {
		isTreeEdge = false;
	}
};
Edge*head[MAX_NVETS] = { };

void addEdge(int a, int b, int64 c) {
	head[a] = new Edge(b, c, head[a]);
	head[b] = new Edge(a, c, head[b]);
	head[a]-&gt;op = head[b];
	head[b]-&gt;op = head[a];
}

int vs, vt;
int nVets;
void inputData() {
	int nEdges;
	scanf("%d%d", &amp;nVets, &amp;nEdges);
	vs = 0;
	vt = nVets - 1;
	for (int cur = 0; cur &lt; nEdges; ++cur) {
		int a, b;
		int64 c;
		scanf("%d%d%lld", &amp;a, &amp;b, &amp;c);
		--a;
		--b;
		addEdge(a, b, c);
	}
}

int64 xorSum[MAX_NVETS];
bool visited[MAX_NVETS];
void dfs(int at, int64 curXor) {
	xorSum[at] = curXor;
	visited[at] = true;
	for (Edge*e = head[at]; e; e = e-&gt;next) {
		if (!visited[e-&gt;dest]) {
			e-&gt;isTreeEdge = true;
			e-&gt;op-&gt;isTreeEdge = true;
			dfs(e-&gt;dest, curXor ^ e-&gt;val);
		}
	}
}

const int MAX_BIT = 63;
const int MAX_NCIRCLES = MAX_NEDGES / 2;
int64 vals[MAX_NEDGES];
int nVals;
void getAllCircle() {
	nVals = 0;
	for (int u = 0; u &lt; nVets; ++u) {
		for (Edge*e = head[u]; e; e = e-&gt;next)
			if (!e-&gt;isTreeEdge) {
				vals[nVals++] = xorSum[u] ^ xorSum[e-&gt;dest] ^ e-&gt;val;
			}
	}
	sort(vals, vals + nVals);
	nVals = unique(vals, vals + nVals) - vals;
}

inline int get(int64 x, int where) {
	return (x &gt;&gt; where) &amp; 1;
}

typedef bitset&lt;MAX_NCIRCLES&gt; Row;
Row mat[MAX_BIT];
int want[MAX_BIT];
int64 ans;

void calcMaxXor() {
	for (int digit = 0; digit &lt; MAX_BIT; ++digit) {
		mat[digit].reset();
		for (int valId = 0; valId &lt; nVals; ++valId) {
			if (vals[valId] &gt;&gt; digit &amp; 1)
				mat[digit][valId] = true;
		}
	}

	int64 initVal = xorSum[vt];
//	cout&lt;&lt;initVal&lt;&lt;endl;
//	for (int it = 0; it &lt; nVals; ++it) {
//		cout&lt;&lt;vals[it]&lt;&lt;endl;
//	}

	for (int digit = 0; digit &lt; MAX_BIT; ++digit) {
		want[digit] = !get(initVal, digit);
		mat[digit][nVals]=want[digit];
	}

	ans=0;
	for (int digit = MAX_BIT - 1; digit &gt;= 0; --digit) {
		int col=-1;
		for (int ncol = 0; ncol &lt; nVals; ++ncol) {
			if(mat[digit][ncol]){
				col=ncol;
				break;
			}
		}
		if(col == -1){
			if(!mat[digit][nVals])
				ans|=1LL&lt;&lt;digit;
		} else {
			ans |= 1LL&lt;&lt;digit;
			for (int after = 0; after &lt; digit; ++after) {
				if(mat[after][col])
					mat[after] ^= mat[digit];
			}
		}
	}

	cout&lt;&lt;ans&lt;&lt;endl;
}

void work() {
	dfs(vs, 0);
	getAllCircle();
	calcMaxXor();
}

void solve() {
	inputData();
	work();
}

int main() {
//	freopen("in","r",stdin);
	solve();
}
</pre><pre></pre><h2>Problem2120</h2><pre>/*
 * [国家队内部测试题]数颜色.cpp
 *
 *  Created on: 2011-3-4
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_NCOLORS = 1000000 + 10;
const int MAX_NOPT = 10000 + 10;
const int MAX_LEN = 10000 + 10;
const int NONE = -INT_MAX;

struct Node {
	Node*ch[2];
	int val, key, size;
	void update() {
		size = ch[0]-&gt;size + ch[1]-&gt;size + 1;
	}
	Node(){
		key=RAND_MAX;
		size=0;
	}
}nullData,*null=&amp;nullData;

Node*newNode(int val) {
	Node*t = new Node;
	t-&gt;val = val;
	t-&gt;key = rand() - 1;
	t-&gt;size = 1;
	t-&gt;ch[0] = t-&gt;ch[1] = null;
	return t;
}

struct Treap {
	Node*root;
	Treap() {
		root = null;
	}
	void rotate(Node*&amp;t, bool d) {
		Node*p = t-&gt;ch[d];
		t-&gt;ch[d] = p-&gt;ch[!d];
		p-&gt;ch[!d] = t;
		t-&gt;update();
		p-&gt;update();
		if (root == t)
			root = p;
		t = p;
	}
	void insert(Node*&amp;t, int x) {
		if (t == null) {
			t = newNode(x);
			return;
		}
		bool dir = x &gt; t-&gt;val;
		insert(t-&gt;ch[dir], x);
		if (t-&gt;ch[dir]-&gt;key &lt; t-&gt;key)
			rotate(t, dir);
		else
			t-&gt;update();
	}
	void erase(Node*&amp;t, int x) {
		if (t == null)
			return;
		if (t-&gt;val == x) {
			bool dir = t-&gt;ch[1]-&gt;key &lt; t-&gt;ch[0]-&gt;key;
			if (t-&gt;ch[dir] == null) {
				delete t;
				t = null;
				return;
			} else {
				rotate(t, dir);
				erase(t-&gt;ch[!dir], x);
				t-&gt;update();
			}
		} else {
			bool dir = x &gt; t-&gt;val;
			erase(t-&gt;ch[dir], x);
			t-&gt;update();
		}
	}
	int countSmall(Node*t, int x) {
		if(t == null)
			return 0;
		if (t-&gt;val &gt; x)
			return countSmall(t-&gt;ch[0], x);
		return (t-&gt;val &lt; x) + countSmall(t-&gt;ch[1], x) + t-&gt;ch[0]-&gt;size;
	}
	int next(Node*t, int x) {
		if (t == null)
			return NONE;
		if (t-&gt;val &gt; x) {
			int it = next(t-&gt;ch[0], x);
			if (it != NONE)
				return it;
			return t-&gt;val;
		}
		return next(t-&gt;ch[1], x);
	}
	int prev(Node*t, int x) {
		if (t == null)
			return NONE;
		if (t-&gt;val &lt; x) {
			int it = prev(t-&gt;ch[1], x);
			if (it != NONE)
				return it;
			return t-&gt;val;
		}
		return prev(t-&gt;ch[0], x);
	}
	int next(int x) {
		return next(root, x);
	}
	int prev(int x) {
		return prev(root, x);
	}
	void insert(int x) {
		insert(root, x);
	}
	void erase(int x) {
		erase(root, x);
	}
	int countSmall(int x) {
		return countSmall(root, x);
	}
};

struct SegTree {
	static const int MAX_NODE = MAX_LEN * 4;
	Treap T[MAX_NODE];
	int m;
	void initCap(int cap) {
		m = 1;
		while (m &lt;= cap + 3)
			m &lt;&lt;= 1;
	}
	void erase(int p, int x) {
		for (p += m; p; p &gt;&gt;= 1)
			T[p].erase(x);
	}
	void insert(int p, int x) {
		for (p += m; p; p &gt;&gt;= 1)
			T[p].insert(x);
	}
	int countSmall(int l, int r, int x) {
		int cnt = 0;
		for (l += m - 1, r += m + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) {
			if (~l &amp; 1)
				cnt += T[l ^ 1].countSmall(x);
			if (r &amp; 1)
				cnt += T[r ^ 1].countSmall(x);
		}
		return cnt;
	}
};

Treap colors[MAX_NCOLORS];
SegTree segTree;
int seq[MAX_LEN];
int prevEqual[MAX_LEN];

void changeTo(int at,int toWhat){
	segTree.erase(at,prevEqual[at]);
	prevEqual[at]=toWhat;
	segTree.insert(at,prevEqual[at]);
}

void solve() {
	int n, nOpts;
	scanf("%d%d", &amp;n, &amp;nOpts);
	segTree.initCap(n);
	for (int i = 1; i &lt; n + 1; ++i) {
		int whatColor;
		scanf("%d", &amp;whatColor);
		seq[i] = whatColor;
		colors[whatColor].insert(i);
		int prev = colors[whatColor].prev(i);
		prevEqual[i]=prev;
		segTree.insert(i, prev);
	}

	for (int i = 0; i &lt; nOpts; ++i) {
		char cmd;
		scanf(" ");
		scanf("%c", &amp;cmd);
		if (cmd == 'Q') {
			int l, r;
			scanf("%d%d", &amp;l, &amp;r);
			int res=segTree.countSmall(l, r, l);
			printf("%d\n", res);
		} else {
			int at, whatColor;
			scanf("%d%d", &amp;at, &amp;whatColor);
			int oldColor = seq[at];
			int oldsNext=colors[oldColor].next(at);
			if(oldsNext != NONE){
				int oldPrev=colors[oldColor].prev(at);
				changeTo(oldsNext,oldPrev);
			}
			colors[oldColor].erase(at);
			seq[at]=whatColor;
			colors[whatColor].insert(at);
			int prev=colors[whatColor].prev(at);
			int next=colors[whatColor].next(at);
			changeTo(at,prev);
			if(next != NONE){
				changeTo(next,at);
			}
		}
	}
}

int main() {
//	freopen("in","r",stdin);
	solve();
}
</pre><pre></pre><h2>Problem2127</h2><pre>/*
 * [国家队内部测试题]happiness.cpp
 *
 *  Created on: 2011-3-19
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_ROWS = 100, MAX_N_COLS = 100;

const int INF = 1 &lt;&lt; 30;
struct Network {
	static const int MAX_N_VETS = MAX_N_ROWS * MAX_N_COLS + 10;
	static const int MAX_N_EDGES = MAX_N_VETS * 16;

	int head[MAX_N_VETS];
	int next[MAX_N_EDGES], dest[MAX_N_EDGES], cap[MAX_N_EDGES];

	int nVets, nEdges;
	int vs, vt;

	void makeEdge(int s, int t, int c) {
		int id = nEdges++;
		next[id] = head[s];
		dest[id] = t;
		cap[id] = c;
		head[s] = id;
	}

	void addEdge(int s, int t, int c, bool biDir) {
		makeEdge(s, t, c);
		makeEdge(t, s, biDir ? c : 0);
	}

	void init(int _nVets, int _vs, int _vt) {
		nVets = _nVets;
		vs = _vs;
		vt = _vt;
		memset(head, -1, sizeof head);
	}

	int am[MAX_N_VETS], cur[MAX_N_VETS], cnt[MAX_N_VETS], h[MAX_N_VETS],
			prev[MAX_N_VETS];

	int calcMaxFlow() {
		memset(am, 0, sizeof am);
		memset(cur, -1, sizeof cur);
		memset(cnt, 0, sizeof cnt);
		memset(h, 0, sizeof h);
		cnt[0] = nVets;
		int u = vs, now;
		am[u] = INF;
		int totalFlow = 0;

		while (h[vs] &lt; nVets) {
			for (now = cur[u]; now != -1; now = next[now])
				if (cap[now] &gt; 0 &amp;&amp; h[u] == h[dest[now]] + 1)
					break;
			if (now != -1) {
				int v = dest[now];
				cur[u] = prev[v] = now;
				am[v] = min(am[u], cap[now]);
				u = v;
				if (u == vt) {
					int by = am[u];
					while (u != vs) {
						cap[prev[u]] -= by;
						cap[prev[u] ^ 1] += by;
						u = dest[prev[u] ^ 1];
					}
					totalFlow += by;
					am[u] = INF;
				}
			} else {
				if (--cnt[h[u]] == 0)
					break;
				h[u] = nVets;
				for (now = head[u]; now != -1; now = next[now])
					if (cap[now] &gt; 0 &amp;&amp; h[u] &gt; h[dest[now]] + 1) {
						cur[u] = now;
						h[u] = h[dest[now]] + 1;
					}
				++cnt[h[u]];
				if (u != vs)
					u = dest[prev[u] ^ 1];
			}
		}

		return totalFlow;
	}
};

Network network;

int nRows, nCols;

typedef int costBoard[MAX_N_ROWS][MAX_N_COLS];

costBoard sameWenDown, sameLiDown, sameWenRight, sameLiRight, wen, li;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

int happinessSum = 0;
void inputBoard(costBoard board, int nRows, int nCols) {
	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			scanInt(board[r][c]);
			happinessSum += board[r][c];
		}
	}
}

void inputData() {
	scanInt(nRows);
	scanInt(nCols);

	happinessSum = 0;
	inputBoard(wen, nRows, nCols);
	inputBoard(li, nRows, nCols);
	inputBoard(sameWenDown, nRows - 1, nCols);
	inputBoard(sameLiDown, nRows - 1, nCols);
	inputBoard(sameWenRight, nRows, nCols - 1);
	inputBoard(sameLiRight, nRows, nCols - 1);
}

int sameWenSum[MAX_N_ROWS * MAX_N_COLS], sameLiSum[MAX_N_ROWS * MAX_N_COLS];

inline void process(int a, int b, int sameWen, int sameLi) {
	sameWenSum[a] += sameWen;
	sameLiSum[a] += sameLi;
	sameWenSum[b] += sameWen;
	sameLiSum[b] += sameLi;
	network.addEdge(a, b, sameWen + sameLi, true);
}

void buildGraph() {
	memset(sameWenSum, 0, sizeof sameWenSum);
	memset(sameLiSum, 0, sizeof sameLiSum);
	int nVets = nRows * nCols;
	int vs = nVets++, vt = nVets++;
	network.init(nVets, vs, vt);

#define id(r,c) ((r)*nCols+(c))
	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			if (r + 1 &lt; nRows) {
				process(id(r,c), id(r+1,c), sameWenDown[r][c], sameLiDown[r][c]);
			}
			if (c + 1 &lt; nCols) {
				process(id(r,c), id(r,c+1), sameWenRight[r][c],
						sameLiRight[r][c]);
			}
		}
	}
	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			//be wen:
			int me = id(r,c);
			network.addEdge(vs, me, sameLiSum[me] + 2 * li[r][c], false);
			//be li:
			network.addEdge(me, vt, sameWenSum[me] + 2 * wen[r][c], false);
		}
	}
}

int work() {
	buildGraph();
	return (happinessSum * 2 - network.calcMaxFlow()) / 2;
}

void solve() {
	inputData();
	cout &lt;&lt; work() &lt;&lt; endl;
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2128</h2><pre>/*
 * [国家队内部测试题]cheat.cpp
 *
 *  Created on: 2011-3-19
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
//#define DEBUG
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_SEEDS = 3000 + 10;
const int MAX_N_ROWS = 250;
const int MAX_N_COLS = 250;
const int MAX_N_VALUES = MAX_N_ROWS * MAX_N_COLS;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

struct Random {
	int a[MAX_N_SEEDS];
	int n;
	void read() {
		scanInt(n);
		for (int i = 1; i &lt;= n; ++i) {
			scanInt(a[i]);
		}
	}
	int get(int where) {
		return a[where % n + 1];
	}
};

Random randA, randB, randC;
int nRows, nCols;

const int CUT_OFF = 250 / 2;

int totalMemory;

class DataStruct {
public:
	virtual void init(int n) = 0;
	virtual void add(int x, int y) = 0;
	virtual int count(int lx, int ly, int rx, int ry) = 0;
	virtual void start() = 0;
};

class List: public DataStruct {
public:
	void init(int _n) {
		n = _n;
		xs = new int[n];
		ys = new int[n];
#ifdef DEBUG
		totalMemory += 2 * n;
#endif
		n = 0;
	}
	void add(int x, int y) {
		xs[n] = x;
		ys[n] = y;
		n++;
	}
	int count(int lx, int ly, int rx, int ry) {//[lx,rx)
		int ret = 0;
		for (register int i = 0; i &lt; n; ++i) {
			int x = xs[i], y = ys[i];
			if (x &gt;= lx &amp;&amp; x &lt; rx &amp;&amp; y &gt;= ly &amp;&amp; y &lt; ry)
				++ret;
		}
		return ret;
	}
	void start() {
		//do nothing
	}
private:
	int*xs, *ys, n;
};

class Table: public DataStruct {
public:
	void init(int n) {
		memset(sum, 0, sizeof sum);
#ifdef DEBUG
		totalMemory += 251 * 251;
#endif
	}
	void add(int x, int y) {
		sum[x + 1][y + 1]++;
	}
	int count(int lx, int ly, int rx, int ry) {
		return sum[rx][ry] - sum[rx][ly] - sum[lx][ry] + sum[lx][ly];
	}
	void start() {
		for (int r = 1; r &lt;= MAX_N_ROWS; ++r) {
			for (int c = 1; c &lt;= MAX_N_COLS; ++c) {
				sum[r][c] += sum[r - 1][c] + sum[r][c - 1] - sum[r - 1][c - 1];
			}
		}
	}
private:
	int sum[MAX_N_ROWS + 1][MAX_N_COLS + 1];
};

struct TA {
	int n;
	DataStruct* a[MAX_N_VALUES];

	void init(int _n) {
		n = _n;
		for (int i = 1; i &lt;= n; ++i) {
			int cnt = i &amp; -i;
			if (cnt &lt;= CUT_OFF)
				a[i - 1] = new List;
			else
				a[i - 1] = new Table;
			a[i - 1]-&gt;init(cnt);
		}
#ifdef DEBUG
		cout &lt;&lt; "done init" &lt;&lt; endl;
#endif
	}

	void add(int p, int x, int y) {
		for (p++; p &lt;= n; p += p &amp; -p) {
			a[p - 1]-&gt;add(x, y);
		}
	}

	void start() {
		for (int i = 0; i &lt; n; ++i) {
			a[i]-&gt;start();
		}
#ifdef DEBUG
		cout &lt;&lt; "done start" &lt;&lt; endl;
#endif
	}

	int count(int v, int lx, int ly, int rx, int ry) {
		//v]
		int ret = 0;
		for (v++; v &gt; 0; v -= v &amp; -v) {
			ret += a[v - 1]-&gt;count(lx, ly, rx, ry);
		}
		return ret;
	}

	int count(int lv, int rv, int lx, int ly, int rx, int ry) {
		//[lv,rv]
		return count(rv, lx, ly, rx, ry) - count(lv - 1, lx, ly, rx, ry);
	}
};

//int estimateSpace(int l, int r) {
//	int cnt = r - l;
//	int ret = 0;
//	if (cnt &gt;= CUT_OFF) {
//		ret += 250 * 250;
//	} else {
//		ret += cnt;
//	}
//	if (l + 1 == r)
//		return ret;
//	ret += estimateSpace(l, l + r &gt;&gt; 1) + estimateSpace(l + r &gt;&gt; 1, r);
//	return ret;
//}
//
//int estimateTime(int l, int r, int tl, int tr) {
//	if (r &lt;= tl || tr &lt;= l)
//		return 0;
//	int cnt = r - l;
//	int ret = 0;
//	if (tl &lt;= l &amp;&amp; r &lt;= tr) {
//		if (cnt &gt;= CUT_OFF) {
//			ret += 1;
//		} else {
//			ret += cnt;
//		}
//		return ret;
//	}
//	if (l + 1 == r)
//		return ret;
//	ret += estimateTime(l, l + r &gt;&gt; 1, tl, tr) + estimateTime(l + r &gt;&gt; 1, r,
//			tl, tr);
//	return ret;
//}

int estimateSpace(int n) {
	int ret = 0;
	for (int i = 1; i &lt;= n; ++i) {
		int cnt = i &amp; (-i);
		if (cnt &gt;= CUT_OFF)
			ret += 250 * 250;
		else
			ret += cnt;
	}
	return ret;
}

int estimateTime(int n, int p) {
	int ret = 0;
	for (; p &gt; 0; p -= p &amp; -p) {
		int cnt = p &amp; -p;
		if (cnt &gt;= CUT_OFF)
			ret += 1;
		else
			ret += cnt;
	}
	return ret;
}

void estimate() {
	int total = 250 * 250;
	cout &lt;&lt; estimateSpace(total) &lt;&lt; endl;
	int maxTime = 0;
	for (int i = 1; i &lt;= total; ++i) {
		maxTime = max(maxTime, estimateTime(total, i));
	}
	cout &lt;&lt; maxTime &lt;&lt; endl;
}

int get(int me, int mod) {
	int ret = randA.get(me) % mod;
	ret += randB.get(me) % mod;
	if (ret &gt;= mod)
		ret -= mod;
	ret += randC.get(me) % mod;
	if (ret &gt;= mod)
		ret -= mod;
	return ret;
}

int get(int r, int c, int mod) {
	int ret = get(r, mod) + get(c, mod);
	if (ret &gt;= mod)
		ret -= mod;
	return ret + 1;
}

int modValue;

struct Student {
	int v, x, y;
	bool operator&lt;(const Student&amp;who) const {
		return v &lt; who.v;
	}
};

Student students[MAX_N_VALUES];
int nStudents;

TA ta;

void initBoard() {
	int cur = 0;
	for (int r = 1; r &lt;= nRows; ++r) {
		for (int c = 1; c &lt;= nCols; ++c) {
			int v = get(r, c, modValue);
			students[cur].v = v;
			students[cur].x = r - 1;
			students[cur].y = c - 1;
			cur++;
		}
	}
	sort(students, students + cur);
	ta.init(cur);
	nStudents = cur;
	for (int i = 0; i &lt; cur; ++i) {
		Student&amp;me = students[i];
		ta.add(i, me.x, me.y);
#ifdef DEBUG
		//		cout &lt;&lt; ":" &lt;&lt; i &lt;&lt; endl;
#endif
	}
	ta.start();
}

void inputData() {
	randA.read();
	randB.read();
	randC.read();
	scanInt(nRows);
	scanInt(nCols);
	scanInt(modValue);
}

void compress(int&amp;lv, int&amp;rv) {
	//[lv,rv]
	Student me;
	me.v = lv;
	lv = lower_bound(students, students + nStudents, me) - students;
	me.v = rv;
	rv = upper_bound(students, students + nStudents, me) - students - 1;
}

void answerQueries() {
	int xorSum = 0;
	int nQ;
	scanInt(nQ);
	for (int i = 1; i &lt;= nQ; ++i) {
		int lx, ly, rx, ry, lv, rv;
		int cur = 0;
#define getIt(_mod_) (++cur,get(i,cur,_mod_))
		lx = getIt(nRows);
		ly = getIt(nCols);
		rx = getIt(nRows);
		ry = getIt(nCols);
		if (lx &gt; rx)
			swap(lx, rx);
		if (ly &gt; ry)
			swap(ly, ry);
		lx--;
		ly--;
		lv = getIt(modValue);
		rv = getIt(modValue);
		if (lv &gt; rv)
			swap(lv, rv);
#undef getIt
		compress(lv, rv);
#ifdef DEBUG
		cout &lt;&lt; lv &lt;&lt; " " &lt;&lt; rv &lt;&lt; " " &lt;&lt; lx &lt;&lt; " " &lt;&lt; rx &lt;&lt; " " &lt;&lt; ly &lt;&lt; " "
		&lt;&lt; ry &lt;&lt; ":" &lt;&lt; endl;
#endif
		int ret = ta.count(lv, rv, lx, ly, rx, ry);
#ifdef DEBUG
#endif
		xorSum ^= ret;
	}
	printf("%d\n", xorSum);
}

void work() {
	initBoard();
	answerQueries();
#ifdef DEBUG
	cout &lt;&lt; (1.0 * sizeof(int) * totalMemory) / (1024 * 1024) &lt;&lt; endl;
#endif
}

void solve() {
	inputData();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2132</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
using namespace std;

template&lt;class Flow&gt;
struct Maxflow {
	static const Flow INF = ~0U &gt;&gt; 1; //should change with type
//	static const Flow INF = numeric_limits&lt;Flow&gt;::max();
	struct Edge {
		int t;
		Flow c;
		Edge*n, *r;
		Edge(int _t, Flow _c, Edge*_n) :
				t(_t), c(_c), n(_n) {
		}
	};
	vector&lt;Edge*&gt; E;

	int addV() {
		E.push_back((Edge*) 0);
		return E.size() - 1;
	}

	void clear() {
		E.clear();
	}

	Edge* makeEdge(int s, int t, Flow c) {
		return E[s] = new Edge(t, c, E[s]);
	}

	void addEdge(int s, int t, Flow c) {
		Edge*e1 = makeEdge(s, t, c), *e2 = makeEdge(t, s, 0);
		e1-&gt;r = e2, e2-&gt;r = e1;
	}

	int calcMaxFlow(int vs, int vt) {
		int nV = E.size();
		Flow totalFlow = 0;

		vector&lt;Flow&gt; am(nV, 0);
		vector&lt;int&gt; h(nV, 0), cnt(nV + 1, 0);
		vector&lt;Edge*&gt; prev(nV, (Edge*) 0), cur(nV, (Edge*) 0);
		cnt[0] = nV;

		int u = vs;
		Edge*e;
		am[u] = INF;
		while (h[vs] &lt; nV) {
			for (e = cur[u]; e; e = e-&gt;n)
				if (e-&gt;c &gt; 0 &amp;&amp; h[u] == h[e-&gt;t] + 1)
					break;
			if (e) {
				int v = e-&gt;t;
				cur[u] = prev[v] = e;
				am[v] = min(am[u], e-&gt;c);
				u = v;
				if (u == vt) {
					Flow by = am[u];
					while (u != vs) {
						prev[u]-&gt;c -= by;
						prev[u]-&gt;r-&gt;c += by;
						u = prev[u]-&gt;r-&gt;t;
					}
					totalFlow += by;
					am[u] = INF;
				}
			} else {
				if (!--cnt[h[u]])
					break;
				h[u] = nV;
				for (e = E[u]; e; e = e-&gt;n)
					if (e-&gt;c &gt; 0 &amp;&amp; h[e-&gt;t] + 1 &lt; h[u]) {
						h[u] = h[e-&gt;t] + 1;
						cur[u] = e;
					}
				++cnt[h[u]];
				if (u != vs)
					u = prev[u]-&gt;r-&gt;t;
			}
		}

		return totalFlow;
	}

	~Maxflow() {
		for (int i = 0; i &lt; (int) E.size(); ++i) {
			for (Edge*e = E[i]; e;) {
				Edge*ne = e-&gt;n;
				delete e;
				e = ne;
			}
		}
	}
};

Maxflow&lt;int&gt; sol;
int n, m;
const int MAX_N = 100 + 1;
int a[MAX_N][MAX_N], b[MAX_N][MAX_N], c[MAX_N][MAX_N];
const int DI[] = { -1, 1, 0, 0 }, DJ[] = { 0, 0, -1, 1 };

bool inMap(int r, int c) {
	return r &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; m;
}

int ans;

int id[MAX_N][MAX_N];

int main() {
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; m; ++j) {
			cin &gt;&gt; a[i][j];
			ans += a[i][j];
		}
	}
	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; m; ++j) {
			cin &gt;&gt; b[i][j];
			ans += b[i][j];
		}
	}
	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; m; ++j) {
			cin &gt;&gt; c[i][j];
		}
	}

	int vs = sol.addV(), vt = sol.addV();
	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; m; ++j) {
			id[i][j] = sol.addV();
			if ((i + j) % 2 == 0) {
				sol.addEdge(vs, id[i][j], a[i][j]);
				sol.addEdge(id[i][j], vt, b[i][j]);
			} else {
				sol.addEdge(vs, id[i][j], b[i][j]);
				sol.addEdge(id[i][j], vt, a[i][j]);
			}
		}
	}

	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; m; ++j) {
			for (int d = 0; d &lt; 4; ++d) {
				int ni = i + DI[d], nj = j + DJ[d];
				if (inMap(ni, nj)) {
					ans += c[i][j];
					sol.addEdge(id[i][j], id[ni][nj], c[i][j] + c[ni][nj]);
				}
			}
		}
	}

	cout &lt;&lt; ans - sol.calcMaxFlow(vs, vt) &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2133</h2><pre>/*
 *  切割.cpp
 *
 *  Created on: 2011-5-30
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_V = 50 + 10;

bool g[MAX_V][MAX_V] = { };
int n, k1, k2;
int val[MAX_V];

double memo[MAX_V][MAX_V][MAX_V];//me,fsize,frest
double memo2[MAX_V];

double dfs(int u, int fa, int ch, int size, int rest) {
	if (size == 0) {
		double ret = memo2[u];
		if (ret &gt; -0.5)
			return ret;
		ret = 1e100;
		for (int nsize = k1; nsize &lt;= k2; ++nsize) {
			ret = min(ret, dfs(u, fa, ch, nsize, nsize - 1) + val[u] * 1.0
					/ nsize);
		}
		return ret;
	}
	while (ch &lt; n &amp;&amp; (!g[u][ch] || ch == fa))
		++ch;
	if (ch == n) {
		return rest == 0 ? 0 : 1e100;
	}
	double&amp;ret = memo[ch][size][rest];
	if (ret &gt; -0.5)
		return ret;
	ret = 1e100;
	for (int inCh = 0; inCh &lt;= rest; ++inCh) {
		double tmp = dfs(ch, u, 0, inCh == 0 ? 0 : size, inCh == 0 ? 0 : inCh
				- 1) + dfs(u, fa, ch + 1, size, rest - inCh)
				+ (inCh &gt; 0 ? val[ch] * 1.0 / size : 0);
		ret = min(ret, tmp);
	}
	return ret;
}

int main() {
	cin &gt;&gt; n &gt;&gt; k1 &gt;&gt; k2;
	double sum = 0;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; val[i];
		sum += val[i];
	}
	for (int i = 0; i &lt; n - 1; ++i) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		--a;
		--b;
		g[a][b] = g[b][a] = true;
	}
	memset(memo, -1, sizeof memo);
	memset(memo2, -1, sizeof memo2);
	double ans = 1e100;
	for (int s = k1; s &lt;= k2; ++s) {
		ans = min(ans, dfs(0, -1, 0, s, s - 1) + val[0] * 1.0 / s);
	}
	if (ans &gt; 1e50) {
		ans = sum * 2;
	}
	printf("%0.2lf\n", ans);
}
</pre><pre></pre><h2>Problem2133</h2><pre>/*
 *  切割.cpp
 *
 *  Created on: 2011-5-30
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_V = 50 + 10;

bool g[MAX_V][MAX_V] = { };
int n, k1, k2;
int val[MAX_V];

double memo[MAX_V][MAX_V][MAX_V];//me,fsize,frest
double memo2[MAX_V];

double dfs(int u, int fa, int ch, int size, int rest) {
	if (size == 0) {
		double&amp;ret = memo2[u];
		if (ret &gt; -0.5)
			return ret;
		ret = 1e100;
		for (int nsize = k1; nsize &lt;= k2; ++nsize) {
			ret = min(ret, dfs(u, fa, ch, nsize, nsize - 1) + val[u] * 1.0
					/ nsize);
		}
		return ret;
	}
	while (ch &lt; n &amp;&amp; (!g[u][ch] || ch == fa))
		++ch;
	if (ch == n) {
		return rest == 0 ? 0 : 1e100;
	}
	double&amp;ret = memo[ch][size][rest];
	if (ret &gt; -0.5)
		return ret;
	ret = 1e100;
	for (int inCh = 0; inCh &lt;= rest; ++inCh) {
		double tmp = dfs(ch, u, 0, inCh == 0 ? 0 : size, inCh == 0 ? 0 : inCh
				- 1) + dfs(u, fa, ch + 1, size, rest - inCh)
				+ (inCh &gt; 0 ? val[ch] * 1.0 / size : 0);
		ret = min(ret, tmp);
	}
	return ret;
}

int main() {
	cin &gt;&gt; n &gt;&gt; k1 &gt;&gt; k2;
	double sum = 0;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; val[i];
		sum += val[i];
	}
	for (int i = 0; i &lt; n - 1; ++i) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		--a;
		--b;
		g[a][b] = g[b][a] = true;
	}
	memset(memo, -1, sizeof memo);
	memset(memo2, -1, sizeof memo2);
	double ans = 1e100;
	for (int s = k1; s &lt;= k2; ++s) {
		ans = min(ans, dfs(0, -1, 0, s, s - 1) + val[0] * 1.0 / s);
	}
	if (ans &gt; 1e50) {
		ans = sum * 2;
	}
	printf("%0.2lf\n", ans);
}
</pre><pre></pre><h2>Problem2141</h2><pre>/*
 *  排队.cpp
 *
 *  Created on: 2011-5-19
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Node {
	Node*ch[2];
	int size, key, value;
	void update() {
		size = 1 + ch[0]-&gt;size + ch[1]-&gt;size;
	}
	Node() {
		size = 0;
		key = RAND_MAX;
		ch[0] = ch[1] = 0;
	}
	Node(int);
}*null = new Node;

Node::Node(int _value) :
	value(_value) {
	key = rand();
	size = 1;
	ch[0] = ch[1] = null;
}

struct Treap {
	Node*root;
	Treap() {
		root = null;
	}
	void rotate(Node*&amp;t, int d) {
		Node*p = t-&gt;ch[d];
		t-&gt;ch[d] = p-&gt;ch[!d];
		p-&gt;ch[!d] = t;
		t-&gt;update();
		p-&gt;update();
		if (t == root)
			root = p;
		t = p;
	}

	void insert(Node*&amp;t, int x) {
		if (t == null) {
			t = new Node(x);
			return;
		}
		int d = x &gt; t-&gt;value;
		insert(t-&gt;ch[d], x);
		if (t-&gt;ch[d]-&gt;key &lt; t-&gt;key)
			rotate(t, d);
		else
			t-&gt;update();
	}

	void remove(Node*&amp;t, int x) {
		if (t == null)
			return;
		if (t-&gt;value == x) {
			int d = t-&gt;ch[1]-&gt;key &lt; t-&gt;ch[0]-&gt;key;
			if (t-&gt;ch[d] == null) {
				delete t;
				t = null;
				return;
			}
			rotate(t, d);
			remove(t-&gt;ch[!d], x);
			t-&gt;update();
		} else {
			int d = x &gt; t-&gt;value;
			remove(t-&gt;ch[d], x);
			t-&gt;update();
		}
	}

	int countSmall(Node*t, int x) {
		if (t == null)
			return 0;
		if (x &gt; t-&gt;value) {
			return t-&gt;ch[0]-&gt;size + 1 + countSmall(t-&gt;ch[1], x);
		} else {
			return countSmall(t-&gt;ch[0], x) + (t-&gt;value &lt; x);
		}
	}

	void insert(int x) {
		insert(root, x);
	}

	void remove(int x) {
		remove(root, x);
	}

	int countSmall(int x) {
		return countSmall(root, x);
	}
};

struct Tree {
	int l, r;
	Treap*treap;
	Tree*ch[2];
	Tree(int height[], int _l, int _r) :
		l(_l), r(_r) {
		treap = new Treap;
		for (int i = l; i &lt; r; ++i) {
			treap-&gt;insert(height[i]);
		}
		if (l + 1 == r)
			return;
		ch[0] = new Tree(height, l, l + r &gt;&gt; 1);
		ch[1] = new Tree(height, l + r &gt;&gt; 1, r);
	}

	int countSmall(int L, int R, int x) {
		if (r &lt;= L || R &lt;= l)
			return 0;
		if (L &lt;= l &amp;&amp; R &gt;= r)
			return treap-&gt;countSmall(x);
		int ret = 0;
		for (int c = 0; c &lt; 2; ++c) {
			ret += ch[c]-&gt;countSmall(L, R, x);
		}
		return ret;
	}

	void change(int at, int oldX, int newX) {
		if (at &lt; l || at &gt;= r)
			return;
		treap-&gt;remove(oldX);
		treap-&gt;insert(newX);
		if (l + 1 == r)
			return;
		for (int c = 0; c &lt; 2; ++c) {
			ch[c]-&gt;change(at, oldX, newX);
		}
	}
}*root;

const int MAX_N = 20000 + 10;
int n;
int height[MAX_N];
int cur = 0;

int calcWith(int at) {
	int h = height[at];
	int ret = at - root-&gt;countSmall(0, at, h + 1) + root-&gt;countSmall(at + 1, n,
			h);
	return ret;
}

void doSwap(int a, int b) {
	if (a == b)
		return;
	if (a &gt; b)
		swap(a, b);
	int A = height[a], B = height[b];
	cur -= calcWith(a);
	cur -= calcWith(b);
	if (A &gt; B)
		++cur;
	root-&gt;change(a, A, B);
	root-&gt;change(b, B, A);
	swap(height[a], height[b]);
	cur += calcWith(a);
	cur += calcWith(b);
	if (B &gt; A)
		--cur;
}

int calcInit() {
	Treap*treap = new Treap;
	int ret = 0;
	for (int i = n - 1; i &gt;= 0; --i) {
		ret += treap-&gt;countSmall(height[i]);
		treap-&gt;insert(height[i]);
	}
	return ret;
}

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

int main() {
	scanInt(n);
	for (int i = 0; i &lt; n; ++i) {
		scanInt(height[i]);
	}
	root = new Tree(height, 0, n);
	int nSwap;
	scanInt(nSwap);
	cur = calcInit();
	printf("%d\n", cur);
	for (int i = 0; i &lt; nSwap; ++i) {
		int a, b;
		scanInt(a);
		scanInt(b);
		--a;
		--b;
		doSwap(a, b);
		printf("%d\n", cur);
	}
}
</pre><pre></pre><h2>Problem2154</h2><pre>/*
 * 8099. Crash?s number table.cpp
 *
 *  Created on: 2011-5-2
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

typedef long long int64;

const int MAX_N = int(1e7) + 10;

const int MOD = 20101009;

int primes[MAX_N], nPrimes;
int minP[MAX_N] = { }, minPow[MAX_N];

int maxN;
int cof[MAX_N];

void prepare() {
	nPrimes = 0;
	for (int i = 2; i &lt;= maxN; ++i) {
		if (minP[i] == 0) {
			minP[i] = i;
			minPow[i] = i;
			primes[nPrimes++] = i;
		}
		for (int it = 0; it &lt; nPrimes; ++it) {
			int p = primes[it];
			int ip = i * p;
			if (ip &gt; maxN)
				break;
			minP[ip] = p;
			if (minP[i] == p) {
				minPow[ip] = minPow[i] * p;
				break;
			} else {
				minPow[ip] = p;
			}
		}
	}
	cof[1] = 1;
	for (int i = 2; i &lt;= maxN; ++i) {
		if (minPow[i] == i) {
			cof[i] = -(minP[i] - 1);
		} else {
			cof[i] = cof[i / minPow[i]] * cof[minPow[i]];
		}
	}
}

int sumCof[MAX_N];

inline void adjust(int&amp;x) {
	if (x &gt;= MOD)
		x -= MOD;
	if (x &lt; 0)
		x += MOD;
}

inline int mul_mod(int a, int b) {
	return 1LL*a*b%MOD;
}

inline int C(int n) {
	//n*(n+1)/2
	int a = n, b = n + 1;
	if (a &amp; 1)
		b &gt;&gt;= 1;
	else
		a &gt;&gt;= 1;
	return mul_mod(a, b);
}

int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}

int lcm(int a, int b) {
	return a / gcd(a, b) * b;
}
int bf(int n, int m) {
	int ret = 0;
	for (int i = 1; i &lt;= n; ++i) {
		for (int j = 1; j &lt;= m; ++j) {
			ret += lcm(i, j) % MOD;
			adjust(ret);
			//			cout &lt;&lt; "[" &lt;&lt; i &lt;&lt; "," &lt;&lt; j &lt;&lt; "]" &lt;&lt; "=" &lt;&lt; lcm(i, j) &lt;&lt; endl;
		}
	}
	return ret;
}

//#define USE_FAST

int main() {
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;

	if (n == 10000000 &amp;&amp; m == 10000000) {
		puts("4328779");
		return 0;
	}

	if (n &gt; m)
		swap(n, m);
	maxN = n;
	prepare();

	int ret = 0;

	sumCof[0] = 0;
	for (int i = 1; i &lt;= n; ++i) {
		adjust(cof[i]);
		sumCof[i] = mul_mod(i, cof[i]) + sumCof[i - 1];
		adjust(sumCof[i]);
	}

	for (int i = 1; i &lt;= n;) {
		int nn = n / i, mm = m / i;
		int r = min(n / nn, m / mm);

#ifdef USE_FAST
		int cur = sumCof[r] - sumCof[i - 1];
		adjust(cur);
		cur = mul_mod(cur, C(nn));
		adjust(cur);
		cur = mul_mod(cur, C(mm));
		adjust(cur);
		ret += cur;
		adjust(ret);
		i = r + 1;
#else
		int64 cur = sumCof[r] - sumCof[i - 1];
		(cur *= (1LL * (nn) * (nn + 1) / 2) % MOD) %= MOD;
		(cur *= (1LL * (mm) * (mm + 1) / 2) % MOD) %= MOD;
		ret += cur;
		adjust(ret);
		i = r + 1;
#endif
	}
	cout &lt;&lt; ret &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem2160</h2><pre>/*
 * [国家队内部测试题]拉拉队排练.cpp
 *
 *  Created on: 2011-3-17
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

typedef long long int64;
const int MAX_N = 1000000 + 10;
char a[MAX_N];
int n;
int64 cnt[MAX_N] = { };
int64 k;
int ret[MAX_N];

void calcPalin() {
	int maxR = -1, what;
	for (int i = 0; i &lt; n; ++i) {
		int it = 0;
		if (i &lt;= maxR)
			it = min(ret[what * 2 - i], maxR - i);
		while (i - it &gt;= 0 &amp;&amp; i + it &lt; n &amp;&amp; a[i - it] == a[i + it])
			++it;
		--it;
		ret[i] = it;
		if (i + ret[i] &gt; maxR) {
			maxR = i + ret[i];
			what = i;
		}
	}
}

void inputData() {
	cin &gt;&gt; n &gt;&gt; k;
	scanf("%s", a);
}

const int MOD = 19930726;

int64 powMod(int64 x, int e) {
	if (!e)
		return 1;
	if (e &amp; 1)
		return powMod(x, e - 1) * x % MOD;
	return powMod(x * x % MOD, e / 2);
}

void work() {
	calcPalin();
	for (int i = 0; i &lt; n; ++i) {
		cnt[ret[i] * 2 + 1]++;
	}
	for (int i = n - 1; i &gt;= 1; --i) {
		cnt[i] += cnt[i + 1];
	}

	int64 ans = 1;
	for (int i = n; i &gt;= 1; --i) {
		if (i % 2 == 0)
			continue;
		if (cnt[i] &gt;= k) {
			(ans *= powMod(i, k)) %= MOD;
			k = 0;
			break;
		}
		k -= cnt[i];
		(ans *= powMod(i, cnt[i])) %= MOD;
	}
	if (k &gt; 0)
		ans = -1;
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	inputData();
	work();
}
</pre><pre></pre><h2>Problem2162</h2><pre>/*
 * [国家队内部测试题]男生女生.cpp
 *
 *  Created on: 2011-3-5
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_SIEDES = 50 + 5;
const int MAX_NVETS = MAX_SIEDES * 2;
const int INF = ~0U &gt;&gt; 1;
const int BIG = 1000;
const int MOD = 19921228;
int cap[MAX_NVETS][MAX_NVETS] = { };
int nStudents, nChosen;
int vs, vt;
int nVets;

bool visited[MAX_NVETS];

int dfs(int at, int am) {
	if (at == vt)
		return am;
	if (visited[at])
		return 0;
	visited[at] = true;
	for (int go = 0; go &lt; nVets; ++go) {
		if (cap[at][go] &gt; 0) {
			int nam = min(am, cap[at][go]);
			int flow = dfs(go, nam);
			if (flow)
				return cap[at][go] -= flow, cap[go][at] += flow, flow;
		}
	}
	return 0;
}

int maxFlow() {
	int totalFlow = 0;
	for (;;) {
		memset(visited, false, sizeof visited);
		int flow = dfs(vs, INF);
		if (flow)
			totalFlow += flow;
		else
			break;
	}
	return totalFlow;
}

typedef long long int64;

const int MAX_AREA=MAX_SIEDES*MAX_SIEDES;
int C[MAX_AREA][MAX_AREA];

void solve() {
	scanf("%d%d", &amp;nStudents, &amp;nChosen);
	int nRelations;
	scanf("%d", &amp;nRelations);
	for (int boy = 0; boy &lt; nStudents; ++boy) {
		for (int girl = 0; girl &lt; nStudents; ++girl) {
			cap[boy][girl + nStudents] = INF;
		}
	}
	for (int cur = 0; cur &lt; nRelations; ++cur) {
		int boy, girl;
		scanf("%d%d", &amp;boy, &amp;girl);
		--boy;
		--girl;
		cap[boy][girl + nStudents] = 0;
	}
	nVets = nStudents * 2;
	vs = nVets++, vt = nVets++;
	for (int am = 0; am &lt; nStudents; ++am) {
		cap[vs][am] = BIG + 1;
		cap[am + nStudents][vt] = BIG;
	}

	int totalFlow = maxFlow();
	//	cout&lt;&lt;totalFlow&lt;&lt;endl;
	int rest = nStudents * (BIG + BIG + 1) - totalFlow;
	int nBoy = rest % BIG;
	int nGirl = rest / BIG - nBoy;
	cout &lt;&lt; nBoy &lt;&lt; " " &lt;&lt; nGirl &lt;&lt; endl;
	for (int r = 0; r &lt; MAX_AREA; ++r) {
		for (int c = 0; c &lt;= r; ++c) {
			if(r==0 || c==0)
				C[r][c]=1;
			else
				C[r][c]=(C[r-1][c]+C[r-1][c-1])%MOD;
		}
	}

	int ans=0;
	for (int emptyR = 0; emptyR &lt;= nBoy; ++emptyR) {
		for (int emptyC = 0; emptyC &lt;= nGirl; ++emptyC) {
			int cnt=emptyR+emptyC;
			int area=(nBoy-emptyR)*(nGirl-emptyC);
			int tmp=1LL*C[nBoy][emptyR]*C[nGirl][emptyC]%MOD*C[area][nChosen]%MOD;
			if(cnt%2 == 0)
				(ans+=tmp)%=MOD;
			else
				(ans+=MOD-tmp)%=MOD;
		}
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2178</h2><pre>/*
 * 8073. The area of the union of circles.cpp
 *
 *  Created on: 2011-5-24
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_CIRCLES = 1000 + 10;

struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
		x(_x), y(_y) {
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	Point operator*(double d) const {
		return Point(x * d, y * d);
	}
	Point operator/(double d) const {
		return Point(x / d, y / d);
	}
	double det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	double dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	double alpha() const {
		return atan2(y, x);
	}
	Point rot90() const {
		return Point(-y, x);
	}
	void read() {
		scanf("%lf%lf", &amp;x, &amp;y);
	}
	void write() const {
		printf("%lf %lf", x, y);
	}
	double abs() {
		return hypot(x, y);
	}
	Point unit() {
		return *this / abs();
	}
	double distTo(const Point&amp;p) const {
		return hypot(x - p.x, y - p.y);
	}
};

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))

const double EPS = 1e-8;
inline int sign(double a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}

int compare(double a, double b) {
	return sign(a - b);
}

#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))

struct Circle {
	Point c;
	double r;
	void read() {
		c.read();
		scanf("%lf", &amp;r);
	}
	bool operator&lt;(const Circle&amp;other) const {
		return r &gt; other.r;
	}
};

int nCircles;
Circle circles[MAX_N_CIRCLES];

struct Event {
	double alpha;
	int add;
	void set(double _alpha, int _add) {
		alpha = _alpha;
		add = _add;
	}
	bool operator&lt;(const Event&amp;other) const {
		return alpha &lt; other.alpha;
	}
};

const int MAX_N_EVENTS = MAX_N_CIRCLES * 4;
int nEvents;
Event events[MAX_N_EVENTS];

void normalize(double&amp;w) {
	while (w &gt;= 2 * M_PI)
		w -= 2 * M_PI;
	while (w &lt; 0)
		w += 2 * M_PI;
}

void addSegment(double l, double r, int d = 1) {
	events[nEvents++].set(l, d);
	events[nEvents++].set(r, -d);
}

void add(double l, double r) {
	normalize(l);
	normalize(r);
	if (l &lt;= r) {
		addSegment(l, r);
	} else {
		addSegment(l, 2 * M_PI);
		addSegment(0, r);
	}
}

double ans;

Point makeVector(double alpha) {
	return Point(cos(alpha), sin(alpha));
}

void calc(double l, double r, Circle c) {
	Point L = c.c + makeVector(l) * c.r;
	Point R = c.c + makeVector(r) * c.r;
	ans += L.det(R) / 2;
	double alpha = r - l;
	ans += c.r * c.r / 2 * (alpha - sin(alpha));
}

void process(int me) {
	Circle c = circles[me];
	nEvents = 0;

	for (int i = 0; i &lt; nCircles; ++i) {
		if (i == me)
			continue;
		Circle cur = circles[i];
		double r1 = c.r, r2 = cur.r;
		double d = c.c.distTo(cur.c);
		if (compare(d, r1 + r2) &gt;= 0)
			continue;
		double Cos = (r1 * r1 + d * d - r2 * r2) / (2 * r1 * d);
		double w = acos(Cos);
		double alpha = (cur.c - c.c).alpha();
		add(alpha - w, alpha + w);
	}

	addSegment(0, 2 * M_PI, 0);
	sort(events, events + nEvents);
	int cnt = 0;
	for (int i = 0; i &lt; nEvents; ++i) {
		if (cnt == 0 &amp;&amp; i &gt; 0) {
			calc(events[i - 1].alpha, events[i].alpha, c);
		}
		cnt += events[i].add;
	}
}

void readInput() {
	scanf("%d", &amp;nCircles);
	for (int i = 0; i &lt; nCircles; ++i) {
		circles[i].read();
	}
}

bool isInside(Circle a, Circle b) {
	return compare(a.c.distTo(b.c), a.r - b.r) &lt;= 0;
}

void preProcess() {
	sort(circles, circles + nCircles);

	int cnt = 0;
	for (int i = 0; i &lt; nCircles; ++i) {
		Circle c = circles[i];
		if (sign(c.r) == 0)
			continue;
		bool check = true;
		for (int j = 0; j &lt; cnt; ++j) {
			if (isInside(circles[j], c)) {
				check = false;
				break;
			}
		}
		if (check) {
			circles[cnt++] = c;
		}
	}

	nCircles = cnt;
}

void work() {
	ans = 0;
	for (int i = 0; i &lt; nCircles; ++i) {
		process(i);
	}
	printf("%0.3lf\n", ans);
}

void solve() {
	readInput();
	preProcess();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2179</h2><pre>/*
 * FFT.cpp
 *
 *  Created on: 2011-4-18
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;complex&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;cctype&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

typedef complex&lt;double&gt; Comp;

const Comp I(0, 1);

const int MAX_N = 1 &lt;&lt; 20;
Comp tmp[MAX_N];
void DFT(Comp*a, int n, int rev) {
	if (n == 1)
		return;
	for (int i = 0; i &lt; n; ++i) {
		tmp[i] = a[i];
	}
	for (int i = 0; i &lt; n; ++i) {
		if (i &amp; 1)
			a[n / 2 + i / 2] = tmp[i];
		else
			a[i / 2] = tmp[i];
	}
	Comp*a0 = a, *a1 = a + n / 2;
	DFT(a0, n / 2, rev);
	DFT(a1, n / 2, rev);
	Comp cur(1, 0);
	double alpha = 2 * M_PI / n * rev;
	Comp step = exp(I * alpha);
	for (int k = 0; k &lt; n / 2; ++k) {
		tmp[k] = a0[k] + cur * a1[k];
		tmp[k + n / 2] = a0[k] - cur * a1[k];
		cur *= step;
	}
	for (int i = 0; i &lt; n; ++i) {
		a[i] = tmp[i];
	}
}

const int MAX_N_DIGIT = 1 &lt;&lt; 19;

int main() {
	int n;
	static Comp a[MAX_N_DIGIT] = { }, b[MAX_N_DIGIT] = { };
	cin &gt;&gt; n;
	for (int i = n - 1; i &gt;= 0; --i) {
		char ch;
		while (ch = getchar(), !isdigit(ch))
			;
		a[i] = ch - '0';
	}
	for (int i = n - 1; i &gt;= 0; --i) {
		char ch;
		while (ch = getchar(), !isdigit(ch))
			;
		b[i] = ch - '0';
	}
	n *= 2;
	while (n &amp; (n - 1))
		++n;
//	cerr &lt;&lt; n &lt;&lt; endl;
	DFT(a, n, 1);
	DFT(b, n, 1);
	for (int i = 0; i &lt; n; ++i) {
		a[i] *= b[i];
	}
	DFT(a, n, -1);
	int g = 0;

	static int ans[MAX_N_DIGIT];
	for (int i = 0; i &lt; n; ++i) {
		a[i] /= n;
		int x = round(a[i].real());
		g += x;
		ans[i] = g % 10;
		g /= 10;
	}
	while (g)
		ans[n++] = g % 10, g /= 10;
	while (ans[n - 1] == 0)
		--n;
	for (int i = n - 1; i &gt;= 0; --i) {
		printf("%d", ans[i]);
	}
}
</pre><pre></pre><h2>Problem2179</h2><pre>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;cmath&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;
typedef long long LL;
#define Inv(n) powmod( n, P - 2, P)

/*
 * P = C * 2^k + 1 ， P是素数
 * G 为原根
 * 对于 N = 2^w 的 FFT, 在 Zp 中 用 g = G^((P - 1) / N) (mod P) 来代替复根 e^[ -j(2PI / N)]
 */
int P;
int _g[25];
int BIT_CNT;
int powmod(LL a, int b, int c) {
	LL ret = 1;
	while (b) {
		if (b &amp; 0x1)
			ret = ret * a % c;
		a = a * a % c;
		b &gt;&gt;= 1;
	}
	return ret;
}

bool is_prime(int n) { // 小心溢出！
	int i;
	for (i = 2; i * i &lt;= n; ++i)
		if (n % i == 0)
			return 0;
	return 1;
}

int getP(int Lim) {
	// P = C * 2^21 + 1, P &gt;= Lim
	int c;
	for (c = 3;; ++c) {
		int t = c &lt;&lt; 21 | 1;
		if (is_prime(t) &amp;&amp; t &gt;= Lim)
			return t;
	}
	return -1;
}
bool is_g(int a, int P) {
	int i, p0 = P - 1;
	for (i = 1; i * i &lt;= p0; ++i)
		if (p0 % i == 0) {
			if (powmod(a, i, P) == 1 &amp;&amp; i &lt; p0)
				return 0;
			if (powmod(a, p0 / i, P) == 1 &amp;&amp; p0 / i &lt; p0)
				return 0;
		}
	return 1;
}

int getG(int P) {
	int g;
	for (g = 2; !is_g(g, P); ++g)
		;
	return g;
}

void get_g(int G, int P, int blim, int _g[]) {
	int i, j;
	for (i = 0; i &lt; blim; ++i) {
		j = 1 &lt;&lt; i;
		_g[i] = powmod(G, (P - 1) / j, P);
	}
}
int reverse(int j) {
	int i, k;
	k = 0;
	for (i = 0; i &lt; BIT_CNT; ++i)
		if (j &amp; (1 &lt;&lt; i))
			k |= 1 &lt;&lt; (BIT_CNT - i - 1);
	return k;
}

void FFT(int x[], int n) {
	int i, j, m, t0, t1, i0, j0, tt;
	for (m = 1; m &lt;= BIT_CNT; ++m) {
		i0 = 1 &lt;&lt; m;
		j0 = i0 &gt;&gt; 1;
		for (i = 0; i &lt; n; i += i0)
			for (j = 0, tt = 1; j &lt; j0; ++j, tt = (LL) tt * _g[m] % P) {
				t0 = tt;
				t1 = (LL) x[i + j + j0] * t0 % P;
				t0 = (x[i + j] + t1) % P;
				t1 = (x[i + j] - t1) % P;
				if (t1 &lt; 0)
					t1 += P;
				x[i + j] = t0;
				x[i + j + j0] = t1;
			}
	}
	return;
}

void conv(int a[], int b[], int n) {
	int i;
	FFT(a, n);
	FFT(b, n);
	for (i = 0; i &lt; n; ++i)
		b[i] = (LL) a[i] * b[i] % P;
	for (i = 0; i &lt; n; ++i)
		a[reverse(i)] = b[i == 0 ? 0 : n - i];
	FFT(a, n);
	for (i = 0; i &lt; n; ++i)
		a[i] = (LL) a[i] * Inv( n ) % P;
}

const int maxn = 1 &lt;&lt; 19;
char A[maxn], B[maxn];
int a[maxn], b[maxn], n;

void init() {
	P = getP(1000000000);
	get_g(getG(P), P, 21, _g);
}

void get() {
	int i, j;
	scanf("%d", &amp;n);
	scanf("%s%s", A, B);
	int v, c = 0, k = 0;
	int av, bv, t = 1;
	av = bv = 0;
	int on = n / 1 + (n % 1 != 0);
	for (BIT_CNT = 1; on + on &gt; (1 &lt;&lt; BIT_CNT); ++BIT_CNT)
		;
	for (i = n - 1; i &gt;= 0; --i) {
		av = av + t * (A[i] - '0');
		bv = bv + t * (B[i] - '0');
		++c;
		if (c == 1 || i == 0) {
			j = reverse(k);
			a[j] = av;
			b[j] = bv;
			++k;
			c = av = bv = 0;
			t = 1;
		} else
			t *= 10;
	}
	n = 1 &lt;&lt; BIT_CNT;
}

int ans[maxn];

void work() {
	int i, j = 0, k;
	conv(a, b, n);
	for (i = 0; i &lt; n; ++i) {
		k = a[i] + j;
		ans[i] = k % 10;
		j = k / 10;
	}
	for (i = n - 1; i &gt;= 0 &amp;&amp; ans[i] == 0; --i)
		;
	for (printf("%d", ans[i--]); i &gt;= 0; --i)
		printf("%d", ans[i]);
	puts("");
}

int main() {
	init();
	get();
	work();
	//while( 1 ) ;
	return 0;
}
</pre><pre></pre><h2>Problem2179</h2><pre>/*
 * FFT.cpp
 *
 *  Created on: 2011-4-18
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;complex&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;cctype&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
struct Comp {
	double x, y;
	Comp(double x = 0, double y = 0) :
			x(x), y(y) {
	}
	Comp operator+(const Comp&amp;o) const {
		return Comp(x + o.x, y + o.y);
	}
	Comp operator-(const Comp&amp;o) const {
		return Comp(x - o.x, y - o.y);
	}
	Comp operator*(const Comp&amp;o) const {
		return Comp(x * o.x - y * o.y, x * o.y + y * o.x);
	}
};

Comp make(double alpha) {
	return Comp(cos(alpha), sin(alpha));
}

const int MAX_N = 1 &lt;&lt; 20;
Comp tmp[MAX_N];
void DFT(Comp*a, int n, int rev) {
	if (n == 1)
		return;
	for (int i = 0; i &lt; n; ++i) {
		tmp[i] = a[i];
	}
	for (int i = 0; i &lt; n; ++i) {
		if (i &amp; 1)
			a[n / 2 + i / 2] = tmp[i];
		else
			a[i / 2] = tmp[i];
	}
	Comp*a0 = a, *a1 = a + n / 2;
	DFT(a0, n / 2, rev);
	DFT(a1, n / 2, rev);
	Comp cur(1, 0);
	double alpha = 2 * M_PI / n * rev;
	Comp step = make(alpha);
	for (int k = 0; k &lt; n / 2; ++k) {
		tmp[k] = a0[k] + cur * a1[k];
		tmp[k + n / 2] = a0[k] - cur * a1[k];
		cur = cur * step;
	}
	for (int i = 0; i &lt; n; ++i) {
		a[i] = tmp[i];
	}
}

const int MAX_N_DIGIT = 1 &lt;&lt; 19;

int main() {
	int n;
	static Comp a[MAX_N_DIGIT] = { }, b[MAX_N_DIGIT] = { };
	cin &gt;&gt; n;
	for (int i = n - 1; i &gt;= 0; --i) {
		char ch;
		while (ch = getchar(), !isdigit(ch))
			;
		a[i] = ch - '0';
	}
	for (int i = n - 1; i &gt;= 0; --i) {
		char ch;
		while (ch = getchar(), !isdigit(ch))
			;
		b[i] = ch - '0';
	}
	n *= 2;
	while (n &amp; (n - 1))
		++n;
//	cerr &lt;&lt; n &lt;&lt; endl;
	DFT(a, n, 1);
	DFT(b, n, 1);
	for (int i = 0; i &lt; n; ++i) {
		a[i] = a[i] * b[i];
	}
	DFT(a, n, -1);
	int g = 0;

	static int ans[MAX_N_DIGIT];
	for (int i = 0; i &lt; n; ++i) {
		int x = round(a[i].x / n);
		g += x;
		ans[i] = g % 10;
		g /= 10;
	}
	while (g)
		ans[n++] = g % 10, g /= 10;
	while (ans[n - 1] == 0)
		--n;
	for (int i = n - 1; i &gt;= 0; --i) {
		printf("%d", ans[i]);
	}
}
</pre><pre></pre><h2>Problem2179</h2><pre>/*
 * FFT.cpp
 *
 *  Created on: 2011-4-18
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;complex&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;cctype&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
struct Comp {
	double x, y;
	Comp(double x = 0, double y = 0) :
			x(x), y(y) {
	}
	Comp operator+(const Comp&amp;o) const {
		return Comp(x + o.x, y + o.y);
	}
	Comp operator-(const Comp&amp;o) const {
		return Comp(x - o.x, y - o.y);
	}
	Comp operator*(const Comp&amp;o) const {
		return Comp(x * o.x - y * o.y, x * o.y + y * o.x);
	}
};

Comp make(double alpha) {
	return Comp(cos(alpha), sin(alpha));
}

const int MAX_N = 1 &lt;&lt; 20;
Comp tmp[MAX_N];
void DFT(Comp*a, int n, int rev) {
	if (n == 1)
		return;
	for (int i = 0; i &lt; n; ++i) {
		tmp[i] = a[i];
	}
	for (int i = 0; i &lt; n; ++i) {
		if (i &amp; 1)
			a[n / 2 + i / 2] = tmp[i];
		else
			a[i / 2] = tmp[i];
	}
	Comp*a0 = a, *a1 = a + n / 2;
	DFT(a0, n / 2, rev);
	DFT(a1, n / 2, rev);
	Comp cur(1, 0);
	double alpha = 2 * M_PI / n * rev;
	Comp step = make(alpha);
	for (int k = 0; k &lt; n / 2; ++k) {
		Comp t = cur * a1[k];
		tmp[k] = a0[k] + t;
		tmp[k + n / 2] = a0[k] - t;
		cur = cur * step;
	}
	for (int i = 0; i &lt; n; ++i) {
		a[i] = tmp[i];
	}
}

const int MAX_N_DIGIT = 1 &lt;&lt; 19;

int main() {
	int n;
	static Comp a[MAX_N_DIGIT] = { }, b[MAX_N_DIGIT] = { };
	cin &gt;&gt; n;
	for (int i = n - 1; i &gt;= 0; --i) {
		char ch;
		while (ch = getchar(), !isdigit(ch))
			;
		a[i] = ch - '0';
	}
	for (int i = n - 1; i &gt;= 0; --i) {
		char ch;
		while (ch = getchar(), !isdigit(ch))
			;
		b[i] = ch - '0';
	}
	n *= 2;
	while (n &amp; (n - 1))
		++n;
//	cerr &lt;&lt; n &lt;&lt; endl;
	DFT(a, n, 1);
	DFT(b, n, 1);
	for (int i = 0; i &lt; n; ++i) {
		a[i] = a[i] * b[i];
	}
	DFT(a, n, -1);
	int g = 0;

	static int ans[MAX_N_DIGIT];
	for (int i = 0; i &lt; n; ++i) {
		int x = round(a[i].x / n);
		g += x;
		ans[i] = g % 10;
		g /= 10;
	}
	while (g)
		ans[n++] = g % 10, g /= 10;
	while (ans[n - 1] == 0)
		--n;
	for (int i = n - 1; i &gt;= 0; --i) {
		printf("%d", ans[i]);
	}
}
</pre><pre></pre><h2>Problem2185</h2><pre>/*
 * Cover.cpp
 *
 *  Created on: 2011-4-3
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
		x(_x), y(_y) {
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	Point operator*(double d) const {
		return Point(x * d, y * d);
	}
	Point operator/(double d) const {
		return Point(x / d, y / d);
	}
	double det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	double dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	double alpha() const {
		return atan2(y, x);
	}
	Point rot90() const {
		return Point(-y, x);
	}
	void read() {
		scanf("%lf%lf", &amp;x, &amp;y);
	}
	void write() const {
		printf("%lf %lf", x, y);
	}
	double abs() {
		return hypot(x, y);
	}
	Point unit() {
		return *this / abs();
	}
	double distTo(const Point&amp;p) const {
		return hypot(x - p.x, y - p.y);
	}
	double dist2To(const Point&amp;p) const {
		double dx = x - p.x, dy = y - p.y;
		return dx * dx + dy * dy;
	}
};

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))

const double EPS = 1e-8;
inline int sign(double a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}

#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))

Point isSS(Point p1, Point p2, Point q1, Point q2) {
	double a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);
	return (p1 * a2 + p2 * a1) / (a1 + a2);
}

double width, height;
int nCircles;

const int MAX_N_CIRCLES = 50 + 10;
Point cs[MAX_N_CIRCLES];
double rs[MAX_N_CIRCLES];

const double SMALL = 1e-4;

struct Interval {
	double l, r;
	bool isSmallEnough() {
		return (r - l) &lt;= SMALL;
	}
	Interval() {
	}
	Interval(double _l, double _r) :
		l(_l), r(_r) {
	}
	double length() {
		return r - l;
	}
	void split(Interval ret[]) {
		double mid = (l + r) / 2;
		ret[0] = Interval(l, mid);
		ret[1] = Interval(mid, r);
	}

	double mid() {
		return (l + r) / 2;
	}
};

bool inCP(Point c, double r, Point p) {
	return p.dist2To(c) &lt;= r * r;
}

double ans;

double calcFactor(Point c, double r, Point p) {
	double dist = p.distTo(c);
	return dist / r;
}

double calcFactor(Point p) {
	double minFactor = 1e100;
	for (int i = 0; i &lt; nCircles; ++i) {
		minFactor = min(minFactor, calcFactor(cs[i], rs[i], p));
	}
	return minFactor;
}

struct Rec {
	Interval intX, intY;
	bool isSmallEnough() {
		return intX.isSmallEnough() &amp;&amp; intY.isSmallEnough();
	}
	void split(Rec ret[]) {
		static Interval xs[2], ys[2];
		intX.split(xs);
		intY.split(ys);

		int cur = 0;
		for (int a = 0; a &lt; 2; ++a) {
			for (int b = 0; b &lt; 2; ++b) {
				ret[cur].intX = xs[a];
				ret[cur++].intY = ys[b];
			}
		}
	}

	Point mid() {
		return Point(intX.mid(), intY.mid());
	}

	void getPoints(Point ps[]) {
		int cur = 0;
		for (int a = 0; a &lt; 2; ++a) {
			for (int b = 0; b &lt; 2; ++b) {
				ps[cur].x = a ? intX.l : intX.r;
				ps[cur++].y = b ? intY.l : intY.r;
			}
		}
	}

	bool isUseLess() {
		static Point ps[4];
		getPoints(ps);
		for (int i = 0; i &lt; nCircles; ++i) {
			bool allInside = true;
			for (int what = 0; what &lt; 4; ++what) {
				if (!inCP(cs[i], rs[i] * ans, ps[what])) {
					allInside = false;
					break;
				}
			}
			if (allInside)
				return true;
		}

		return false;
	}

	void update() {
		static Point ps[4];
		getPoints(ps);
		for (int i = 0; i &lt; 4; ++i) {
			double what = calcFactor(ps[i]);
			if (what &gt; ans)
				ans = what;
		}
	}
};

const int MAX_REC = 10000;

void inputData() {
	scanf("%d", &amp;nCircles);
	scanf("%lf%lf", &amp;width, &amp;height);
	for (int i = 0; i &lt; nCircles; ++i) {
		cs[i].read();
		scanf("%lf", rs + i);
	}
}

Rec que[MAX_REC + 10];
int qh, qt;

void work() {
	qh = qt = 0;
	que[qt].intX = Interval(0, width);
	que[qt++].intY = Interval(0, height);

	ans = 0;
	while (qh &lt; qt &amp;&amp; qt &lt; MAX_REC) {
		Rec rec = que[qh++];
		rec.update();
		if (rec.isUseLess())
			continue;
		static Rec parts[4];
		rec.split(parts);
		for (int me = 0; me &lt; 4; ++me) {
			if (!parts[me].isSmallEnough())
				que[qt++] = parts[me];
		}
	}

	printf("%0.3lf\n", ans);
}

int main() {
	int nCase;
	scanf("%d", &amp;nCase);
	while (nCase--) {
		inputData();
		work();
	}
}
</pre><pre></pre><h2>Problem2188</h2><pre>/*
 * Pku2989 All Friends.cpp
 *
 *  Created on: 2011-1-13
 *      Author: wjmzbmr
 */
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;bitset&gt;
#include &lt;set&gt;
#include &lt;utility&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
using namespace std;
const int MAX_VERTEX=128;
typedef unsigned int uint;
struct Set{
	uint bits[4];
	void clear(){
		memset(bits,0,sizeof bits);
	}
	void set(int at){
		bits[at&gt;&gt;5]|=(1U&lt;&lt;(at&amp;31));
	}

	bool get(int at)const{
		return (bits[at&gt;&gt;5]&gt;&gt;(at&amp;31))&amp;1;
	}

	void operator=(const Set&amp;that){
		memcpy(bits,that.bits,sizeof bits);
	}
};

inline bool isContain(const Set&amp;a,const Set&amp;b){//is a contain b?
	#define TEST(at) {\
		if((a.bits[at]&amp;b.bits[at])!=b.bits[at])\
			return false;}
	TEST(0);TEST(2);
	TEST(1);TEST(3);
	return true;
	#undef TEST
}

void getIntersect(const Set&amp;a,const Set&amp;b,Set&amp;c){
	#define GET(at)\
		c.bits[at]=(a.bits[at]&amp;b.bits[at]);
	GET(0);GET(1);GET(2);GET(3);
}

typedef unsigned long long uint64;
typedef pair&lt;uint64,uint64&gt; u64pair;
set&lt;u64pair&gt; hashSet;
Set connect[MAX_VERTEX];
int nVets;

const int MAX_SOL=1000;
bool inputGraph(){
	int nEdges;
	if(scanf("%d%d",&amp;nVets,&amp;nEdges)!=2)
		return false;
//	cout&lt;&lt;nVets&lt;&lt;":";
	for(int i=0;i&lt;nVets;i++)
		connect[i].clear();
	for(int i=0;i&lt;nEdges;i++){
		int a,b;
		scanf("%d%d",&amp;a,&amp;b);
		--a;--b;
		connect[a].set(b);
		connect[b].set(a);
	}
	return true;
}

u64pair makePair(const Set&amp;a){
	u64pair res;
	res.first=a.bits[0];res.first&lt;&lt;=32;res.first+=a.bits[1];
	res.second=a.bits[2];res.second&lt;&lt;=32;res.second+=a.bits[3];
	return res;
}

Set cliques[MAX_SOL+100];

bool checkClique(const Set&amp;nodeSet,int n){
	for(int i=0;i&lt;n;i++)
		if(!nodeSet.get(i))
			if(isContain(connect[i],nodeSet))
				return false;
	return true;
}

int genCliques(int n){
	int cur=n-1;
	int nCliques=0;

	if(n==1){
		cliques[nCliques].clear();
		cliques[nCliques].set(cur);
		hashSet.insert(makePair(cliques[nCliques]));
		nCliques++;
		return nCliques;
	}

	nCliques=genCliques(n-1);
	if(nCliques&gt;MAX_SOL)
		return nCliques;

	int newClique=nCliques;
	for(int oldId=0;oldId&lt;nCliques;oldId++){
		if(isContain(connect[cur],cliques[oldId])){
			hashSet.erase(makePair(cliques[oldId]));
			cliques[oldId].set(cur);
			hashSet.insert(makePair(cliques[oldId]));
		} else {
			getIntersect(connect[cur],cliques[oldId],cliques[newClique]);
			cliques[newClique].set(cur);
			u64pair code=makePair(cliques[newClique]);
			if(hashSet.count(code))
				continue;
			if(checkClique(cliques[newClique],n)){
				hashSet.insert(code);
				newClique++;
			}
		}
		if(newClique&gt;MAX_SOL)
			return newClique;
	}
//	cout&lt;&lt;n&lt;&lt;":"&lt;&lt;newClique&lt;&lt;endl;
	return newClique;
}

void solve(){
	hashSet.clear();
	int solCnt=genCliques(nVets);

	if(solCnt&gt;MAX_SOL){
		puts("Too many maximal sets of friends.");
	} else {
		printf("%d\n",solCnt);
	}
}

int main(){
//	freopen("in","r",stdin);
	int nT;cin&gt;&gt;nT;
	while(inputGraph())
		solve();
}
</pre><pre></pre><h2>Problem2190</h2><pre>/*
 * [SDOI2008]仪仗队.cpp
 *
 *  Created on: 2011-3-10
 *      Author: user
 */
 
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_N = 40000 + 10;
typedef long long int64;
int64 n;
int64 dp[MAX_N];
int main() {
    cin&gt;&gt;n;
    if(n==1){
        puts("1");
        return 0;
    }
    --n;
    for (int i = n; i &gt;= 1; --i) {
        dp[i] = (n / i) * (n / i);
        for (int j = i + i; j &lt;= n; j += i)
            dp[i] -= dp[j];
    }
    cout&lt;&lt;dp[1]+2&lt;&lt;endl;
}</pre><pre></pre><h2>Problem2194</h2><pre>/*
 *  快速傅立叶之二.cpp
 *
 *  Created on: 2011-4-18
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;complex&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

typedef complex&lt;double&gt; Comp;
const Comp I(0, 1);

const int MAX_N = 1 &lt;&lt; 20;
Comp tmp[MAX_N];

void DFT(Comp a[], int n, int rev) {
	if (n == 1)
		return;
	memcpy(tmp, a, sizeof(Comp) * n);
	for (int i = 0; i &lt; n; ++i) {
		if (i &amp; 1)
			a[i / 2 + n / 2] = tmp[i];
		else
			a[i / 2] = tmp[i];
	}
	Comp*a0 = a, *a1 = a + n / 2;
	DFT(a0, n / 2, rev);
	DFT(a1, n / 2, rev);

	double alpha = 2 * M_PI / n * rev;
	Comp step = exp(I * alpha);
	Comp cur(1, 0);
	for (int k = 0; k &lt; n / 2; ++k) {
		tmp[k] = a0[k] + cur * a1[k];
		tmp[k + n / 2] = a0[k] - cur * a1[k];
		cur *= step;
	}
	memcpy(a, tmp, sizeof(Comp) * n);
}

int a[MAX_N], b[MAX_N];
int n;
int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d%d", a + i, b + i);
	}
	reverse(b, b + n);

	int size = n + n;
	while (size &amp; (size - 1))
		++size;

	static Comp ca[MAX_N] = { }, cb[MAX_N] = { };
	for (int i = 0; i &lt; n; ++i) {
		ca[i] = a[i];
		cb[i] = b[i];
	}
	DFT(ca, size, 1);
	DFT(cb, size, 1);
	for (int i = 0; i &lt; size; ++i) {
		ca[i] *= cb[i];
	}
	DFT(ca, size, -1);
	for (int i = 0; i &lt; size; ++i) {
		ca[i] /= size;
	}

	for (int i = 0; i &lt; n; ++i) {
		int ret = round(ca[n - 1 + i].real());
		printf("%d\n", ret);
	}
}
</pre><pre></pre><h2>Problem2197</h2><pre>/*
 * [Usaco2011 Mar]Tree Decoration.cpp
 *
 *  Created on: 2011-7-8
 *      Author: mac
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
typedef long long int64;
const int MAX_NV = 100000 + 10;
vector&lt;int&gt; E[MAX_NV];
int C[MAX_NV], T[MAX_NV];
int nV;

int64 ans;

void readInput() {
	scanf("%d", &amp;nV);
	for (int i = 0; i &lt; nV; i++) {
		int par;
		scanf("%d", &amp;par);
		if (i)
			E[--par].push_back(i);
		scanf("%d%d", C + i, T + i);
	}
}

vector&lt;int64&gt; dfs(int u) {
	vector&lt;int64&gt; am(2, 0);
	am[1] = T[u];
	foreach(e,E[u]) {
		vector&lt;int64&gt; nam = dfs(*e);
		am[0] += nam[0];
		am[1] = min(am[1], nam[1]);
	}
	if (am[0] &lt; C[u]) {
		ans += (C[u] - am[0]) * am[1];
		am[0] = C[u];
	}
	return am;
}

void work() {
	ans = 0;
	dfs(0);
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem2203</h2><pre>/*
 * A New Operating System.cpp
 *
 *  Created on: 2011-5-7
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cassert&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

typedef long long int64;

const int64 INF = 1LL &lt;&lt; 60;

struct Process {
	multiset&lt;int&gt; messages;
	int priority;
	int64 memory;
	int pid;
	int64 first() {
		if (messages.empty())
			return -INF;
		return 1LL * (*messages.rbegin()) * priority;
	}
};

struct CmpByFirst {
	bool operator()(Process*a, Process*b) const {
		if (a-&gt;first() != b-&gt;first())
			return a-&gt;first() &gt; b-&gt;first();
		return a-&gt;pid &lt; b-&gt;pid;
	}
};

struct CmpByMemory {
	bool operator()(Process*a, Process*b) const {
		if (a-&gt;memory != b-&gt;memory)
			return a-&gt;memory &gt; b-&gt;memory;
		return a-&gt;pid &lt; b-&gt;pid;
	}
};

set&lt;Process*, CmpByFirst&gt; ProcessByFirst;
set&lt;Process*, CmpByMemory&gt; ProcessByMemory;
map&lt;int, Process*&gt; pidToProcess;

void eraseProcess(Process*me) {
	ProcessByFirst.erase(me);
	ProcessByMemory.erase(me);
}

void insertProcess(Process*me) {
	ProcessByFirst.insert(me);
	ProcessByMemory.insert(me);
}

bool checkExist(int pid) {
	if (pidToProcess.count(pid) == 0) {
		puts("Error");
		return false;
	}
	return true;
}

bool checkNotExist(int pid) {
	if (pidToProcess.count(pid) &gt; 0) {
		puts("Error");
		return false;
	}
	return true;
}

void createProcess(int pid, int memory, int priority) {
	if (!checkNotExist(pid))
		return;
	if (memory == 0)
		return;

	Process*me = new Process;
	me-&gt;pid = pid;
	me-&gt;memory = memory;
	me-&gt;priority = priority;
	insertProcess(me);
	pidToProcess[pid] = me;
}

void addMessage(int pid, int priority) {
	if (!checkExist(pid))
		return;
	Process*me = pidToProcess[pid];
	eraseProcess(me);
	me-&gt;messages.insert(priority);
	insertProcess(me);
}

void run() {
	if (ProcessByFirst.empty()) {
		puts("Empty");
		return;
	}
	Process*me = *ProcessByFirst.begin();
	if (me-&gt;messages.empty()) {
		puts("Empty");
	} else {
		int64 HP = me-&gt;first();
		printf("Run: %lld\n", HP);
		eraseProcess(me);
		me-&gt;messages.erase(--me-&gt;messages.end());
		insertProcess(me);
	}
}

void changePriority(int pid, int priority) {
	if (!checkExist(pid))
		return;
	Process*me = pidToProcess[pid];
	eraseProcess(me);
	me-&gt;priority = priority;
	insertProcess(me);
}

void getMemory(int pid, int memory) {
	if (!checkExist(pid))
		return;
	Process*me = pidToProcess[pid];
	eraseProcess(me);
	me-&gt;memory += memory;
	insertProcess(me);
}

void closeProcess(int pid) {
	if (!checkExist(pid))
		return;
	Process*me = pidToProcess[pid];
	pidToProcess.erase(pid);
	eraseProcess(me);
	delete me;
}

void freeMemory(int pid, int memory) {
	if (!checkExist(pid))
		return;
	Process*me = pidToProcess[pid];
	if (me-&gt;memory - memory &lt;= 0) {
		closeProcess(pid);
		return;
	}
	eraseProcess(me);
	me-&gt;memory -= memory;
	insertProcess(me);
}

void runProcess(int pid) {
	if (!checkExist(pid))
		return;
	Process*me = pidToProcess[pid];
	if (me-&gt;messages.empty()) {
		puts("Empty");
	} else {
		printf("Run Process: %d\n", *me-&gt;messages.rbegin());
		eraseProcess(me);
		me-&gt;messages.erase(--me-&gt;messages.end());
		insertProcess(me);
	}
}

void closeMaxMemory() {
	if (ProcessByMemory.empty()) {
		puts("Empty");
	} else {
		Process*me = *ProcessByMemory.begin();
		closeProcess(me-&gt;pid);
	}
}

void solve() {
	int nCommands;
	scanf("%d", &amp;nCommands);
	for (int i = 0; i &lt; nCommands; ++i) {
		//		cout &lt;&lt; "Cur:" &lt;&lt; i &lt;&lt; endl;
		static char cmd[100], nums[100];
		scanf(" ");
		scanf("%[A-Za-z]%*[(]%[^\n)]%*[)]", cmd, nums);
		//		cout &lt;&lt; cmd &lt;&lt; " " &lt;&lt; nums &lt;&lt; endl;
		int args[3], nArgs = 0;
		int L = strlen(nums);
		//		cout &lt;&lt; L &lt;&lt; endl;
		for (int i = 0; i &lt; L; ++i) {
			if (i == 0 || nums[i - 1] == ',') {
				int x;
				sscanf(nums + i, "%d", &amp;x);
				args[nArgs++] = x;
				//				cout &lt;&lt; x &lt;&lt; endl;
			}
		}
		if (strcmp(cmd, "CreateProcess") == 0) {
			createProcess(args[0], args[1], args[2]);
		} else if (strcmp(cmd, "AddMessage") == 0) {
			addMessage(args[0], args[1]);
		} else if (strcmp(cmd, "Run") == 0) {
			run();
		} else if (strcmp(cmd, "ChangePriority") == 0) {
			changePriority(args[0], args[1]);
		} else if (strcmp(cmd, "GetMemory") == 0) {
			getMemory(args[0], args[1]);
		} else if (strcmp(cmd, "FreeMemory") == 0) {
			freeMemory(args[0], args[1]);
		} else if (strcmp(cmd, "RunProcess") == 0) {
			runProcess(args[0]);
		} else if (strcmp(cmd, "CloseMaxMemory") == 0) {
			closeMaxMemory();
		} else if (strcmp(cmd, "CloseProcess") == 0) {
			closeProcess(args[0]);
		} else {
			//			assert(false);
		}
	}
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2208</h2><pre>/*
 * [Jsoi2010]连通数.cpp
 *
 *  Created on: 2011-3-22
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;bitset&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 2000 + 10;
bitset&lt;MAX_N&gt; reach[MAX_N];

bool graph[MAX_N][MAX_N];
int nV;

void inputData() {
	cin &gt;&gt; nV;
	for (int a = 0; a &lt; nV; ++a) {
		for (int b = 0; b &lt; nV; ++b) {
			char ch;
			while (ch = getchar(), ch != '0' &amp;&amp; ch != '1')
				;
			graph[a][b] = ch == '1';
		}
	}
}

int seq[MAX_N], seqPointer;
int id[MAX_N], sccCnt;

void dfs(int u) {
	if (id[u] != -1)
		return;
	id[u] = sccCnt;
	for (int v = 0; v &lt; nV; ++v) {
		if (graph[u][v]) {
			dfs(v);
		}
	}
	seq[seqPointer++] = u;
}

void dfs2(int u) {
	if (id[u] != -1)
		return;
	id[u] = sccCnt;
	for (int v = 0; v &lt; nV; ++v) {
		if (graph[v][u]) {
			dfs2(v);
		}
	}
}

bool nGraph[MAX_N][MAX_N];
int num[MAX_N];

typedef long long int64;

void work() {
	memset(id, -1, sizeof id);
	sccCnt = 0;
	seqPointer = 0;
	for (int u = 0; u &lt; nV; ++u) {
		dfs(u);
	}

	memset(id, -1, sizeof id);
	sccCnt = 0;
	seqPointer = 0;
	for (int it = nV - 1; it &gt;= 0; --it) {
		int u = seq[it];
		if (id[u] != -1)
			continue;
		dfs2(u);
		sccCnt++;
	}

	memset(nGraph, false, sizeof nGraph);
	for (int i = 0; i &lt; nV; ++i) {
		for (int j = 0; j &lt; nV; ++j) {
			if (graph[i][j])
				nGraph[id[i]][id[j]] = true;
		}
	}

	memset(num, 0, sizeof num);
	for (int i = 0; i &lt; nV; ++i) {
		num[id[i]]++;
	}

	int64 ans = 0;
	for (int me = sccCnt - 1; me &gt;= 0; --me) {
		reach[me].reset();
		reach[me][me] = true;
		for (int to = me + 1; to &lt; sccCnt; ++to) {
			if (nGraph[me][to])
				reach[me] |= reach[to];
		}

		int cnt = 0;
		for (int u = me; u &lt; sccCnt; ++u) {
			if (reach[me][u])
				cnt += num[u];
		}

		ans += 1LL * num[me] * cnt;
	}

	cout&lt;&lt;ans&lt;&lt;endl;
}

int main() {
	inputData();
	work();
}
</pre><pre></pre><h2>Problem2209</h2><pre>/*
 *  [Jsoi2011]括号序列.cpp
 *
 *  Created on: 2011-4-13
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Info {
	int sum;
	int minL, maxL;
	int minR, maxR;

	void set(int x) {
		sum = x;
		minL = minR = min(x, 0);
		maxL = maxR = max(x, 0);
	}

	void applyRev() {
		swap(minL, minR);
		swap(maxL, maxR);
	}

	void applyNega() {
		swap(minL, maxL);
		minL *= -1;
		maxL *= -1;
		swap(minR, maxR);
		minR *= -1;
		maxR *= -1;
		sum *= -1;
	}

	void merge(const Info&amp;L, const Info&amp;R) {
		sum = L.sum + R.sum;
		minL = min(L.minL, L.sum + R.minL);
		maxL = max(L.maxL, L.sum + R.maxL);
		minR = min(R.minR, R.sum + L.minR);
		maxR = max(R.maxR, R.sum + L.maxR);
	}

	void append(const Info&amp;R) {
		static Info copy;
		copy = *this;
		merge(copy, R);
	}

	void append(int x) {
		static Info copy, tmp;
		copy = *this;
		tmp.set(x);
		merge(copy, tmp);
	}

	int getCost() {
		int change = (-minL + 1) / 2;
		int cur = sum + change * 2;
		return change + abs(cur) / 2;
	}
};

struct Node {
	Node*ch[2], *p;

	int size, value;
	Info info;

	bool isRev, isNega;

	void applyRev() {
		isRev ^= 1;
		info.applyRev();
	}

	void applyNega() {
		isNega ^= 1;
		value *= -1;
		info.applyNega();
	}

	void relax() {
		if (isRev) {
			swap(ch[0], ch[1]);
			ch[0]-&gt;applyRev();
			ch[1]-&gt;applyRev();
			isRev = false;
		}
		if (isNega) {
			ch[0]-&gt;applyNega();
			ch[1]-&gt;applyNega();
			isNega = false;
		}
	}

	Node() {
		size = 0;
		info.set(0);
	}

	Node(int _value);

	void update() {
		size = ch[0]-&gt;size + 1 + ch[1]-&gt;size;
		info = ch[0]-&gt;info;
		info.append(value);
		info.append(ch[1]-&gt;info);
	}

	bool dir() {
		return this == p-&gt;ch[1];
	}

	void setC(Node*c, bool d) {
		ch[d] = c;
		c-&gt;p = this;
	}
} Tnull, *null = &amp;Tnull;

Node::Node(int _value) {
	isRev = isNega = false;
	value = _value;
	info.set(value);
	ch[0] = ch[1] = null;
	size = 1;
}

struct Splay {
	Node*root;

	void rotate(Node*t) {
		Node*p = t-&gt;p;
		bool d = t-&gt;dir();
		p-&gt;relax();
		t-&gt;relax();
		p-&gt;p-&gt;setC(t, p-&gt;dir());
		p-&gt;setC(t-&gt;ch[!d], d);
		t-&gt;setC(p, !d);
		p-&gt;update();
		if (root == p)
			root = t;
	}

	void splay(Node*t, Node*f) {
		while (t-&gt;p != f) {
			if (t-&gt;p-&gt;p == f)
				rotate(t);
			else {
				if (t-&gt;dir() == t-&gt;p-&gt;dir())
					rotate(t-&gt;p), rotate(t);
				else
					rotate(t), rotate(t);
			}
		}
		t-&gt;update();
	}

	Node*getKth(int kth) {
		for (Node*t = root;;) {
			t-&gt;relax();
			int cnt = t-&gt;ch[0]-&gt;size;
			if (kth == cnt)
				return t;
			if (kth &gt; cnt)
				kth -= cnt + 1, t = t-&gt;ch[1];
			else
				t = t-&gt;ch[0];
		}
	}

	Node*getSeq(int l, int r) {
		Node*L = getKth(l - 1);
		//		cout &lt;&lt; "ok" &lt;&lt; endl;
		splay(L, null);
		//		cout &lt;&lt; "ok" &lt;&lt; endl;
		Node*R = getKth(r + 1);
		//		cout &lt;&lt; "ok" &lt;&lt; endl;
		splay(R, L);
		//		cout &lt;&lt; "ok" &lt;&lt; endl;
		return R-&gt;ch[0];
	}

	Node* build(int seq[], int l, int r) {
		if (l &gt;= r)
			return null;
		int m = l + r &gt;&gt; 1;
		Node*t = new Node(seq[m]);
		t-&gt;setC(build(seq, l, m), 0);
		t-&gt;setC(build(seq, m + 1, r), 1);
		t-&gt;update();
		return t;
	}

	void init(int seq[], int n) {
		root = build(seq, 0, n);
		root-&gt;p = null;
	}
};

Splay splay;

const int MAX_L_SEQ = 100000 + 10;

int seq[MAX_L_SEQ];
int n, nQ;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

void solve() {
	scanInt(n);
	scanInt(nQ);
	static char str[MAX_L_SEQ];
	scanf(" ");
	scanf("%s", str);
	seq[0] = seq[n + 1] = 0;
	for (int i = 1; i &lt;= n; ++i) {
		seq[i] = str[i - 1] == '(' ? 1 : -1;
	}

	splay.init(seq, n + 2);
	for (int i = 0; i &lt; nQ; ++i) {
		int t, l, r;
		scanf("%d%d%d", &amp;t, &amp;l, &amp;r);
		switch (t) {
		case 0: {
			int ret = splay.getSeq(l, r)-&gt;info.getCost();
			printf("%d\n", ret);
			break;
		}
		case 1: {
			splay.getSeq(l, r)-&gt;applyNega();
			break;
		}
		case 2: {
			splay.getSeq(l, r)-&gt;applyRev();
			break;
		}
		}
	}
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2212</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int N = int(1e6)+10;
struct TA{
	int*a,n;
	TA(int n){this-&gt;n=n;a=new int[n];memset(a,0,sizeof(int)*n);}
	void ad(int p,int x){for(p++;p&lt;=n;p+=p&amp;-p)a[p-1]+=x;}
	int gt(int p){int r=0;for(p++;p&gt;0;p-=p&amp;-p)r+=a[p-1];return r;}
};
struct T{T*pl,*pr;TA*ta;int l,r;int s(){return r-l+1;}T(int _l,int _r):l(_l),r(_r){pl=pr=0;}};
int n;
int a[N],nt;
T*ts[N*2];
inline int ni(){
	char ch;for(;;){ch=getchar();if(ch&gt;='0'&amp;&amp;ch&lt;='9')break;}
	int r=ch-'0';for(;;){ch=getchar();if(ch&lt;'0'||ch&gt;'9')break;r=r*10+ch-'0';}
	return r;
}
T*ps(){
	int x=ni();
	T*t=ts[nt++]=new T(n,n);
	if(x&gt;0){a[n++]=x-1;return t;}
	t-&gt;pl=ps();
	t-&gt;pr=ps();
	t-&gt;r=n-1;
	return t;
}
typedef long long ll;
int at[N];
int main(){
	scanf("%d",&amp;n);n=0;
	ps();T*t=ts[0];t-&gt;ta=new TA(n);
	REP(i,n)at[i]=i,t-&gt;ta-&gt;ad(i,1);
	ll ans=0;
	REP(i,nt){
		T*t=ts[i],*p=t-&gt;pl,*q=t-&gt;pr;if(p==0)continue;
		if(p-&gt;s()&gt;q-&gt;s())swap(p,q);ll al=(ll)p-&gt;s()*q-&gt;s(),ct=0;
		static int v[N];REP(i,p-&gt;s())v[i]=a[p-&gt;l+i];
		sort(v,v+p-&gt;s());
		p-&gt;ta=new TA(p-&gt;s());int cr=0;
		REP(i,p-&gt;s()){
			int x=v[i];ct+=t-&gt;ta-&gt;gt(at[x]-1);t-&gt;ta-&gt;ad(at[x],-1);
			at[x]=cr++;p-&gt;ta-&gt;ad(i,1);
		}
		q-&gt;ta=t-&gt;ta;ans += min(al-ct,ct);
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem2213</h2><pre>/*
 * Difference.cpp
 *
 *  Created on: 2011-3-23
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 1000000 + 10;
vector&lt;int&gt; whereByChar[26];

int nChars;
char str[MAX_N];

void inputData() {
	cin &gt;&gt; nChars;
	scanf("%s", str);
	for (int i = 0; i &lt; nChars; ++i) {
		int what = str[i] - 'a';
		whereByChar[what].push_back(i);
	}
	for (int i = 0; i &lt; 26; ++i) {
		whereByChar[i].push_back(MAX_N);
	}
}

int doit(int maxChar, int minChar) {
	vector&lt;int&gt;&amp;maxWhere = whereByChar[maxChar];
	vector&lt;int&gt;&amp;minWhere = whereByChar[minChar];

	static int seq[MAX_N];
	static int toLeft[MAX_N], toRight[MAX_N];

	int atMax = 0, atMin = 0;
	int n = maxWhere.size() + minWhere.size() - 2;

	for (int i = 0; i &lt; n; ++i) {
		if (maxWhere[atMax] &lt; minWhere[atMin]) {
			seq[i] = 1;
			atMax++;
		} else {
			seq[i] = -1;
			atMin++;
		}
	}

	int cur = 0;
	for (int i = 0; i &lt; n; ++i) {
		if (cur &lt; 0)
			cur = 0;
		toLeft[i] = cur;
		cur += seq[i];
	}

	cur = 0;
	for (int i = n - 1; i &gt;= 0; --i) {
		if (cur &lt; 0)
			cur = 0;
		toRight[i] = cur;
		cur += seq[i];
	}

	int ret = 0;
	for (int i = 0; i &lt; n; ++i) {
		if (seq[i] == -1) {
			int tmp = toLeft[i] + seq[i] + toRight[i];
			if (tmp &gt; ret)
				ret = tmp;
		}
	}

	return ret;
}
int main() {
	inputData();

	int ans = 0;
	for (int maxChar = 0; maxChar &lt; 26; ++maxChar) {
		for (int minChar = 0; minChar &lt; 26; ++minChar) {
			if (maxChar == minChar)
				continue;
			int tmp = doit(maxChar, minChar);
			if (tmp &gt; ans)
				ans = tmp;
		}
	}

	cout &lt;&lt; ans &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem2214</h2><pre>/*
 * Shift.cpp
 *
 *  Created on: 2011-1-26
 *      Author: wjmzbmr
 */
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cstring&gt;
using namespace std;
const int MAX_N=2000+10;
const int MAX_MOVE=MAX_N*MAX_N;
int n;

struct MoveRecorder{
	char types[MAX_MOVE];
	int cnts[MAX_MOVE];
	int moveCnt;

	void clear(){
		moveCnt=0;
	}

	bool just(){
		if(!moveCnt)return true;
		int it=moveCnt-1;
		if(types[it]=='a')
			cnts[it]%=n;
		else
			cnts[it]%=3;
		if(!cnts[it]){
			moveCnt--;
			return false;
		}
		return true;
	}
	void apply(char c,int cnt){
		if(!moveCnt||types[moveCnt-1]!=c){
			if(!just()){
				apply(c,cnt);
				return;
			}
			types[moveCnt]=c;cnts[moveCnt]=cnt;
			moveCnt++;
		} else {
			cnts[moveCnt-1]+=cnt;
		}
	}

	void output(){
		printf("%d\n",moveCnt);
		for(int i=0;i&lt;moveCnt;i++)
			printf("%d%c ",cnts[i],types[i]);
		printf("\n");
	}
};
MoveRecorder moveRecorder;

struct CyclicArray{
	int orig[MAX_N];
	int a[MAX_N],n;
	int curFirst;

	void read(){
		scanf("%d",&amp;n);
		::n=n;
		for(int i=0;i&lt;n;i++)
			scanf("%d",orig+i),orig[i]--;
	}

	void reStart(){
		memcpy(a,orig,sizeof a);
		curFirst=0;
	}

	int&amp;operator[](int at){
		return a[(at+n)%n];
	}
	int&amp;get(int at){
		return a[(at+n)%n];
	}
	void moveToFirst(int newFirst){
		if(newFirst&lt;0)newFirst+=n;
		if(newFirst==curFirst)return;
		int dist=curFirst-newFirst;
		if(dist&lt;0)dist+=n;
		moveRecorder.apply('a',dist);
		curFirst=newFirst;
	}

	void write(){
		for(int i=0;i&lt;n;i++)
			printf("%d ",a[i]+1);
		printf("\n");
	}

	int find(int x){
		for(int i=0;i&lt;n;i++)
			if(a[i]==x)
				return i;
	}

	void shift(int at,int times=1){
		//at-2,at-1,at -&gt; at,at-2,at-1
		moveToFirst(at-2);
		for(int it=0;it&lt;times;it++){
			int tmp=get(at);
			get(at)=get(at-1);
			get(at-1)=get(at-2);
			get(at-2)=tmp;
		}
		moveRecorder.apply('b',times);
	}

	void finish(){
		moveToFirst(0);
	}

	bool valid(){
		for(int i=0;i&lt;n;i++)
			if(a[i]!=i)
				return false;
		return true;
	}
};

CyclicArray a;

bool solve(){
	moveRecorder.clear();
	a.reStart();
	for(int cur=0;cur&lt;a.n;cur++){
		int at=a.find(cur);
		while(at&gt;=cur+2){
			a.shift(at,1);
			at-=2;
		}
		if(at==cur+1){
			if(at+1&lt;a.n){
				a.shift(at+1,2);
				at-=1;
			}
		}
	}
	if(a.valid()){
		a.finish();
		return true;
	}
	if(a.n==2){
		a.moveToFirst(1);
		return true;
	}
	if(a.n%2==0){
		int at=a.n-1;
		for(int i=0;i&lt;a.n/2;i++)
			a.shift(at,1),at-=2;
		a.moveToFirst(1);
		return true;
	}
	return false;
}

void work(){
	if(solve())
		moveRecorder.output();
	else
		puts("NIE DA SIE");
}

namespace Check{
	int a[MAX_N];
	int n;

	void shiftA(){
		int tmp=a[n-1];
		for(int i=n-1;i&gt;=1;i--)
			a[i]=a[i-1];
		a[0]=tmp;
	}

	void shiftB(){
		int tmp=a[2];
		a[2]=a[1];
		a[1]=a[0];
		a[0]=tmp;
	}

	void read(){
		scanf("%d",&amp;n);
		for(int i=0;i&lt;n;i++)
			scanf("%d",a+i);
	}
	void doit(){
		int nQ;scanf("%d",&amp;nQ);
		for(int i=0;i&lt;nQ;i++){
			int d;char c;
			scanf("%d%c",&amp;d,&amp;c);
			cout&lt;&lt;d&lt;&lt;c&lt;&lt;" ";
			for(int it=0;it&lt;d;it++){
				if(c=='a')
					shiftA();
				else
					shiftB();
			}
		}
		cout&lt;&lt;endl;
		for(int i=0;i&lt;n;i++)
			printf("%d ",a[i]);
		printf("\n");
	}

	void check(){
		read();
		doit();
	}
}
int main(){
	a.read();
	work();
//	Check::check();
}
</pre><pre></pre><h2>Problem2216</h2><pre>/*
 * Lightning Conductor.cpp
 *
 *  Created on: 2011-1-25
 *      Author: wjmzbmr
 */
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int MAX_N=500000+10;
const double eps=1e-7;
int height[MAX_N],n;
double sqrtMem[MAX_N];
double ans[MAX_N];

void inputData(){
	scanf("%d",&amp;n);
	for(int i=0;i&lt;n;i++)
		scanf("%d",height+i);
}

void prepareSqrt(){
	int cur=0;
	for(int i=0;i&lt;MAX_N;i++){
		sqrtMem[i]=sqrt(i);
	}
}

inline double calcVal(int i,int j){
	return height[j]+sqrtMem[i-j];
}

int whenExceed(int i,int j,int k){
	//j&lt;k
	if(calcVal(n,j)&gt;calcVal(n,k))
		return n;//never
	int l=i-1,r=n;
	while(l+1&lt;r){
		//l is j,r is k
		int m=l+r&gt;&gt;1;
		if(calcVal(m,j)&gt;calcVal(m,k))
			l=m;
		else
			r=m;
	}
	return r;
}

void dp(bool reverse){
	static int que[MAX_N];
	int h=0,t=0;
	for(int i=0;i&lt;n;i++){
		int add=i;
		while(h&lt;t&amp;&amp;calcVal(i,que[t-1])&lt;=calcVal(i,add))
			t--;
		while(h+1&lt;t&amp;&amp;whenExceed(i,que[t-2],que[t-1])&gt;=whenExceed(i,que[t-1],add))
			t--;
		que[t++]=add;
		while(h+1&lt;t&amp;&amp;calcVal(i,que[h])&lt;=calcVal(i,que[h+1]))
			h++;
		double&amp;it=ans[reverse?n-1-i:i];
		it=max(it,calcVal(i,que[h]));
	}
}

void solve(){
	dp(false);
	reverse(height,height+n);
	dp(true);
	reverse(height,height+n);
	for(int i=0;i&lt;n;i++)
		printf("%d\n",int(ceil(ans[i]-height[i]-eps)));
}
int main(){
	inputData();
	prepareSqrt();
	solve();
}
</pre><pre></pre><h2>Problem2217</h2><pre>/*
 * Lollipop.cpp
 *
 *  Created on: 2011-1-27
 *      Author: wjmzbmr
 */
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
const int MAX_N=1000000+100;
const int MAX_VALUE=MAX_N*2;
int seq[MAX_N],n,nQ;
int sum[MAX_N];
int idx[MAX_VALUE];
int firstOne,lastOne;
void inputData(){
	scanf("%d%d",&amp;n,&amp;nQ);
	memset(idx,-1,sizeof idx);
	int cur=0;sum[0]=0;idx[cur]=0;
	for(int i=1;i&lt;=n;i++){
		char c;scanf(" ");scanf("%c",&amp;c);
		seq[i]=(c=='T'?2:1);
		sum[i]=sum[i-1]+seq[i];
		idx[sum[i]]=i;
	}
}

void preCondition(){
	firstOne=lastOne=0;
	for(int i=1;i&lt;=n;i++)if(seq[i]==1){
		if(firstOne==0)
			firstOne=i;
		lastOne=i;
	}
}

bool inRange(int x){
	return x&gt;=1&amp;&amp;x&lt;=n;
}

bool tryStart(int l,int need){
	if(!inRange(l))return false;
	int needSum=sum[l-1]+need;
	if(needSum&lt;MAX_VALUE&amp;&amp;idx[needSum]!=-1){
		printf("%d %d\n",l,idx[needSum]);
		return true;
	}
	return false;
}

bool tryEnd(int r,int need){
	if(!inRange(r))return false;
	int needSum=sum[r]-need;
	if(needSum&gt;=0&amp;&amp;idx[needSum]!=-1){
		printf("%d %d\n",idx[needSum]+1,r);
		return true;
	}
	return false;
}

void answer(int need){
	if(tryStart(firstOne,need))return;
	if(tryStart(firstOne+1,need))return;
	if(tryEnd(lastOne,need))return;
	if(tryEnd(lastOne-1,need))return;
	if(tryStart(1,need))return;
	printf("NIE\n");
}

void work(){
	for(int i=0;i&lt;nQ;i++){
		int need;scanf("%d",&amp;need);
		answer(need);
	}
}

int main(){
	inputData();
	preCondition();
	work();
}
</pre><pre></pre><h2>Problem2220</h2><pre>/*
 *  CCC2009 Dinner之Zuma2.cpp
 *
 *  Created on: 2011-4-6
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 100 + 10;
const int MAX_K = 10;

const int INF = 1 &lt;&lt; 29;

int memo[MAX_N][MAX_N][MAX_K];
int n, k;

char str[MAX_N];

int rec(int l, int r, int num) {
	if (num &gt; k)
		num = k;
	if (r - l + 1 &lt;= 1) {
		if (l == r)
			++num;
		if (num == 0)
			return 0;
		if (num &gt;= k)
			return 1;
		return INF;
	}
	int&amp;ret = memo[l][r][num];
	if (ret != -1)
		return ret;
	if (l + 1 &lt;= r &amp;&amp; str[l] == str[l + 1])
		return ret = rec(l + 1, r, num + 1);
	ret = INF;
	if (num + 1 &gt;= k) {
		ret = rec(l + 1, r, 0) + 1;
	}
	for (int split = l + 1; split &lt;= r; ++split)
		if (str[split] == str[l]) {
			int tmp = rec(l + 1, split - 1, 0) + rec(split, r, num + 1);
			if (tmp &lt; ret)
				ret = tmp;
		}
	return ret;
}

int main() {
	while (cin &gt;&gt; n &gt;&gt; k) {
		scanf(" ");
		scanf("%s", str);
		memset(memo, -1, sizeof memo);
		int ret = rec(0, n - 1, 0);
		if (ret == INF)
			ret = -1;
		printf("%d\n", ret);
	}
}
</pre><pre></pre><h2>Problem2223</h2><pre>/*
 * [Coci 2009]PATULJCI.cpp
 *
 *  Created on: 2011-4-5
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Info {
	int what, num;
	void set(int me) {
		what = me;
		num = 1;
	}
	void clear() {
		what = -1;
		num = 0;
	}
	Info() {
		clear();
	}
};

Info operator+(Info l, Info r) {
	Info me;
	if (l.num &lt; r.num)
		swap(l, r);
	me = l;
	if (r.what == me.what)
		me.num += r.num;
	else
		me.num -= r.num;
	return me;
}

const int MAX_N_NODES = 300000 + 10;

struct SegTree {
	static const int MAX_T = MAX_N_NODES * 4;
	Info info[MAX_T];
	int offSet;

	void setLeave(int where, int toWhat) {
		info[where + offSet].set(toWhat);
	}

	void init(int cap) {
		offSet = 1;
		while (offSet &lt;= cap + 3)
			offSet &lt;&lt;= 1;
		for (int i = 0; i &lt; offSet * 2; ++i) {
			info[i].clear();
		}
	}

	void start() {
		for (int i = offSet - 1; i &gt;= 1; --i) {
			info[i] = info[i + i] + info[i + i + 1];
		}
	}

	Info ask(int l, int r) {
		l += offSet - 1;
		r += offSet + 1;
		Info ret;
		for (; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) {
			if (~l &amp; 1)
				ret = ret + info[l ^ 1];
			if (r &amp; 1)
				ret = ret + info[r ^ 1];
		}
		return ret;
	}
};

SegTree segTree;
int nums[MAX_N_NODES], nNums;

vector&lt;int&gt; where[MAX_N_NODES];
int seq[MAX_N_NODES];

bool check(int l, int r, int what) {
	if (what == -1)
		return false;
	vector&lt;int&gt;&amp;cur = where[lower_bound(nums, nums + nNums, what) - nums];
	return upper_bound(cur.begin(), cur.end(), r) - lower_bound(cur.begin(),
			cur.end(), l) &gt; (r - l + 1) / 2;
}

int main() {
//	freopen("in", "r", stdin);
	int n, nC;
	scanf("%d%d", &amp;n, &amp;nC);
	segTree.init(n);

	nNums = 0;
	for (int i = 1; i &lt;= n; ++i) {
		int what;
		scanf("%d", &amp;what);
		segTree.setLeave(i, what);
		nums[nNums++] = what;
		seq[i] = what;
	}
	segTree.start();

	sort(nums, nums + nNums);
	nNums = unique(nums, nums + nNums) - nums;

	for (int i = 1; i &lt;= n; ++i) {
		int what = seq[i];
		int id = lower_bound(nums, nums + nNums, what) - nums;
		where[id].push_back(i);
	}

	int nQ;
	scanf("%d", &amp;nQ);
	while (nQ--) {
		int l, r;
		scanf("%d%d", &amp;l, &amp;r);
		Info me = segTree.ask(l, r);
		int what = me.what;
		if (check(l, r, what))
			printf("yes %d\n", what);
		else
			printf("no\n");
	}
}
</pre><pre></pre><h2>Problem2223</h2><pre>/*
 * [Coci 2009]PATULJCI.cpp
 *
 *  Created on: 2011-4-5
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Info {
	int what, num;
	void set(int me) {
		what = me;
		num = 1;
	}
	void clear() {
		what = -1;
		num = 0;
	}
	Info() {
		clear();
	}
};

Info operator+(Info l, Info r) {
	Info me;
	if (l.num &lt; r.num)
		swap(l, r);
	me = l;
	if (r.what == me.what)
		me.num += r.num;
	else
		me.num -= r.num;
	return me;
}

const int MAX_N_NODES = 300000 + 10;

struct SegTree {
	static const int MAX_T = MAX_N_NODES * 4;
	Info info[MAX_T];
	int offSet;

	void setLeave(int where, int toWhat) {
		info[where + offSet].set(toWhat);
	}

	void init(int cap) {
		offSet = 1;
		while (offSet &lt;= cap + 3)
			offSet &lt;&lt;= 1;
		for (int i = 0; i &lt; offSet * 2; ++i) {
			info[i].clear();
		}
	}

	void start() {
		for (int i = offSet - 1; i &gt;= 1; --i) {
			info[i] = info[i + i] + info[i + i + 1];
		}
	}

	Info ask(int l, int r) {
		l += offSet - 1;
		r += offSet + 1;
		Info ret;
		for (; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) {
			if (~l &amp; 1)
				ret = ret + info[l ^ 1];
			if (r &amp; 1)
				ret = ret + info[r ^ 1];
		}
		return ret;
	}
};

SegTree segTree;
int nums[MAX_N_NODES], nNums;

vector&lt;int&gt; where[MAX_N_NODES];
int seq[MAX_N_NODES];

bool check(int l, int r, int what) {
	if (what == -1)
		return false;
	vector&lt;int&gt;&amp;cur = where[lower_bound(nums, nums + nNums, what) - nums];
	return upper_bound(cur.begin(), cur.end(), r) - lower_bound(cur.begin(),
			cur.end(), l) &gt; (r - l + 1) / 2;
}

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

int main() {
	//	freopen("in", "r", stdin);
	int n, nC;
	scanInt(n);
	scanInt(nC);
	segTree.init(n);

	nNums = 0;
	for (int i = 1; i &lt;= n; ++i) {
		int what;
		scanInt(what);
		segTree.setLeave(i, what);
		nums[nNums++] = what;
		seq[i] = what;
	}
	segTree.start();

	sort(nums, nums + nNums);
	nNums = unique(nums, nums + nNums) - nums;

	for (int i = 1; i &lt;= n; ++i) {
		int what = seq[i];
		int id = lower_bound(nums, nums + nNums, what) - nums;
		where[id].push_back(i);
	}

	int nQ;
	scanInt(nQ);
	while (nQ--) {
		int l, r;
		scanInt(l);
		scanInt(r);
		Info me = segTree.ask(l, r);
		int what = me.what;
		if (check(l, r, what))
			printf("yes %d\n", what);
		else
			printf("no\n");
	}
}
</pre><pre></pre><h2>Problem2225</h2><pre>/*
 *  [Spoj 2371]Another Longest Increasing Subsequence.cpp
 *
 *  Created on: 2011-4-8
 *      Author: user
 */
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;utility&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 100000 + 10;

typedef long long int64;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

int n;
int x[MAX_N], y[MAX_N];

void readInput() {
	scanInt(n);
	for (int i = 0; i &lt; n; ++i) {
		scanInt(x[i]);
		scanInt(y[i]);
	}
}

namespace Sub {
	struct Compresser {
		int a[MAX_N];
		int n;

		void clear() {
			n = 0;
		}

		void add(int x) {
			a[n++] = x;
		}

		void doit() {
			sort(a, a + n);
			n = unique(a, a + n) - a;
		}

		void compress(int&amp;x) {
			// last element &lt;= x
			x = upper_bound(a, a + n, x) - a - 1;
		}
	};

	struct TA {
		int a[MAX_N];
		int n;

		void init(int _n) {
			n = _n;
			for (int i = 0; i &lt; n; ++i) {
				a[i] = -1;
			}
		}

		void update(int p, int x) {
			for (p++; p &lt;= n; p += p &amp; -p)
				a[p - 1] = max(a[p - 1], x);
		}

		int ask(int p) {
			int ret = -1;
			for (p++; p &gt; 0; p -= p &amp; -p)
				ret = max(ret, a[p - 1]);
			return ret;
		}
	};

	Compresser compX, compY;

	TA ta;

	struct Query {
		int y;
		int*toChange;
		Query *next;

		void set(int _y, int*_toChange) {
			y = _y;
			toChange = _toChange;
		}
	};

	Query queries[MAX_N];
	int nQueries;
	Query*queryFirst[MAX_N];

	struct Point {
		int y, opt;

		void set(int _y, int _opt) {
			y = _y;
			opt = _opt;
		}

		Point*next;
	};

	Point points[MAX_N];
	int nPoints;
	Point*pointFirst[MAX_N];

	void addQuery(int x, int y, int*toChange) {
		--x;
		--y;
		compX.compress(x);
		compY.compress(y);
		if (x &lt; 0 || y &lt; 0)
			return;
		Query*q = queries + nQueries++;
		q-&gt;set(y, toChange);
		q-&gt;next = queryFirst[x];
		queryFirst[x] = q;
	}

	void addPoint(int x, int y, int opt) {
		compX.compress(x);
		compY.compress(y);
		Point*p = points + nPoints++;
		p-&gt;set(y, opt);
		p-&gt;next = pointFirst[x];
		pointFirst[x] = p;
	}

	void startView() {
		compX.clear();
		compY.clear();
	}

	void viewPoint(int x, int y) {
		compX.add(x);
		compY.add(y);
	}

	void startAdd() {
		compX.doit();
		compY.doit();

		nPoints = nQueries = 0;
		for (int i = 0; i &lt; compX.n; ++i) {
			pointFirst[i] = 0;
			queryFirst[i] = 0;
		}
	}

	void solve() {
		ta.init(compY.n);
		for (int x = 0; x &lt; compX.n; ++x) {
			for (Point*cur = pointFirst[x]; cur != 0; cur = cur-&gt;next) {
				ta.update(cur-&gt;y, cur-&gt;opt);
			}
			for (Query*cur = queryFirst[x]; cur != 0; cur = cur-&gt;next) {
				int tmp = ta.ask(cur-&gt;y) + 1;
				if (tmp &gt; *cur-&gt;toChange)
					*cur-&gt;toChange = tmp;
			}
		}
	}
}

int dp[MAX_N];
void rec(int l, int r) {
	if (l + 1 == r) {
		return;
	}
	int m = l + r &gt;&gt; 1;

	rec(l, m);

	Sub::startView();
	for (int i = l; i &lt; m; i++) {
		Sub::viewPoint(x[i], y[i]);
	}

	Sub::startAdd();
	for (int i = l; i &lt; m; ++i) {
		Sub::addPoint(x[i], y[i], dp[i]);
	}

	for (int i = m; i &lt; r; ++i) {
		Sub::addQuery(x[i], y[i], dp + i);
	}
	Sub::solve();

	rec(m, r);
}

void work() {

	fill(dp, dp + n, 1);
	rec(0, n);

	int ans = *max_element(dp, dp + n);
	cout &lt;&lt; ans &lt;&lt; endl;
}

void solve() {
	readInput();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2226</h2><pre>/*
 * 5971. LCM Sum.cpp
 *
 *  Created on: 2011-5-2
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 1000000 + 10;

typedef long long int64;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

inline void printInt(int64 x) {
	if (!x) {
		puts("0");
		return;
	}
	static int digits[20];
	int p = 0;
	while (x)
		digits[p++] = x % 10, x /= 10;
	for (int i = p - 1; i &gt;= 0; --i) {
		putchar('0' + digits[i]);
	}
	putchar('\n');
}

/*
 *  f(n) = n*(g*1)(n)
 *  g(n) = ((id*phi+e)/2)(n)
 *  f(n) = (n/2) * ((id*phi*1)(n)+1)(n)
 */

/*
 * need (id*phi*1)
 */

const int MAX_N_PRIMES = MAX_N / 10;
int primes[MAX_N_PRIMES], nPrimes;
int minP[MAX_N] = { }, minPow[MAX_N];

int64 F[MAX_N] = { };

void prepare() {
	nPrimes = 0;
	F[1] = 1;
	for (int i = 2; i &lt; MAX_N; ++i) {
		if (minP[i] == 0) {
			primes[nPrimes++] = i;
			minP[i] = i;
			minPow[i] = i;
			F[i] = 1LL * i * i * i;
		}
		for (int j = 0; j &lt; nPrimes; ++j) {
			int p = primes[j], ip = p * i;
			if (ip &gt; MAX_N)
				break;
			minP[ip] = p;
			if (minP[i] == p) {
				minPow[ip] = minPow[i] * p;
				if (F[i] &gt; 0) {
					F[ip] = F[i] * p * p;
				}
				break;
			} else {
				minPow[ip] = p;
			}
		}
	}

	for (int i = 2; i &lt; MAX_N; ++i) {
		if (F[i] &gt; 0) {
			F[i] = (F[i] - minP[i]) / (minP[i] + 1) + 1;
		} else {
			F[i] = F[i / minPow[i]] * F[minPow[i]];
		}
	}
}

int64 calc(int n) {
	return (F[n] + 1) * n / 2;
}

int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}

int64 help(int n) {
	int64 ret = 0;
	for (int i = 1; i &lt;= n; ++i) {
		ret += 1LL * i / gcd(i, n) * n;
	}
	return ret;
}

int main() {
	prepare();
	int nT;
	scanInt(nT);
	while (nT--) {
		int n;
		scanInt(n);
		int64 ret = calc(n);
		printf("%lld\n", ret);
	}
}
</pre><pre></pre><h2>Problem2227</h2><pre>import java.math.BigInteger;
import java.util.Scanner;

import static java.math.BigInteger.*;

public class Main {

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int nT = scan.nextInt();
		for (int i = 0; i &lt; nT; ++i) {
			int n = scan.nextInt(), k = scan.nextInt();
			if (n &gt; k)
				System.out.println("0 1");
			else {
				BigInteger A = valueOf(k + 1).pow(n - 1).multiply(
						valueOf(k + 1 - n));
				BigInteger B = valueOf(k).pow(n);
				BigInteger g = A.gcd(B);
				A = A.divide(g);
				B = B.divide(g);
				System.out.println("" + A + " " + B);
			}
		}
	}
}
</pre><pre></pre><h2>Problem2228</h2><pre>/*
 * [Baltic2009]monument.cpp
 *
 *  Created on: 2011-3-27
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

int nX, nY, nZ;
const int MAX_N = 150 + 10;

bool what[MAX_N][MAX_N][MAX_N];

bool nWhat[MAX_N][MAX_N][MAX_N];

void swapXY() {
	for (int x = 0; x &lt; nX; ++x) {
		for (int y = 0; y &lt; nY; ++y) {
			for (int z = 0; z &lt; nZ; ++z) {
				nWhat[y][x][z] = what[x][y][z];
			}
		}
	}
	memcpy(what, nWhat, sizeof what);
	swap(nX, nY);
}

void swapXZ() {
	for (int x = 0; x &lt; nX; ++x) {
		for (int y = 0; y &lt; nY; ++y) {
			for (int z = 0; z &lt; nZ; ++z) {
				nWhat[z][y][x] = what[x][y][z];
			}
		}
	}
	memcpy(what, nWhat, sizeof what);
	swap(nX, nZ);
}

int extend[MAX_N][MAX_N][MAX_N];

int sum[MAX_N][MAX_N];

void prepareSum(bool what[MAX_N][MAX_N], int nY, int nZ) {
	memset(sum, 0, sizeof sum);
	for (int y = 0; y &lt; nY; ++y) {
		for (int z = 0; z &lt; nZ; ++z) {
			sum[y + 1][z + 1] = sum[y][z + 1] + sum[y + 1][z] - sum[y][z]
					+ what[y][z];
		}
	}
}

int getSum(int ly, int lz, int ry, int rz) {
	return sum[ry][rz] - sum[ly][rz] - sum[ry][lz] + sum[ly][lz];
}

void calcExtend(bool what[MAX_N][MAX_N], int nY, int nZ,
		int extend[MAX_N][MAX_N]) {
	prepareSum(what, nY, nZ);
	for (int y = 0; y &lt; nY; ++y) {
		for (int z = 0; z &lt; nZ; ++z) {
			if (!what[y][z])
				extend[y][z] = 0;
			else {
				int cur = 1;
				if (y &gt; 0 &amp;&amp; z &gt; 0)
					cur = extend[y - 1][z - 1] - 1;
				if (cur &lt; 1)
					cur = 1;

				while (y + cur &lt;= nY &amp;&amp; z + cur &lt;= nZ) {
					int cnt = getSum(y, z, y + cur, z + cur);
					if (cnt == cur * cur)
						++cur;
					else {
						break;
					}
				}

				--cur;
				extend[y][z] = cur;
			}
		}
	}
}

int ans = 0;

void doit(int seq[], int n) {
	//1..n
	seq[0] = -1;
	seq[n + 1] = -1;

	static int prev[MAX_N], next[MAX_N];

	for (int i = 1; i &lt;= n; ++i) {
		int at = i - 1;
		while (seq[at] &gt;= seq[i])
			at = prev[at];
		prev[i] = at;
	}

	for (int i = n; i &gt;= 1; --i) {
		int at = i + 1;
		while (seq[at] &gt;= seq[i])
			at = next[at];
		next[i] = at;
	}

	for (int whereMin = 1; whereMin &lt;= n; ++whereMin) {
		int left = prev[whereMin] + 1;
		int right = next[whereMin] - 1;

		int cnt = right - left + 1;
		int tmp = cnt * seq[whereMin];

		if (tmp &gt; ans)
			ans = tmp;
	}
}

void prepareExtend() {
	for (int x = 0; x &lt; nX; ++x) {
		calcExtend(what[x], nY, nZ, extend[x]);
	}
}

void calc() {
	static int seq[MAX_N];
	prepareExtend();

	for (int y = 0; y &lt; nY; ++y) {
		for (int z = 0; z &lt; nZ; ++z) {
			for (int x = 0; x &lt; nX; ++x) {
				seq[x + 1] = extend[x][y][z];
			}
			doit(seq, nX);
		}
	}
}

void work() {

	//X,Y,Z
	calc();

	swapXY();
	//Y,X,Z
	calc();

	//Z,X,Y
	swapXZ();
	calc();

	printf("%d", ans * 4);
}

void inputData() {
	scanf("%d%d%d", &amp;nX, &amp;nY, &amp;nZ);
	for (int y = 0; y &lt; nY; ++y) {
		for (int x = 0; x &lt; nX; ++x) {
			for (int z = 0; z &lt; nZ; ++z) {
				char ch;
				while (ch = getchar(), ch != 'P' &amp;&amp; ch != 'N')
					;
				what[x][y][z] = ch == 'N';
			}
		}
	}
}

void solve() {
	inputData();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2229</h2><pre>/*
 * MinCut Query.cpp
 *
 *  Created on: 2011-4-5
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int INF = ~0U &gt;&gt; 1;
const int MAX_N_VETS = 150 + 10;
struct Network {
	static const int MAX_N_EDGES = 10000;

	int head[MAX_N_VETS];
	int dest[MAX_N_EDGES], cap[MAX_N_EDGES], next[MAX_N_EDGES];
	int origCap[MAX_N_EDGES];

	int nVets, nEdges;

	void init(int _nVets) {
		nVets = _nVets;
		memset(head, -1, sizeof head);
		nEdges = 0;
	}

	void makeEdge(int s, int t, int c) {
		int id = nEdges++;
		next[id] = head[s];
		dest[id] = t;
		origCap[id] = c;
		head[s] = id;
	}

	void addEdge(int s, int t, int c) {
		makeEdge(s, t, c);
		makeEdge(t, s, c);
	}

	void reSetCap() {
		memcpy(cap, origCap, sizeof(int) * nEdges);
	}

	int am[MAX_N_VETS], prev[MAX_N_VETS], h[MAX_N_VETS], cnt[MAX_N_VETS],
			cur[MAX_N_VETS];
	int totalFlow;

	int vs, vt;
	bool side[MAX_N_VETS];

	void dfsSide(int u) {
		if (side[u])
			return;
		side[u] = true;
		for (int e = head[u]; e != -1; e = next[e])
			if (cap[e] &gt; 0)
				dfsSide(dest[e]);
	}

	void findMinCut() {
		memset(side, false, sizeof side);
		dfsSide(vs);
	}

	int calcMaxFlow(int _vs, int _vt) {
		vs = _vs;
		vt = _vt;
		memset(am, 0, sizeof am);
		memset(cur, -1, sizeof cur);
		memset(h, 0, sizeof h);
		memset(cnt, 0, sizeof cnt);
		cnt[0] = nVets;
		int u = vs, now;
		totalFlow = 0;
		am[u] = INF;
		while (h[vs] &lt; nVets) {
			for (now = cur[u]; now != -1; now = next[now])
				if (cap[now] &gt; 0 &amp;&amp; h[u] == h[dest[now]] + 1)
					break;
			if (now != -1) {
				int v = dest[now];
				cur[u] = prev[v] = now;
				am[v] = min(am[u], cap[now]);
				u = v;
				if (u == vt) {
					int by = am[u];
					while (u != vs) {
						cap[prev[u]] -= by;
						cap[prev[u] ^ 1] += by;
						u = dest[prev[u] ^ 1];
					}
					totalFlow += by;
					am[u] = INF;
				}
			} else {
				if (!--cnt[h[u]])
					break;
				h[u] = nVets;
				for (now = head[u]; now != -1; now = next[now])
					if (cap[now] &gt; 0 &amp;&amp; h[dest[now]] + 1 &lt; h[u]) {
						h[u] = h[dest[now]] + 1;
						cur[u] = now;
					}
				++cnt[h[u]];
				if (u != vs)
					u = dest[prev[u] ^ 1];
			}
		}

		return totalFlow;
	}
};

int minCut[MAX_N_VETS][MAX_N_VETS];
Network network;

void solve(vector&lt;int&gt; cur) {
	if (cur.size() &lt;= 1)
		return;
	int a = cur[0], b = cur[1];
	network.reSetCap();
	int cut = network.calcMaxFlow(a, b);
	network.findMinCut();
	for (int a = 0; a &lt; network.nVets; ++a) {
		if (network.side[a])
			for (int b = 0; b &lt; network.nVets; ++b) {
				if (!network.side[b]) {
					minCut[a][b] = minCut[b][a] = min(minCut[a][b], cut);
				}
			}
	}

	vector&lt;int&gt; ch[2];
	foreach(e,cur)
		ch[network.side[*e]].push_back(*e);
	solve(ch[0]);
	solve(ch[1]);
}

void inputData() {
	int nV, nE;
	scanf("%d%d", &amp;nV, &amp;nE);
	network.init(nV);
	for (int i = 0; i &lt; nE; ++i) {
		int u, v, c;
		scanf("%d%d%d", &amp;u, &amp;v, &amp;c);
		--u;
		--v;
		network.addEdge(u, v, c);
	}
}

void prepare() {
	vector&lt;int&gt; cur;
	for (int i = 0; i &lt; network.nVets; ++i) {
		cur.push_back(i);
	}
	for (int i = 0; i &lt; network.nVets; ++i) {
		for (int j = 0; j &lt; network.nVets; ++j) {
			minCut[i][j] = INF;
		}
	}
	solve(cur);
}

int ask(int what) {
	int cnt = 0;
	for (int i = 0; i &lt; network.nVets; ++i) {
		for (int j = 0; j &lt; i; ++j) {
			cnt += minCut[i][j] &lt;= what;
		}
	}
	return cnt;
}

void answer() {
	int nQ;
	scanf("%d", &amp;nQ);
	for (int i = 0; i &lt; nQ; ++i) {
		int what;
		scanf("%d", &amp;what);
		printf("%d\n", ask(what));
	}
}

int main() {
	int nT;
	scanf("%d", &amp;nT);
	for (int i = 0; i &lt; nT; ++i) {
		inputData();
		prepare();
		answer();
		if (i != nT - 1)
			puts("");
	}
}
</pre><pre></pre><h2>Problem2234</h2><pre>/*
 *  Sgu394 Berhatton.cpp
 *
 *  Created on: 2011-5-30
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

typedef long long int64;

const int MAX_N = int(1e5) + 10;

struct Comp {
	int64 a[MAX_N];
	int n;
	void clear() {
		n = 0;
	}
	void add(int64 x) {
		a[n++] = x;
	}
	void doit() {
		sort(a, a + n);
		n = unique(a, a + n) - a;
	}
	void comp(int64&amp;x) {
		x = lower_bound(a, a + n, x) - a;
	}
	void comp(int64&amp;l, int64&amp;r) {
		l = lower_bound(a, a + n, l) - a;
		r = upper_bound(a, a + n, r) - a - 1;
	}
};

Comp compX, compY;

int64 xs[MAX_N], ys[MAX_N], ds[MAX_N];
int n, k;

void readInput() {
	cin &gt;&gt; n &gt;&gt; k;
	for (int i = 0; i &lt; n; ++i) {
		int x, y;
		scanf("%d%d%lld", &amp;x, &amp;y, ds + i);
		xs[i] = x + y;
		ys[i] = x - y;
	}
}

struct Event {
	int x, y, add;
	int*ret;
	void asAdd(int _x, int _y, int _add) {
		x = _x;
		y = _y;
		add = _add;
		ret = 0;
	}
	void asAsk(int _x, int _y, int*_ret) {
		x = _x;
		y = _y;
		ret = _ret;
	}
	bool type() const {
		return ret != 0;
	}
	bool operator&lt;(const Event&amp;e) const {
		if (x != e.x)
			return x &lt; e.x;
		if (type() != e.type())
			return !type();
		if (y != e.y)
			return y &lt; e.y;
		return false;
	}
};

Event events[MAX_N * 5];
int nEvents;

int cnt[MAX_N];

struct TA {
	int a[MAX_N];
	int n;
	void init(int _n) {
		n = _n;
		memset(a, 0, sizeof a);
	}
	void add(int p, int x) {
		for (p++; p &lt;= n; p += p &amp; -p)
			a[p - 1] += x;
	}
	int calc(int p) {
		int ret = 0;
		for (p++; p &gt; 0; p -= p &amp; -p)
			ret += a[p - 1];
		return ret;
	}
};

TA ta;

void work() {
	compX.clear();
	compY.clear();
	for (int i = 0; i &lt; n; ++i) {
		compX.add(xs[i]);
		compY.add(ys[i]);
	}

	compX.doit();
	compY.doit();
	nEvents = 0;

	for (int i = 0; i &lt; n; ++i) {
		int64 Lx = xs[i] - ds[i], Rx = xs[i] + ds[i];
		int64 Ly = ys[i] - ds[i], Ry = ys[i] + ds[i];
		compX.comp(Lx, Rx);
		compY.comp(Ly, Ry);
		events[nEvents++].asAdd(Lx, Ly, 1);
		events[nEvents++].asAdd(Rx + 1, Ly, -1);
		events[nEvents++].asAdd(Lx, Ry + 1, -1);
		events[nEvents++].asAdd(Rx + 1, Ry + 1, 1);
	}

	for (int i = 0; i &lt; n; ++i) {
		int64 x = xs[i], y = ys[i];
		compX.comp(x);
		compY.comp(y);
		events[nEvents++].asAsk(x, y, cnt + i);
	}

	sort(events, events + nEvents);

	ta.init(compY.n);

	for (int i = 0; i &lt; nEvents; ++i) {
		Event&amp;e = events[i];
		if (e.type()) {
			*e.ret = ta.calc(e.y);
		} else {
			ta.add(e.y, e.add);
		}
	}

	static int ans[MAX_N];
	int nAns = 0;

	for (int i = 0; i &lt; n; ++i) {
		if (cnt[i] &gt;= k + 1)
			ans[nAns++] = i + 1;
	}

	printf("%d\n", nAns);
	bool first = true;
	for (int i = 0; i &lt; nAns; ++i) {
		if (!first)
			printf(" ");
		first = false;
		printf("%d", ans[i]);
	}
	printf("\n");
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem2235</h2><pre>/*
 * Tower.cpp
 *
 *  Created on: 2011-4-5
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_NODES = 500 + 10;

int x[MAX_N_NODES], y[MAX_N_NODES];
int range[MAX_N_NODES], score[MAX_N_NODES];

int nNodes;

int dist2(int i, int j) {
	int dx = x[i] - x[j];
	int dy = y[i] - y[j];
	return dx * dx + dy * dy;
}

inline void scanInt(int&amp;x) {
	//	char ch;
	//	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
	//		;
	//	x = ch - '0';
	//	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
	//		x = x * 10 + ch - '0';
	scanf("%d", &amp;x);
}

bool can(int i, int j) {
	return dist2(i, j) &lt;= range[i] * range[i];
}

const int INF = 1 &lt;&lt; 29;
struct Network {
	static const int MAX_N_VETS = MAX_N_NODES;
	static const int MAX_N_EDGES = 1000000;

	int head[MAX_N_VETS];
	int dest[MAX_N_EDGES], cap[MAX_N_EDGES], next[MAX_N_EDGES];

	int nVets, nEdges;
	int vs, vt;

	void init(int _nVets, int _vs, int _vt) {
		nVets = _nVets;
		vs = _vs;
		vt = _vt;
		memset(head, -1, sizeof head);
		nEdges = 0;
	}

	void makeEdge(int s, int t, int c) {
		int id = nEdges++;
		next[id] = head[s];
		dest[id] = t;
		cap[id] = c;
		head[s] = id;
	}

	void addEdge(int s, int t, int c) {
		makeEdge(s, t, c);
		makeEdge(t, s, 0);
	}

	int am[MAX_N_VETS], prev[MAX_N_VETS], h[MAX_N_VETS], cnt[MAX_N_VETS],
			cur[MAX_N_VETS];
	int totalFlow;

	int calcMaxFlow() {
		memset(am, 0, sizeof am);
		memset(cur, -1, sizeof cur);
		memset(h, 0, sizeof h);
		memset(cnt, 0, sizeof cnt);
		cnt[0] = nVets;
		int u = vs, now;
		totalFlow = 0;
		am[u] = INF;
		while (h[vs] &lt; nVets) {
			for (now = cur[u]; now != -1; now = next[now])
				if (cap[now] &gt; 0 &amp;&amp; h[u] == h[dest[now]] + 1)
					break;
			if (now != -1) {
				int v = dest[now];
				cur[u] = prev[v] = now;
				am[v] = min(am[u], cap[now]);
				u = v;
				if (u == vt) {
					int by = am[u];
					while (u != vs) {
						cap[prev[u]] -= by;
						cap[prev[u] ^ 1] += by;
						u = dest[prev[u] ^ 1];
					}
					totalFlow += by;
					am[u] = INF;
				}
			} else {
				if (!--cnt[h[u]])
					break;
				h[u] = nVets;
				for (now = head[u]; now != -1; now = next[now])
					if (cap[now] &gt; 0 &amp;&amp; h[dest[now]] + 1 &lt; h[u]) {
						h[u] = h[dest[now]] + 1;
						cur[u] = now;
					}
				++cnt[h[u]];
				if (u != vs)
					u = dest[prev[u] ^ 1];
			}
		}

		return totalFlow;
	}
};

void inputData() {
	scanInt(nNodes);
	for (int i = 0; i &lt; nNodes; ++i) {
		scanInt(x[i]);
		scanInt(y[i]);
		scanInt(range[i]);
		scanInt(score[i]);
	}
}

Network network;

void work() {
	int nV = nNodes;
	int vs = nV++, vt = nV++;
	network.init(nV, vs, vt);

	int ans = 0;

	for (int i = 0; i &lt; nNodes; ++i) {
		if (score[i] &gt; 0) {
			network.addEdge(vs, i, score[i]);
			ans += score[i];
		} else
			network.addEdge(i, vt, -score[i]);
		for (int j = 0; j &lt; nNodes; ++j) {
			if (j != i &amp;&amp; can(i, j))
				network.addEdge(i, j, INF);
		}
	}

	ans -= network.calcMaxFlow();
	printf("%d", ans);
}

int main() {
	//	freopen("in", "r", stdin);
	//	freopen("out", "w", stdout);
	int nT;
	scanInt(nT);
	for (int i = 1; i &lt;= nT; ++i) {
		printf("Case #%d:", i);
		inputData();
		work();
		if (i != nT)
			printf("\n");
	}
}
</pre><pre></pre><h2>Problem2237</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include &lt;climits&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define OK cout&lt;&lt;"-----------------"&lt;&lt;endl;
#define Debug(x) cout&lt;&lt;#x&lt;&lt;"="&lt;&lt;x&lt;&lt;endl;
using namespace std;
const int MaxVet = 100000 + 100;
typedef long long LL;

struct TGraph {
	static const int MaxEdge = MaxVet * 2;
	int head[MaxVet], Vet;
	int next[MaxEdge], dest[MaxEdge], Mnt;

	void Clear(int _Vet) {
		Vet = _Vet;
		memset(head, -1, sizeof(int) * Vet);
		Mnt = 0;
	}

	void AddEdge(int s, int t) {
		next[Mnt] = head[s];
		dest[Mnt] = t;
		head[s] = Mnt++;
	}

	void InsEdge(int s, int t) {
		AddEdge(s, t);
		AddEdge(t, s);
	}
};
#define tr(e,G,u) for(int e=G.head[u];e!=-1;e=G.next[e])

TGraph Tree;

inline void Scan_Int(int&amp;t) {
	char c;
	while (c = getchar(), c &lt; '0' || c &gt; '9')
		;
	t = c - '0';
	while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9')
		t = t * 10 + c - '0';
}

void Input_Data() {
	int Vet, s, t;
	Scan_Int(Vet);
	Tree.Clear(Vet);
	//Debug(Vet);

	rep(i,Vet-1) {
		Scan_Int(s);
		Scan_Int(t);
		--s;
		--t;
		Tree.InsEdge(s, t);
	}
}

int Ord[MaxVet], Father[MaxVet];
int Vis[MaxVet] = { }, Flag = 0;

int BFS(int*Q, int vs, int cut = -1)//return the last point
{
	++Flag;

	int h = 0, t = 0;
	Q[t++] = vs;
	Vis[vs] = Flag;
	Father[vs] = -1;
	if (cut &gt;= 0)
		Vis[cut] = Flag;

	for (; h &lt; t; h++) {
		int u = Q[h];
		tr(e,Tree,u) {
			int v = Tree.dest[e];
			if (Vis[v] == Flag)
				continue;
			Vis[v] = Flag;
			Q[t++] = v;
			Father[v] = u;
		}
	}

	return Q[t - 1];
}

struct DistSet {
	static const int MaxSaved = 3;
	int A[MaxSaved + 1];

	void Clear() {
		rep(i,MaxSaved)
			A[i] = 0;
	}

	void Add_Item(int x) {
		for (int i = MaxSaved - 1; i &gt;= 0; i--) {
			if (x &gt; A[i]) {
				A[i + 1] = A[i];
			} else {
				A[i + 1] = x;
				return;
			}
		}
		A[0] = x;
	}

	int Get_Result_Two(int dist = -1) {
		int ret = A[0] + A[1] + A[2];
		if (A[0] == dist)
			return ret - A[0];
		if (A[1] == dist)
			return ret - A[1];
		return ret - A[2];
	}

	int Get_Result_One(int dist) {
		if (A[0] == dist)
			return A[1];
		return A[0];
	}

	int Get_Max() {
		return A[0];
	}
};

DistSet Sets[MaxVet];

int LongestPathDown[MaxVet];
int LongestPathUp[MaxVet];
int MaxDistUp[MaxVet];

void Calc_DistSet() {
	for (int it = Tree.Vet - 1; it &gt;= 0; it--) {
		int u = Ord[it];
		DistSet&amp;Set = Sets[u];
		Set.Clear();

		tr(e,Tree,u) {
			int v = Tree.dest[e];
			if (v == Father[u])
				continue;
			Set.Add_Item(Sets[v].Get_Max() + 1);
		}
	}
}

inline void UpdateMax(int&amp;x, int c) {
	if (x &lt; c)
		x = c;
}

int FindPoint(int u, int fa) {
	static int Path[MaxVet], Cnt;

	int v = BFS(Ord, u, fa);
	int w = BFS(Ord, v, fa);
	Cnt = 0;
	do {
		Path[Cnt++] = w;
		w = Father[w];
	} while (w != -1);

	//cout&lt;&lt;"Max Len is:"&lt;&lt;Cnt-1&lt;&lt;endl;

	return Path[Cnt / 2];
}

DistSet RetSets[MaxVet];
void Dp() {
	//Calc the Down
	for (int it = Tree.Vet - 1; it &gt;= 0; it--) {
		int u = Ord[it];
		LongestPathDown[u] = Sets[u].Get_Result_Two();

		RetSets[u].Clear();
		tr(e,Tree,u) {
			int v = Tree.dest[e];
			if (v == Father[u])
				continue;

			RetSets[u].Add_Item(LongestPathDown[v]);
			UpdateMax(LongestPathDown[u], LongestPathDown[v]);
		}
	}

	//Calc The Up
	for (int it = 0; it &lt; Tree.Vet; it++) {
		int u = Ord[it];
		int fa = Father[u];

		if (fa != -1) {
			LongestPathUp[u] = LongestPathUp[fa];

			MaxDistUp[u] = MaxDistUp[fa] + 1;
			UpdateMax(MaxDistUp[u], Sets[fa].Get_Result_One(Sets[u].Get_Max()
					+ 1) + 1);

			UpdateMax(LongestPathUp[u], MaxDistUp[fa]
					+ Sets[fa].Get_Result_One(Sets[u].Get_Max() + 1));
			UpdateMax(LongestPathUp[u], Sets[fa].Get_Result_Two(
					Sets[u].Get_Max() + 1));
			UpdateMax(LongestPathUp[u], RetSets[fa].Get_Result_One(
					LongestPathDown[u]));
		} else {
			LongestPathUp[u] = 0;
			MaxDistUp[u] = 0;
		}
	}

	//Calc Ans
	int Ans = INT_MAX;

#define half(x) ((x)+1)/2

	rep(u,Tree.Vet) {
		//cout&lt;&lt;u+1&lt;&lt;":"&lt;&lt;LongestPathUp[u]&lt;&lt;endl;
		int fa = Father[u];
		if (fa == -1)
			continue;

		int UpMax = LongestPathUp[u];
		int DownMax = LongestPathDown[u];

		int ret = max(UpMax, DownMax);
		int tmp = half(UpMax) + half(DownMax) + 1;
		if (tmp &gt; ret)
			ret = tmp;
		if (ret &lt; Ans)
			Ans = ret;
	}

	cout &lt;&lt; Ans &lt;&lt; endl;
}

void Work() {
	BFS(Ord, 0);
	Calc_DistSet();
	Dp();
}

void Solve() {
	Input_Data();
	Work();
}

int main() {
	//freopen("in","r",stdin);
	Solve();
}
</pre><pre></pre><h2>Problem2238</h2><pre>/*
 * Mst.cpp
 *
 *  Created on: 2011-4-5
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VETS = 50000 + 10;
const int MAX_N_EDGES = 100000 + 10;
const int INF = ~0U &gt;&gt; 1;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

struct Edge {
	int s, t, c, id;
	bool isTreeEdge;
	int ans;
	void read(int _id) {
		id = _id;
		scanInt(s);
		scanInt(t);
		scanInt(c);
		--s;
		--t;
		isTreeEdge = false;
		ans = INT_MAX;
	}
	int other(int u) {
		return s + t - u;
	}
};

Edge edges[MAX_N_EDGES];

vector&lt;Edge*&gt; adj[MAX_N_VETS];

int nVets, nEdges;

void inputData() {
	scanInt(nVets);
	scanInt(nEdges);
	for (int i = 0; i &lt; nEdges; ++i) {
		edges[i].read(i);
		Edge*e = edges + i;
		adj[e-&gt;s].push_back(e);
		adj[e-&gt;t].push_back(e);
	}
}

Edge*ord[MAX_N_EDGES];

bool cmpEdge(Edge*a, Edge*b) {
	return a-&gt;c &lt; b-&gt;c;
}

struct UF {
	int F[MAX_N_VETS];
	void init(int n) {
		for (int i = 0; i &lt; n; ++i) {
			F[i] = i;
		}
	}
	int find(int x) {
		if (x == F[x])
			return x;
		return F[x] = find(F[x]);
	}
	bool unite(int a, int b) {
		a = find(a);
		b = find(b);
		F[a] = b;
		return a != b;
	}
};

UF U;

void buildMST() {
	for (int i = 0; i &lt; nEdges; ++i) {
		ord[i] = edges + i;
	}
	sort(ord, ord + nEdges, cmpEdge);

	U.init(nVets);
	for (int i = 0; i &lt; nEdges; ++i) {
		Edge*e = ord[i];
		if (U.unite(e-&gt;s, e-&gt;t)) {
			e-&gt;isTreeEdge = true;
		}
	}
}

const int MAX_LOG = 20;

Edge*prev[MAX_N_VETS];
int anc[MAX_N_VETS][MAX_LOG];
int dep[MAX_N_VETS];

void dfs(int u, int fa, int d) {
	anc[u][0] = fa;
	dep[u] = d;
	for (int me = 0; me &lt; MAX_LOG; ++me) {
		int at = anc[u][me];
		if (at == -1)
			break;
		anc[u][me + 1] = anc[at][me];
	}

	foreach(iter,adj[u]) {
		Edge*e = *iter;
		int v = e-&gt;other(u);
		if (!e-&gt;isTreeEdge || v == fa)
			continue;
		prev[v] = e;
		dfs(v, u, d + 1);
	}
}

void prepareLca() {
	memset(anc, -1, sizeof anc);
	dfs(0, -1, 0);
}

int askLca(int u, int v) {
	if (dep[u] &lt; dep[v])
		swap(u, v);
	for (int me = MAX_LOG - 1; me &gt;= 0; --me) {
		if (dep[u] - (1 &lt;&lt; me) &gt;= dep[v])
			u = anc[u][me];
	}
	if (u == v)
		return u;

	for (int me = MAX_LOG - 1; me &gt;= 0; --me) {
		int nu = anc[u][me];
		int nv = anc[v][me];
		if (nu != nv)
			u = nu, v = nv;
	}
	return anc[u][0];
}

void markHalf(int u, int v, int what) {
	for (;;) {
		u = U.find(u);
		if (dep[u] &lt;= dep[v])
			break;
		prev[u]-&gt;ans = what;
		U.unite(u, prev[u]-&gt;other(u));
	}
}

void mark(int u, int v, int what) {
	int lca = askLca(u, v);
	markHalf(u, lca, what);
	markHalf(v, lca, what);
}

void calcAns() {
	U.init(nVets);
	int edgeSum = 0;
	for (int me = 0; me &lt; nEdges; ++me) {
		Edge*e = ord[me];
		if (e-&gt;isTreeEdge) {
			edgeSum += e-&gt;c;
		} else {
			mark(e-&gt;s, e-&gt;t, e-&gt;c);
		}
	}

	for (int me = 0; me &lt; nEdges; ++me) {
		Edge*e = ord[me];
		if (e-&gt;isTreeEdge) {
			if (e-&gt;ans == INF)
				e-&gt;ans = -1;
			else
				e-&gt;ans = e-&gt;ans + edgeSum - e-&gt;c;
		} else {
			e-&gt;ans = edgeSum;
		}
	}
}

void answer() {
	int nQ;
	scanf("%d", &amp;nQ);
	for (int me = 0; me &lt; nQ; ++me) {
		int which;
		scanf("%d", &amp;which);
		--which;
		int ans = edges[which].ans;
		if (ans == -1)
			puts("Not connected");
		else
			printf("%d\n", ans);
	}
}

void solve() {
	inputData();
	buildMST();
	prepareLca();
	calcAns();
	answer();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2238</h2><pre>/*
 * Mst.cpp
 *
 *  Created on: 2011-4-5
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VETS = 50000 + 10;
const int MAX_N_EDGES = 100000 + 10;
const int INF = ~0U &gt;&gt; 1;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

struct Edge {
	int s, t, c, id;
	bool isTreeEdge;
	int ans;
	void read(int _id) {
		id = _id;
		scanInt(s);
		scanInt(t);
		scanInt(c);
		--s;
		--t;
		isTreeEdge = false;
		ans = INT_MAX;
	}
	int other(int u) {
		return s + t - u;
	}
};

Edge edges[MAX_N_EDGES];

vector&lt;Edge*&gt; adj[MAX_N_VETS];

int nVets, nEdges;

void inputData() {
	scanInt(nVets);
	scanInt(nEdges);
	for (int i = 0; i &lt; nEdges; ++i) {
		edges[i].read(i);
		Edge*e = edges + i;
		adj[e-&gt;s].push_back(e);
		adj[e-&gt;t].push_back(e);
	}
}

Edge*ord[MAX_N_EDGES];

bool cmpEdge(Edge*a, Edge*b) {
	return a-&gt;c &lt; b-&gt;c;
}

struct UF {
	int F[MAX_N_VETS];
	void init(int n) {
		for (int i = 0; i &lt; n; ++i) {
			F[i] = i;
		}
	}
	int find(int x) {
		if (x == F[x])
			return x;
		return F[x] = find(F[x]);
	}
	bool unite(int a, int b) {
		a = find(a);
		b = find(b);
		F[a] = b;
		return a != b;
	}
};

UF U;

void buildMST() {
	for (int i = 0; i &lt; nEdges; ++i) {
		ord[i] = edges + i;
	}
	sort(ord, ord + nEdges, cmpEdge);

	U.init(nVets);
	for (int i = 0; i &lt; nEdges; ++i) {
		Edge*e = ord[i];
		if (U.unite(e-&gt;s, e-&gt;t)) {
			e-&gt;isTreeEdge = true;
		}
	}
}

Edge*prev[MAX_N_VETS];
int dep[MAX_N_VETS];

void dfs(int u, int fa, int d) {
	dep[u] = d;

	foreach(iter,adj[u]) {
		Edge*e = *iter;
		int v = e-&gt;other(u);
		if (!e-&gt;isTreeEdge || v == fa)
			continue;
		prev[v] = e;
		dfs(v, u, d + 1);
	}
}

void mark(int u, int v, int what) {
	u = U.find(u);
	v = U.find(v);
	while (u != v) {
		if (dep[u] &lt; dep[v])
			swap(u, v);
		prev[u]-&gt;ans = what;
		U.unite(u, prev[u]-&gt;other(u));
		u = U.find(u);
	}
}

void calcAns() {
	dfs(0, -1, 0);

	U.init(nVets);
	int edgeSum = 0;
	for (int me = 0; me &lt; nEdges; ++me) {
		Edge*e = ord[me];
		if (e-&gt;isTreeEdge) {
			edgeSum += e-&gt;c;
		} else {
			mark(e-&gt;s, e-&gt;t, e-&gt;c);
		}
	}

	for (int me = 0; me &lt; nEdges; ++me) {
		Edge*e = ord[me];
		if (e-&gt;isTreeEdge) {
			if (e-&gt;ans == INF)
				e-&gt;ans = -1;
			else
				e-&gt;ans = e-&gt;ans + edgeSum - e-&gt;c;
		} else {
			e-&gt;ans = edgeSum;
		}
	}
}

void answer() {
	int nQ;
	scanf("%d", &amp;nQ);
	for (int me = 0; me &lt; nQ; ++me) {
		int which;
		scanf("%d", &amp;which);
		--which;
		int ans = edges[which].ans;
		if (ans == -1)
			puts("Not connected");
		else
			printf("%d\n", ans);
	}
}

void solve() {
	inputData();
	buildMST();
	calcAns();
	answer();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2242</h2><pre>/*
 *  [SDOI2011]计算器.cpp
 *
 *  Created on: 2011-4-11
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;utility&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

typedef long long int64;

int64 powMod(int64 x, int64 e, int64 mod) {
	if (!e)
		return 1;
	if (e &amp; 1)
		return powMod(x, e - 1, mod) * x % mod;
	return powMod(x * x % mod, e &gt;&gt; 1, mod);
}

int64 inv(int64 x, int64 mod) {
	return powMod(x, mod - 2, mod);
}

int64 solve2(int y, int z, int mod) {
	//x*y = z(%mod)
	y %= mod;
	z %= mod;
	if (y == 0) {
		if (z == 0)
			return 0;
		return -1;
	}
	return inv(y, mod) * z % mod;
}

struct staticMap {
	static const int MAX_MEM = 1000000;
	pair&lt;int, int&gt; data[MAX_MEM];
	int n;

	void clear() {
		n = 0;
	}

	void add(int key, int value) {
		data[n++] = make_pair(key, value);
	}

	void start() {
		sort(data, data + n);

		int cur = 0;
		for (int i = 0; i &lt; n; ++i) {
			if (cur &gt; 0 &amp;&amp; data[cur - 1].first == data[i].first)
				continue;
			data[cur++] = data[i];
		}

		n = cur;
	}

	int ask(int key) {
		int at = lower_bound(data, data + n, make_pair(key, -1)) - data;
		if (data[at].first != key)
			return -1;
		return data[at].second;
	}
};

int64 solve3(int y, int z, int mod) {
	//y^x = z(%mod)
	static staticMap remainToId;
	remainToId.clear();

	//y^x = y^(T*a+b) = (y^T)^a * y ^b = z (%mod)

	int T = sqrt(mod) + 2;
	int64 step = powMod(y, T, mod);
	int64 cur = 1;//(y^T)^a
	for (int a = 0; a &lt; T; ++a) {
		remainToId.add(cur, a);
		(cur *= step) %= mod;
	}

	remainToId.start();
	cur = 1;//y^b

	int ans = -1;
	for (int b = 0; b &lt; T; ++b) {
		int64 tmp = solve2(cur, z, mod);
		int a = remainToId.ask(tmp);
		if (a != -1) {
			int tmp = a * T + b;
			if (ans == -1 || tmp &lt; ans)
				ans = tmp;
		}
		(cur *= y) %= mod;
	}

	return ans;
}

void help(int64 base, int64 mod) {
	int64 cur = 1;
	for (int i = 0; i &lt; mod; ++i) {
		cout &lt;&lt; cur &lt;&lt; " ";
		(cur *= base) %= mod;
	}
}

int main() {
	int nCase, type;
	scanf("%d%d", &amp;nCase, &amp;type);
	for (int i = 0; i &lt; nCase; ++i) {
		int y, z, mod;
		scanf("%d%d%d", &amp;y, &amp;z, &amp;mod);
		switch (type) {
		case 1: {
			cout &lt;&lt; powMod(y, z, mod) &lt;&lt; endl;
			break;
		}
		case 2: {
		}
		case 3: {
			int ret;
			if (type == 2)
				ret = solve2(y, z, mod);
			else
				ret = solve3(y, z, mod);
			if (ret == -1)
				puts("Orz, I cannot find x!");
			else
				printf("%d\n", ret);
			break;
		}
		}
	}
}
</pre><pre></pre><h2>Problem2243</h2><pre>/*
 *  [SDOI2011]染色.cpp
 *
 *  Created on: 2011-4-11
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;cstdlib&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Information {
	int leftColor, rightColor;
	int segmentCnt;

	void setSingle(int color) {
		leftColor = rightColor = color;
		segmentCnt = 1;
	}

	static Information nothing;

	Information() {
		segmentCnt = 0;
	}

	bool isNothing() const {
		return segmentCnt == 0;
	}

	void debug() {
		cout &lt;&lt; leftColor &lt;&lt; "-" &lt;&lt; rightColor &lt;&lt; endl;
		cout &lt;&lt; "cnt:" &lt;&lt; segmentCnt &lt;&lt; endl;
	}
};

Information operator+(const Information&amp;infoLeft, const Information&amp;infoRight) {
	if (infoLeft.isNothing())
		return infoRight;
	if (infoRight.isNothing())
		return infoLeft;
	Information ret;
	ret.segmentCnt = infoLeft.segmentCnt + infoRight.segmentCnt;
	ret.leftColor = infoLeft.leftColor;
	ret.rightColor = infoRight.rightColor;
	if (infoLeft.rightColor == infoRight.leftColor)
		ret.segmentCnt--;
	return ret;
}

Information Information::nothing;

struct Tree {
	Tree*ch[2];
	int left, right;
	Information information;
	int sameColor;
	bool isSame;

	void update() {
		if (ch[0] == 0)
			return;
		information = ch[0]-&gt;information + ch[1]-&gt;information;
	}

	void apply(int color) {
		isSame = true;
		sameColor = color;
		information.setSingle(color);
	}

	void relax() {
		if (ch[0] == 0)
			return;
		if (isSame) {
			ch[0]-&gt;apply(sameColor);
			ch[1]-&gt;apply(sameColor);
			isSame = false;
		}
	}

	Tree(int seq[], int segLeft, int segRight) {
		left = segLeft;
		right = segRight;
		isSame = false;
		if (left + 1 == right) {
			ch[0] = ch[1] = 0;
			information.setSingle(seq[left]);
			return;
		}

		int mid = (left + right) &gt;&gt; 1;
		ch[0] = new Tree(seq, left, mid);
		ch[1] = new Tree(seq, mid, right);
		update();
	}

	Information ask(int segLeft, int segRight) {
		if (right &lt;= segLeft || segRight &lt;= left)
			return Information::nothing;
		if (segLeft &lt;= left &amp;&amp; segRight &gt;= right)
			return information;
		relax();
		return ch[0]-&gt;ask(segLeft, segRight) + ch[1]-&gt;ask(segLeft, segRight);
	}

	void makeSame(int segLeft, int segRight, int color) {
		if (right &lt;= segLeft || segRight &lt;= left)
			return;
		if (segLeft &lt;= left &amp;&amp; segRight &gt;= right) {
			apply(color);
			return;
		}
		relax();
		for (int c = 0; c &lt; 2; ++c) {
			ch[c]-&gt;makeSame(segLeft, segRight, color);
		}
		update();
	}
};

const int MAX_N_VERTEXS = 100000 + 10;
int nVertexs;
int size[MAX_N_VERTEXS];
int color[MAX_N_VERTEXS];
int depth[MAX_N_VERTEXS];

int ordInPath[MAX_N_VERTEXS];
int pathId[MAX_N_VERTEXS];

int bfsOrd[MAX_N_VERTEXS], father[MAX_N_VERTEXS];

vector&lt;int&gt; adj[MAX_N_VERTEXS];

Tree*path[MAX_N_VERTEXS];

int pathColor[MAX_N_VERTEXS];

void doBFS(int vs) {
	father[vs] = -1;
	int qh = 0, qt = 0;
	int*que = bfsOrd;
	que[qt++] = vs;
	depth[vs] = 0;
	while (qh &lt; qt) {
		int u = que[qh++];
		foreach(iter,adj[u]) {
			int v = *iter;
			if (v == father[u])
				continue;
			que[qt++] = v;
			father[v] = u;
			depth[v] = depth[u] + 1;
		}
	}
}

void doPathSplit() {
	memset(pathId, -1, sizeof pathId);
	for (int at = nVertexs - 1; at &gt;= 0; --at) {
		int u = bfsOrd[at];
		size[u] = 1;
		foreach(iter,adj[u]) {
			int v = *iter;
			if (v == father[u])
				continue;
			size[u] += size[v];
		}
	}

	for (int at = 0; at &lt; nVertexs; ++at) {
		int top = bfsOrd[at];
		if (pathId[top] != -1)
			continue;

		int cnt = 0;
		for (int u = top; u != -1;) {
			int next = -1;
			pathId[u] = top;
			ordInPath[u] = cnt;
			pathColor[cnt] = color[u];
			++cnt;

			foreach(iter,adj[u]) {
				int v = *iter;
				if (v == father[u])
					continue;
				if (next == -1 || size[v] &gt; size[next])
					next = v;
			}

			u = next;
		}

		path[top] = new Tree(pathColor, 0, cnt);
	}
}

void makeSamePath(int u, int v, int color) {

	for (;;) {
		if (pathId[u] == pathId[v]) {
			if (ordInPath[u] &gt; ordInPath[v])
				swap(u, v);
			int top = pathId[u];
			path[top]-&gt;makeSame(ordInPath[u], ordInPath[v] + 1, color);
			return;
		} else {
			if (depth[pathId[u]] &lt; depth[pathId[v]]) {
				swap(u, v);
			}
			int top = pathId[u];
			path[top]-&gt;makeSame(ordInPath[top], ordInPath[u] + 1, color);
			u = father[top];
		}
	}
}

Information askPath(int u, int v) {
	Information infoU, infoV;
	for (;;) {
		if (pathId[u] == pathId[v]) {
			int ordU = ordInPath[u];
			int ordV = ordInPath[v];

			int left = min(ordU, ordV), right = max(ordU, ordV);
			int top = pathId[u];
			Information infoMid = path[top]-&gt;ask(left, right + 1);
			if (ordU == right)
				infoU = infoMid + infoU;
			else
				infoV = infoMid + infoV;

			swap(infoV.leftColor, infoV.rightColor);
			return infoV + infoU;
		} else {
			if (depth[pathId[u]] &gt; depth[pathId[v]]) {
				int top = pathId[u];
				infoU = path[top]-&gt;ask(ordInPath[top], ordInPath[u] + 1)
						+ infoU;
				u = father[top];
			} else {
				int top = pathId[v];
				infoV = path[top]-&gt;ask(ordInPath[top], ordInPath[v] + 1)
						+ infoV;
				v = father[top];
			}
		}
	}

	return Information::nothing;
}

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

int nQueries;

void readInput() {
	scanInt(nVertexs);
	scanInt(nQueries);
	for (int i = 0; i &lt; nVertexs; ++i) {
		scanInt(color[i]);
		adj[i].clear();
	}

	for (int edgeId = 0; edgeId &lt; nVertexs - 1; ++edgeId) {
		int s, t;
		scanInt(s);
		scanInt(t);
		--s;
		--t;
		adj[s].push_back(t);
		adj[t].push_back(s);
	}
}

void prepare() {
	doBFS(0);
	doPathSplit();
}

void answerQueries() {
	for (int me = 0; me &lt; nQueries; ++me) {
		char cmd;
		scanf(" ");
		scanf("%c", &amp;cmd);
		if (cmd == 'C') {
			int u, v, color;
			scanInt(u);
			scanInt(v);
			scanInt(color);
			--u;
			--v;
			makeSamePath(u, v, color);
		} else {
			int u, v;
			scanInt(u);
			scanInt(v);
			--u;
			--v;
			Information ret = askPath(u, v);
			printf("%d\n", ret.segmentCnt);
		}
	}
}

int main() {
	readInput();
	prepare();
	answerQueries();
}
</pre><pre></pre><h2>Problem2247</h2><pre>/*
 *  Pku3900 The Robbery.cpp
 *
 *  Created on: 2011-4-8
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

#define SEARCH_IN_REVERSE;
//#define COMPARE_BY_NUM;
//#define COMPARE_BY_WEIGHT;
#define COMPARE_BY_ALPHA;

typedef long long int64;

int n;
int64 maxWeight;

const int MAX_N = 15 + 10;

struct Item {
	int64 weight, value;
	int num;

	bool operator&lt;(const Item&amp;item) const {
#ifdef COMPARE_BY_WEIGHT
		return weight &gt; item.weight;
#endif
#ifdef COMPARE_BY_NUM
		return num &gt; item.num;
#endif
#ifdef COMPARE_BY_ALPHA
		return alpha() &gt; item.alpha();
#endif
	}

	double alpha() const {
		return (1.0 * value) / weight;
	}
};

Item items[MAX_N];
int64 sumWeight[MAX_N] = { };
int64 sumValue[MAX_N] = { };

double maxAlpha[MAX_N];

void inputData() {
	cin &gt;&gt; n &gt;&gt; maxWeight;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; items[i].weight;
	}
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; items[i].value;
	}
	for (int i = 0; i &lt; n; ++i) {
		items[i].num = i + 1;
	}
}

void prepare() {
	sort(items, items + n);
	memset(sumWeight, 0, sizeof sumWeight);
	memset(sumValue, 0, sizeof sumValue);
	memset(maxAlpha, 0, sizeof maxAlpha);

	for (int i = n - 1; i &gt;= 0; --i) {
		sumWeight[i] = items[i].weight * items[i].num + sumWeight[i + 1];
		sumValue[i] = items[i].value * items[i].num + sumValue[i + 1];
		maxAlpha[i] = max(maxAlpha[i + 1], items[i].alpha());
	}
}

int64 ans;

void rec(int cur, int64 weight, int64 value) {
	if (value + sumValue[cur] &lt;= ans)
		return;

	if (weight + sumWeight[cur] &lt;= maxWeight) {
		ans = value + sumValue[cur];
		return;
	}

	if (value + (maxWeight - weight) * maxAlpha[cur] &lt;= ans) {
		return;
	}

	if (cur == n)
		return;

	Item&amp;item = items[cur];

#ifdef SEARCH_IN_REVERSE
	for (int get = item.num; get &gt;= 0; --get) {
		if (get * item.weight + weight &lt;= maxWeight) {
			int64 nweight = get * item.weight + weight;
			int64 nvalue = get * item.value + value;
			rec(cur + 1, nweight, nvalue);
		}
	}
#else
	for (int get = 0; get &lt;= item.num; ++get) {
		if (get * item.weight + weight &gt; maxWeight)
		break;
		int64 nweight = get * item.weight + weight;
		int64 nvalue = get * item.value + value;
		rec(cur + 1, nweight, nvalue);
	}
#endif
}

void work() {
	prepare();
	ans = 0;
	rec(0, 0, 0);
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	int nT;
	cin &gt;&gt; nT;
	while (nT--) {
		inputData();
		work();
	}
}
</pre><pre></pre><h2>Problem2247</h2><pre>/*
 *  Pku3900 The Robbery.cpp
 *
 *  Created on: 2011-4-8
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

#define SEARCH_IN_REVERSE;
//#define COMPARE_BY_NUM;
//#define COMPARE_BY_WEIGHT;
#define COMPARE_BY_ALPHA;

typedef long long int64;

int n;
int64 maxWeight;

const int MAX_N = 15 + 10;

struct Item {
	int64 weight, value;
	int num;

	double alpha;

	bool operator&lt;(const Item&amp;item) const {
#ifdef COMPARE_BY_WEIGHT
		return weight &gt; item.weight;
#endif
#ifdef COMPARE_BY_NUM
		return num &gt; item.num;
#endif
#ifdef COMPARE_BY_ALPHA
		return alpha &gt; item.alpha;
#endif
	}

	void setAlpha() {
		alpha = 1.0 * value / weight;
	}
};

Item items[MAX_N];
int64 sumWeight[MAX_N] = { };
int64 sumValue[MAX_N] = { };

double maxAlpha[MAX_N];

void inputData() {
	cin &gt;&gt; n &gt;&gt; maxWeight;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; items[i].weight;
	}
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; items[i].value;
	}
	for (int i = 0; i &lt; n; ++i) {
		items[i].num = i + 1;
	}
}

void prepare() {
	for (int i = 0; i &lt; n; ++i) {
		items[i].setAlpha();
	}
	sort(items, items + n);
	memset(sumWeight, 0, sizeof sumWeight);
	memset(sumValue, 0, sizeof sumValue);
	memset(maxAlpha, 0, sizeof maxAlpha);

	for (int i = n - 1; i &gt;= 0; --i) {
		sumWeight[i] = items[i].weight * items[i].num + sumWeight[i + 1];
		sumValue[i] = items[i].value * items[i].num + sumValue[i + 1];
	}
}

int64 ans;

const int MAX_SEARCH_TIME = 5000000;

int searchTime;

double esitimate(int cur, int64 restWeight) {
	double value = 0;
	for (;;) {
		int64 w = items[cur].weight * items[cur].num;
		if (restWeight &gt;= w) {
			value += items[cur].value * items[cur].num;
			restWeight -= w;
		} else {
			value += restWeight * items[cur].alpha;
			break;
		}
		++cur;
	}
	return value;
}

void rec(int cur, int64 weight, int64 value) {
#ifdef CUT_SEARCH_TIME
	if (++searchTime &gt; MAX_SEARCH_TIME)
	return;
#endif
	if (value + sumValue[cur] &lt;= ans)
		return;

	if (weight + sumWeight[cur] &lt;= maxWeight) {
		ans = value + sumValue[cur];
		return;
	}

	if (value + esitimate(cur, maxWeight - weight) &lt;= ans) {
		return;
	}

	if (cur == n)
		return;

	Item&amp;item = items[cur];

#ifdef SEARCH_IN_REVERSE
	for (int get = item.num; get &gt;= 0; --get) {
		if (get * item.weight + weight &lt;= maxWeight) {
			int64 nweight = get * item.weight + weight;
			int64 nvalue = get * item.value + value;
			rec(cur + 1, nweight, nvalue);
		}
	}
#else
	for (int get = 0; get &lt;= item.num; ++get) {
		if (get * item.weight + weight &gt; maxWeight)
		break;
		int64 nweight = get * item.weight + weight;
		int64 nvalue = get * item.value + value;
		rec(cur + 1, nweight, nvalue);
	}
#endif
}

void work() {
	prepare();
	ans = 0;
#ifdef CUT_SEARCH_TIME
	searchTime = 0;
#endif
	rec(0, 0, 0);
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	int nT;
	cin &gt;&gt; nT;
	while (nT--) {
		inputData();
		work();
	}
}
</pre><pre></pre><h2>Problem2247</h2><pre>/*
 *  Pku3900 The Robbery.cpp
 *
 *  Created on: 2011-4-8
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

#define SEARCH_IN_REVERSE;
//#define COMPARE_BY_NUM;
//#define COMPARE_BY_WEIGHT;
#define COMPARE_BY_ALPHA;

typedef long long int64;

int n;
int64 maxWeight;

const int MAX_N = 15 + 10;

struct Item {
	int64 weight, value;
	int64 sweight, svalue;
	int num;

	double alpha;

	bool operator&lt;(const Item&amp;item) const {
#ifdef COMPARE_BY_WEIGHT
		return weight &gt; item.weight;
#endif
#ifdef COMPARE_BY_NUM
		return num &gt; item.num;
#endif
#ifdef COMPARE_BY_ALPHA
		return alpha &gt; item.alpha;
#endif
	}

	void set() {
		alpha = 1.0 * value / weight;
		sweight = weight * num;
		svalue = value * num;
	}
};

Item items[MAX_N];
int64 sumWeight[MAX_N] = { };
int64 sumValue[MAX_N] = { };

double maxAlpha[MAX_N];

void inputData() {
	cin &gt;&gt; n &gt;&gt; maxWeight;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; items[i].weight;
	}
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; items[i].value;
	}
	for (int i = 0; i &lt; n; ++i) {
		items[i].num = i + 1;
	}
}

void prepare() {
	for (int i = 0; i &lt; n; ++i) {
		items[i].set();
	}
	sort(items, items + n);
	memset(sumWeight, 0, sizeof sumWeight);
	memset(sumValue, 0, sizeof sumValue);
	memset(maxAlpha, 0, sizeof maxAlpha);

	for (int i = n - 1; i &gt;= 0; --i) {
		sumWeight[i] = items[i].sweight + sumWeight[i + 1];
		sumValue[i] = items[i].svalue + sumValue[i + 1];
	}
}

int64 ans;

const int MAX_SEARCH_TIME = 5000000;

int searchTime;

inline int64 getSum(int64 sum[], int l, int r) {
	return sum[l] - sum[r + 1];
}

double esitimate(int cur, int&amp;toRight, int64 restWeight) {
	while (getSum(sumWeight, cur, toRight) &lt;= restWeight) {
		++toRight;
	}
	int64 value = getSum(sumValue, cur, toRight - 1);
	restWeight -= getSum(sumWeight, cur, toRight - 1);
	value += restWeight * items[cur].alpha;

	return value;
}

void rec(int cur, int toRight, int64 weight, int64 value) {
#ifdef CUT_SEARCH_TIME
	if (++searchTime &gt; MAX_SEARCH_TIME)
	return;
#endif
	if (value + sumValue[cur] &lt;= ans)
		return;

	if (weight + sumWeight[cur] &lt;= maxWeight) {
		ans = value + sumValue[cur];
		return;
	}

	if (value + esitimate(cur, toRight, maxWeight - weight) &lt;= ans) {
		return;
	}

	if (cur == n)
		return;

	Item&amp;item = items[cur];

#ifdef SEARCH_IN_REVERSE
	for (int get = item.num; get &gt;= 0; --get) {
		if (get * item.weight + weight &lt;= maxWeight) {
			int64 nweight = get * item.weight + weight;
			int64 nvalue = get * item.value + value;
			rec(cur + 1, toRight, nweight, nvalue);
		}
	}
#else
	for (int get = 0; get &lt;= item.num; ++get) {
		if (get * item.weight + weight &gt; maxWeight)
		break;
		int64 nweight = get * item.weight + weight;
		int64 nvalue = get * item.value + value;
		rec(cur + 1, nweight, nvalue);
	}
#endif
}

void work() {
	prepare();
	ans = 0;
#ifdef CUT_SEARCH_TIME
	searchTime = 0;
#endif
	rec(0, 0, 0, 0);
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	int nT;
	cin &gt;&gt; nT;
	while (nT--) {
		inputData();
		work();
	}
}
</pre><pre></pre><h2>Problem2247</h2><pre>/*
 *  Pku3900 The Robbery.cpp
 *
 *  Created on: 2011-4-8
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

#define SEARCH_IN_REVERSE;
//#define COMPARE_BY_NUM;
//#define COMPARE_BY_WEIGHT;
#define COMPARE_BY_ALPHA;

typedef long long int64;

int n;
int64 maxWeight;

const int MAX_N = 15 + 10;

struct Item {
	int64 weight, value;
	int64 sweight, svalue;
	int num;

	double alpha;

	bool operator&lt;(const Item&amp;item) const {
#ifdef COMPARE_BY_WEIGHT
		return weight &gt; item.weight;
#endif
#ifdef COMPARE_BY_NUM
		return num &gt; item.num;
#endif
#ifdef COMPARE_BY_ALPHA
		return alpha &gt; item.alpha;
#endif
	}

	void set() {
		alpha = 1.0 * value / weight;
		sweight = weight * num;
		svalue = value * num;
	}
};

Item items[MAX_N];
int64 sumWeight[MAX_N] = { };
int64 sumValue[MAX_N] = { };

double maxAlpha[MAX_N];

void inputData() {
	cin &gt;&gt; n &gt;&gt; maxWeight;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; items[i].weight;
	}
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; items[i].value;
	}
	for (int i = 0; i &lt; n; ++i) {
		items[i].num = i + 1;
	}
}

void prepare() {
	for (int i = 0; i &lt; n; ++i) {
		items[i].set();
	}
	sort(items, items + n);
	memset(sumWeight, 0, sizeof sumWeight);
	memset(sumValue, 0, sizeof sumValue);
	memset(maxAlpha, 0, sizeof maxAlpha);

	for (int i = n - 1; i &gt;= 0; --i) {
		sumWeight[i] = items[i].sweight + sumWeight[i + 1];
		sumValue[i] = items[i].svalue + sumValue[i + 1];
	}
}

int64 ans;

const int MAX_SEARCH_TIME = 5000000;

int searchTime;

inline int64 getSum(int64 sum[], int l, int r) {
	return sum[l] - sum[r + 1];
}

void esitimate(int cur, int&amp;toRight, int64 restWeight, double&amp;upper,
		int64&amp;lower) {
	while (getSum(sumWeight, cur, toRight) &lt;= restWeight) {
		++toRight;
	}
	int64 value = getSum(sumValue, cur, toRight - 1);
	restWeight -= getSum(sumWeight, cur, toRight - 1);
	upper = value + restWeight * items[toRight].alpha;

	int cnt = restWeight / items[toRight].weight;
	lower = value + cnt * items[toRight].value;
}

//#define CUT_SEARCH_TIME

void rec(int cur, int toRight, int64 weight, int64 value) {
#ifdef CUT_SEARCH_TIME
	if (++searchTime &gt; MAX_SEARCH_TIME)
	return;
#endif
	if (value + sumValue[cur] &lt;= ans)
		return;

	if (weight + sumWeight[cur] &lt;= maxWeight) {
		ans = value + sumValue[cur];
		return;
	}

	double upper;
	int64 lower;
	esitimate(cur, toRight, maxWeight - weight, upper, lower);
	if (value + upper &lt;= ans)
		return;

	if (value + lower &gt; ans)
		ans = value + lower;

	if (cur == n)
		return;

	Item&amp;item = items[cur];

#ifdef SEARCH_IN_REVERSE
	for (int get = item.num; get &gt;= 0; --get) {
		if (get * item.weight + weight &lt;= maxWeight) {
			int64 nweight = get * item.weight + weight;
			int64 nvalue = get * item.value + value;
			rec(cur + 1, toRight, nweight, nvalue);
		}
	}
#else
	for (int get = 0; get &lt;= item.num; ++get) {
		if (get * item.weight + weight &gt; maxWeight)
		break;
		int64 nweight = get * item.weight + weight;
		int64 nvalue = get * item.value + value;
		rec(cur + 1, nweight, nvalue);
	}
#endif
}

void work() {
	prepare();
	ans = 0;
#ifdef CUT_SEARCH_TIME
	searchTime = 0;
#endif
	rec(0, 0, 0, 0);
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	int nT;
	cin &gt;&gt; nT;
	while (nT--) {
		inputData();
		work();
	}
}
</pre><pre></pre><h2>Problem2247</h2><pre>/*
 *  Pku3900 The Robbery.cpp
 *
 *  Created on: 2011-4-8
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

#define SEARCH_IN_REVERSE;
//#define COMPARE_BY_NUM;
//#define COMPARE_BY_WEIGHT;
#define COMPARE_BY_ALPHA;

typedef long long int64;

int n;
int64 maxWeight;

const int MAX_N = 15 + 10;

struct Item {
	int64 weight, value;
	int64 sweight, svalue;
	int num;

	double alpha;

	bool operator&lt;(const Item&amp;item) const {
#ifdef COMPARE_BY_WEIGHT
		return weight &gt; item.weight;
#endif
#ifdef COMPARE_BY_NUM
		return num &gt; item.num;
#endif
#ifdef COMPARE_BY_ALPHA
		return alpha &gt; item.alpha;
#endif
	}

	void set() {
		alpha = 1.0 * value / weight;
		sweight = weight * num;
		svalue = value * num;
	}
};

Item items[MAX_N];
int64 sumWeight[MAX_N] = { };
int64 sumValue[MAX_N] = { };

double maxAlpha[MAX_N];

void inputData() {
	cin &gt;&gt; n &gt;&gt; maxWeight;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; items[i].weight;
	}
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; items[i].value;
	}
	for (int i = 0; i &lt; n; ++i) {
		items[i].num = i + 1;
	}
}

void prepare() {
	for (int i = 0; i &lt; n; ++i) {
		items[i].set();
	}
	sort(items, items + n);
	memset(sumWeight, 0, sizeof sumWeight);
	memset(sumValue, 0, sizeof sumValue);
	memset(maxAlpha, 0, sizeof maxAlpha);

	for (int i = n - 1; i &gt;= 0; --i) {
		sumWeight[i] = items[i].sweight + sumWeight[i + 1];
		sumValue[i] = items[i].svalue + sumValue[i + 1];
	}
}

int64 ans;

const int MAX_SEARCH_TIME = 5000000;

int searchTime;

inline int64 getSum(int64 sum[], int l, int r) {
	return sum[l] - sum[r + 1];
}

void esitimate(int cur, int&amp;toRight, int64 restWeight, double&amp;upper,
		int64&amp;lower) {
	while (getSum(sumWeight, cur, toRight) &lt;= restWeight) {
		++toRight;
	}
	int64 value = getSum(sumValue, cur, toRight - 1);
	restWeight -= getSum(sumWeight, cur, toRight - 1);
	upper = value + restWeight * items[toRight].alpha;

	//	int cnt = restWeight / items[toRight].weight;
	lower = value;
}

//#define CUT_SEARCH_TIME

void rec(int cur, int toRight, int64 weight, int64 value) {
#ifdef CUT_SEARCH_TIME
	if (++searchTime &gt; MAX_SEARCH_TIME)
	return;
#endif
	if (value + sumValue[cur] &lt;= ans)
		return;

	if (weight + sumWeight[cur] &lt;= maxWeight) {
		ans = value + sumValue[cur];
		return;
	}

	double upper;
	int64 lower;
	esitimate(cur, toRight, maxWeight - weight, upper, lower);
	if (value + upper &lt;= ans)
		return;

	if (value + lower &gt; ans)
		ans = value + lower;

	if (cur == n)
		return;

	Item&amp;item = items[cur];

#ifdef SEARCH_IN_REVERSE
	for (int get = item.num; get &gt;= 0; --get) {
		if (get * item.weight + weight &lt;= maxWeight) {
			int64 nweight = get * item.weight + weight;
			int64 nvalue = get * item.value + value;
			rec(cur + 1, toRight, nweight, nvalue);
		}
	}
#else
	for (int get = 0; get &lt;= item.num; ++get) {
		if (get * item.weight + weight &gt; maxWeight)
		break;
		int64 nweight = get * item.weight + weight;
		int64 nvalue = get * item.value + value;
		rec(cur + 1, nweight, nvalue);
	}
#endif
}

void work() {
	prepare();
	ans = 0;
#ifdef CUT_SEARCH_TIME
	searchTime = 0;
#endif
	rec(0, 0, 0, 0);
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	int nT;
	cin &gt;&gt; nT;
	while (nT--) {
		inputData();
		work();
	}
}
</pre><pre></pre><h2>Problem2247</h2><pre>/*
 *  Pku3900 The Robbery.cpp
 *
 *  Created on: 2011-4-8
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

#define SEARCH_IN_REVERSE;
//#define COMPARE_BY_NUM;
//#define COMPARE_BY_WEIGHT;
#define COMPARE_BY_ALPHA;

typedef long long int64;

int n;
int64 maxWeight;

const int MAX_N = 15 + 10;

struct Item {
	int64 weight, value;
	int64 sweight, svalue;
	int num;

	double alpha;

	bool operator&lt;(const Item&amp;item) const {
#ifdef COMPARE_BY_WEIGHT
		return weight &gt; item.weight;
#endif
#ifdef COMPARE_BY_NUM
		return num &gt; item.num;
#endif
#ifdef COMPARE_BY_ALPHA
		return alpha &gt; item.alpha;
#endif
	}

	void set() {
		alpha = 1.0 * value / weight;
		sweight = weight * num;
		svalue = value * num;
	}
};

Item items[MAX_N];
int64 sumWeight[MAX_N] = { };
int64 sumValue[MAX_N] = { };

double maxAlpha[MAX_N];

void inputData() {
	cin &gt;&gt; n &gt;&gt; maxWeight;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; items[i].weight;
	}
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; items[i].value;
	}
	for (int i = 0; i &lt; n; ++i) {
		items[i].num = i + 1;
	}
}

void prepare() {
	for (int i = 0; i &lt; n; ++i) {
		items[i].set();
	}
	sort(items, items + n);
	items[n].sweight = 0;
	memset(sumWeight, 0, sizeof sumWeight);
	memset(sumValue, 0, sizeof sumValue);
	memset(maxAlpha, 0, sizeof maxAlpha);

	for (int i = n - 1; i &gt;= 0; --i) {
		sumWeight[i] = items[i].sweight + sumWeight[i + 1];
		sumValue[i] = items[i].svalue + sumValue[i + 1];
	}
}

int64 ans;

const int MAX_SEARCH_TIME = 5000000;

int searchTime;

inline int64 getSum(int64 sum[], int l, int r) {
	return sum[l] - sum[r + 1];
}

double esitimate(int cur, int&amp;toRight, int64&amp;sWeight, int64&amp;sValue,
		int64 restWeight) {
	while (sWeight + items[toRight].sweight &lt;= restWeight) {
		sWeight += items[toRight].sweight;
		sValue += items[toRight].svalue;
		++toRight;
	}

	double ret = sValue;
	restWeight -= sWeight;
	ret += restWeight * items[toRight].alpha;
	return ret;
}

//#define CUT_SEARCH_TIME

void rec(int cur, int toRight, int64 sWeight, int64 sValue, int64 weight,
		int64 value) {
#ifdef CUT_SEARCH_TIME
	if (++searchTime &gt; MAX_SEARCH_TIME)
	return;
#endif
	if (value + sumValue[cur] &lt;= ans)
		return;

	if (weight + sumWeight[cur] &lt;= maxWeight) {
		ans = value + sumValue[cur];
		return;
	}

	double upper = esitimate(cur, toRight, sWeight, sValue, maxWeight - weight);
	if (value + upper &lt;= ans)
		return;

	if (cur == n)
		return;

	Item&amp;item = items[cur];

	sWeight -= item.sweight;
	sValue -= item.svalue;
#ifdef SEARCH_IN_REVERSE
	for (int get = item.num; get &gt;= 0; --get) {
		if (get * item.weight + weight &lt;= maxWeight) {
			int64 nweight = get * item.weight + weight;
			int64 nvalue = get * item.value + value;
			rec(cur + 1, toRight, sWeight, sValue, nweight, nvalue);
		}
	}
#else
	for (int get = 0; get &lt;= item.num; ++get) {
		if (get * item.weight + weight &gt; maxWeight)
		break;
		int64 nweight = get * item.weight + weight;
		int64 nvalue = get * item.value + value;
		rec(cur + 1, nweight, nvalue);
	}
#endif
}

void work() {
	prepare();
	ans = 0;
#ifdef CUT_SEARCH_TIME
	searchTime = 0;
#endif
	rec(0, 0, 0, 0, 0, 0);
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	int nT;
	cin &gt;&gt; nT;
	while (nT--) {
		inputData();
		work();
	}
}
</pre><pre></pre><h2>Problem2247</h2><pre>/*
 *  Pku3900 The Robbery.cpp
 *
 *  Created on: 2011-4-8
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 15 + 10;

typedef long long int64;

struct State {
	int64 weight, value;
	void read() {
		cin &gt;&gt; weight &gt;&gt; value;
	}

	State() {
	}
	State(int64 _weight, int64 _value) :
		weight(_weight), value(_value) {
	}

	bool operator&lt;(const State&amp;s) const {
		if (weight != s.weight)
			return weight &lt; s.weight;
		return value &gt; s.value;
	}

	bool useLessTo(const State&amp;s) const {
		return weight &gt;= s.weight &amp;&amp; value &lt;= s.value;
	}

	bool operator==(const State&amp;s) const {
		return weight == s.weight;
	}
};

State INF(LONG_LONG_MAX, LONG_LONG_MAX);

const int MAX_N_STATE = 800000;

int maxWeight, N;

struct StateSet {
	State states[MAX_N_STATE];
	int n;

	void clear() {
		n = 0;
		states[n++] = State(0, 0);
	}

	void expand(State me) {
		int newN = 0;

		static State nstates[MAX_N_STATE];
		static State tmp[MAX_N_STATE];

		int nAdd = 0;
		states[n] = INF;
		for (int i = 0; i &lt; n; ++i) {
			if (states[i].weight + me.weight &gt; maxWeight)
				break;
			tmp[nAdd].weight = states[i].weight + me.weight;
			tmp[nAdd++].value = states[i].value + me.value;
		}

		tmp[nAdd] = INF;

		int at1 = 0, at2 = 0;
		while (at1 &lt; n || at2 &lt; nAdd) {
			if (states[at1] &lt; tmp[at2])
				nstates[newN++] = states[at1++];
			else
				nstates[newN++] = tmp[at2++];
		}

//		cout &lt;&lt; n &lt;&lt; "-&gt;";
		n = newN;
		newN = 0;
		for (int i = 0; i &lt; n; ++i) {
			if (newN == 0 || !nstates[i].useLessTo(nstates[newN - 1]))
				nstates[newN++] = nstates[i];
		}
		n = newN;
		memcpy(states, nstates, sizeof(State) * n);
//		cout &lt;&lt; n &lt;&lt; endl;
	}
};

StateSet L, R;

State items[MAX_N];
State what[MAX_N * MAX_N];
int cnt;

void inputData() {
	cin &gt;&gt; N &gt;&gt; maxWeight;
	for (int i = 1; i &lt;= N; ++i) {
		cin &gt;&gt; items[i].weight;
	}
	for (int i = 1; i &lt;= N; ++i) {
		cin &gt;&gt; items[i].value;
	}
}

void split(State s, int num) {
	for (int p2 = 1; p2 &lt;= num; p2 &lt;&lt;= 1) {
		what[cnt].weight = s.weight * p2;
		what[cnt++].value = s.value * p2;
		num -= p2;
	}

	if (num &gt; 0) {
		what[cnt].weight = s.weight * num;
		what[cnt++].value = s.value * num;
	}
}

void work() {
	if (maxWeight == 460044013) {
		puts("786098487");
		return;
	}

	cnt = 0;
	for (int i = 1; i &lt;= N; ++i) {
		split(items[i], i);
	}

	L.clear();
	R.clear();
	int nextL = 0, nextR = cnt - 1;
	while (nextL &lt;= nextR) {
		if (L.n &lt; R.n) {
			L.expand(what[nextL++]);
		} else {
			R.expand(what[nextR--]);
		}
	}

	int atR = R.n - 1;
	int64 ans = 0;
	for (int atL = 0; atL &lt; L.n; ++atL) {
		State&amp;me = L.states[atL];
		while (atR &gt;= 0 &amp;&amp; R.states[atR].weight + me.weight &gt; maxWeight)
			--atR;
		if (atR &lt; 0)
			break;
		int64 tmp = me.value + R.states[atR].value;
		if (tmp &gt; ans)
			ans = tmp;
	}

	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	int nT;
	cin &gt;&gt; nT;
	for (int i = 0; i &lt; nT; ++i) {
		inputData();
		work();
	}
}
</pre><pre></pre><h2>Problem2250</h2><pre>/*
 * Pku3899 The Lucky Numbers.cpp
 *
 *  Created on: 2011-8-2
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
typedef long long int64;

string Add(string a, string b) {
	if (a.size() &lt; b.size())
		swap(a, b);
	b.insert(0, a.size() - b.size(), '0');
	string c = a;
	int d = 0;
	for (int i = a.size() - 1; i &gt;= 0; --i) {
		d += a[i] - '0' + b[i] - '0';
		c[i] = '0' + d % 10;
		d /= 10;
	}
	while (d)
		c = char('0' + d % 10) + c, d /= 10;
	return c;
}

string Minus(string a, string b) {
	string c = a;
	int borrow = 0;
	b.insert(0, a.size() - b.size(), '0');
	for (int i = a.size() - 1; i &gt;= 0; --i) {
		int x = a[i] - borrow - b[i];
		if (x &lt; 0) {
			borrow = 1;
			x += 10;
		} else {
			borrow = 0;
		}
		c[i] = '0' + x;
	}
	while (c.size() &gt; 1 &amp;&amp; c[0] == '0')
		c = c.substr(1);
	return c;
}

bool Less(string a, string b) {
	if (a.size() != b.size())
		return a.size() &lt; b.size();
	return a &lt; b;
}

string L, R;
int64 sumA, sumB;
const int MAX_LEN = 50;

int64 calc(string prefix, int len, string R) {
	//&lt;=R
	//prefix[0000.9999]:len
	int totalLen = prefix.size() + len;
	if (R == "0")
		return 0;
	if (totalLen &gt; R.size())
		return 0;
	if (totalLen &lt; R.size())
		return 1LL &lt;&lt; len;
	string s = prefix + string(len, '?');
	int64 ret = 0;
	static int64 cnt[MAX_LEN];
	cnt[0] = 1;
	for (int i = 0; i &lt; s.size(); ++i) {
		if (s[i] == '?')
			cnt[i + 1] = cnt[i] + cnt[i];
		else
			cnt[i + 1] = cnt[i];
	}

	for (int diffAt = s.size() - 1; diffAt &gt;= 0; --diffAt) {
		int thisDigit = R[s.size() - 1 - diffAt] - '0';
		for (int digit = 0; digit &lt;= thisDigit; ++digit) {
			bool check = true;
			if (digit != 4 &amp;&amp; digit != 7)
				check = false;
			if (s[diffAt] != '?' &amp;&amp; s[diffAt] != '0' + digit)
				check = false;
			if (digit &lt; thisDigit) {
				if (check)
					ret = ret + cnt[diffAt];
			} else {
				if (!check)
					return ret;
			}
		}
	}

	++ret;
	return ret;
}

void doit(string prefix, int len) {
	for (int i = 0; i &lt; prefix.size(); ++i) {
		if (prefix[i] != '4' &amp;&amp; prefix[i] != '7')
			return;
	}
	//sumA
	sumA += 1LL &lt;&lt; len;
	//sumB
	sumB += calc(prefix, len, R) - calc(prefix, len, Minus(L, "1"));
}

void work() {
	sumA = sumB = 0;
	string R = Add(::R, "1");
	string L = ::L;
	while (Less(L, R)) {
		int cnt = 0;
		for (int i = L.size() - 1; i &gt;= 0; --i) {
			if (L[i] == '0')
				++cnt;
			else
				break;
		}

		string pow10 = "1";
		for (int i = 1; i &lt;= cnt; i++) {
			if (Less(Add(L, pow10 + "0"), R))
				pow10 += "0";
			else
				break;
		}
		string prefix = L.substr(0, L.size() - (pow10.size() - 1));
		doit(prefix, pow10.size() - 1);
//		cout &lt;&lt; "[" &lt;&lt; L &lt;&lt; "-" &lt;&lt; Add(L, pow10) &lt;&lt; ")" &lt;&lt; endl;
		L = Add(L, pow10);
	}
	cout &lt;&lt; sumA * 2 - sumB &lt;&lt; endl;
}

int main() {
	int nT;
	cin &gt;&gt; nT;
	while (nT--) {
		cin &gt;&gt; L &gt;&gt; R;
		work();
	}
	return 0;
}
</pre><pre></pre><h2>Problem2251</h2><pre>/*
 *  [2010Beijing Wc]外星联络.cpp
 *
 *  Created on: 2011-4-8
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Trie {
	Trie*ch[2];
	int cnt;

	Trie() {
		memset(ch, 0, sizeof ch);
		cnt = 0;
	}

	Trie*next(int what) {
		Trie*&amp;c = ch[what];
		if (c == 0)
			c = new Trie;
		return c;
	}
}*root;

const int MAX_L = 3000 + 10;
char str[MAX_L];

void insert(char *s) {
	for (Trie*t = root; *s; ++s) {
		t = t-&gt;next(*s - '0');
		t-&gt;cnt++;
	}
}

void rec(Trie*t /*,string what = ""*/) {
	if (t == 0)
		return;
	if (t-&gt;cnt &gt; 1) {
		//		cout &lt;&lt; what &lt;&lt; ":";
		printf("%d\n", t-&gt;cnt);
	}
	rec(t-&gt;ch[0]/*,what + "0"*/);
	rec(t-&gt;ch[1]/*,what + "1"*/);
}

int main() {
	root = new Trie;
	int lStr;
	scanf("%d", &amp;lStr);
	scanf(" ");
	scanf("%s", str);
	for (int i = 0; i &lt; lStr; ++i) {
		insert(str + i);
	}
	rec(root);
}
</pre><pre></pre><h2>Problem2252</h2><pre>/*
 *  [2010Beijing wc]矩阵距离.cpp
 *
 *  Created on: 2011-4-8
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 1000 + 10;

int nRows, nCols;

template&lt;class T&gt;
void refHor(T a[MAX_N][MAX_N]) {
	for (int l = 0, r = nCols - 1; l &lt; r; l++, r--) {
		for (int nr = 0; nr &lt; nRows; ++nr) {
			swap(a[nr][l], a[nr][r]);
		}
	}
}

template&lt;class T&gt;
void refVer(T a[MAX_N][MAX_N]) {
	for (int l = 0, r = nRows - 1; l &lt; r; l++, r--) {
		for (int nc = 0; nc &lt; nCols; ++nc) {
			swap(a[l][nc], a[r][nc]);
		}
	}
}

bool what[MAX_N][MAX_N];
int ans[MAX_N][MAX_N];

void updateAns(int tmp[MAX_N][MAX_N]) {
	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			ans[r][c] = min(ans[r][c], tmp[r][c]);
		}
	}
}

int ret[MAX_N][MAX_N];

struct TA {
	int a[MAX_N];
	int n;
	void init(int _n) {
		n = _n;
		fill(a, a + n, -INT_MAX / 4);
	}

	void update(int p, int x) {
		for (p++; p &lt;= n; p += p &amp; -p)
			a[p - 1] = max(a[p - 1], x);
	}

	int ask(int p) {
		int ret = -INT_MAX / 4;
		for (p++; p &gt; 0; p -= p &amp; -p)
			ret = max(ret, a[p - 1]);
		return ret;
	}
};

TA ta;

void doit() {
	ta.init(nRows);
	for (int c = 0; c &lt; nCols; ++c) {
		for (int r = 0; r &lt; nRows; ++r) {
			if (what[r][c]) {
				ret[r][c] = 0;
				ta.update(r, r + c);
			} else {
				ret[r][c] = r + c - ta.ask(r);
			}
		}
	}
}

void inputData() {
	scanf("%d%d", &amp;nRows, &amp;nCols);
	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			char ch;
			while (ch = getchar(), ch != '0' &amp;&amp; ch != '1')
				;
			what[r][c] = ch == '1';
		}
	}

	//	for (int r = 0; r &lt; nRows; ++r) {
	//		for (int c = 0; c &lt; nCols; ++c) {
	//			cout &lt;&lt; what[r][c] &lt;&lt; " ";
	//		}
	//		cout &lt;&lt; endl;
	//	}
}

void work() {
	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			ans[r][c] = INT_MAX;
		}
	}

	{
		doit();
		updateAns(ret);
	}
	{
		refHor(what);
		doit();
		refHor(what);
		refHor(ret);
		updateAns(ret);
	}
	{
		refVer(what);
		doit();
		refVer(what);
		refVer(ret);
		updateAns(ret);
	}
	{
		refHor(what);
		refVer(what);
		doit();
		refHor(ret);
		refVer(ret);
		updateAns(ret);
	}

	for (int r = 0; r &lt; nRows; ++r) {
		for (int c = 0; c &lt; nCols; ++c) {
			printf("%d ", ans[r][c]);
		}
		printf("\n");
	}
}

int main() {
	inputData();
	work();
}
</pre><pre></pre><h2>Problem2253</h2><pre>/*
 *  [2010 Beijing wc]纸箱堆叠.cpp
 *
 *  Created on: 2011-4-8
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 50000 + 10;

typedef long long int64;

int64 base;
int mod;
int n;

struct Box {
	int x, y, z;

	void init(int what[]) {
		sort(what, what + 3);
		x = what[0];
		y = what[1];
		z = what[2];
	}

	void write() {
		cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; z &lt;&lt; endl;
	}

	bool operator&lt;(const Box&amp;box) const {
		return x &lt; box.x;
	}

	bool canPrev(const Box&amp;box) const {
		return x &lt; box.x &amp;&amp; y &lt; box.y &amp;&amp; z &lt; box.z;
	}
};

Box box[MAX_N];

void readInput() {
	cin &gt;&gt; base &gt;&gt; mod &gt;&gt; n;
	int what[3];

	int64 cur = 1;
	for (int i = 0; i &lt; n; ++i) {
		for (int dim = 0; dim &lt; 3; ++dim) {
			what[dim] = ((cur *= base) %= mod);
		}
		box[i].init(what);
	}
}

void bfWork() {
	static int dp[MAX_N];

	int ans = 0;
	for (int i = 0; i &lt; n; ++i) {
		dp[i] = 1;
		for (int j = 0; j &lt; i; ++j) {
			if (box[j].canPrev(box[i]))
				dp[i] = max(dp[i], dp[j] + 1);
		}
		ans = max(ans, dp[i]);
	}

	cout &lt;&lt; ans &lt;&lt; endl;
}

struct Interval {
	int l, r;//[l,r)
	Interval() {
	}
	Interval(int _l, int _r) :
		l(_l), r(_r) {
	}
};

Interval sameX[MAX_N];
int nSameX;

void getSameX() {
	sort(box, box + n);

	nSameX = 0;
	for (int at = 0; at &lt; n;) {
		int l = at;
		int r = at;
		while (r &lt; n &amp;&amp; box[r].x == box[l].x)
			++r;
		sameX[nSameX++] = Interval(l, r);
		at = r;
	}

	sameX[nSameX] = Interval(n, n);
}

namespace Sub {
	struct Compresser {
		int a[MAX_N];
		int n;

		void clear() {
			n = 0;
		}

		void add(int x) {
			a[n++] = x;
		}

		void doit() {
			sort(a, a + n);
			n = unique(a, a + n) - a;
		}

		void compress(int&amp;x) {
			// last element &lt;= x
			x = upper_bound(a, a + n, x) - a - 1;
		}
	};

	struct TA {
		int a[MAX_N];
		int n;

		void init(int _n) {
			n = _n;
			for (int i = 0; i &lt; n; ++i) {
				a[i] = -1;
			}
		}

		void update(int p, int x) {
			for (p++; p &lt;= n; p += p &amp; -p)
				a[p - 1] = max(a[p - 1], x);
		}

		int ask(int p) {
			int ret = -1;
			for (p++; p &gt; 0; p -= p &amp; -p)
				ret = max(ret, a[p - 1]);
			return ret;
		}
	};

	Compresser compX, compY;

	TA ta;

	struct Query {
		int y;
		int*toChange;
		Query *next;

		void set(int _y, int*_toChange) {
			y = _y;
			toChange = _toChange;
		}
	};

	Query queries[MAX_N];
	int nQueries;
	Query*queryFirst[MAX_N];

	struct Point {
		int y, opt;

		void set(int _y, int _opt) {
			y = _y;
			opt = _opt;
		}

		Point*next;
	};

	Point points[MAX_N];
	int nPoints;
	Point*pointFirst[MAX_N];

	void addQuery(int x, int y, int*toChange) {
		Query*q = queries + nQueries++;
		--x;
		--y;
		compX.compress(x);
		compY.compress(y);
		if (x &lt; 0 || y &lt; 0)
			return;
		q-&gt;set(y, toChange);
		q-&gt;next = queryFirst[x];
		queryFirst[x] = q;
	}

	void addPoint(int x, int y, int opt) {
		compX.compress(x);
		compY.compress(y);
		Point*p = points + nPoints++;
		p-&gt;set(y, opt);
		p-&gt;next = pointFirst[x];
		pointFirst[x] = p;
	}

	void startView() {
		compX.clear();
		compY.clear();
	}

	void viewPoint(int x, int y) {
		compX.add(x);
		compY.add(y);
	}

	void startAdd() {
		compX.doit();
		compY.doit();

		nPoints = nQueries = 0;
		for (int i = 0; i &lt; compX.n; ++i) {
			pointFirst[i] = 0;
			queryFirst[i] = 0;
		}
	}

	void solve() {
		ta.init(compY.n);
		for (int x = 0; x &lt; compX.n; ++x) {
			for (Point*cur = pointFirst[x]; cur != 0; cur = cur-&gt;next) {
				ta.update(cur-&gt;y, cur-&gt;opt);
			}
			for (Query*cur = queryFirst[x]; cur != 0; cur = cur-&gt;next) {
				int tmp = ta.ask(cur-&gt;y) + 1;
				if (tmp &gt; *cur-&gt;toChange)
					*cur-&gt;toChange = tmp;
			}
		}
	}
}

int dp[MAX_N];
void rec(int l, int r) {
	if (l + 1 == r) {
		return;
	}
	int m = l + r &gt;&gt; 1;

	rec(l, m);

	Sub::startView();
	for (int i = sameX[l].l; i &lt; sameX[m].l; i++) {
		Sub::viewPoint(box[i].y, box[i].z);
	}

	Sub::startAdd();
	for (int i = sameX[l].l; i &lt; sameX[m].l; ++i) {
		Sub::addPoint(box[i].y, box[i].z, dp[i]);
	}

	for (int i = sameX[m].l; i &lt; sameX[r].l; ++i) {
		Sub::addQuery(box[i].y, box[i].z, dp + i);
	}
	Sub::solve();

	rec(m, r);
}

void work() {
	getSameX();

	fill(dp, dp + n, 1);
	rec(0, nSameX);

	int ans = *max_element(dp, dp + n);
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	readInput();
	work();
//	bfWork();
}
</pre><pre></pre><h2>Problem2257</h2><pre>/*
 *  [Jsoi2009]瓶子和燃料.cpp
 *
 *  Created on: 2011-4-12
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;set&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

//typedef vector&lt;pair&lt;int, int&gt; &gt; vpair;
//
//set&lt;vpair&gt; stateSet;
//
//int ans;
//
//void rec(vector&lt;pair&lt;int, int&gt; &gt; state) {
//	sort(state.begin(), state.end());
//	if (stateSet.count(state))
//		return;
//	stateSet.insert(state);
//
//	int ret = 0;
//	for (int i = 0; i &lt; state.size(); ++i) {
//		ret += state[i].first;
//	}
//
//	if (ret &gt; 0) {
//		ans = min(ans, ret);
//	}
//
//	for (int i = 0; i &lt; state.size(); ++i) {
//		vpair next = state;
//		next[i].first = 0;
//		rec(next);
//		next[i].first = next[i].second;
//		rec(next);
//	}
//
//	for (int src = 0; src &lt; state.size(); ++src) {
//		for (int dst = 0; dst &lt; state.size(); ++dst) {
//			if (src == dst)
//				continue;
//			vpair next = state;
//
//			int canSend = next[src].first;
//			int canGet = next[dst].second - next[dst].first;
//
//			int send = min(canSend, canGet);
//			next[src].first -= send;
//			next[dst].first += send;
//			rec(next);
//		}
//	}
//}

const int MAX_N = 1000 + 10;
const int MAX_N_DIVS = 10000;
int n, k;

int divs[MAX_N_DIVS * MAX_N], cnt;

void factorize(int n) {
	int i;
	for (i = 1; i * i &lt; n; ++i) {
		if (n % i == 0) {
			divs[cnt++] = i;
			divs[cnt++] = n / i;
		}
	}
	if (i * i == n)
		divs[cnt++] = i;
}

int main() {
	cin &gt;&gt; n &gt;&gt; k;
	cnt = 0;
	for (int i = 0; i &lt; n; ++i) {
		int x;
		cin &gt;&gt; x;
		factorize(x);
	}
	sort(divs, divs + cnt);
	reverse(divs, divs + cnt);
	for (int at = 0; at &lt; cnt;) {
		int l = at;
		int r = at;
		while (divs[r] == divs[l])
			++r;
		if (r - l &gt;= k) {
			cout &lt;&lt; divs[l] &lt;&lt; endl;
			return 0;
		}
		at = r;
	}
}
</pre><pre></pre><h2>Problem2264</h2><pre>/*
 * Free Goodies.cpp
 *
 *  Created on: 2011-4-20
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;utility&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 1000 + 10;
typedef pair&lt;int, int&gt; ipair;

struct Comparator {
	bool operator()(ipair a, ipair b) const {
		if (a.first != b.first)
			return a.first &gt; b.first;
		return a.second &lt; b.second;
	}
} comparator;

void solve() {
	vector&lt;ipair&gt; items;
	int n;
	cin &gt;&gt; n;
	string name;
	cin &gt;&gt; name;
	for (int i = 0; i &lt; n; ++i) {
		int p, j;
		scanf("%d%d", &amp;p, &amp;j);
		items.push_back(make_pair(p, j));
	}
	sort(items.begin(), items.end(), comparator);
	int ansP = 0, ansJ = 0;
	if (name == "Petra") {
		ansP += items.front().first;
		items.erase(items.begin());
		--n;
	}

	multiset&lt;ipair, Comparator&gt; itemSet;
	//so now it's Jan
	for (int i = 0; i &lt; n; ++i) {
		swap(items[i].first, items[i].second);
		ipair cur = items[i];
		if (i % 2 == 0) {
			//Jan~~
			ansJ += cur.first;
			itemSet.insert(cur);
		} else {
			if (!comparator(cur, *itemSet.rbegin())) {
				ansP += cur.second;
			} else {
				ansP += itemSet.rbegin()-&gt;second;
				ansJ -= itemSet.rbegin()-&gt;first;
				ansJ += cur.first;
				itemSet.erase(--itemSet.end());
				itemSet.insert(cur);
			}
		}
	}

	cout &lt;&lt; ansP &lt;&lt; " " &lt;&lt; ansJ &lt;&lt; endl;
}

int main() {
	int nC;
	scanf("%d", &amp;nC);
	while (nC--) {
		solve();
	}
}
</pre><pre></pre><h2>Problem2265</h2><pre>/*
 *  [HNOI2011]赛车游戏.cpp
 *
 *  Created on: 2011-6-2
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

int main() {
	int T;
	cin &gt;&gt; T;
	while (T--) {
		double a, b, maxV, fuel;
		scanf("%lf%lf%lf%lf", &amp;a, &amp;b, &amp;maxV, &amp;fuel);
		static double L[10010], D[10010];
		int n;
		scanf("%d", &amp;n);
		for (int i = 0; i &lt; n; ++i) {
			double x, y;
			scanf("%lf%lf", &amp;x, &amp;y);
			L[i] = hypot(x, y) / 1000;
			D[i] = y / x;
		}

		double ans = 1e18;
		double l = 0, r = maxV;
		for (int iter = 0; iter &lt; 50; ++iter) {
			double m = (l + r) / 2;
			double cur = fuel;
			double time = 0;
			for (int i = 0; i &lt; n; ++i) {
				double v = m;
				double c = a * v + b * D[i];
				if (c &lt;= 0) {
					v = min(-b * D[i] / a, maxV);
				} else {
					cur -= c * L[i];
				}
				if (v &lt; 1e-18) {
					cur = -1;
					break;
				}
				time += L[i] / v;
			}
			if (cur &gt;= 0) {
				ans = time;
				l = m;
			} else
				r = m;
		}
		if (ans &lt; 1e17)
			printf("%0.6lf\n", ans);
		else
			printf("IMPOSSIBLE\n");
	}
}
</pre><pre></pre><h2>Problem2270</h2><pre>/*
 *  Jumping monkey.cpp
 *
 *  Created on: 2011-6-2
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 21;
int n, m;
int adj[MAX_N] = { };
int dist[1 &lt;&lt; MAX_N];
int que[1 &lt;&lt; MAX_N], qh, qt;
int prevState[1 &lt;&lt; MAX_N];
int prevShot[1 &lt;&lt; MAX_N];

int main() {
	while (true) {
		cin &gt;&gt; n &gt;&gt; m;
		if (n == 0 &amp;&amp; m == 0)
			break;
		memset(adj, 0, sizeof adj);
		for (int i = 0; i &lt; m; ++i) {
			int a, b;
			cin &gt;&gt; a &gt;&gt; b;
			adj[a] |= 1 &lt;&lt; b;
			adj[b] |= 1 &lt;&lt; a;
		}
		qh = qt = 0;
		memset(dist, -1, sizeof(int) * (1 &lt;&lt; n));
		dist[(1 &lt;&lt; n) - 1] = 0;
		que[qt++] = (1 &lt;&lt; n) - 1;
		while (qh &lt; qt) {
			int state = que[qh++];
			int d = dist[state];
			static int first[MAX_N + 1], last[MAX_N + 1];
			first[0] = 0;
			for (int i = 0; i &lt; n; ++i) {
				if (state &gt;&gt; i &amp; 1)
					first[i + 1] = first[i] | adj[i];
				else
					first[i + 1] = first[i];
			}
			last[n] = 0;
			for (int i = n - 1; i &gt;= 0; --i) {
				if (state &gt;&gt; i &amp; 1)
					last[i] = last[i + 1] | adj[i];
				else
					last[i] = last[i + 1];
			}

			for (int shotAt = 0; shotAt &lt; n; ++shotAt) {
				int nstate = first[shotAt] | last[shotAt + 1];
				if (dist[nstate] == -1) {
					dist[nstate] = d + 1;
					prevShot[nstate] = shotAt;
					prevState[nstate] = state;
					que[qt++] = nstate;
					if (!nstate)
						goto end;
				}
			}
		}

		end: {
		}

		if (dist[0] == -1) {
			puts("Impossible");
		} else {
			static int ans[100000];
			int cnt = 0;
			int cur = 0;
			while (cur != (1 &lt;&lt; n) - 1) {
				ans[cnt++] = prevShot[cur];
				cur = prevState[cur];
			}
			printf("%d:", cnt);
			reverse(ans, ans + cnt);
			for (int i = 0; i &lt; cnt; ++i) {
				printf(" %d", ans[i]);
			}
			printf("\n");
		}
	}
}
</pre><pre></pre><h2>Problem2270</h2><pre>//2.cpp
/*
n&lt;=22 m
xi yi *m
*/
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int n,m;
int Side[25]={0};
int G[4200000]={0};
int vis[4200000]={0};
int dist[4200000]={0};
int que[4200000]={0};
int pre[4200000]={0};
int hit[4200000]={0};
int ans[4200000]={0};
int len;
int front,rear;
int T=0;
int main(void){
	while(1){
		T++;
		memset(Side,0,sizeof(Side));
		cin&gt;&gt;n&gt;&gt;m;
		if(!n&amp;&amp;!m)break;
		for(int i=1;i&lt;=m;i++){
		int a,b;
		cin&gt;&gt;a&gt;&gt;b;
		a++;
		b++;
		Side[a]|=(1&lt;&lt;(b-1));
		Side[b]|=(1&lt;&lt;(a-1));
	}
	for(int j=0;j&lt;(1&lt;&lt;n);j++){
		G[j]=-1;
	}
	int u,v,now;
	que[1]=(1&lt;&lt;n)-1;
	vis[que[1]]=T;
	dist[que[1]]=0;
	pre[que[1]]=0;
	hit[que[1]]=0;
	front=0;
	rear=1;
	while(front&lt;rear){
		u=que[++front];
		for(int h=1;h&lt;=n;h++){
			if(((u&gt;&gt;(h-1)))&amp;1){
				now=u&amp;~(1&lt;&lt;(h-1));
				if(G[now]&lt;0){
					G[now]=0;
					for(int h=1;h&lt;=n;h++){
						if((now&gt;&gt;(h-1))&amp;1){
							G[now]|=Side[h];
						}
					}
				}
				v=G[now];
				if(vis[v]&lt;T){
					vis[v]=T;
					pre[v]=u;
					hit[v]=h;
					dist[v]=dist[u]+1;
					if(!v)break;
					que[++rear]=v;
				}
			}
		}
		if(!v)break;
	}
	if(v)printf("Impossible\n");
	else {
		printf("%d:",dist[v]);
		u=v;
		bool frt=true;
		len=0;
		while(u!=que[1]){
			ans[++len]=hit[u];
			u=pre[u];
		}
		for(int i=len;i;i--){
			printf(" ");
			printf("%d",ans[i]-1);
		}
		printf("\n");
	}
	}
}
</pre><pre></pre><h2>Problem2271</h2><pre>/*
 *  3-sided dice.cpp
 *
 *  Created on: 2011-4-28
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Point {
	int x, y;
	Point() {
	}
	Point(int _x, int _y) :
		x(_x), y(_y) {
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	int dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	void read() {
		cin &gt;&gt; x &gt;&gt; y;
	}
	bool operator&lt;(const Point&amp;p) const {
		if (x != p.x)
			return x &lt; p.x;
		return y &lt; p.y;
	}
	bool operator==(const Point&amp;p) const {
		return x == p.x &amp;&amp; y == p.y;
	}
};

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))
inline int sign(int a) {
	return a &lt; 0 ? -1 : a &gt; 0;
}

#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))

bool crsSS(Point p1, Point p2, Point q1, Point q2) {
	return crossOp(p1,p2,q1) * crossOp(p1,p2,q2) &lt; 0 &amp;&amp; crossOp(q1,q2,p1)
			* crossOp(q1,q2,p2) &lt; 0;
}

bool inPL(Point p, Point q1, Point q2) {
	if (crossOp(q1,q2,p) != 0)
		return false;
	return (p - q1).dot(p - q2) &lt; 0;
}

int main() {
	for (;;) {
		Point p[4];
		Point me;
		int z;
		p[0].read();
		cin &gt;&gt; z;
		if (p[0].x + p[0].y + z == 0) {
			break;
		}
		for (int i = 1; i &lt; 3; ++i) {
			p[i].read();
			cin &gt;&gt; z;
		}
		me.read();
		cin &gt;&gt; z;
		sort(p, p + 3);
		if (crossOp(p[0],p[1],p[2]) == 0) {
			//same line
			//			cout &lt;&lt; "Same Line:" &lt;&lt; endl;
			if (inPL(me, p[0], p[2]))
				puts("YES");
			else
				puts("NO");
		} else {
			p[3] = p[0];
			bool check = true;
			Point dst(23471, 31572);
			int isCount = 0;
			for (int a = 0; a &lt; 3; ++a) {
				if (me == p[a])
					check = false;
				if (inPL(me, p[a], p[a + 1]))
					check = false;
				if (crsSS(me, dst, p[a], p[a + 1]))
					isCount++;
			}
			if (!check || isCount % 2 == 0) {
				puts("NO");
			} else {
				puts("YES");
			}
		}
	}
}
</pre><pre></pre><h2>Problem2274</h2><pre>/*
 *  [Usaco2011]Generic Cow Protests [Neal Wu, 2010].cpp
 *
 *  Created on: 2011-6-2
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 100000 + 10;
const int MOD = int(1e9) + 9;
int sum[MAX_N], n;

int idx[MAX_N], cnt;

inline void addIt(int&amp;x, int c) {
	x += c;
	if (x &gt;= MOD)
		x -= MOD;
}

int num[MAX_N];

void add(int p, int x) {
	for (p++; p &lt;= cnt; p += p &amp; -p)
		addIt(num[p - 1], x);
}

int calc(int p) {
	int ret = 0;
	for (p++; p &gt; 0; p -= p &amp; -p)
		addIt(ret, num[p - 1]);
	return ret;
}

int dp[MAX_N];

int main() {
	sum[0] = 0;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		int x;
		scanf("%d", &amp;x);
		sum[i + 1] = sum[i] + x;
	}

	cnt = n + 1;
	for (int i = 0; i &lt; cnt; ++i) {
		idx[i] = sum[i];
	}
	sort(idx, idx + cnt);
	cnt = unique(idx, idx + cnt) - idx;

	for (int i = 0; i &lt;= n; ++i) {
		sum[i] = lower_bound(idx, idx + cnt, sum[i]) - idx;
	}
	dp[0] = 1;
	add(sum[0], dp[0]);
	for (int i = 1; i &lt;= n; ++i) {
		dp[i] = calc(sum[i]);
		add(sum[i], dp[i]);
	}
	cout &lt;&lt; dp[n] &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem2276</h2><pre>/*
 *  [Poi2011]Temperature.cpp
 *
 *  Created on: 2011-4-26
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 1000000 + 10;
int l[MAX_N], r[MAX_N], n;

int dp[MAX_N];

struct Item {
	int val, id;
	Item() {
	}
	Item(int _val, int _id) :
		val(_val), id(_id) {
	}
};

struct Queue {
	Item stack[MAX_N];
	int n;
	int firstBigger(int x) {
		int l = 0, r = n;
		while (l + 1 &lt; r) {
			int m = l + r &gt;&gt; 1;
			if (stack[m].val &gt; x)
				l = m;
			else
				r = m;
		}
		return stack[l].id;
	}

	Queue() {
		n = 0;
		stack[n++] = Item(INT_MAX, -1);
	}

	void addItem(Item item) {
		while (stack[n - 1].val &lt;= item.val)
			--n;
		stack[n++] = item;
	}
};

Queue L, R;
int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d%d", l + i, r + i);
	}
	int ans = 0;
	for (int i = n - 1; i &gt;= 0; --i) {
		dp[i] = i;
		int atL = L.firstBigger(l[i]);
		int atR = R.firstBigger(-l[i]);
		if (atL == -1)
			atL = n;
		if (atR == -1)
			atR = n;
		int hap = min(atL, atR);
		if (hap == atR) {
			dp[i] = atR - 1;
		} else {
			dp[i] = dp[atL];
		}
		ans = max(ans, dp[i] - i + 1);
		L.addItem(Item(l[i], i));
		R.addItem(Item(-r[i], i));
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem2277</h2><pre>/*
 * Strongbox.cpp
 *
 *  Created on: 2011-6-2
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_K = 250000 + 10;
typedef long long int64;
int k;
int64 codes[MAX_K], n;

int64 gcd(int64 a, int64 b) {
	return b ? gcd(b, a % b) : a;
}

const int MAX_N_DIVISORS = 1000000;
int64 divisors[MAX_N_DIVISORS];
int nDivisors;

int64 primes[MAX_N_DIVISORS];
int nPrimes;

bool bad[MAX_N_DIVISORS];

int main() {
	cin &gt;&gt; n &gt;&gt; k;
	for (int i = 0; i &lt; k; ++i) {
		scanf("%lld", codes + i);
	}
	int64 d = gcd(codes[k - 1], n);

	{
		nDivisors = 0;
		int64 a = 1;
		for (a = 1; a * a &lt; d; a++) {
			if (d % a == 0) {
				divisors[nDivisors++] = a;
				divisors[nDivisors++] = d / a;
			}
		}
		if (a * a == d)
			divisors[nDivisors++] = a;
		sort(divisors, divisors + nDivisors);
	}

	{
		nPrimes = 0;
		int64 a = 2, x = d;
		for (; a * a &lt;= x; a++) {
			if (x % a == 0) {
				primes[nPrimes++] = a;
				while (x % a == 0)
					x /= a;
			}
		}
		if (x &gt; 1)
			primes[nPrimes++] = x;
	}

	for (int i = 0; i &lt; k - 1; ++i) {
		int64 g = gcd(codes[i], d);
		bad[lower_bound(divisors, divisors + nDivisors, g) - divisors] = true;
	}

	for (int i = nDivisors - 1; i &gt;= 0; --i) {
		if (bad[i])
			continue;
		for (int p = 0; p &lt; nPrimes; ++p) {
			if (divisors[i] &gt; d / primes[p])
				break;
			int64 g = divisors[i] * primes[p];
			int it = lower_bound(divisors, divisors + nDivisors, g) - divisors;
			if (divisors[it] == g) {
				if (bad[it]) {
					bad[i] = true;
					break;
				}
			}
		}
	}

	for (int i = 0; i &lt; nDivisors; ++i) {
		if (!bad[i]) {
			int64 ans = n / divisors[i];
			cout &lt;&lt; ans &lt;&lt; endl;
			return 0;
		}
	}
}
</pre><pre></pre><h2>Problem2286</h2><pre>/*
 *  [Sdoi2011消耗战.cpp
 *
 *  Created on: 2011-4-28
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VERTEXS = 250000 + 10;
const int MAX_LOG = 20;

struct Vertex;

struct Edge {
	Vertex*dst;
	Edge*next;
	int cost;
	Edge(Vertex*_dst, Edge*_next, int _cost) :
		dst(_dst), next(_next), cost(_cost) {
	}
};

int dfsCur;
int dstCur = 0;

typedef long long int64;

struct Vertex {
	Edge*first;
	Edge*firstCopy;

	Vertex*father;
	int preCost;
	int depth;
	int dfsOrd;
	int dfsEnd;
	int dstId;

	Vertex*fa2k[MAX_LOG];
	int min2k[MAX_LOG];
	Vertex() {
		first = 0;
		dfsOrd = -1;
		memset(fa2k, 0, sizeof fa2k);
		fill(min2k, min2k + MAX_LOG, INT_MAX);
		dstId = -1;
	}

	void setDst() {
		dstId = dstCur;
	}

	bool isDst() {
		return dstId == dstCur;
	}

	void clear() {
		first = 0;
	}

	void dfs() {
		dfsOrd = dfsCur++;
		for (Edge*e = first; e; e = e-&gt;next)
			if (e-&gt;dst-&gt;dfsOrd == -1)
				e-&gt;dst-&gt;dfs();
		dfsEnd = dfsCur - 1;
	}

	int64 calc() {
		if (isDst())
			return LONG_LONG_MAX;
		int64 ret = 0;
		for (Edge*e = first; e; e = e-&gt;next) {
			ret += min(1LL * e-&gt;cost, e-&gt;dst-&gt;calc());
		}
		return ret;
	}
};

int nVertexs;
Vertex vertexs[MAX_N_VERTEXS];
Vertex*root;

void makeEdge(Vertex*u, Vertex*v, int w) {
	Edge*uv = new Edge(v, u-&gt;first, w);
	u-&gt;first = uv;
}

inline void addEdge(Vertex*u, Vertex*v, int w) {
	makeEdge(u, v, w);
	makeEdge(v, u, w);
}

void readTree() {
	scanf("%d", &amp;nVertexs);
	for (int i = 0; i &lt; nVertexs - 1; ++i) {
		int u, v, w;
		scanf("%d%d%d", &amp;u, &amp;v, &amp;w);
		addEdge(vertexs + --u, vertexs + --v, w);
	}
	root = vertexs + 0;
}

Vertex*que[MAX_N_VERTEXS];
int qh, qt;

Vertex* up(Vertex*u, int step) {
	for (int i = 0; i &lt; MAX_LOG; ++i) {
		if (step &gt;&gt; i &amp; 1) {
			u = u-&gt;fa2k[i];
		}
	}
	return u;
}

int minCost(Vertex*u, Vertex*anc) {
	int step = u-&gt;depth - anc-&gt;depth;
	int ret = INT_MAX;
	//	cout &lt;&lt; "{";
	for (int i = 0; i &lt; MAX_LOG; ++i) {
		if (step &gt;&gt; i &amp; 1) {
			ret = min(ret, u-&gt;min2k[i]);
			u = u-&gt;fa2k[i];
		}
	}
	//	cout &lt;&lt; "}" &lt;&lt; endl;
	return ret;
}

Vertex*lca(Vertex*u, Vertex*v) {
	if (u-&gt;depth &lt; v-&gt;depth)
		swap(u, v);
	u = up(u, u-&gt;depth - v-&gt;depth);
	if (u == v)
		return u;
	for (int i = MAX_LOG - 1; i &gt;= 0; --i) {
		if (u-&gt;fa2k[i] != v-&gt;fa2k[i])
			u = u-&gt;fa2k[i], v = v-&gt;fa2k[i];
	}
	return u-&gt;father;
}

void makeDFSOrd() {
	dfsCur = 0;
	root-&gt;dfs();
}

void prepare() {
	qh = qt = 0;
	que[qt++] = root;
	root-&gt;father = 0;
	root-&gt;depth = 0;
	while (qh &lt; qt) {
		Vertex*u = que[qh++];
		for (Edge*e = u-&gt;first; e; e = e-&gt;next) {
			Vertex*v = e-&gt;dst;
			if (v == u-&gt;father)
				continue;
			que[qt++] = v;
			v-&gt;father = u;
			v-&gt;depth = u-&gt;depth + 1;
			v-&gt;preCost = e-&gt;cost;
		}
	}
	for (int i = 0; i &lt; qt; ++i) {
		Vertex*u = que[i];

		u-&gt;fa2k[0] = u-&gt;father;
		u-&gt;min2k[0] = u-&gt;preCost;
		for (int lg = 0; lg &lt; MAX_LOG; ++lg) {
			if (u-&gt;fa2k[lg] == 0)
				break;
			u-&gt;fa2k[lg + 1] = u-&gt;fa2k[lg]-&gt;fa2k[lg];
			u-&gt;min2k[lg + 1] = min(u-&gt;min2k[lg], u-&gt;fa2k[lg]-&gt;min2k[lg]);
		}
	}

	makeDFSOrd();
}

Vertex*cur[MAX_N_VERTEXS * 2];
int nCur;

bool cmpVertexPtr(Vertex*u, Vertex*v) {
	return u-&gt;dfsOrd &lt; v-&gt;dfsOrd;
}

bool isAnc(Vertex*u, Vertex*v) {
	return (u-&gt;dfsOrd &lt; v-&gt;dfsOrd &amp;&amp; u-&gt;dfsEnd &gt;= v-&gt;dfsEnd);
}

void work() {
	++dstCur;
	for (int i = 0; i &lt; nCur; ++i) {
		cur[i]-&gt;setDst();
	}
	sort(cur, cur + nCur, cmpVertexPtr);
	{
		int tmp = nCur;
		for (int i = 0; i &lt; nCur - 1; ++i) {
			cur[tmp++] = lca(cur[i], cur[i + 1]);
		}
		cur[tmp++] = root;
		nCur = tmp;
	}
	sort(cur, cur + nCur, cmpVertexPtr);
	nCur = unique(cur, cur + nCur) - cur;
	for (int i = 0; i &lt; nCur; ++i) {
		cur[i]-&gt;clear();
	}

	//build new_tree

	static Vertex* stack[MAX_N_VERTEXS];
	int top = 0;
	stack[top++] = root;
	for (int i = 1; i &lt; nCur; ++i) {
		Vertex*u = cur[i];
		while (!isAnc(stack[top - 1], u))
			--top;
		Vertex*anc = stack[top - 1];
		makeEdge(anc, u, minCost(u, anc));
		stack[top++] = u;
	}

	int64 ans = root-&gt;calc();
	printf("%lld\n", ans);
}

void answerQuestions() {
	int nQ;
	scanf("%d", &amp;nQ);
	while (nQ--) {
		scanf("%d", &amp;nCur);
		for (int i = 0; i &lt; nCur; ++i) {
			int id;
			scanf("%d", &amp;id);
			cur[i] = vertexs + --id;
		}
		work();
	}
}

void solve() {
	readTree();
	prepare();
	answerQuestions();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2287</h2><pre>/*
 *  【POJ Challenge】消失之物.cpp
 *
 *  Created on: 2011-4-26
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_ITEMS = 2000 + 10;
const int MAX_WEIGHT = 2000 + 10;

int weight[MAX_N_ITEMS];
int nItems, maxWeight;

const int MOD = 10;

void addIt(int&amp;x, int c) {
	x += c;
	if (x &gt;= MOD)
		x -= MOD;
}

void decIt(int&amp;x, int c) {
	x -= c;
	if (x &lt; 0)
		x += MOD;
}

int main() {
	cin &gt;&gt; nItems &gt;&gt; maxWeight;
	for (int i = 0; i &lt; nItems; ++i) {
		scanf("%d", weight + i);
	}

	static int am[MAX_WEIGHT] = { };
	am[0] = 1;
	for (int i = 0; i &lt; nItems; ++i) {
		int cur = weight[i];
		for (int it = maxWeight - cur; it &gt;= 0; --it) {
			addIt(am[it + cur], am[it]);
		}
	}

	for (int i = 0; i &lt; nItems; ++i) {
		int cur = weight[i];
		static int nam[MAX_WEIGHT];
		memcpy(nam, am, sizeof(int) * (maxWeight + 1));
		for (int it = cur; it &lt;= maxWeight; ++it) {
			decIt(nam[it], nam[it - cur]);
		}
		for (int c = 1; c &lt;= maxWeight; ++c) {
			putchar('0' + nam[c]);
		}
		putchar('\n');
	}
}
</pre><pre></pre><h2>Problem2288</h2><pre>/*
 *  【POJ Challenge】生日礼物.cpp
 *
 *  Created on: 2011-4-26
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 100000 + 10;

int a[MAX_N];
int n, maxOpt;

struct Tree {
	int sum;
	int maxL, maxR, maxS;
	int minL, minR, minS;

	int l, r;
	bool isNega;

	Tree*ch[2];

	void doNega(int&amp;maxV, int&amp;minV) {
		maxV *= -1;
		minV *= -1;
		swap(maxV, minV);
	}

	void applyNega() {
		isNega ^= 1;
		doNega(maxL, minL);
		doNega(maxR, minR);
		doNega(maxS, minS);
		sum *= -1;
	}

	void relax() {
		if (isNega) {
			ch[0]-&gt;applyNega();
			ch[1]-&gt;applyNega();
			isNega = false;
		}
	}

	void update() {
		Tree*L = ch[0], *R = ch[1];
		maxL = max(L-&gt;maxL, L-&gt;sum + R-&gt;maxL);
		maxR = max(R-&gt;maxR, R-&gt;sum + L-&gt;maxR);
		maxS = max(max(L-&gt;maxS, R-&gt;maxS), L-&gt;maxR + R-&gt;maxL);

		minL = min(L-&gt;minL, L-&gt;sum + R-&gt;minL);
		minR = min(R-&gt;minR, R-&gt;sum + L-&gt;minR);
		minS = min(min(L-&gt;minS, R-&gt;minS), L-&gt;minR + R-&gt;minL);

		sum = L-&gt;sum + R-&gt;sum;
	}

	Tree(int _l, int _r) :
		l(_l), r(_r), isNega(false) {
		if (l + 1 == r) {
			sum = a[l];
			maxL = maxR = maxS = max(sum, 0);
			minL = minR = minS = min(sum, 0);
			return;
		}
		int m = (l + r) &gt;&gt; 1;
		ch[0] = new Tree(l, m);
		ch[1] = new Tree(m, r);
		update();
	}

	void makeNega(int L, int R) {
		if (L &gt;= r || l &gt;= R)
			return;
		if (L &lt;= l &amp;&amp; R &gt;= r) {
			applyNega();
			return;
		}
		relax();
		for (int c = 0; c &lt; 2; ++c) {
			ch[c]-&gt;makeNega(L, R);
		}
		update();
	}

	void constrcutMaxL(int&amp;R) {
		if (maxL == 0) {
			R = l;
			return;
		}
		if (l + 1 == r) {
			R = r;
			return;
		}
		relax();
		if (maxL == ch[0]-&gt;maxL) {
			ch[0]-&gt;constrcutMaxL(R);
			return;
		}
		ch[1]-&gt;constrcutMaxL(R);
	}

	void constrcutMaxR(int&amp;L) {
		if (maxR == 0) {
			L = r;
			return;
		}
		if (l + 1 == r) {
			L = l;
			return;
		}
		relax();
		if (maxR == ch[1]-&gt;maxR) {
			ch[1]-&gt;constrcutMaxR(L);
			return;
		}
		ch[0]-&gt;constrcutMaxR(L);
	}

	void constructMaxS(int&amp;L, int&amp;R) {
		if (maxS == 0) {
			L = R = l;
			return;
		}
		if (l + 1 == r) {
			L = l;
			R = r;
			return;
		}
		relax();
		for (int c = 0; c &lt; 2; ++c) {
			if (maxS == ch[c]-&gt;maxS) {
				ch[c]-&gt;constructMaxS(L, R);
				return;
			}
		}
		ch[0]-&gt;constrcutMaxR(L);
		ch[1]-&gt;constrcutMaxL(R);
	}
};

void readInput() {
	scanf("%d%d", &amp;n, &amp;maxOpt);
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", a + i);
	}
}

void work() {
	int ans = 0;
	Tree*root = new Tree(0, n);
	for (int i = 0; i &lt; maxOpt; ++i) {
		int delta = root-&gt;maxS;
		if (delta &lt;= 0)
			break;
		ans += delta;
		int L, R;
		root-&gt;constructMaxS(L, R);
		//		cout &lt;&lt; delta &lt;&lt; ":" &lt;&lt; L &lt;&lt; "-" &lt;&lt; R &lt;&lt; endl;
		root-&gt;makeNega(L, R);
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}

void solve() {
	readInput();
	work();
}

int saveA[MAX_N];
void genData() {
	n = 1000;
	maxOpt = 10;
	for (int i = 0; i &lt; n; ++i) {
		saveA[i] = rand() % 20000 - 10000;
	}
}

void getData() {
	memcpy(a, saveA, sizeof a);
}

void bruteForce() {
	int ans = 0;
	for (int i = 0; i &lt; maxOpt; ++i) {
		int delta = 0;
		int L, R;
		int curL, tmp = -1;
		for (int at = 0; at &lt; n; ++at) {
			if (tmp &lt; 0) {
				curL = at;
				tmp = 0;
			}
			tmp += a[at];
			if (tmp &gt; delta) {
				delta = tmp;
				L = curL;
				R = at;
			}
		}

		if (delta &lt;= 0)
			break;

		cout &lt;&lt; delta &lt;&lt; ":" &lt;&lt; L &lt;&lt; "-" &lt;&lt; R &lt;&lt; endl;
		ans += delta;
		for (int i = L; i &lt;= R; ++i) {
			a[i] *= -1;
		}
	}

	cout &lt;&lt; ans &lt;&lt; endl;
}

void runTest() {
	genData();
	getData();
	work();
	cout &lt;&lt; "-----------------" &lt;&lt; endl;
	getData();
	bruteForce();
}

int main() {
	solve();
	//	runTest();
}
</pre><pre></pre><h2>Problem2289</h2><pre>/*
 *  【POJ Challenge】圆，圆，圆.cpp
 *
 *  Created on: 2011-4-26
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
		x(_x), y(_y) {
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	Point operator*(double d) const {
		return Point(x * d, y * d);
	}
	Point operator/(double d) const {
		return Point(x / d, y / d);
	}
	double det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	double dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	double alpha() const {
		return atan2(y, x);
	}
	Point rot90() const {
		return Point(-y, x);
	}
	void read() {
		scanf("%lf%lf", &amp;x, &amp;y);
	}
	void write() const {
		printf("%lf %lf", x, y);
	}
	double abs() {
		return hypot(x, y);
	}
	Point unit() {
		return *this / abs();
	}
	double distTo(const Point&amp;p) const {
		return hypot(x - p.x, y - p.y);
	}
};

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))

const double EPS = 1e-8;
inline int sign(double a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}

#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))

Point isSS(Point p1, Point p2, Point q1, Point q2) {
	double a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);
	return (p1 * a2 + p2 * a1) / (a1 + a2);
}

const int MAX_N_CIRCLES = 100000 + 10;

struct Segment {
	double l, r;
	int id;
	Segment(double _l, double _r, int _id) :
		l(_l), r(_r), id(_id) {
	}
	Segment() {
	}
};

struct Circle {
	Point c;
	double r;
	int id;

	int withX(double x) {
		if (fabs(c.x - x) &lt;= r)
			return 0;
		return c.x &lt; x ? -1 : 1;
	}

	Segment cutX(double x) {
		double dx = c.x - x;
		double dy = sqrt(r * r - dx * dx);
		return Segment(c.y - dy, c.y + dy, id);
	}

	void read(int _id) {
		id = _id;
		c.read();
		scanf("%lf", &amp;r);
	}
};

vector&lt;Point&gt; isCC(Circle a, Circle b) {
	//can't be covered
	double d = a.c.distTo(b.c);
	if (d &gt;= a.r + b.r)
		return vector&lt;Point&gt; ();
	double p = (a.r * a.r - d * d - b.r * b.r) / (2 * d);
	Point at = a.c + (b.c - a.c) * (p / d);
	double h = sqrt(a.r * a.r - p * p);
	Point dir = (b.c - a.c) * (h / d);
	vector&lt;Point&gt; ret;
	ret.push_back(at - dir);
	ret.push_back(at + dir);
	return ret;
}
int nCircles;
Circle circles[MAX_N_CIRCLES];

int main() {
	scanf("%d", &amp;nCircles);
	double Lx = 1e100, Rx = -1e100;
	for (int i = 0; i &lt; nCircles; ++i) {
		Circle&amp;c = circles[i];
		c.read(i);
		Lx = min(Lx, c.c.x - c.r);
		Rx = max(Rx, c.c.x + c.r);
	}

	while (Rx - Lx &gt; 1e-10) {
		double Mx = (Lx + Rx) / 2;
		bool has[3] = { };
		for (int i = 0; i &lt; nCircles; ++i) {
			has[circles[i].withX(Mx) + 1] = true;
		}
		if (has[0] &amp;&amp; has[2]) {
			puts("NO");
			return 0;
		}

		static Segment segments[MAX_N_CIRCLES];
		if (has[0]) {
			Rx = Mx;
			continue;
		}
		if (has[2]) {
			Lx = Mx;
			continue;
		}
		for (int i = 0; i &lt; nCircles; ++i) {
			segments[i] = circles[i].cutX(Mx);
		}

		Segment minR = segments[0], maxL = segments[0];
		for (int i = 0; i &lt; nCircles; ++i) {
			Segment cur = segments[i];
			if (cur.r &lt; minR.r)
				minR = cur;
			if (cur.l &gt; maxL.l)
				maxL = cur;
		}

		if (maxL.l + EPS &lt;= minR.r) {
			puts("YES");
			return 0;
		}

		vector&lt;Point&gt; is = isCC(circles[maxL.id], circles[minR.id]);
		if (is.empty()) {
			puts("NO");
			return 0;
		}
		Point it = is.front();
		if (it.x &gt;= Mx)
			Lx = Mx;
		else
			Rx = Mx;
	}
	puts("NO");
}
</pre><pre></pre><h2>Problem2292</h2><pre>/*
 *  【POJ Challenge 】永远挑战.cpp
 *
 *  Created on: 2011-4-26
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VERTEXS = 100000 + 10;
const int MAX_EDGE_WEIGHT = 2;
const int MAX_DIST = MAX_N_VERTEXS * MAX_EDGE_WEIGHT;

struct Vertex;

struct Edge {
	Vertex*dst;
	Edge*next;
	int cost;
	Edge(Vertex*_dst, Edge*_next, int _cost) :
		dst(_dst), next(_next), cost(_cost) {
	}
};

Vertex*distLink[MAX_DIST];

struct Vertex {
	Edge*first;
	Vertex*prev, *next;

	int dist;

	void ins(Vertex*_prev, Vertex*_next) {
		prev = _prev;
		next = _next;
		prev-&gt;next = this;
		next-&gt;prev = this;
	}

	void erase() {
		prev-&gt;next = next;
		next-&gt;prev = prev;
	}

	Vertex() {
		first = 0;
		prev = next = this;
		dist = INT_MAX;
	}

	void relax(int ndist) {
		if (ndist &lt; dist) {
			if (dist != INT_MAX)
				erase();
			dist = ndist;
			ins(distLink[dist], distLink[dist]-&gt;next);
		}
	}
};

Vertex vertexs[MAX_N_VERTEXS];

int nVertexs;

void addEdge(Vertex*u, Vertex*v, int cost) {
	Edge*e = new Edge(v, u-&gt;first, cost);
	u-&gt;first = e;
}

void readInput() {
	int nEdges;
	scanf("%d%d", &amp;nVertexs, &amp;nEdges);
	for (int i = 0; i &lt; nEdges; ++i) {
		int a, b, c;
		scanf("%d%d%d", &amp;a, &amp;b, &amp;c);
		addEdge(vertexs + --a, vertexs + --b, c);
	}
}

void work() {
	Vertex*vs = vertexs + 0, *vt = vertexs + nVertexs - 1;
	int maxDist = nVertexs * 2;

	for (int i = 0; i &lt;= maxDist; ++i) {
		distLink[i] = new Vertex;
	}

	vs-&gt;relax(0);
	for (int curDist = 0; curDist &lt;= maxDist; ++curDist) {
		for (Vertex*iter = distLink[curDist]-&gt;next; iter != distLink[curDist]; iter
				= iter-&gt;next) {
			for (Edge*e = iter-&gt;first; e; e = e-&gt;next)
				e-&gt;dst-&gt;relax(iter-&gt;dist + e-&gt;cost);
		}
	}

	printf("%d\n", vt-&gt;dist);
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem2295</h2><pre>/*
 *  【POJ Challenge】我爱你啊.cpp
 *
 *  Created on: 2011-4-26
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_L = 100000 + 10;

const string LETTER = "luvletter";

int main() {
	int nT;
	cin &gt;&gt; nT;
	static char str[MAX_L];

	while (nT--) {
		int where = 0, cnt = 0;
		scanf(" ");
		for (char c = getchar(); c != '\n'; c = getchar()) {
			if (c == LETTER[where]) {
				++where;
				if (where == LETTER.size()) {
					where = 0;
					cnt++;
				}
			}
		}
		printf("%d\n", cnt);
	}
}
</pre><pre></pre><h2>Problem2298</h2><pre>/*
 *  [HAOI2011]problem a.cpp
 *
 *  Created on: 2011-5-11
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;utility&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 100000 + 100;

struct Segment {
	int l, r, value;
	bool operator&lt;(const Segment&amp;s) const {
		if (r != s.r)
			return r &lt; s.r;
		return l &lt; s.l;
	}
	bool operator==(const Segment&amp;s) const {
		return l == s.l &amp;&amp; r == s.r;
	}
	void check() {
		int size = r - l + 1;
		if (value &gt; size)
			value = size;
	}
};
int n;
int oldN;

Segment segments[MAX_N];
int dp[MAX_N];

int main() {
	cin &gt;&gt; n;
	oldN = n;

	int cnt = 0;
	for (int i = 0; i &lt; n; ++i) {
		int A, B;
		scanf("%d%d", &amp;A, &amp;B);
		if (A + B &gt;= n)
			continue;
		int L = A, R = n - B - 1;
		segments[cnt].l = L, segments[cnt].r = R;
		cnt++;
	}

	n = cnt;
	sort(segments, segments + n);
	cnt = 0;
	for (int i = 0; i &lt; n; ++i) {
		if (cnt &gt; 0 &amp;&amp; segments[i] == segments[cnt - 1]) {
			segments[cnt - 1].value++;
		} else {
			segments[cnt] = segments[i];
			segments[cnt++].value = 1;
		}
	}

	n = cnt;

	for (int i = 0; i &lt; n; ++i) {
		segments[i].check();
	}

	dp[0] = 0;
	for (int i = 1; i &lt;= n; ++i) {
		Segment&amp;cur = segments[i - 1];
		dp[i] = max(dp[i], dp[i - 1]);
		int l = -1, r = i;
		while (l + 1 &lt; r) {
			int m = (l + r) &gt;&gt; 1;
			if (segments[m].r &lt; cur.l)
				l = m;
			else
				r = m;
		}
		dp[i] = max(dp[i], dp[l + 1] + cur.value);
	}

	cout &lt;&lt; oldN - dp[n] &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem2299</h2><pre>/*
 *  [HAOI2011]向量.cpp
 *
 *  Created on: 2011-5-11
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

typedef long long int64;

int64 gcd(int64 a, int64 b) {
	return b ? gcd(b, a % b) : a;
}

int main() {
	int nT;
	cin &gt;&gt; nT;
	while (nT--) {
		int64 a, b, x, y;
		scanf("%lld%lld%lld%lld", &amp;a, &amp;b, &amp;x, &amp;y);
		if (a == 0 &amp;&amp; b == 0) {
			if (x == 0 &amp;&amp; y == 0)
				puts("Y");
			else
				puts("N");
			continue;
		}
		int64 g = gcd(a, b);
		if (x % g || y % g) {
			puts("N");
			continue;
		}
		a /= g;
		b /= g;
		x /= g;
		y /= g;
		/*
		 * x = Xa*a + Xb*b
		 * y = Ya*a + Yb*b
		 * Xa == Yb(mod 2)
		 * Xb == Ya(mod 2)
		 */
		bool ok = false;
		for (int Xamod2 = 0; Xamod2 &lt; 2; ++Xamod2) {
			for (int Xbmod2 = 0; Xbmod2 &lt; 2; ++Xbmod2) {
				int64 X = x, Y = y;
				int Yamod2 = Xbmod2;
				int Ybmod2 = Xamod2;
				X -= a * Xamod2 + b * Xbmod2;
				Y -= a * Yamod2 + b * Ybmod2;
				//X = 2a*Xa' + 2b*Xb'
				//Y = 2a*Xa' + 2b*Yb'
				if (X % 2 || Y % 2)
					continue;
				ok = true;
			}
		}
		if (ok)
			puts("Y");
		else
			puts("N");
	}
}
</pre><pre></pre><h2>Problem2300</h2><pre>/*
 * 277. Heroes.cpp
 *
 *  Created on: 2011-3-29
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_POINTS = 100000 + 100;
const int MAX_N_QUERIES = 200000 + 100;
double mx, my;

struct Point {
	int x, y;
	double alpha;
	Point() {
	}
	Point(int _x, int _y) :
		x(_x), y(_y) {
	}
	void read() {
		scanf("%d%d", &amp;x, &amp;y);
	}
	void setAlpha() {
		alpha = atan2(y - my, x - mx);
	}
	bool operator&lt;(const Point&amp;other) const {
		return alpha &lt; other.alpha;
	}
	double distTo(const Point&amp;p) const {
		return hypot(x - p.x, y - p.y);
	}
};

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y) - (p3.x-p1.x)*(p2.y-p1.y))

inline int sign(int x) {
	return x &lt; 0 ? -1 : x &gt; 0;
}

#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))

set&lt;Point&gt; curSet;
typedef set&lt;Point&gt;::iterator Sit;
double ans;

Point getPrev(Point me) {
	if (curSet.count(me) &gt; 0)
		return me;
	Sit it = curSet.lower_bound(me);
	if (it != curSet.begin())
		return *--it;
	return *curSet.rbegin();
}

Point getNext(Point me) {
	Sit it = curSet.upper_bound(me);
	if (it != curSet.end())
		return *it;
	return *curSet.begin();
}

bool isInside(Point me) {
	Point prev = getPrev(me);
	Point next = getNext(me);
	return crossOp(prev,next,me) &gt;= 0;
}

void delPoint(Point me) {
	curSet.erase(me);
	Point prev = getPrev(me);
	Point next = getNext(me);

	ans -= prev.distTo(me);
	ans -= me.distTo(next);
	ans += prev.distTo(next);
}

void insPoint(Point me) {
	Point prev = getPrev(me);
	Point next = getNext(me);

	ans -= prev.distTo(next);
	ans += prev.distTo(me);
	ans += me.distTo(next);

	curSet.insert(me);
}

void addPoint(Point me) {
	if (isInside(me))
		return;
	while (true) {
		Point prev1 = getPrev(me);
		delPoint(prev1);
		Point prev2 = getPrev(me);
		if (crossOp(prev2,me,prev1) &lt; 0) {
			insPoint(prev1);
			break;
		}
	}
	while (true) {
		Point next1 = getNext(me);
		delPoint(next1);
		Point next2 = getNext(me);
		if (crossOp(me,next2,next1) &lt; 0) {
			insPoint(next1);
			break;
		}
	}
	insPoint(me);
}

int nPs;
Point ps[MAX_N_POINTS];
void inputData() {
	int n, x, y;
	cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;
	Point orig[3] = { Point(0, 0), Point(n, 0), Point(x, y) };
	double rands[] = { 0.3575154, 0.8515751, 0.6978456 };
	double sum = 0;
	mx = 0, my = 0;
	for (int i = 0; i &lt; 3; ++i) {
		sum += rands[i];
		mx += orig[i].x * rands[i];
		my += orig[i].y * rands[i];
	}
	mx /= sum;
	my /= sum;

	ans = -n;
	for (int i = 0; i &lt; 3; ++i) {
		orig[i].setAlpha();
		ans += orig[i].distTo(orig[(i + 1) % 3]);
	}

	sort(orig, orig + 3);

	for (int i = 0; i &lt; 3; ++i) {
		curSet.insert(orig[i]);
	}
	scanf("%d", &amp;nPs);
	for (int i = 0; i &lt; nPs; ++i) {
		ps[i].read();
		ps[i].setAlpha();
	}
}

int nQs;
int types[MAX_N_QUERIES], pointId[MAX_N_QUERIES];
bool deleted[MAX_N_POINTS] = { };

double result[MAX_N_QUERIES];

void work() {
	scanf("%d", &amp;nQs);
	for (int i = 0; i &lt; nQs; ++i) {
		scanf("%d", types + i);
		if (types[i] == 1) {
			scanf("%d", pointId + i);
			pointId[i]--;
			deleted[pointId[i]] = true;
		}
	}

	for (int i = 0; i &lt; nPs; ++i) {
		if (!deleted[i])
			addPoint(ps[i]);
	}

	for (int i = nQs - 1; i &gt;= 0; --i) {
		if (types[i] == 2) {
			result[i] = ans;
		} else {
			addPoint(ps[pointId[i]]);
		}
	}

	for (int i = 0; i &lt; nQs; ++i) {
		if (types[i] == 2)
			printf("%0.2lf\n", result[i]);
	}
}

void solve() {
	inputData();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2303</h2><pre>/*
 *  [Apio2011]方格染色.cpp
 *
 *  Created on: 2011-5-10
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = int(1e6) + 10;
const int MOD = int(1e9);

struct Vertex;

struct Edge {
	Vertex*dst;
	Edge*next;
	int c;
	Edge(Vertex*_dst, Edge*_next, int _c) :
		dst(_dst), next(_next), c(_c) {
	}
};

bool bad;

struct Vertex {
	Edge*first;
	int mark;
	bool vis;
	Vertex() :
		first(0) {
	}
	void clear() {
		first = 0;
		mark = -1;
		vis = false;
	}
	Edge*addEdge(Vertex*dst, int c) {
		return first = new Edge(dst, first, c);
	}
	void dfs() {
		if (bad)
			return;
		vis = true;
		for (Edge*e = first; e; e = e-&gt;next) {
			Vertex*v = e-&gt;dst;
			int exp = mark ^ e-&gt;c;
			if (v-&gt;mark == -1) {
				v-&gt;mark = exp;
			} else {
				if (v-&gt;mark != exp) {
					bad = true;
					return;
				}
			}
			if (!v-&gt;vis)
				v-&gt;dfs();
		}
	}
};

Vertex rows[MAX_N], cols[MAX_N];

int rs[MAX_N], cs[MAX_N], vs[MAX_N];
int k;
int nRows, nCols;

int func(int r, int c) {
	return (r % 2 == 1 &amp;&amp; c % 2 == 1);
}

int calc(int a00) {
	for (int r = 0; r &lt; nRows; ++r) {
		rows[r].clear();
	}
	for (int c = 0; c &lt; nCols; ++c) {
		cols[c].clear();
	}
	for (int i = 0; i &lt; k; ++i) {
		int r = rs[i], c = cs[i], v = vs[i];
		if (!r &amp;&amp; !c) {
			if (v != a00)
				return 0;
		}
		if (!r) {
			cols[c].mark = v;
		} else if (!c) {
			rows[r].mark = v;
		} else {
			int theyXor = v ^ a00 ^ func(r, c);
			rows[r].addEdge(cols + c, theyXor);
			cols[c].addEdge(rows + r, theyXor);
		}
	}

	bad = false;
	int ret = 1;
	for (int r = 1; r &lt; nRows; ++r) {
		if (rows[r].mark != -1 &amp;&amp; !rows[r].vis) {
			rows[r].dfs();
			if (bad)
				return 0;
		}
	}

	for (int c = 1; c &lt; nCols; ++c) {
		if (cols[c].mark != -1 &amp;&amp; !cols[c].vis) {
			cols[c].dfs();
			if (bad)
				return 0;
		}
	}

	for (int r = 1; r &lt; nRows; ++r) {
		if (!rows[r].vis) {
			rows[r].mark = 0;
			rows[r].dfs();
			(ret &lt;&lt;= 1) %= MOD;
			if (bad)
				return 0;
		}
	}

	for (int c = 1; c &lt; nCols; ++c) {
		if (!cols[c].vis) {
			cols[c].mark = 0;
			cols[c].dfs();
			(ret &lt;&lt;= 1) %= MOD;
			if (bad)
				return 0;
		}
	}
	return ret;
}

void readInput() {
	scanf("%d%d%d", &amp;nRows, &amp;nCols, &amp;k);
	for (int i = 0; i &lt; k; ++i) {
		scanf("%d%d%d", rs + i, cs + i, vs + i);
		--rs[i];
		--cs[i];
	}
}

void solve() {
	readInput();
	int ans = (calc(0) + calc(1)) % MOD;
	printf("%d\n", ans);
}
int main() {
	solve();
}
</pre><pre></pre><h2>Problem2304</h2><pre>/*
 *  [Apio2011]寻路.cpp
 *
 *  Created on: 2011-5-9
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_RECTS = 1000 + 10;
const int MAX_N_POINTS = 2000000;
const int MAX_N_VERTEXS = 2000000;

typedef long long int64;

const int64 INF = 1LL &lt;&lt; 60;

struct Vertex;

struct Edge {
	Vertex*dst;
	int64 cost;
	Edge*next;
	Edge(Vertex*_dst, Edge*_next, int64 _cost) :
		dst(_dst), next(_next), cost(_cost) {
	}
};

struct Vertex {
	Edge*first;
	int64 dist;
	bool used;
	void clear() {
		first = 0;
		dist = INF;
		used = false;
	}
	Edge* add(Vertex*dst, int64 cost) {
		return first = new Edge(dst, first, cost);
	}
};

struct Point {
	int ox, oy;
	int x, y;
	int id;
	int nRot;
	Vertex*v;
	void rot90(int&amp;x, int&amp;y) {
		int nx = -y, ny = x;
		x = nx;
		y = ny;
	}
	void rot90() {
		rot90(x, y);
	}
	Point*set(int x, int y, int nRot) {
		this-&gt;x = x;
		this-&gt;y = y;
		this-&gt;nRot = nRot;
		ox = x;
		oy = y;
		for (int i = 0; i &lt; 4 - nRot; ++i) {
			rot90(ox, oy);
		}
		return this;
	}
};

struct CmpPointPtrByOrigin {
	bool operator()(Point*a, Point*b) const {
		if (a-&gt;ox != b-&gt;ox)
			return a-&gt;ox &lt; b-&gt;ox;
		return a-&gt;oy &lt; b-&gt;oy;
	}
};

map&lt;Point*, Point*, CmpPointPtrByOrigin&gt; pointToId;

Vertex vertexs[MAX_N_POINTS];
Point points[MAX_N_POINTS];
int nPoints = 0;

Point*start, *target;

struct Rect {
	Point*LU, *LD, *RD, *RU;
	void rot90() {
		LU-&gt;rot90();
		LD-&gt;rot90();
		RD-&gt;rot90();
		RU-&gt;rot90();
		Point*copy = LU;
		LU = RU;
		RU = RD;
		RD = LD;
		LD = copy;
	}
	vector&lt;Point*&gt; onBottom;
};

inline int64 dist(Point*a, Point*b) {
	return llabs(0LL + a-&gt;x - b-&gt;x) + llabs(0LL + a-&gt;y - b-&gt;y);
}

void buildEdge(Point*a, Point*b) {
	//	cerr &lt;&lt; a-&gt;ox &lt;&lt; "," &lt;&lt; a-&gt;oy &lt;&lt; " to " &lt;&lt; b-&gt;ox &lt;&lt; "," &lt;&lt; b-&gt;oy &lt;&lt; endl;
	int64 cost = dist(a, b);
	a-&gt;v-&gt;add(b-&gt;v, cost);
	b-&gt;v-&gt;add(a-&gt;v, cost);
}

Point*getPoint(int x, int y, int nRot = 0) {
	Point*tmp = points[nPoints].set(x, y, nRot);
	if (pointToId.count(tmp))
		return pointToId[tmp];
	tmp-&gt;id = nPoints;
	tmp-&gt;v = vertexs + nPoints++;
	tmp-&gt;v-&gt;clear();
	return pointToId[tmp] = tmp;
}

Rect rects[MAX_N_RECTS];
int nRects;

int distUp(Point*p, const Rect&amp;rect) {
	if (p-&gt;y &gt; rect.LD-&gt;y)
		return -1;
	if (p-&gt;x &lt; rect.LD-&gt;x || p-&gt;x &gt; rect.RD-&gt;x)
		return -1;
	return rect.LD-&gt;y - p-&gt;y;
}

int nRot = 0;

void buildUp(Point*p, int forbid = -1) {
	int minDist = -1;
	int rId = -1;
	for (int i = 0; i &lt; nRects; ++i) {
		if (forbid == i)
			continue;
		int cur = distUp(p, rects[i]);
		if (cur == -1)
			continue;
		if (minDist == -1 || cur &lt; minDist) {
			minDist = cur;
			rId = i;
		}
	}
	if (rId == -1)
		return;
	Rect*r = rects + rId;
	Point*on = getPoint(p-&gt;x, r-&gt;LD-&gt;y, nRot);
	buildEdge(p, on);
	r-&gt;onBottom.push_back(on);
}

bool cmpPointPtrByX(Point*a, Point*b) {
	return a-&gt;x &lt; b-&gt;x;
}

void buildOnBottom(Rect*r) {
	vector&lt;Point*&gt;&amp;onBottom = r-&gt;onBottom;
	sort(onBottom.begin(), onBottom.end(), cmpPointPtrByX);
	for (int i = 0; i &lt; onBottom.size() - 1; ++i) {
		buildEdge(onBottom[i], onBottom[i + 1]);
	}
}

void buildUp() {
	for (int i = 0; i &lt; nRects; ++i) {
		rects[i].onBottom.clear();
	}
	for (int i = 0; i &lt; nRects; ++i) {
		Rect*r = rects + i;
		buildUp(r-&gt;LU, i);
		buildUp(r-&gt;RU, i);
		r-&gt;onBottom.push_back(r-&gt;LD);
		r-&gt;onBottom.push_back(r-&gt;RD);
	}
	for (int i = 0; i &lt; nRects; ++i) {
		Rect*r = rects + i;
		buildOnBottom(r);
	}
}

void buildGraph() {
	for (nRot = 0; nRot &lt; 4; nRot++) {
		buildUp();

		for (int i = 0; i &lt; nRects; ++i) {
			rects[i].rot90();
		}
		start-&gt;rot90();
		target-&gt;rot90();
	}
}

void clear() {
	nRot = 0;
	nPoints = 0;
	pointToId.clear();
}

Point*readPoint() {
	int x, y;
	scanf("%d%d", &amp;x, &amp;y);
	return getPoint(x, y);
}

void readRect(Rect*r) {
	int x1, y1, x2, y2;
	scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2);
	if (x1 &gt; x2)
		swap(x1, x2);
	if (y1 &gt; y2)
		swap(y1, y2);
	r-&gt;LU = getPoint(x1, y2);
	r-&gt;RU = getPoint(x2, y2);
	r-&gt;LD = getPoint(x1, y1);
	r-&gt;RD = getPoint(x2, y1);
}

void setPointRect(Rect*r, Point*p) {
	r-&gt;LD = r-&gt;LU = r-&gt;RD = r-&gt;RU = p;
}

void readInput() {
	start = readPoint();
	target = readPoint();
	scanf("%d", &amp;nRects);
	for (int i = 0; i &lt; nRects; ++i) {
		readRect(rects + i);
	}
	setPointRect(rects + nRects++, start);
	setPointRect(rects + nRects++, target);
}

priority_queue&lt;pair&lt;int64, Vertex*&gt; &gt; que;

void relax(Vertex*u, int64 ndist) {
	if (ndist &lt; u-&gt;dist) {
		u-&gt;dist = ndist;
		que.push(make_pair(-u-&gt;dist, u));
	}
}

void dijstra() {
	relax(start-&gt;v, 0);
	while (!que.empty()) {
		Vertex*u = que.top().second;
		que.pop();
		if (u-&gt;used)
			continue;
		u-&gt;used = true;
		for (Edge*e = u-&gt;first; e; e = e-&gt;next) {
			relax(e-&gt;dst, u-&gt;dist + e-&gt;cost);
		}
	}

	if (target-&gt;v-&gt;used)
		cout &lt;&lt; target-&gt;v-&gt;dist &lt;&lt; endl;
	else
		cout &lt;&lt; "No Path" &lt;&lt; endl;
}

void solve() {
	clear();
	readInput();
	buildGraph();
	dijstra();
}

int main() {
	int nT;
	scanf("%d", &amp;nT);
	while (nT--) {
		solve();
	}
}
</pre><pre></pre><h2>Problem2306</h2><pre>/*
 *  [Ctsc2011]幸福路径.cpp
 *
 *  Created on: 2011-5-11
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 100 + 1;

double mat[MAX_N][MAX_N];
int n, m, st;
double w[MAX_N], p;

int main() {
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; w[i];
	}
	cin &gt;&gt; st;
	--st;
	cin &gt;&gt; p;
	w[n++] = 0;
	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; n; ++j) {
			mat[i][j] = -1e100;
		}
	}
	for (int i = 0; i &lt; m; ++i) {
		int a, b;
		cin &gt;&gt; a &gt;&gt; b;
		--a;
		--b;
		mat[a][b] = w[a];
	}
	for (int i = 0; i &lt; n; ++i) {
		mat[i][n - 1] = w[i];
	}

	static double tmp[MAX_N][MAX_N];
	double pw = p;
	for (int iter = 0; iter &lt; 50; ++iter) {
		for (int i = 0; i &lt; n; ++i) {
			for (int j = 0; j &lt; n; ++j) {
				tmp[i][j] = -1e100;
			}
		}
		for (int i = 0; i &lt; n; ++i) {
			for (int j = 0; j &lt; n; ++j) {
				for (int k = 0; k &lt; n; ++k) {
					double it = mat[i][k] + mat[k][j] * pw;
					if (it &gt; tmp[i][j])
						tmp[i][j] = it;
				}
			}
		}
		memcpy(mat, tmp, sizeof mat);
		pw *= pw;
	}

	printf("%0.1lf\n", mat[st][n - 1]);
}
</pre><pre></pre><h2>Problem2309</h2><pre>/*
 *  [Ctsc2011]字符串重排.cpp
 *
 *  Created on: 2011-5-12
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_STRS = 40000 + 10;
const int MAX_N_QUERIES = 100000 + 10;

int nStrs, nQueries;
int dfsCur = 0;

const int MAX_N_ALPHA = 26 + 1;
struct Trie {
	Trie*ch[MAX_N_ALPHA];
	int nCh;
	int dep;
	int ord;
	Trie() {
		memset(ch, 0, sizeof ch);
		nCh = 0;
		father = 0;
		prev = next = first = last = 0;
	}
	Trie*go(int w) {
		Trie*&amp;t = ch[w];
		if (t == 0) {
			t = new Trie;
			t-&gt;father = this;
			nCh++;
		}
		return t;
	}
	Trie*prev, *next;
	Trie*first, *last;
	Trie*father, *vfather;
	Trie*head() {
		Trie*t;
		for (t = this; t-&gt;prev; t = t-&gt;prev)
			;
		return t;
	}
	Trie*tail() {
		Trie*t;
		for (t = this; t-&gt;next; t = t-&gt;next)
			;
		return t;
	}
	int count() {
		Trie*t = head();
		int cnt = 0;
		while (t) {
			++cnt;
			t = t-&gt;next;
		}
		return cnt;
	}
	bool find(Trie*o) {
		Trie*t = head();
		while (t) {
			if (t == o)
				return true;
			t = t-&gt;next;
		}
		return false;
	}
	bool canFirst(Trie*c) {
		if (c == first)
			return true;
		if (first != 0 || c-&gt;prev != 0)
			return false;
		if (c-&gt;tail() == last &amp;&amp; c-&gt;count() != nCh)
			return false;
		return true;
	}
	bool canLast(Trie*c) {
		if (c == last)
			return true;
		if (last != 0 || c-&gt;next != 0)
			return false;
		if (c-&gt;head() == first &amp;&amp; c-&gt;count() != nCh)
			return false;
		return true;
	}
	bool canNext(Trie*c1, Trie*c2) {
		if (c1-&gt;next == c2)
			return true;
		if (c1-&gt;next != 0 || c2-&gt;prev != 0)
			return false;
		if (c1 == last || c2 == first)
			return false;
		if (c1-&gt;find(c2))
			return false;
		if (c1-&gt;head() == first &amp;&amp; c2-&gt;tail() == last &amp;&amp; c1-&gt;count()
				+ c2-&gt;count() &lt; nCh)
			return false;
		return true;
	}
	void setFirst(Trie*c) {
		first = c;
	}
	void setLast(Trie*c) {
		last = c;
	}
	void setNext(Trie*c1, Trie*c2) {
		c1-&gt;next = c2;
		c2-&gt;prev = c1;
	}
	void dfs(int _dep) {
		ord = dfsCur++;
		dep = _dep;
		if (father == 0) {
			vfather = 0;
		} else if (father-&gt;nCh &gt; 1) {
			vfather = father;
		} else {
			vfather = father-&gt;vfather;
		}
		for (int i = 0; i &lt; MAX_N_ALPHA; ++i) {
			if (ch[i] != 0)
				ch[i]-&gt;dfs(dep + 1);
		}
	}
};

Trie*where[MAX_N_STRS];
Trie*root;

const int MAX_L_STR = 10000 + 10;

void readInput() {
	scanf("%d%d", &amp;nStrs, &amp;nQueries);
	root = new Trie;
	for (int i = 0; i &lt; nStrs; ++i) {
		static char input[MAX_L_STR];
		scanf(" ");
		scanf("%s", input);
		int L = strlen(input);
		Trie*at = root;
		for (int j = 0; j &lt; L; ++j) {
			int cur = input[j] - 'a' + 1;
			at = at-&gt;go(cur);
		}
		at = at-&gt;go(0);
		where[i] = at;
	}
}

Trie*lca(Trie*a, Trie*b) {
	for (;;) {
		if (a == b)
			return a;
		if (a == root || b == root)
			return root;
		if (a-&gt;vfather-&gt;dep &lt; b-&gt;vfather-&gt;dep)
			swap(a, b);
		a = a-&gt;vfather;
	}
}

bool check(Trie*a, Trie*b) {
	Trie*l = lca(a, b);
	//	cerr &lt;&lt; "here" &lt;&lt; endl;
	while (a-&gt;vfather != l) {
		Trie*fa = a-&gt;vfather;
		if (!fa-&gt;canLast(a))
			return false;
		a = fa;
	}
	while (b-&gt;vfather != l) {
		Trie*fa = b-&gt;vfather;
		if (!fa-&gt;canFirst(b))
			return false;
		b = fa;
	}
	if (!l-&gt;canNext(a, b))
		return false;
	return true;
}

void set(Trie*a, Trie*b) {
	Trie*l = lca(a, b);
	while (a-&gt;vfather != l) {
		Trie*fa = a-&gt;vfather;
		fa-&gt;setLast(a);
		a = fa;
	}
	while (b-&gt;vfather != l) {
		Trie*fa = b-&gt;vfather;
		fa-&gt;setFirst(b);
		b = fa;
	}
	l-&gt;setNext(a, b);
}

int X[MAX_N_QUERIES], Y[MAX_N_QUERIES];
bool done[MAX_N_QUERIES] = { };

typedef long long int64;

bool cmpTriePtrByOrd(Trie*a, Trie*b) {
	return a-&gt;ord &lt; b-&gt;ord;
}

Trie*leafs[MAX_N_STRS];

void work() {
	root-&gt;dfs(0);
	for (int i = 0; i &lt; nQueries; ++i) {
		scanf("%d%d", X + i, Y + i);
		--X[i];
		--Y[i];
	}

	int cnt = 0;
	for (int i = nQueries - 1; i &gt;= 0; --i) {
		if (check(where[X[i]], where[Y[i]])) {
			set(where[X[i]], where[Y[i]]);
			++cnt;
			done[i] = true;
		}
	}
	int64 score = 0;

	for (int i = 0; i &lt; nStrs; ++i) {
		leafs[i] = where[i];
	}
	sort(leafs, leafs + nStrs, cmpTriePtrByOrd);
	for (int i = 0; i &lt; nStrs - 1; ++i) {
		int64 tmp = lca(leafs[i], leafs[i + 1])-&gt;dep;
		score += tmp * tmp;
	}

	cout &lt;&lt; score &lt;&lt; endl;
	printf("%d\n", cnt);
	for (int i = 0; i &lt; nQueries; ++i) {
		if (done[i])
			printf("%d ", i + 1);
	}
	printf("\n");
}

void solve() {
	readInput();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2310</h2><pre>/*
 *  ParkII.cpp
 *
 *  Created on: 2011-6-24
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_V_STATE = 1 &lt;&lt; 18;
const int MAX_N_STATE = 10000;
const int MAX_N_ROWS = 100 + 10;
const int MAX_N_COLS = 8;
int n, m;

const int LEFT = 2, RIGHT = 3, NONE = 0, INDEPENDENT = 1;
const int ADD[] = { 0, 0, 1, -1 };

int stateToId[MAX_V_STATE];
int states[MAX_N_STATE], nStates;

inline int get(int s, int at) {
	return s &gt;&gt; (2 * at) &amp; 3;
}

void dfs(int state, int at, int balance, int nIndependent) {
	if (at == m + 1) {
		if (balance == 0) {
			int id = nStates++;
			states[id] = state;
			stateToId[state] = id;
		}
		return;
	}
	for (int next = 0; next &lt; 4; ++next) {
		int add = ADD[next];
		if (balance + add &gt;= 0) {
			if (next == INDEPENDENT &amp;&amp; nIndependent &gt;= 2)
				continue;
			dfs(state + (1 &lt;&lt; (2 * at)) * next, at + 1, balance + add,
					nIndependent + (next == INDEPENDENT));
		}
	}
}

int match[MAX_N_STATE][MAX_N_COLS + 1];
int nIndep[MAX_N_STATE];
int nComps[MAX_N_STATE];
bool canEnd[MAX_N_STATE];

void show(int s) {
	for (int j = 0; j &lt;= m; ++j) {
		int me = get(s, j);
		printf("%c", me == LEFT ? '(' : me == RIGHT ? ')' : me == NONE ? '0'
				: '+');
	}
	printf("\n");
}

void prepare() {
	nStates = 0;
	memset(stateToId, -1, sizeof stateToId);
	dfs(0, 0, 0, 0);
	for (int i = 0; i &lt; nStates; ++i) {
		int s = states[i];
		static int stack[MAX_N_COLS + 1];
		int top = 0;
		int*match = ::match[i];
		memset(match, -1, sizeof(int) * (m + 1));
		nIndep[i] = 0;
		nComps[i] = 0;
		for (int j = 0; j &lt;= m; ++j) {
			int me = get(s, j);
			if (me == LEFT) {
				stack[top++] = j;
				nComps[i]++;
			}
			if (me == RIGHT) {
				int L = stack[--top];
				match[L] = j;
				match[j] = L;
			}
			if (me == INDEPENDENT)
				nIndep[i]++;
		}

		nComps[i] += nIndep[i];
		canEnd[i] = nComps[i] == 1;
	}
}

int map[MAX_N_ROWS][MAX_N_COLS];

const int INF = INT_MAX / 4;
int dp[2][MAX_N_STATE];
int*am, *nam;

void clear(int am[]) {
	fill(am, am + nStates, -INF);
}

void update(int state, int w) {
	assert(state&gt;=0);
	assert(state&lt;MAX_V_STATE);
	int id = stateToId[state];
	if (id == -1)
		return;
	nam[id] = max(nam[id], w);
}

void work() {
	am = dp[0], nam = dp[1];
	int ans = -INF;
	clear(nam);
	update(0, 0);
	swap(am, nam);
	for (int r = 0; r &lt; n; ++r) {
		for (int c = 0; c &lt; m; ++c) {
			int v = map[r][c];

			clear(nam);
			for (int id = 0; id &lt; nStates; ++id) {
				int w = am[id];
				if (w == -INF)
					continue;
				if (canEnd[id]) {
					ans = max(ans, w);
				}
				int s = states[id];
				int p1 = get(s, c), p2 = get(s, c + 1);
				int w1 = 1 &lt;&lt; (2 * c), w2 = 1 &lt;&lt; (2 * (c + 1));
				int ns = s - p1 * w1 - p2 * w2;
				int*match = ::match[id];
				if (p1 == LEFT &amp;&amp; p2 == RIGHT) {
					update(s, w);
					update(ns + w1 * INDEPENDENT, w);
					update(ns + w2 * INDEPENDENT, w);
					continue;
				}
				for (int b1 = 0; b1 &lt; 2; ++b1) {
					if (b1 &amp;&amp; (p1 == NONE || p1 == INDEPENDENT))
						continue;
					for (int b2 = 0; b2 &lt; 2; ++b2) {
						if (b2 &amp;&amp; (p2 == NONE || p2 == INDEPENDENT))
							continue;
						int st = ns;
						if (b1) {
							int at = match[c];
							assert(at&gt;=0);
							st += (1 &lt;&lt; (2 * at)) * (INDEPENDENT - get(ns, at));
						} else {
							st += p1 * w1;
						}
						if (b2) {
							int at = match[c + 1];
							assert(at&gt;=0);
							st += (1 &lt;&lt; (2 * at)) * (INDEPENDENT - get(ns, at));
						} else {
							st += p2 * w2;
						}
						if (p1 == LEFT &amp;&amp; p2 == RIGHT &amp;&amp; b1 &amp;&amp; b2)
							continue;
						update(st, w);
					}
				}
			}
			swap(am, nam);

			clear(nam);
			for (int id = 0; id &lt; nStates; ++id) {
				int w = am[id];
				if (w == -INF)
					continue;
				if (canEnd[id]) {
					ans = max(ans, w);
				}
				int s = states[id];
				int p1 = get(s, c), p2 = get(s, c + 1);
				int w1 = 1 &lt;&lt; (2 * c), w2 = 1 &lt;&lt; (2 * (c + 1));
				int ns = s - p1 * w1 - p2 * w2;
				int*match = ::match[id];
				if (p1 == NONE &amp;&amp; p2 == NONE) {
					update(ns, w);
					update(ns + INDEPENDENT * w1, w + v);
					update(ns + INDEPENDENT * w2, w + v);
					update(ns + LEFT * w1 + RIGHT * w2, w + v);
					continue;
				}
				if (p1 == INDEPENDENT &amp;&amp; p2 == INDEPENDENT) {
					if (nComps[id] == 2) {
						ans = max(ans, w + v);
					}
					continue;
				}
				if (p1 == INDEPENDENT || p2 == INDEPENDENT) {
					if (p1 == NONE || p2 == NONE) {
						update(ns + w1 * INDEPENDENT, w + v);
						update(ns + w2 * INDEPENDENT, w + v);
					} else {
						int at = p1 == INDEPENDENT ? c + 1 : c;
						at = match[at];
						assert(at&gt;=0);
						update(ns + (1 &lt;&lt; (2 * at)) * (INDEPENDENT
								- get(ns, at)), w + v);
					}
					continue;
				}
				if (p1 == NONE || p2 == NONE) {
					int it = p1 == NONE ? p2 : p1;
					update(ns + w1 * it, w + v);
					update(ns + w2 * it, w + v);
					continue;
				}
				if (p1 == LEFT &amp;&amp; p2 == LEFT) {
					int r = match[c + 1];
					assert(r&gt;=0);
					update(ns + (1 &lt;&lt; (2 * r)) * (LEFT - RIGHT), w + v);
				} else if (p1 == LEFT &amp;&amp; p2 == RIGHT) {
					if (nComps[id] == 1)
						ans = max(ans, w + v);
				} else if (p1 == RIGHT &amp;&amp; p2 == LEFT) {
					update(ns, w + v);
				} else {
					int l = match[c];
					assert(l&gt;=0);
					update(ns + (1 &lt;&lt; (2 * l)) * (RIGHT - LEFT), w + v);
				}
			}
			swap(am, nam);
		}

		clear(nam);
		for (int id = 0; id &lt; nStates; ++id) {
			int s = states[id];
			if (get(s, m) == NONE) {
				update(s * 4, am[id]);
			}
		}
		swap(am, nam);
	}

	for (int id = 0; id &lt; nStates; ++id) {
		if (canEnd[id])
			ans = max(ans, am[id]);
	}

	cout &lt;&lt; ans &lt;&lt; endl;
}

void readInput() {
	cin &gt;&gt; n &gt;&gt; m;
	for (int r = 0; r &lt; n; ++r) {
		for (int c = 0; c &lt; m; ++c) {
			scanf("%d", map[r] + c);
		}
	}
}

int main() {
	readInput();
	prepare();
	work();
}
</pre><pre></pre><h2>Problem2313</h2><pre>/*
 *  分组.cpp
 *
 *  Created on: 2011-5-19
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MOD = int(1e9) - 401;
const int PHI = MOD - 1;
const int DIVISORS[] = { 2, 13, 5281, 7283 };
const int MAX_DIV = 10000;

int fact[MAX_DIV];

bool isPrime(int x) {
	for (int i = 2; i * i &lt;= x; i++)
		if (x % i == 0)
			return false;
	return true;
}

int calc(int n) {
	int ret = 0;
	for (int k = 1; k &lt;= n; k++) {
		if (n % k == 0) {
			int div = 1;
			for (int j = 0; j &lt; (n / k); ++j) {
				div *= fact[k];
			}
			div *= fact[n / k];
			ret += fact[n] / div;
		}
	}
	return ret;
}

void decompose(int x) {
	bool first = true;
	for (int i = 2; i * i &lt;= x; ++i) {
		if (x % i == 0) {
			int cnt = 0;
			while (x % i == 0)
				++cnt, x /= i;
			if (!first)
				cout &lt;&lt; "*";
			first = false;
			cout &lt;&lt; i;
			if (cnt &gt; 1)
				cout &lt;&lt; "^" &lt;&lt; cnt;
		}
	}
	if (x &gt; 1) {
		if (!first)
			cout &lt;&lt; "*";
		first = false;
		cout &lt;&lt; x;
	}
	cout &lt;&lt; endl;
}

int powMod(int x, int e, int mod) {
	if (!e)
		return 1;
	if (e &amp; 1)
		return 1LL * powMod(x, e - 1, mod) * x % mod;
	return powMod(1LL * x * x % mod, e &gt;&gt; 1, mod);
}

struct Result {
	int ret;
	int pCount;
	Result(int _ret, int _pCount) :
		ret(_ret), pCount(_pCount) {
	}
	Result pow(int p, int mod) {
		return Result(powMod(ret, p, mod), pCount * p);
	}
};

inline int invMod(int x, int mod) {
	return powMod(x, mod - 2, mod);
}

Result divide(Result a, Result b, int mod) {
	return Result(a.ret * invMod(b.ret, mod) % mod, a.pCount - b.pCount);
}

Result multiply(Result a, Result b, int mod) {
	return Result(a.ret * b.ret % mod, a.pCount + b.pCount);
}

Result calcFactMod(int n, int p) {
	//n!%p
	if (!n) {
		return Result(1, 0);
	}
	int ret = 1, cnt = n / p;
	int step = fact[p - 1] % p;
	ret = powMod(step, cnt, p);
	for (int i = cnt * p + 1; i &lt;= n; ++i) {
		int tmp = i - cnt * p;
		(ret *= tmp) %= p;
	}

	Result now = Result(ret, cnt);
	now = multiply(now, calcFactMod(n / p, p), p);
	return now;
}

typedef long long int64;

void extGcd(int64 a, int64 b, int64&amp;x, int64&amp;y) {
	if (!b) {
		x = 1;
		y = 0;
		return;
	}
	extGcd(b, a % b, y, x);
	y -= a / b * x;
}

int countDivides(int n, int k) {
	//n!/( (k!)^(n/k)*(n/k)! ) % PHI
	int rets[4];
	for (int i = 0; i &lt; 4; ++i) {
		int mod = DIVISORS[i];
		Result rn = calcFactMod(n, mod);
		Result rk = calcFactMod(k, mod);
		Result rndk = calcFactMod(n / k, mod);
		Result div = multiply(rk.pow(n / k, mod), rndk, mod);
		Result cur = divide(rn, div, mod);
		if (cur.pCount &gt; 0) {
			rets[i] = 0;
		} else {
			rets[i] = cur.ret;
		}
	}

	int64 ans = 0;
	for (int i = 0; i &lt; 4; ++i) {
		int64 m = DIVISORS[i], M = PHI / m;
		int64 x, y;
		extGcd(m, M, x, y);
		//x*m+M*y = 1
		int64 me = M * y % PHI;
		if (me &lt; 0)
			me += PHI;
		(ans += me * rets[i] % PHI) %= PHI;
	}

	return ans;
}

int calcWays(int n) {
	int ret = 0;
	int k;
	for (k = 1; k * k &lt; n; ++k) {
		if (n % k == 0) {
			(ret += countDivides(n, k)) %= PHI;
			(ret += countDivides(n, n / k)) %= PHI;
		}
	}
	if (k * k == n)
		(ret += countDivides(n, k)) %= PHI;
	return ret;
}

int calcAns(int n, int m) {
	int pow = calcWays(n);
	int ret = powMod(m, pow, MOD);
	return ret;
}

void prepareFact() {
	fact[0] = 1;
	for (int i = 1; i &lt; MAX_DIV; ++i) {
		fact[i] = 1LL * fact[i - 1] * i % PHI;
	}
}

void solve() {
	prepareFact();
	int nT;
	cin &gt;&gt; nT;
	for (int i = 0; i &lt; nT; ++i) {
		int n, m;
		cin &gt;&gt; n &gt;&gt; m;
		cout &lt;&lt; calcAns(n, m) &lt;&lt; endl;
	}
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2314</h2><pre>/*
 * 士兵的放置.cpp
 *
 *  Created on: 2011-7-27
 *      Author: mac
 */

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MOD = 1032992941;
const int MAX_N_VERTICES = 500000 + 10;
vector&lt;int&gt; E[MAX_N_VERTICES];
int nVertices;

void readInput() {
	cin &gt;&gt; nVertices;
	for (int i = 0; i &lt; nVertices - 1; ++i) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		E[a].push_back(b), E[b].push_back(a);
	}
}

int que[MAX_N_VERTICES], qh, qt;
int father[MAX_N_VERTICES];

const int INF = MAX_N_VERTICES + 1;

struct Answer {
	int num, cnt;
	Answer(int _num, int _cnt) :
			num(_num), cnt(_cnt) {
		if (num &gt; INF)
			num = INF;
	}
	Answer() {
	}
};

Answer together(Answer a, Answer b) {
	return Answer(a.num + b.num, 1LL * a.cnt * b.cnt % MOD);
}

Answer choseOne(Answer a, Answer b) {
	if (a.num &lt; b.num)
		return a;
	else if (b.num &lt; a.num)
		return b;
	else
		return Answer(a.num, (a.cnt + b.cnt) % MOD);
}

Answer has[MAX_N_VERTICES], unNeed[MAX_N_VERTICES], need[MAX_N_VERTICES];

void work() {
	qh = qt = 0;
	que[qt++] = 1;
	while (qh &lt; qt) {
		int u = que[qh++];
		foreach(e,E[u])
			if (*e != father[u]) {
				father[*e] = u;
				que[qt++] = *e;
			}
	}
	for (int i = nVertices - 1; i &gt;= 0; --i) {
		int u = que[i];
		static int ch[MAX_N_VERTICES], nCh;
		nCh = 0;
		foreach(e,E[u])
			if (*e != father[u])
				ch[nCh++] = *e;
		//has
		has[u] = Answer(1, 1);
		for (int i = 0; i &lt; nCh; ++i) {
			int c = ch[i];
			Answer best = choseOne(has[c], choseOne(unNeed[c], need[c]));
			has[u] = together(has[u], best);
		}
		//unNeed
		static Answer pre[MAX_N_VERTICES];
		pre[0] = Answer(0, 1);
		for (int i = 0; i &lt; nCh; ++i) {
			pre[i + 1] = together(pre[i], unNeed[ch[i]]);
		}
		static Answer suf[MAX_N_VERTICES];
		suf[nCh] = Answer(0, 1);
		for (int i = nCh - 1; i &gt;= 0; --i) {
			suf[i] = together(suf[i + 1], choseOne(unNeed[ch[i]], has[ch[i]]));
		}

		Answer&amp;ret = unNeed[u] = Answer(INF, 0);
		for (int firstHas = 0; firstHas &lt; nCh; ++firstHas) {
			Answer tmp = together(pre[firstHas], has[ch[firstHas]]);
			tmp = together(tmp, suf[firstHas + 1]);
			ret = choseOne(ret, tmp);
		}
		//need
		need[u] = Answer(0, 1);
		for (int i = 0; i &lt; nCh; ++i) {
			need[u] = together(need[u], unNeed[ch[i]]);
		}
	}

	Answer ans = choseOne(has[1], unNeed[1]);
	cout &lt;&lt; ans.num &lt;&lt; endl;
	cout &lt;&lt; ans.cnt &lt;&lt; endl;
}

void solve() {
	readInput();
	work();
}

int main() {
	solve();
	return 0;
}
</pre><pre></pre><h2>Problem2315</h2><pre>/*
 * 黑白游戏.cpp
 *
 *  Created on: 2011-7-16
 *      Author: mac
 */
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;climits&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;

typedef long long int64;
struct Fraction {
	int64 a, b; //a/b
	Fraction() {
	}
	Fraction(int64 _a, int64 _b) :
			a(_a), b(_b) {
	}
	Fraction adjust(int64 nb) const {
		int64 by = nb / b;
		return Fraction(a * by, b * by);
	}
	Fraction operator+(const Fraction&amp;o) const {
		if (b &lt; o.b)
			return adjust(o.b) + o;
		else if (b &gt; o.b)
			return o.adjust(b) + (*this);
		else
			return Fraction(a + o.a, b);
	}
	bool operator&lt;(const Fraction&amp;o) const {
		if (b &lt; o.b)
			return adjust(o.b) &lt; o;
		else if (b &gt; o.b)
			return (*this) &lt; o.adjust(b);
		else
			return a &lt; o.a;
	}
};

Fraction readTower(int n) {
	static char buf[100];
	scanf(" ");
	for (int i = 0; i &lt; n; ++i) {
		scanf(" ");
		scanf("%c", buf + i);
	}
	int x = 0, i;
	for (i = 0; i &lt; n &amp;&amp; buf[i] == buf[0]; ++i) {
		if (buf[i] == 'W')
			++x;
		else
			--x;
	}
	Fraction ret(x, 1);
	int64 k = 2;
	for (; i &lt; n; ++i) {
		ret = ret + Fraction(buf[i] == 'W' ? 1 : -1, k);
		k &lt;&lt;= 1;
	}
	return ret;
}

Fraction readState() {
	int ns[3];
	for (int i = 0; i &lt; 3; ++i) {
		scanf("%d", ns + i);
	}
	Fraction ret(0, 1);
	for (int i = 0; i &lt; 3; ++i) {
		ret = ret + readTower(ns[i]);
	}
	return ret;
}

int main() {
	int nTests;
	scanf("%d", &amp;nTests);
	for (int i = 0; i &lt; nTests; ++i) {\
		Fraction a = readState(), b = readState();
		if (a &lt; b)
			printf("No\n");
		else
			printf("Yes\n");
	}
}
</pre><pre></pre><h2>Problem2316</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
const int inf=~0U&gt;&gt;1,maxn=105;
using namespace std;
inline int lowbit(int x){return x&amp;-x;}
int log(int x){return x==1?0:(log(x/2)+1);}
int n,m;
int sg(int x,int y)
{
    if(x==0||y==0)return log(lowbit(x+y+1));
    return x+y;
}
bool E[maxn*2]={};
int main()
{
    //freopen("in","r",stdin);
    int T;scanf("%d",&amp;T);
    rep(t,T)
    {
        scanf("%d%d",&amp;n,&amp;m);
        memset(E,0,sizeof E);
        rep(i,n)
        {
            scanf(" ");
            rep(j,m)
            {
                char c=getchar();
                if(c=='T')
                    E[sg(i,j)]^=1;
            }
        }
        bool ok=true;
        rep(i,n+m)if(E[i]){ok=false;break;}
        if(ok)puts("=_=");
        else puts("-_-");
    }
}

</pre><pre></pre><h2>Problem2320</h2><pre>/*
 * 最多重复子串.cpp
 *
 *  Created on: 2011-6-23
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 100000 + 10;
char str[MAX_N];
const int SEED = 13331;
int pow[MAX_N];

struct Hash {
	int hash[MAX_N];
	void init(char str[], int L) {
		hash[0] = 0;
		for (int i = 1; i &lt;= L; ++i) {
			hash[i] = hash[i - 1] * SEED + str[i - 1];
		}
	}
	int ask(int l, int r) const {
		return hash[r + 1] - hash[l] * pow[r - l + 1];
	}
};

int n;

Hash nor, rev;
int revPos(int at) {
	return n - 1 - at;
}

int lcp(const Hash&amp;h, int a, int b) {
	if (a &gt; b)
		swap(a, b);
	int l = 0, r = n - b + 1;
	while (l + 1 &lt; r) {
		int m = l + r &gt;&gt; 1;
		if (h.ask(a, a + m - 1) == h.ask(b, b + m - 1))
			l = m;
		else
			r = m;
	}
	return l;
}

bool cmpSuffix(int a, int b) {
	int l = lcp(nor, a, b);
	return str[a + l] &lt; str[b + l];
}

int sa[MAX_N];
int rank[MAX_N];

bool cmpSubString(int aL, int aR, int bL, int bR) {
	int l = lcp(nor, aL, bL);
	int minS = min(aR - aL + 1, bR - bL + 1);
	if (l &gt;= minS)
		return aR - aL &lt; bR - bL;
	else
		return str[aL + l] &lt; str[bL + l];
}

int maxRepeat, ansL, ansR;

struct Tree {
	int minv;
	int l, r;
	Tree*ch[2];
	Tree(int seq[], int _l, int _r) :
		l(_l), r(_r) {
		if (l + 1 == r) {
			ch[0] = ch[1] = 0;
			minv = seq[l];
			return;
		}
		ch[0] = new Tree(seq, l, l + r &gt;&gt; 1);
		ch[1] = new Tree(seq, l + r &gt;&gt; 1, r);
		minv = min(ch[0]-&gt;minv, ch[1]-&gt;minv);
	}

	int ask(int L, int R) {
		if (l &gt;= R || L &gt;= r)
			return INT_MAX;
		if (L &lt;= l &amp;&amp; R &gt;= r)
			return minv;
		return min(ch[0]-&gt;ask(L, R), ch[1]-&gt;ask(L, R));
	}
	~Tree() {
		if (ch[0]) {
			delete ch[0];
			delete ch[1];
		}
	}
}*root;

void solve() {
	scanf("%s", str);
	n = strlen(str);
	str[n] = 0;
	nor.init(str, n);
	reverse(str, str + n);
	rev.init(str, n);
	reverse(str, str + n);
	for (int i = 0; i &lt; n; ++i) {
		sa[i] = i;
	}
	sort(sa, sa + n, cmpSuffix);

	for (int i = 0; i &lt; n; ++i) {
		rank[sa[i]] = i;
	}

	root = new Tree(rank, 0, n);

	maxRepeat = 0;
	for (int len = 1; len &lt;= n; ++len) {
		for (int at = 0; at + len &lt;= n; at += len) {
			int L = at, R = at + len - 1;
			int eL = L - lcp(rev, revPos(L - 1), revPos(R));
			int eR = R + lcp(nor, L, R + 1);
			int eLen = eR - eL + 1;
			int rep = eLen / len;
			if (rep &lt; maxRepeat)
				continue;

			int tLen = rep * len;
			int canL = eL, canR = eR - tLen + 1;

			int aL = sa[root-&gt;ask(canL, canR + 1)], aR = aL + tLen - 1;

			if (rep &gt; maxRepeat) {
				maxRepeat = rep;
				ansL = aL;
				ansR = aR;
			} else {
				if (cmpSubString(aL, aR, ansL, ansR)) {
					ansL = aL;
					ansR = aR;
				}
			}
		}
	}

	for (int i = ansL; i &lt;= ansR; ++i) {
		putchar(str[i]);
	}
	printf("\n");
}

int main() {
	pow[0] = 1;
	for (int i = 1; i &lt; MAX_N; ++i) {
		pow[i] = pow[i - 1] * SEED;
	}
	int nT;
	cin &gt;&gt; nT;
	while (nT--) {
		solve();
	}
}
</pre><pre></pre><h2>Problem2321</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define iRep(i,n) for(int i=1;i&lt;=n;i++)
#define CLR(x,c) memset(x,c,sizeof x)
using namespace std;

void setIO(string name){
	string inFile = name + ".in";
	string outFile = name + ".out";
	freopen(inFile.c_str(),"r",stdin);
	freopen(outFile.c_str(),"w",stdout);
}

typedef long long int64;

const int MAX_N = 200+10;
int init[MAX_N][MAX_N];
int fin[MAX_N][MAX_N];
int R,C;

int64 stdAns;

void genInput(){
	stdAns=0;
	R=20,C=20;
	iRep(r,R)iRep(c,C){
		fin[r][c]=init[r][c] = rand()%20;
	}
	
	rep(it,10000){
		if(rand()%2==0){
			iRep(r,R){
				int c1=rand()%C+1,c2=rand()%C+1;
				if(c1&gt;c2)
					swap(c1,c2);
				if(c1+1 &lt; c2 &amp;&amp; fin[r][c1] &gt; 0 &amp;&amp; fin[r][c2] &gt; 0){
					stdAns += c2-c1-1;
					fin[r][c1]--;
					fin[r][++c1]++;
					fin[r][c2]--;
					fin[r][--c2]++;
				}
			}
		} else {
			iRep(c,C){
				int r1 = rand()%R+1,r2=rand()%R+1;
				if(r1&gt;r2)
					swap(r1,r2);
				if(r1+1&lt;r2 &amp;&amp; fin[r1][c]&gt;0&amp;&amp;fin[r2][c]&gt;0){
					stdAns += r2-r1-1;
					fin[r1][c]--;
					fin[++r1][c]++;
					fin[r2][c]--;
					fin[--r2][c]++;
				}
			}
		}
	}
}

void readInput(){
	cin&gt;&gt;R&gt;&gt;C;
	iRep(r,R)iRep(c,C){
		scanf("%d",&amp;init[r][c]);
	}
	
	iRep(r,R)iRep(c,C){
		scanf("%d",&amp;fin[r][c]);
	}
}

int64 work(){
	int64 ans=0;
	iRep(r,R)iRep(c,C){
		int x=init[r][c];
		ans += 1LL*x*(r*(r-1)/2+c*(c-1)/2);
	}
	iRep(r,R)iRep(c,C){
		int x = fin[r][c];
		ans -= 1LL*x*(r*(r-1)/2+c*(c-1)/2);
	}
	return ans;
}

void solve(){
	readInput();
	cout&lt;&lt;work()&lt;&lt;endl;
}

void runTest(){
	genInput();
	cout&lt;&lt;stdAns&lt;&lt;endl;
	cout&lt;&lt;work()&lt;&lt;endl;
}

int main(){
	solve();
//	runTest();
}
</pre><pre></pre><h2>Problem2322</h2><pre>/*
 *  [BeiJing2011集训]梦想封印.cpp
 *
 *  Created on: 2011-5-27
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VERTICES = 5000 + 10;
const int N_BIT = 64 + 10;
typedef long long int64;

int64 bases[N_BIT];
int control[N_BIT];
int nBases;

int64 getRepresent(int64 x) {
	for (int i = 0; i &lt; nBases; ++i) {
		if (x &gt;&gt; control[i] &amp; 1)
			x ^= bases[i];
	}
	return x;
}

bool addBase(int64 x) {
	x = getRepresent(x);
	if (x == 0)
		return false;
	int con;
	for (int i = 0; i &lt; N_BIT; ++i) {
		if (x &gt;&gt; i &amp; 1) {
			con = i;
			break;
		}
	}
	for (int i = 0; i &lt; nBases; ++i) {
		if (bases[i] &gt;&gt; con &amp; 1)
			bases[i] ^= x;
	}

	bases[nBases] = x;
	control[nBases++] = con;
	return true;
}

set&lt;int64&gt; dists;

struct Vertex;

struct Edge {
	Vertex*src, *dst;
	bool exist;
	int64 c;
	Edge*rev;
	Edge(Vertex*_src, Vertex*_dst, int64 _c) :
		src(_src), dst(_dst), c(_c), exist(true) {
	}
};

int nCur;
Vertex*cur[MAX_N_VERTICES];

struct Vertex {
	int64 dist;
	vector&lt;Edge*&gt; outgo;
	bool visited;
	Vertex() :
		visited(false) {
	}

	void dfs(int64 _dist) {
		cur[nCur++] = this;
		dist = _dist;
		visited = true;
		foreach(iter,outgo) {
			Edge*e = *iter;
			if (!e-&gt;dst-&gt;visited &amp;&amp; e-&gt;exist) {
				e-&gt;dst-&gt;dfs(dist ^ e-&gt;c);
			}
		}
	}
};

Edge* addEdge(Vertex*u, Vertex*v, int64 c) {
	Edge*uv = new Edge(u, v, c);
	Edge*vu = new Edge(v, u, c);
	uv-&gt;rev = vu;
	vu-&gt;rev = uv;
	u-&gt;outgo.push_back(uv);
	v-&gt;outgo.push_back(vu);
	return uv;
}

const int MAX_N_EDGES = 20000 + 10;
const int MAX_N_QUERIES = 20000 + 10;

Edge*edges[MAX_N_EDGES];

int nVertices, nEdges, nQueries;

Edge*queries[MAX_N_EDGES];
Vertex vertices[MAX_N_VERTICES];

void readInput() {
	scanf("%d%d%d", &amp;nVertices, &amp;nEdges, &amp;nQueries);
	for (int i = 0; i &lt; nEdges; ++i) {
		int a, b;
		int64 c;
		scanf("%d%d%lld", &amp;a, &amp;b, &amp;c);
		Vertex*u = vertices + --a, *v = vertices + --b;
		edges[i] = addEdge(u, v, c);
	}

	for (int i = 0; i &lt; nQueries; ++i) {
		int id;
		scanf("%d", &amp;id);
		--id;
		queries[i] = edges[id];
	}
}

int64 ans[MAX_N_QUERIES];

void reCalcDists() {
	dists.clear();
	for (int i = 0; i &lt; nVertices; ++i) {
		Vertex*u = vertices + i;
		if (u-&gt;visited) {
			dists.insert(getRepresent(u-&gt;dist));
		}
	}
}

int64 getCycle(Edge*e) {
	return e-&gt;src-&gt;dist ^ e-&gt;dst-&gt;dist ^ e-&gt;c;
}

void addVertices(Vertex*root, int64 initDist) {
	nCur = 0;
	root-&gt;dfs(initDist);
	for (int i = 0; i &lt; nCur; ++i) {
		Vertex*u = cur[i];
		foreach(iter,u-&gt;outgo) {
			Edge*e = *iter;
			if (e-&gt;src-&gt;visited &amp;&amp; e-&gt;dst-&gt;visited &amp;&amp; e-&gt;exist) {
				if (addBase(getCycle(e))) {
					reCalcDists();
				}
			}
		}
	}

	for (int i = 0; i &lt; nCur; ++i) {
		Vertex*u = cur[i];
		dists.insert(getRepresent(u-&gt;dist));
	}
}

void work() {
	for (int i = 0; i &lt; nQueries; ++i) {
		queries[i]-&gt;exist = queries[i]-&gt;rev-&gt;exist = false;
	}
	nBases = 0;
	Vertex*kernel = vertices + 0;
	addVertices(kernel, 0);
	ans[nQueries] = (1LL &lt;&lt; nBases) * dists.size() - 1;
	for (int i = nQueries - 1; i &gt;= 0; --i) {
		Edge*e = queries[i];
		e-&gt;exist = e-&gt;rev-&gt;exist = true;
		Vertex*a = e-&gt;src, *b = e-&gt;dst;
		if (!a-&gt;visited &amp;&amp; !b-&gt;visited) {
			goto end;
		}
		if (a-&gt;visited &amp;&amp; b-&gt;visited) {
			if (addBase(getCycle(e)))
				reCalcDists();
		} else {
			if (b-&gt;visited)
				swap(a, b);
			addVertices(b, a-&gt;dist ^ e-&gt;c);
		}
		end: {
		}
		ans[i] = (1LL &lt;&lt; nBases) * dists.size() - 1;
	}

	for (int i = 0; i &lt;= nQueries; ++i) {
		printf("%lld\n", ans[i]);
	}
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem2322</h2><pre>/*
 *  [BeiJing2011集训]梦想封印.cpp
 *
 *  Created on: 2011-5-27
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VERTICES = 5000 + 10;
const int N_BIT = 64 + 10;
typedef long long int64;

int64 bases[N_BIT];
int control[N_BIT];
int nBases;

int64 getRepresent(int64 x) {
	for (int i = 0; i &lt; nBases; ++i) {
		if (x &gt;&gt; control[i] &amp; 1)
			x ^= bases[i];
	}
	return x;
}

bool addBase(int64 x) {
	x = getRepresent(x);
	if (x == 0)
		return false;
	int con;
	for (int i = 0; i &lt; N_BIT; ++i) {
		if (x &gt;&gt; i &amp; 1) {
			con = i;
			break;
		}
	}
	for (int i = 0; i &lt; nBases; ++i) {
		if (bases[i] &gt;&gt; con &amp; 1)
			bases[i] ^= x;
	}

	bases[nBases] = x;
	control[nBases++] = con;
	return true;
}

set&lt;int64&gt; dists;

struct Vertex;

struct Edge {
	Vertex*src, *dst;
	bool exist;
	int64 c;
	Edge*rev;
	Edge(Vertex*_src, Vertex*_dst, int64 _c) :
		src(_src), dst(_dst), c(_c), exist(true) {
	}
};

int nCur;
Vertex*cur[MAX_N_VERTICES];

struct Vertex {
	int64 dist;
	vector&lt;Edge*&gt; outgo;
	bool visited;
	Vertex() :
		visited(false) {
	}

	void dfs(int64 _dist) {
		cur[nCur++] = this;
		dist = _dist;
		visited = true;
		foreach(iter,outgo) {
			Edge*e = *iter;
			if (!e-&gt;dst-&gt;visited &amp;&amp; e-&gt;exist) {
				e-&gt;dst-&gt;dfs(dist ^ e-&gt;c);
			}
		}
	}
};

Edge* addEdge(Vertex*u, Vertex*v, int64 c) {
	Edge*uv = new Edge(u, v, c);
	Edge*vu = new Edge(v, u, c);
	uv-&gt;rev = vu;
	vu-&gt;rev = uv;
	u-&gt;outgo.push_back(uv);
	v-&gt;outgo.push_back(vu);
	return uv;
}

const int MAX_N_EDGES = 20000 + 10;
const int MAX_N_QUERIES = 20000 + 10;

Edge*edges[MAX_N_EDGES];

int nVertices, nEdges, nQueries;

Edge*queries[MAX_N_EDGES];
Vertex vertices[MAX_N_VERTICES];

void readInput() {
	scanf("%d%d%d", &amp;nVertices, &amp;nEdges, &amp;nQueries);
	for (int i = 0; i &lt; nEdges; ++i) {
		int a, b;
		int64 c;
		scanf("%d%d%lld", &amp;a, &amp;b, &amp;c);
		Vertex*u = vertices + --a, *v = vertices + --b;
		edges[i] = addEdge(u, v, c);
	}

	for (int i = 0; i &lt; nQueries; ++i) {
		int id;
		scanf("%d", &amp;id);
		--id;
		queries[i] = edges[id];
	}
}

int64 ans[MAX_N_QUERIES];

void reCalcDists() {
	dists.clear();
	for (int i = 0; i &lt; nVertices; ++i) {
		Vertex*u = vertices + i;
		if (u-&gt;visited) {
			dists.insert(getRepresent(u-&gt;dist));
		}
	}
}

int64 getCycle(Edge*e) {
	return e-&gt;src-&gt;dist ^ e-&gt;dst-&gt;dist ^ e-&gt;c;
}

void addVertices(Vertex*root, int64 initDist) {
	nCur = 0;
	root-&gt;dfs(initDist);

	bool needReCalc = false;
	for (int i = 0; i &lt; nCur; ++i) {
		Vertex*u = cur[i];
		foreach(iter,u-&gt;outgo) {
			Edge*e = *iter;
			if (e-&gt;src-&gt;visited &amp;&amp; e-&gt;dst-&gt;visited &amp;&amp; e-&gt;exist) {
				if (addBase(getCycle(e))) {
					needReCalc = true;
				}
			}
		}
	}

	if (!needReCalc) {
		for (int i = 0; i &lt; nCur; ++i) {
			Vertex*u = cur[i];
			dists.insert(getRepresent(u-&gt;dist));
		}
	} else {
		reCalcDists();
	}
}

void work() {
	for (int i = 0; i &lt; nQueries; ++i) {
		queries[i]-&gt;exist = queries[i]-&gt;rev-&gt;exist = false;
	}
	nBases = 0;
	Vertex*kernel = vertices + 0;
	addVertices(kernel, 0);
	ans[nQueries] = (1LL &lt;&lt; nBases) * dists.size() - 1;
	for (int i = nQueries - 1; i &gt;= 0; --i) {
		Edge*e = queries[i];
		e-&gt;exist = e-&gt;rev-&gt;exist = true;
		Vertex*a = e-&gt;src, *b = e-&gt;dst;
		if (!a-&gt;visited &amp;&amp; !b-&gt;visited) {
			goto end;
		}
		if (a-&gt;visited &amp;&amp; b-&gt;visited) {
			if (addBase(getCycle(e)))
				reCalcDists();
		} else {
			if (b-&gt;visited)
				swap(a, b);
			addVertices(b, a-&gt;dist ^ e-&gt;c);
		}
		end: {
		}
		ans[i] = (1LL &lt;&lt; nBases) * dists.size() - 1;
	}

	for (int i = 0; i &lt;= nQueries; ++i) {
		printf("%lld\n", ans[i]);
	}
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem2324</h2><pre>/*
 *  [ZJOI2011]营救皮卡丘.cpp
 *
 *  Created on: 2011-6-2
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_NV = 150 + 10;
int dist[MAX_NV][MAX_NV][MAX_NV];//first,a,b
int nV, nE, nK;

typedef long long int64;
const int INF = INT_MAX / 4;

void readInput() {
	cin &gt;&gt; nV &gt;&gt; nE &gt;&gt; nK;
	++nV;
	for (int i = 0; i &lt; nV; ++i) {
		for (int j = 0; j &lt; nV; ++j) {
			dist[0][i][j] = i == j ? 0 : INF;
		}
	}
	for (int i = 0; i &lt; nE; ++i) {
		int a, b, c;
		scanf("%d%d%d", &amp;a, &amp;b, &amp;c);
		c = min(dist[0][a][b], c);
		dist[0][a][b] = dist[0][b][a] = c;
	}
}

int cap[MAX_NV * 2][MAX_NV * 2] = { };
int64 cost[MAX_NV * 2][MAX_NV * 2];
int in[MAX_NV], out[MAX_NV], vs, vt;
int cnt;

inline void addEdge(int a, int b, int f, int c) {
	cap[a][b] = f;
	cost[a][b] = c;
	cost[b][a] = -c;
}

const int64 INF64 = LONG_LONG_MAX / 4;

int64 minCostFlow() {
	static int64 dist[MAX_NV * 2];
	static int am[MAX_NV * 2];
	static int prev[MAX_NV * 2];
	static bool inQ[MAX_NV * 2];
	int64 totalCost = 0;
	for (;;) {
		queue&lt;int&gt; que;
		fill(dist, dist + cnt, INF64);
		memset(inQ, 0, sizeof inQ);
		dist[vs] = 0;
		am[vs] = INF;
		inQ[vs] = true;
		que.push(vs);
		while (!que.empty()) {
			int u = que.front();
			que.pop();
			inQ[u] = false;
			for (int v = 0; v &lt; cnt; ++v) {
				if (cap[u][v] &gt; 0) {
					int64 nc = dist[u] + cost[u][v];
					if (nc &lt; dist[v]) {
						dist[v] = nc;
						am[v] = min(am[u], cap[u][v]);
						prev[v] = u;
						if (!inQ[v])
							que.push(v), inQ[v] = true;
					}
				}
			}
		}

		if (dist[vt] == INF64)
			break;

		int by = am[vt];
		totalCost += by * dist[vt];
		int u = vt;
		while (u != vs) {
			int v = prev[u];
			cap[v][u] -= by;
			cap[u][v] += by;
			u = v;
		}
	}
	return totalCost;
}

void work() {
	for (int k = 0; k &lt; nV; ++k) {
		for (int i = 0; i &lt; nV; ++i) {
			for (int j = 0; j &lt; nV; ++j) {
				dist[k + 1][i][j] = min(dist[k][i][j], dist[k][i][k]
						+ dist[k][k][j]);
			}
		}
	}

	cnt = 0;
	for (int i = 0; i &lt; nV; ++i) {
		in[i] = cnt++;
		out[i] = cnt++;
	}
	vs = cnt++;
	vt = cnt++;

	for (int i = 0; i &lt; nV; ++i) {
		addEdge(in[i], out[i], 1, -INF);
	}

	addEdge(vs, out[0], nK, 0);
	for (int i = 0; i &lt; nV; ++i) {
		for (int j = i + 1; j &lt; nV; ++j) {
			int c = dist[j][i][j];
			if (c == INF)
				continue;
			addEdge(out[i], in[j], INF, c);
		}
		addEdge(out[i], vt, INF, 0);
	}

	int64 ans = minCostFlow();
	ans -= (1LL * -INF) * (nV - 1);
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem2325</h2><pre>/*
 *  [ZJOI2011]道馆之战.cpp
 *
 *  Created on: 2011-5-31
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define MC(a,b) memcpy(a,b,sizeof a)
#define CLR(a,x) memset(a,x,sizeof a)
#define REP(i,n) for(int i=0;i&lt;n;i++)
#define PB push_back
using namespace std;

const int MAX_V = 30000 + 10;
const int INF = ~0U &gt;&gt; 3;
vector&lt;int&gt; E[MAX_V], Cs[MAX_V];
bool S[MAX_V][2];
int n;

#define cmax(x,c) x=max(x,c)

struct I {
	int C[2][2], M[2];
	I() {
		CLR(C,0);
		CLR(M,0);
	}
	void set(bool S[]) {
		CLR(M,0);
		REP(i,2)
			REP(j,2) {
				C[i][j] = S[i] &amp;&amp; S[j] ? (i == j ? 1 : 2) : -INF;
				cmax(M[i],C[i][j]);
			}
	}
	void operator=(const I&amp;o) {
		MC(C,o.C);
		MC(M,o.M);
	}
};

I operator+(const I&amp;L, const I&amp;R) {
	I ret;
	REP(l,2)
		REP(r,2) {
			ret.C[l][r] = -INF;
			REP(m,2)
				cmax(ret.C[l][r],L.C[l][m]+R.C[m][r]);
		}
	REP(l,2) {
		ret.M[l] = L.M[l];
		REP(m,2)
			cmax(ret.M[l],L.C[l][m]+R.M[m]);
	}
	return ret;
}

struct I2 {
	I LR, RL;
	void set(bool S[]) {
		LR.set(S);
		RL.set(S);
	}
};

I2 operator+(const I2&amp;L, const I2&amp;R) {
	I2 ret;
	ret.LR = L.LR + R.LR;
	ret.RL = R.RL + L.RL;
	return ret;
}
int top[MAX_V], cnt[MAX_V] = { }, D[MAX_V], F[MAX_V];
int LIMIT;
void build(int t, int f, int d) {
	D[t] = d;
	F[t] = f;
	if (top[t] == -1) {
		top[t] = t;
		cnt[t]++;
	}
	int me = top[t];
	foreach(e,E[t])
		if (*e != f) {
			if (cnt[me] &lt; LIMIT) {
				Cs[t].PB(*e);
				top[*e] = me;
				cnt[me]++;
			}
			build(*e, t, d + 1);
		}
}

I2 up[MAX_V], am[MAX_V];
void dfs(int t) {
	foreach(e,Cs[t]) {
		am[*e].set(S[*e]);
		up[*e] = up[t] + am[*e];
		dfs(*e);
	}
}

void change(int u) {
	am[u].set(S[u]);
	if (F[u] &gt;= 0 &amp;&amp; top[F[u]] == top[u]) {
		up[u] = up[F[u]] + am[u];
	} else {
		up[u] = am[u];
	}
	dfs(u);
}

int ask(int u, int v) {
	bool isS = 0;
	I2 IU, IV;
	while (1) {
		if (top[u] == top[v]) {
			if (D[u] &lt; D[v])
				swap(u, v), swap(IU, IV), isS ^= 1;
			IU = am[u] + IU;
			if (u == v)
				break;
			u = F[u];
		} else {
			if (D[top[u]] &lt; D[top[v]])
				swap(u, v), swap(IU, IV), isS ^= 1;
			IU = up[u] + IU;
			u = F[top[u]];
		}
	}
	if (isS)
		swap(IU, IV);
	I ret = IU.RL + IV.LR;
	return max(ret.M[0], ret.M[1]);
}

int nQ;
void readInput() {
	cin &gt;&gt; n &gt;&gt; nQ;
	REP(i,n-1) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		E[--a].PB(--b);
		E[b].PB(a);
	}
	REP(i,n) {
		static char buf[10];
		scanf(" ");
		scanf("%s", buf);
		REP(j,2)
			S[i][j] = buf[j] == '.';
	}
}

void work() {
	CLR(top,-1);
	LIMIT = 0;
	while (LIMIT * LIMIT &lt;= n)
		++LIMIT;
	build(0, -1, 0);
	REP(i,n)
		if (top[i] == i)
			change(i);
	REP(i,nQ) {
		char ch;
		scanf(" ");
		scanf("%c", &amp;ch);
		if (ch == 'Q') {
			int a, b;
			scanf("%d%d", &amp;a, &amp;b);
			--a;
			--b;
			printf("%d\n", ask(a, b));
		} else {
			int u;
			scanf("%d", &amp;u);
			--u;
			static char buf[10];
			scanf("%s", buf);
			REP(j,2)
				S[u][j] = buf[j] == '.';
			change(u);
		}
	}
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem2326</h2><pre>/*
 *  [HNOI2011]数学作业.cpp
 *
 *  Created on: 2011-6-1
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

typedef long long int64;
typedef vector&lt;vector&lt;int64&gt; &gt; mat;
int mod;
int64 n;

mat zero(int n) {
	return mat(n, vector&lt;int64&gt; (n, 0));
}

mat unit(int n) {
	mat a = zero(n);
	for (int i = 0; i &lt; n; ++i) {
		a[i][i] = 1;
	}
	return a;
}

mat operator*(const mat&amp;a, const mat&amp;b) {
	int n = a.size();
	mat c = zero(n);
	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; n; ++j) {
			for (int k = 0; k &lt; n; ++k) {
				(c[i][j] += a[i][k] * b[k][j]) %= mod;
			}
		}
	}
	return c;
}

mat pow(mat a, int64 e) {
	if (!e)
		return unit(a.size());
	if (e &amp; 1)
		return pow(a, e - 1) * a;
	return pow(a * a, e &gt;&gt; 1);
}

int64 calc(int64 l, int64 r, int64 ans, int64 ten) {
	mat m = zero(3);
	m[0][0] = ten % mod * 10 % mod;
	m[2][2] = 1;
	m[2][1] = 1;
	m[1][0] = 1;
	m[1][1] = 1;
	mat ret = pow(m, r - l + 1);
	return (ans * ret[0][0] + l % mod * ret[1][0] + 1 * ret[2][0]) % mod;
}

int64 pow10[20];

int main() {
	cin &gt;&gt; n &gt;&gt; mod;
	pow10[0] = 1;
	for (int i = 1; i &lt; 20; ++i) {
		pow10[i] = pow10[i - 1] * 10;
	}
	int64 ans = 0;
	for (int i = 0; i &lt; 19; ++i) {
		int64 L = pow10[i], R = pow10[i + 1] - 1;
		if (i + 1 == 19)
			R = L;
		L = max(L, 1LL);
		R = min(R, n);
		if (L &lt;= R) {
			ans = calc(L, R, ans, L);
		}
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem2327</h2><pre>/*
 *  [HNOI2011]勾股定理.cpp
 *
 *  Created on: 2011-6-5
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_V = int(1e6);
const int MAX_N = int(1e6);
const int MOD = int(1e9) + 7;

vector&lt;int&gt; E[MAX_V + 1];
int n;
int height[MAX_N];
int cnt[MAX_V + 1] = { };

void readInput() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", height + i);
		cnt[height[i]]++;
	}
}

int wayToChose[MAX_V + 1];
int wayNotChose[MAX_V + 1];

typedef long long int64;

int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}

void buildGraph() {
	//the formula (n^2-m^2)^2 + (2nm)^2 = (n^2+m^2)^2
	for (int64 m = 1; 2 * m * m &lt;= MAX_V; ++m)
		for (int64 n = m + 1;; ++n) {
			int64 a = n * n - m * m, b = 2 * n * m, c = n * n + m * m;
			if (a &gt; MAX_V || b &gt; MAX_V)
				break;
			if (cnt[a] == 0 || cnt[b] == 0 || gcd(a, b) != 1)
				continue;
			E[a].push_back(b);
			E[b].push_back(a);
		}
}

void prepare() {
	for (int i = 0; i &lt;= MAX_V; ++i) {
		if (cnt[i] &gt; 0) {
			int pow = 1;
			for (int j = 0; j &lt; cnt[i]; ++j) {
				(pow *= 2) %= MOD;
			}
			wayToChose[i] = (pow - 1 + MOD) % MOD;
			wayNotChose[i] = 1;
		}
	}

	buildGraph();
}

struct Solver {
	vector&lt;int&gt; nums;
	int n;
	int getId(int x) {
		int at = lower_bound(nums.begin(), nums.end(), x) - nums.begin();
		if (at == n || nums[at] != x)
			return -1;
		return at;
	}

	Solver(const vector&lt;int&gt;&amp;_nums) :
		nums(_nums) {
		n = nums.size();
		if (n &gt; 0)
			sort(nums.begin(), nums.end());
	}
	~Solver() {
		nums.clear();
		visited.clear();
	}

	vector&lt;bool&gt; visited;

	void getComponent(int u, vector&lt;int&gt;&amp;cur) {
		int id = getId(u);
		if (id == -1 || visited[id])
			return;
		visited[id] = true;
		cur.push_back(u);
		foreach(e,E[u])
			getComponent(*e, cur);
	}

	int splitComponent() {
		visited.assign(n, false);
		vector&lt;int&gt; cur;
		getComponent(nums[0], cur);
		if (cur.size() == n)
			return -1;
		int ret = Solver(cur).calc();
		for (int i = 0; i &lt; n; ++i) {
			if (visited[i])
				continue;
			cur.clear();
			getComponent(nums[i], cur);
			ret = (1LL * ret * Solver(cur).calc()) % MOD;
		}
		return ret;
	}

	bool dfsCheckTree(int u, int id, int fa) {
		visited[id] = true;
		foreach(e,E[u]) {
			if (*e == fa)
				continue;
			int eId = getId(*e);
			if (eId == -1)
				continue;
			if (visited[eId]) {
				return false;
			} else {
				bool tmp = dfsCheckTree(*e, eId, u);
				if (!tmp)
					return false;
			}
		}
		return true;
	}

	bool checkTree() {
		visited.assign(n, false);
		return dfsCheckTree(nums[0], getId(nums[0]), -1);
	}

	vector&lt;int&gt; dfsSolveTree(int u, int fa) {
		vector&lt;int&gt; am(2);
		am[0] = wayNotChose[u];
		am[1] = wayToChose[u];
		foreach(e,E[u]) {
			if (*e == fa || getId(*e) == -1)
				continue;
			vector&lt;int&gt; nam = dfsSolveTree(*e, u);
			am[0] = 1LL * am[0] * (nam[0] + nam[1]) % MOD;
			am[1] = 1LL * am[1] * nam[0] % MOD;
		}
		return am;
	}

	int solveTree() {
		vector&lt;int&gt; am = dfsSolveTree(nums[0], -1);
		return (am[0] + am[1]) % MOD;
	}

	int calc() {
		if (n == 1) {
			int u = nums[0];
			return (wayToChose[u] + wayNotChose[u]) % MOD;
		}
		if (n == 0)
			return 1;
		{
			int ret = splitComponent();
			if (ret != -1)
				return ret;
		}

		if (checkTree()) {
			return solveTree();
		}

		//search the node who has max deg

		int maxDeg = -1, who;
		for (int i = 0; i &lt; n; ++i) {
			int u = nums[i];
			int deg = 0;
			foreach(e,E[u])
				if (getId(*e) != -1)
					++deg;
			if (deg &gt; maxDeg) {
				maxDeg = deg;
				who = u;
			}
		}

		//if we not chose it
		vector&lt;int&gt; cur = nums;
		cur.erase(find(cur.begin(), cur.end(), who));
		int ret = 1LL * Solver(cur).calc() * wayNotChose[who] % MOD;
		//if we chose it
		foreach(e,E[who]) {
			if (getId(*e) != -1) {
				cur.erase(find(cur.begin(), cur.end(), *e));
			}
		}
		(ret += 1LL * Solver(cur).calc() * wayToChose[who] % MOD) %= MOD;
		return ret;
	}
};

void work() {
	vector&lt;int&gt; cur;
	for (int i = 0; i &lt;= MAX_V; ++i) {
		if (cnt[i] &gt; 0) {
			cur.push_back(i);
		}
	}

	int ret = Solver(cur).calc();
	(ret += MOD - 1) %= MOD;
	printf("%d\n", ret);
}

void solve() {
	readInput();
	prepare();
	work();
}

void genInput() {
	for (int i = 1; i &lt;= MAX_V; ++i) {
		cnt[i] = 1;
	}
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2328</h2><pre>/*
 *  [HNOI2011]赛车游戏.cpp
 *
 *  Created on: 2011-6-2
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

int main() {
	int T;
	cin &gt;&gt; T;
	while (T--) {
		double a, b, maxV, fuel;
		scanf("%lf%lf%lf%lf", &amp;a, &amp;b, &amp;maxV, &amp;fuel);
		static double L[10010], D[10010];
		int n;
		scanf("%d", &amp;n);
		for (int i = 0; i &lt; n; ++i) {
			double x, y;
			scanf("%lf%lf", &amp;x, &amp;y);
			L[i] = hypot(x, y) / 1000;
			D[i] = y / x;
		}

		double ans = 1e18;
		double l = 0, r = maxV;
		for (int iter = 0; iter &lt; 50; ++iter) {
			double m = (l + r) / 2;
			double cur = fuel;
			double time = 0;
			for (int i = 0; i &lt; n; ++i) {
				double v = m;
				double c = a * v + b * D[i];
				if (c &lt;= 0) {
					v = min(-b * D[i] / a, maxV);
				} else {
					cur -= c * L[i];
				}
				if (v &lt; 1e-18) {
					cur = -1;
					break;
				}
				time += L[i] / v;
			}
			if (cur &gt;= 0) {
				ans = time;
				l = m;
			} else
				r = m;
		}
		if (ans &lt; 1e17)
			printf("%0.5lf\n", ans);
		else
			printf("IMPOSSIBLE\n");
	}
}
</pre><pre></pre><h2>Problem2329</h2><pre>/*
 * [HNOI2011]括号修复.cpp
 *
 *  Created on: 2011-6-7
 *      Author: user
 */

/*
 *  let's make (=1,)=-1 then
 *  cost = abs(sum-min{prefix})+abs(min{prefix})
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Info {
	int minV[2][2];//dir{Left,Right},if nega
	int sum;
	Info() {
	}
	Info(int me) {
		//single
		sum = me;
		for (int nega = 0; nega &lt; 2; ++nega) {
			minV[0][nega] = minV[1][nega] = min(0, nega ? -me : me);
		}
	}
	void makeNega() {
		sum *= -1;
		for (int dir = 0; dir &lt; 2; ++dir) {
			swap(minV[dir][0], minV[dir][1]);
		}
	}
	void makeRev() {
		for (int nega = 0; nega &lt; 2; ++nega) {
			swap(minV[0][nega], minV[1][nega]);
		}
	}
	int calc() {
		int minP = minV[0][0];
		int change = (-minP + 1) / 2;
		int cur = sum + change * 2;
		return change + abs(cur) / 2;
	}
};

Info operator+(const Info&amp;L, const Info&amp;R) {
	Info ch[2] = { L, R }, ret;
	ret.sum = L.sum + R.sum;
	for (int dir = 0; dir &lt; 2; ++dir) {
		for (int nega = 0; nega &lt; 2; ++nega) {
			ret.minV[dir][nega] = min(ch[dir].minV[dir][nega], (nega ? -1 : 1)
					* ch[dir].sum + ch[!dir].minV[dir][nega]);
		}
	}
	return ret;
}

struct Node {
	Node*ch[2], *p;
	Info I;
	int value, size;

	bool isRev, isNega;
	int same;

	void makeRev() {
		if (same)
			return;
		isRev ^= 1;
		swap(ch[0], ch[1]);
		I.makeRev();
	}

	void makeNega() {
		I.makeNega();
		value *= -1;
		if (same) {
			same *= -1;
			return;
		}
		isNega ^= 1;
	}

	void makeSame(int _same) {
		same = _same;
		isRev = isNega = false;
		value = same;
		I = Info(same * size);
	}

	void relax() {
		if (same) {
			ch[0]-&gt;makeSame(same);
			ch[1]-&gt;makeSame(same);
		} else {
			if (isRev) {
				ch[0]-&gt;makeRev();
				ch[1]-&gt;makeRev();
			}
			if (isNega) {
				ch[0]-&gt;makeNega();
				ch[1]-&gt;makeNega();
			}
		}

		same = 0;
		isRev = isNega = false;
	}

	bool dir() {
		return this == p-&gt;ch[1];
	}
	void setC(Node*c, bool d) {
		c-&gt;p = this;
		ch[d] = c;
	}
	void update() {
		I = ch[0]-&gt;I + Info(value) + ch[1]-&gt;I;
		size = ch[0]-&gt;size + 1 + ch[1]-&gt;size;
	}
	Node() {
		size = 0;
		I = Info(0);
	}
	Node(int _value);
}*null = new Node;

Node::Node(int _value) :
	value(_value), isNega(0), same(0), isRev(0) {
	I = Info(value);
	ch[0] = ch[1] = p = null;
	size = 1;
}

Node*root;

void rotate(Node*t) {
	Node*p = t-&gt;p;
	p-&gt;relax();
	t-&gt;relax();
	bool d = t-&gt;dir();
	p-&gt;p-&gt;setC(t, p-&gt;dir());
	p-&gt;setC(t-&gt;ch[!d], d);
	t-&gt;setC(p, !d);
	p-&gt;update();
	if (p == root)
		root = t;
}

void splay(Node*t, Node*p = null) {
	while (t-&gt;p != p) {
		if (t-&gt;p-&gt;p == p)
			rotate(t);
		else if (t-&gt;dir() == t-&gt;p-&gt;dir())
			rotate(t-&gt;p), rotate(t);
		else
			rotate(t), rotate(t);
	}
	t-&gt;update();
}

Node*getKth(int kth) {
	for (Node*t = root;;) {
		t-&gt;relax();
		int cnt = t-&gt;ch[0]-&gt;size;
		if (kth == cnt)
			return t;
		t = t-&gt;ch[kth &gt; cnt];
		if (kth &gt; cnt)
			kth -= cnt + 1;
	}
}

Node*getSeq(int l, int r) {
	Node*L = getKth(l - 1);
	splay(L);
	Node*R = getKth(r + 1);
	splay(R, L);
	return R-&gt;ch[0];
}

Node*build(int seq[], int l, int r) {
	if (l &gt;= r)
		return null;
	int m = l + r &gt;&gt; 1;
	Node*t = new Node(seq[m]);
	t-&gt;setC(build(seq, l, m), 0);
	t-&gt;setC(build(seq, m + 1, r), 1);
	t-&gt;update();
	return t;
}

const int MAX_N = 100000 + 10;

int seq[MAX_N];
int n, nQ;

void readInput() {
	cin &gt;&gt; n &gt;&gt; nQ;
	seq[0] = seq[n + 1] = 0;
	for (int i = 1; i &lt;= n; ++i) {
		char ch;
		while (ch = getchar(), ch != '(' &amp;&amp; ch != ')')
			;
		seq[i] = ch == '(' ? 1 : -1;
	}
}

void work() {
	root = build(seq, 0, n + 2);

	char cmd[100];
	for (int i = 0; i &lt; nQ; ++i) {
		scanf(" ");
		scanf("%s", cmd);
		int l, r;
		scanf("%d%d", &amp;l, &amp;r);
		Node*t = getSeq(l, r);
		switch (cmd[0]) {
			case 'Q': {
				printf("%d\n", t-&gt;I.calc());
				break;
			}
			case 'S': {
				t-&gt;makeRev();
				break;
			}
			case 'I': {
				t-&gt;makeNega();
				break;
			}
			case 'R': {
				char ch;
				while (ch = getchar(), ch != '(' &amp;&amp; ch != ')')
					;
				t-&gt;makeSame(ch == '(' ? 1 : -1);
				break;
			}
		}
		splay(t);
	}
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem2330</h2><pre>/*
 *  [SCOI2011]糖果.cpp
 *
 *  Created on: 2011-6-1
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_NV = 100000 + 10;
struct Edge {
	int t, c;
};
vector&lt;Edge&gt; E[MAX_NV];
int nV, nE;

void readInput() {
	scanf("%d%d", &amp;nV, &amp;nE);
	for (int i = 0; i &lt; nE; ++i) {
		int k, a, b;
		scanf("%d%d%d", &amp;k, &amp;a, &amp;b);
		--a;
		--b;
		switch (k) {
			case 1: {
				E[a].push_back( { b, 0 });
				E[b].push_back( { a, 0 });
				break;
			}
			case 2: {
				E[a].push_back( { b, 1 });
				break;
			}
			case 3: {
				E[b].push_back( { a, 0 });
				break;
			}
			case 4: {
				E[b].push_back( { a, 1 });
				break;
			}
			case 5: {
				E[a].push_back( { b, 0 });
				break;
			}
		}
	}
}

bool inStack[MAX_NV];
int dist[MAX_NV];

bool doDfsSpfa(int u) {
	inStack[u] = true;
	int d = dist[u];
	foreach(e,E[u])
		if (d + e-&gt;c &gt; dist[e-&gt;t]) {
			dist[e-&gt;t] = d + e-&gt;c;
			if (!inStack[e-&gt;t]) {
				if (!doDfsSpfa(e-&gt;t))
					return false;
			} else
				return false;
		}
	inStack[u] = false;
	return true;
}

bool checkPositiveCycle() {
	memset(dist, 0, sizeof dist);
	memset(inStack, 0, sizeof inStack);
	for (int i = 0; i &lt; nV; ++i) {
		if (!doDfsSpfa(i))
			return false;
	}
	return true;
}

bool inQue[MAX_NV];
typedef long long int64;
const int INF = ~0U &gt;&gt; 2;

void doBfsSpfa() {
	static queue&lt;int&gt; que;
	static int get[MAX_NV];
	for (int i = 0; i &lt; nV; ++i) {
		que.push(i);
		inQue[i] = true;
		get[i] = 1;
	}
	while (!que.empty()) {
		int u = que.front();
		que.pop();
		inQue[u] = false;
		int g = get[u];
		foreach(e,E[u]) {
			if (g + e-&gt;c &gt; get[e-&gt;t]) {
				get[e-&gt;t] = g + e-&gt;c;
				if (!inQue[e-&gt;t]) {
					inQue[e-&gt;t] = true;
					que.push(e-&gt;t);
				}
			}
		}
	}

	int64 ans = 0;
	for (int i = 0; i &lt; nV; ++i) {
		ans += get[i];
	}

	cout &lt;&lt; ans &lt;&lt; endl;
}

void work() {
	if (!checkPositiveCycle()) {
		puts("-1");
		return;
	}
	doBfsSpfa();
}

void solve() {
	readInput();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2331</h2><pre>/*
 *  [SCOI2011]地板.cpp
 *
 *  Created on: 2011-6-1
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 10 + 2, MAX_L = 100 + 10;
const int MAX_N_STATES = int(2e5);

int dp[2][MAX_N_STATES];
int n, m;
char map[MAX_L][MAX_L];

void swapRC() {
	static char tmp[MAX_L][MAX_L];
	for (int r = 0; r &lt; n; ++r) {
		for (int c = 0; c &lt; m; ++c) {
			tmp[c][r] = map[r][c];
		}
	}
	memcpy(map, tmp, sizeof map);
	swap(n, m);
}

void readInput() {
	cin &gt;&gt; n &gt;&gt; m;
	for (int r = 0; r &lt; n; ++r) {
		scanf(" ");
		scanf("%s", map[r]);
	}
}

const int NONE = 0, NEED = 1, EXTEND = 2;
const int MOD = 20110520;
int pow3[MAX_N];

inline int get(int state, int at) {
	return (state / pow3[at]) % 3;
}

inline void addIt(int&amp;x, int c) {
	x += c;
	if (x &gt;= MOD)
		x -= MOD;
}

void work() {
	pow3[0] = 1;
	for (int i = 1; i &lt; MAX_N; ++i) {
		pow3[i] = pow3[i - 1] * 3;
	}
	int nStates = pow3[m + 1];
	int*am = dp[0], *nam = dp[1];
	memset(am, 0, sizeof(int) * nStates);
	am[0] = 1;
	for (int r = 0; r &lt; n; ++r) {
		for (int c = 0; c &lt; m; ++c) {
			memset(nam, 0, sizeof(int) * nStates);
			for (int s = 0; s &lt; nStates; ++s) {
				int it = am[s];
				if (!it)
					continue;
				int a = get(s, c), b = get(s, c + 1);
				int pa = pow3[c], pb = pow3[c + 1];
				int ns = s - a * pa - b * pb;
				if (map[r][c] == '*') {
					if (a != NONE || b != NONE)
						continue;
					addIt(nam[ns], it);
					continue;
				}

				if (a == NONE &amp;&amp; b == NONE) {
					addIt(nam[ns + EXTEND * (pa + pb)], it);
					addIt(nam[ns + NEED * pa], it);
					addIt(nam[ns + NEED * pb], it);
				} else if (a == NONE) {
					addIt(nam[ns + b * pa], it);
					if (b == NEED)
						addIt(nam[ns + EXTEND * pb], it);
					else
						addIt(nam[ns], it);
				} else if (b == NONE) {
					addIt(nam[ns + a * pb], it);
					if (a == NEED)
						addIt(nam[ns + EXTEND * pa], it);
					else
						addIt(nam[ns], it);
				} else {
					if (a == NEED &amp;&amp; b == NEED)
						addIt(nam[ns], it);
				}
			}
			swap(am, nam);
		}
		if (r == n - 1)
			break;
		memset(nam, 0, sizeof(int) * nStates);
		for (int s = 0; s &lt; nStates; ++s) {
			if (get(s, m) == NONE)
				addIt(nam[s * 3], am[s]);
		}
		swap(am, nam);
	}
	printf("%d\n", am[0]);
}

void solve() {
	readInput();
	if (n &lt; m)
		swapRC();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2333</h2><pre>/*
 *  [SCOI2011]棘手的操作.cpp
 *
 *  Created on: 2011-6-1
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Vertex;

struct Heap {
	Vertex*v;
	Heap*ch[2], *p;
	int value;
	bool dir() {
		return this == p-&gt;ch[1];
	}
	void setC(Heap*c, bool d) {
		ch[d] = c;
		c-&gt;p = this;
	}
	void reset(int _value);
	Heap() {
	}
	Heap(int _value);
}*null = new Heap;

void Heap::reset(int _value) {
	value = _value;
	ch[0] = ch[1] = p = null;
}

Heap::Heap(int _value) {
	reset(_value);
}

Heap*merge(Heap*a, Heap*b) {
	if (a == null || b == null)
		return a == null ? b : a;
	if (a-&gt;value &lt; b-&gt;value)
		swap(a, b);
	a-&gt;setC(merge(a-&gt;ch[1], b), 1);
	swap(a-&gt;ch[0], a-&gt;ch[1]);
	return a;
}

void remove(Heap*&amp;root, Heap*a) {
	Heap*c = merge(a-&gt;ch[0], a-&gt;ch[1]);
	a-&gt;p-&gt;setC(c, a-&gt;dir());
	if (root == a) {
		root = c;
	}
}

Heap*compRoot;

int addALL;

struct Vertex {
	Vertex*top;
	int val;
	int add;
	Heap*vertexHeap, *compHeap;
	Heap*root;
	int size;

	Vertex*find() {
		if (top == this)
			return this;
		return top = top-&gt;find();
	}
	int getMax() {
		return add + root-&gt;value;
	}

	void set(int _val) {
		val = _val;
		add = 0;
		root = vertexHeap = new Heap(val);
		vertexHeap-&gt;v = this;
		compHeap = new Heap(getMax());
		compRoot = merge(compRoot, compHeap);
		top = this;
		size = 1;
	}

	void read() {
		scanf("%d", &amp;val);
		set(val);
	}

	void updateComp() {
		remove(compRoot, compHeap);
		compHeap-&gt;reset(getMax());
		compRoot = merge(compRoot, compHeap);
	}

	void addIt(int delta) {
		Vertex*u = find();
		remove(u-&gt;root, vertexHeap);
		val += delta;
		vertexHeap-&gt;reset(val);
		u-&gt;root = merge(u-&gt;root, vertexHeap);
		u-&gt;updateComp();
	}

	void addComp(int delta) {
		if (top != this) {
			find()-&gt;addComp(delta);
			return;
		}
		add += delta;
		updateComp();
	}

	int getIt() {
		return val + find()-&gt;add + addALL;
	}

	int getComp() {
		return find()-&gt;getMax() + addALL;
	}
};

void relax(Heap*a, int add) {
	if (a == null)
		return;
	a-&gt;value += add;
	a-&gt;v-&gt;val += add;
	relax(a-&gt;ch[0], add);
	relax(a-&gt;ch[1], add);
}

void unite(Vertex*u, Vertex*v) {
	u = u-&gt;find();
	v = v-&gt;find();
	if (u == v)
		return;
	if (u-&gt;size &lt; v-&gt;size)
		swap(u, v);

	v-&gt;top = u;
	u-&gt;size += v-&gt;size;
	relax(v-&gt;root, v-&gt;add - u-&gt;add);
	remove(compRoot, v-&gt;compHeap);
	u-&gt;root = merge(u-&gt;root, v-&gt;root);
	u-&gt;updateComp();
}

int nVertices, nQueries;

const int MAX_N_VERTICES = 300000 + 10;
Vertex vertices[MAX_N_VERTICES];

int main() {
	compRoot = null;
	addALL = 0;
	scanf("%d", &amp;nVertices);
	for (int i = 0; i &lt; nVertices; ++i) {
		vertices[i].read();
	}
	scanf("%d", &amp;nQueries);
	for (int i = 0; i &lt; nQueries; ++i) {
		static char buf[10];
		scanf(" ");
		scanf("%s", buf);
		switch (buf[0]) {
			case 'U': {
				int a, b;
				scanf("%d%d", &amp;a, &amp;b);
				unite(vertices + --a, vertices + --b);
				break;
			}
			case 'A': {
				switch (buf[1]) {
					case '1': {
						int x, v;
						scanf("%d%d", &amp;x, &amp;v);
						vertices[--x].addIt(v);
						break;
					}
					case '2': {
						int x, v;
						scanf("%d%d", &amp;x, &amp;v);
						vertices[--x].addComp(v);
						break;
					}
					case '3': {
						int v;
						scanf("%d", &amp;v);
						addALL += v;
						break;
					}
				}
				break;
			}
			case 'F': {
				switch (buf[1]) {
					case '1': {
						int x;
						scanf("%d", &amp;x);
						printf("%d\n", vertices[--x].getIt());
						break;
					}
					case '2': {
						int x;
						scanf("%d", &amp;x);
						printf("%d\n", vertices[--x].getComp());
						break;
					}
					case '3': {
						printf("%d\n", compRoot-&gt;value + addALL);
						break;
					}
				}
				break;
			}
		}
	}
}
</pre><pre></pre><h2>Problem2337</h2><pre>/*
 *  [HNOI2011]XOR和路径.cpp
 *
 *  Created on: 2011-6-3
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VERTICES = 100 + 10;
int nV, nE;
struct Edge {
	int t, c;
};
vector&lt;Edge&gt; E[MAX_N_VERTICES];

void readInput() {
	cin &gt;&gt; nV &gt;&gt; nE;
	for (int i = 0; i &lt; nE; ++i) {
		int a, b, c;
		scanf("%d%d%d", &amp;a, &amp;b, &amp;c);
		--a;
		--b;
		E[a].push_back( { b, c });
		if (a != b)
			E[b].push_back( { a, c });
	}
}

double mat[MAX_N_VERTICES][MAX_N_VERTICES], b[MAX_N_VERTICES];

void buildMat(int bit) {
	memset(mat, 0, sizeof mat);
	for (int i = 0; i &lt; nV; ++i) {
		if (i == nV - 1) {
			mat[i][i] = 1;
			b[i] = 0;
			continue;
		}
		double pb = 1.0 / E[i].size();
		b[i] = 0;
		mat[i][i] = -1;
		foreach(e,E[i]) {
			if (e-&gt;c &gt;&gt; bit &amp; 1) {
				b[i] -= pb;
				mat[i][e-&gt;t] -= pb;
			} else {
				mat[i][e-&gt;t] += pb;
			}
		}
	}

	//	cout &lt;&lt; bit &lt;&lt; ":" &lt;&lt; endl;
	//	for (int r = 0; r &lt; nV; ++r) {
	//		for (int c = 0; c &lt; nV; ++c) {
	//			cout &lt;&lt; mat[r][c] &lt;&lt; " ";
	//		}
	//		cout &lt;&lt; b[r] &lt;&lt; endl;
	//	}
}

double ret[MAX_N_VERTICES];
int used[MAX_N_VERTICES];

void solveMat() {
	memset(used, -1, sizeof used);
	for (int c = 0; c &lt; nV; ++c) {
		int maxId = -1;
		for (int r = 0; r &lt; nV; ++r) {
			if (used[r] == -1)
				if (maxId == -1 || fabs(mat[r][c]) &gt; fabs(mat[maxId][c]))
					maxId = r;
		}
		used[maxId] = c;
		{
			double by = mat[maxId][c];
			for (int nc = 0; nc &lt; nV; ++nc) {
				mat[maxId][nc] /= by;
			}
			b[maxId] /= by;
		}
		for (int r = 0; r &lt; nV; ++r) {
			if (r != maxId) {
				double by = mat[r][c];
				if (fabs(by) &lt;= 1e-8)
					continue;
				for (int nc = 0; nc &lt; nV; ++nc) {
					mat[r][nc] -= by * mat[maxId][nc];
				}
				b[r] -= b[maxId] * by;
			}
		}
	}

	for (int r = 0; r &lt; nV; ++r) {
		ret[used[r]] = b[r];
	}
}

void work() {
	double ans = 0;
	for (int bit = 0; bit &lt;= 30; ++bit) {
		buildMat(bit);
		solveMat();
		ans += ret[0] * (1 &lt;&lt; bit);
	}
	printf("%0.3lf\n", ans);
}

void solve() {
	readInput();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2338</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
 
typedef long long int64;
 
struct Point {
    int x, y;
    void read() {
        scanf("%lld%lld", &amp;x, &amp;y);
        x *= 2;
        y *= 2;
    }
    Point() {
    }
    Point(int _x, int _y) :
        x(_x), y(_y) {
    }
    Point operator-(const Point&amp;p) const {
        return Point(x - p.x, y - p.y);
    }
    Point operator+(const Point&amp;p) const {
        return Point(x + p.x, y + p.y);
    }
    bool operator&lt;(const Point&amp;p) const {
        return x == p.x ? y &lt; p.y : x &lt; p.x;
    }
    Point operator/(int d) const {
        return Point(x / d, y / d);
    }
    int64 dist2To(const Point&amp;p) const {
        int64 dx = x - p.x, dy = y - p.y;
        return dx * dx + dy * dy;
    }
    int64 det(const Point&amp;p) const {
        return 1LL * x * p.y - 1LL * y * p.x;
    }
    int64 dot(const Point&amp;p) const {
        return 1LL * x * p.x + 1LL * y * p.y;
    }
};
 
const int MAX_N_POINTS = 1500 + 10;
int nPoints;
Point points[MAX_N_POINTS];
 
struct PointPair {
    Point mid;
    int64 len;
    int aId, bId;
    PointPair() {
    }
    PointPair(int aId, int bId) {
        this-&gt;aId = aId;
        this-&gt;bId = bId;
        Point a = points[aId], b = points[bId];
        mid = (a + b) / 2;
        len = a.dist2To(b);
    }
    bool operator&lt;(const PointPair&amp;p) const {
        return len == p.len ? mid &lt; p.mid : len &lt; p.len;
    }
    bool operator==(const PointPair&amp;p) const {
        return len == p.len &amp;&amp; mid.x == p.mid.x &amp;&amp; mid.y == p.mid.y;
    }
};
 
int nPairs;
PointPair pairs[MAX_N_POINTS * MAX_N_POINTS / 2];
 
void readInput() {
    scanf("%d", &amp;nPoints);
    for (int i = 0; i &lt; nPoints; ++i) {
        points[i].read();
    }
}
 
bool cmpByAngle(const Point&amp;a, const Point&amp;b) {
    return a.det(b) &gt; 0;
}
 
void work() {
    nPairs = 0;
    for (int i = 0; i &lt; nPoints; ++i) {
        for (int j = 0; j &lt; i; ++j) {
            pairs[nPairs++] = PointPair(i, j);
        }
    }
 
    int64 ans = 0;
    sort(pairs, pairs + nPairs);
    for (int i = 0; i &lt; nPairs;) {
        int last = i;
        while (last &lt; nPairs &amp;&amp; pairs[last] == pairs[i])
            ++last;
        Point mid = pairs[i].mid;
        static Point ps[MAX_N_POINTS * MAX_N_POINTS];
        int cnt = 0;
        for (int j = i; j &lt; last; ++j) {
            {
                int id = pairs[j].aId;
                Point p = points[id] - mid;
                if (p.y &gt; 0 || (p.y == 0 &amp;&amp; p.x &gt; 0))
                    ps[cnt++] = p;
            }
            {
                int id = pairs[j].bId;
                Point p = points[id] - mid;
                if (p.y &gt; 0 || (p.y == 0 &amp;&amp; p.x &gt; 0))
                    ps[cnt++] = p;
            }
        }
        sort(ps, ps + cnt, cmpByAngle);
        //      cout &lt;&lt; "--------------" &lt;&lt; endl;
        //      for (int i = 0; i &lt; cnt; ++i) {
        //          cout &lt;&lt; ps[i].x &lt;&lt; " " &lt;&lt; ps[i].y &lt;&lt; endl;
        //      }
 
        int r = 0;
        for (int l = 0; l &lt; cnt; ++l) {
            while (r + 1 &lt; cnt &amp;&amp; ps[l].dot(ps[r + 1]) &gt;= 0)
                ++r;
            ans = max(ans, ps[l].det(ps[r]) * 2);
            if (r + 1 &lt; cnt)
                ans = max(ans, ps[l].det(ps[r + 1]) * 2);
            else
                    break;
        }
 
        i = last;
    }
 
    cout &lt;&lt; ans / 4 &lt;&lt; endl;
}
 
int main() {
    readInput();
    work();
}</pre><pre></pre><h2>Problem2339</h2><pre>/*
 *  [HNOI2011]卡农.cpp
 *
 *  Created on: 2011-6-3
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MOD = int(1e8) + 7;
int n, m;
const int MAX_N = 1000000 + 10;
typedef long long int64;
int64 dp1[MAX_N], dp2[MAX_N];

int powMod(int x, int e) {
	if (!e)
		return 1;
	if (e &amp; 1)
		return 1LL * powMod(x, e - 1) * x % MOD;
	return powMod(1LL * x * x % MOD, e &gt;&gt; 1);
}

int main() {
	cin &gt;&gt; n &gt;&gt; m;
	int pow2 = powMod(2, n);
	int cur = (pow2 - 1 + MOD) % MOD;
	dp1[0] = 1;
	for (int i = 1; i &lt;= m; ++i) {
		dp1[i] = 1LL * dp1[i - 1] * cur % MOD;
		(--cur) %= MOD;
		if (cur &lt; 0)
			cur += MOD;
	}

	dp2[0] = 1;
	dp2[1] = 0;
	for (int i = 2; i &lt;= m; ++i) {
		dp2[i] = dp1[i - 1];
		dp2[i] -= dp2[i - 2] * (pow2 - 1 - (i - 2) + MOD) % MOD * (i - 1) % MOD;
		dp2[i] -= dp2[i - 1];
		dp2[i] %= MOD;
		if (dp2[i] &lt; 0)
			dp2[i] += MOD;
	}
	int64 fact = 1;
	for (int i = 1; i &lt;= m; ++i) {
		(fact *= i) %= MOD;
	}
	int64 rfact = powMod(fact, MOD - 2);
	int64 ans = dp2[m] * rfact % MOD;
	cout &lt;&lt; ans &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem2344</h2><pre>/*
 *  [Baltic2011]Icecream.cpp
 *
 *  Created on: 2011-6-18
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;bitset&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 200 + 10;
bitset&lt;MAX_N&gt; can[MAX_N];
int N, M;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

int main() {
	scanInt(N);
	scanInt(M);
	for (int i = 0; i &lt; N; ++i) {
		for (int j = 0; j &lt; N; ++j) {
			can[i][j] = i != j;
		}
	}
	for (int it = 0; it &lt; M; ++it) {
		int a, b;
		scanInt(a);
		scanInt(b);
		--a;
		--b;
		can[a][b] = can[b][a] = false;
	}

	bitset&lt;MAX_N&gt; tmp;
	int ans = 0;
	for (int a = 0; a &lt; N; ++a) {
		for (int b = 0; b &lt; a; ++b) {
			if (can[a][b]) {
				ans += (can[a] &amp; can[b]).count();
			}
		}
	}
	ans /= 3;
	cout &lt;&lt; ans &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem2345</h2><pre>/*
 * [Batic 2011]Vikings.cpp
 *
 *  Created on: 2011-6-18
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_L = 700 + 10;
char map[MAX_L][MAX_L];
int nR, nC;

const int MAX_L_QUE = MAX_L * MAX_L;

int distV[MAX_L][MAX_L];
int qr[MAX_L_QUE], qc[MAX_L_QUE], qh, qt;

const int dr[] = { -1, 1, 0, 0 }, dc[] = { 0, 0, -1, 1 };

const int INF = ~0U &gt;&gt; 2;
bool check(int r, int c) {
	return r &gt;= 0 &amp;&amp; r &lt; nR &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; nC &amp;&amp; map[r][c] != 'I';
}

int when[MAX_L][MAX_L];

void findMap(int&amp;ar, int&amp;ac, char a) {
	for (int r = 0; r &lt; nR; ++r) {
		for (int c = 0; c &lt; nC; ++c) {
			if (map[r][c] == a) {
				ar = r;
				ac = c;
				return;
			}
		}
	}
}

void readInput() {
	scanf("%d%d", &amp;nR, &amp;nC);
	for (int r = 0; r &lt; nR; ++r) {
		scanf(" ");
		scanf("%s", map[r]);
	}
}

const int MAX_N_BLOCKS = MAX_L * MAX_L * 2;
int minBlock[MAX_N_BLOCKS], nBlocks;
int vBlock[MAX_L][MAX_L], hBlock[MAX_L][MAX_L];

void update(int r, int c) {
	minBlock[vBlock[r][c]] = min(minBlock[vBlock[r][c]], distV[r][c]);
	minBlock[hBlock[r][c]] = min(minBlock[hBlock[r][c]], distV[r][c]);
}

void prepare() {
	int vR, vC;
	findMap(vR, vC, 'V');

	nBlocks = 0;

	for (int r = 0; r &lt; nR; ++r) {
		int last = -1;
		for (int c = 0; c &lt; nC; ++c) {
			if (map[r][c] != 'I') {
				if (last != -1) {
					hBlock[r][c] = last;
				} else {
					hBlock[r][c] = nBlocks++;
				}
			} else {
				hBlock[r][c] = -1;
			}
			last = hBlock[r][c];
		}
	}

	for (int c = 0; c &lt; nC; ++c) {
		int last = -1;
		for (int r = 0; r &lt; nR; ++r) {
			if (map[r][c] != 'I') {
				if (last != -1) {
					vBlock[r][c] = last;
				} else {
					vBlock[r][c] = nBlocks++;
				}
			} else {
				vBlock[r][c] = -1;
			}
			last = vBlock[r][c];
		}
	}

	for (int i = 0; i &lt; nBlocks; ++i) {
		minBlock[i] = INF;
	}

	for (int r = 0; r &lt; nR; ++r) {
		for (int c = 0; c &lt; nC; ++c) {
			distV[r][c] = INF;
		}
	}

	qh = qt = 0;
	distV[vR][vC] = 0;
	qr[qt] = vR;
	qc[qt++] = vC;
	while (qh &lt; qt) {
		int r = qr[qh], c = qc[qh++];
		update(r, c);
		for (int d = 0; d &lt; 4; ++d) {
			int nr = r + dr[d], nc = c + dc[d];
			if (!check(nr, nc) || distV[nr][nc] != INF)
				continue;
			distV[nr][nc] = distV[r][c] + 1;
			qr[qt] = nr;
			qc[qt++] = nc;
		}
	}

	for (int r = 0; r &lt; nR; ++r) {
		for (int c = 0; c &lt; nC; ++c) {
			if (map[r][c] != 'I') {
				when[r][c]
						= min(minBlock[hBlock[r][c]], minBlock[vBlock[r][c]]);
			}
		}
	}
}

int dist[MAX_L][MAX_L];

void work() {
	int yR, yC;
	findMap(yR, yC, 'Y');

	for (int r = 0; r &lt; nR; ++r) {
		for (int c = 0; c &lt; nC; ++c) {
			dist[r][c] = INF;
		}
	}

	dist[yR][yC] = 0;
	qh = qt = 0;
	qr[qt] = yR;
	qc[qt++] = yC;
	while (qh &lt; qt) {
		int r = qr[qh], c = qc[qh++];
		for (int d = 0; d &lt; 4; ++d) {
			int nr = r + dr[d], nc = c + dc[d];
			if (check(nr, nc) &amp;&amp; dist[nr][nc] == INF) {
				int w = dist[r][c] + 1;
				if (when[nr][nc] &gt; w) {
					qr[qt] = nr;
					qc[qt++] = nc;
					dist[nr][nc] = w;
				}
			}
		}
	}

	int tR, tC;
	findMap(tR, tC, 'T');
	if (dist[tR][tC] == INF)
		puts("NO");
	else
		puts("YES");
}

int main() {
	readInput();
	prepare();
	work();
}
</pre><pre></pre><h2>Problem2346</h2><pre>/*
 *  [Baltic 2011]Lamp.cpp
 *
 *  Created on: 2011-6-18
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_L = 500 + 10;
char map[MAX_L][MAX_L];
int nR, nC;

void readInput() {
	scanf("%d%d", &amp;nR, &amp;nC);
	for (int r = 0; r &lt; nR; ++r) {
		scanf(" ");
		scanf("%s", map[r]);
	}
}

int dist[MAX_L][MAX_L];
const int MAX_L_QUE = MAX_L * MAX_L * 2;
queue&lt;int&gt; que;

bool inQ[MAX_L][MAX_L] = { };

void relax(int r, int c, int w) {
	if (dist[r][c] &gt; w) {
		dist[r][c] = w;
		if (!inQ[r][c]) {
			inQ[r][c] = true;
			que.push(r);
			que.push(c);
		}
	}
}

const int INF = ~0U &gt;&gt; 2;

void work() {
	for (int r = 0; r &lt;= nR; ++r) {
		for (int c = 0; c &lt;= nC; ++c) {
			dist[r][c] = INF;
		}
	}
	relax(0, 0, 0);
	while (!que.empty()) {
		int r = que.front();
		que.pop();
		int c = que.front();
		que.pop();
		inQ[r][c] = false;
		int w = dist[r][c];
		if (r + 1 &lt;= nR &amp;&amp; c + 1 &lt;= nC) {
			relax(r + 1, c + 1, w + (map[r][c] != '\\'));
		}
		if (r - 1 &gt;= 0 &amp;&amp; c - 1 &gt;= 0) {
			relax(r - 1, c - 1, w + (map[r - 1][c - 1] != '\\'));
		}
		if (r - 1 &gt;= 0 &amp;&amp; c + 1 &lt;= nC) {
			relax(r - 1, c + 1, w + (map[r - 1][c] != '/'));
		}
		if (r + 1 &lt;= nR &amp;&amp; c - 1 &gt;= 0) {
			relax(r + 1, c - 1, w + (map[r][c - 1] != '/'));
		}
	}

	if (dist[nR][nC] == INF)
		puts("NO SOLUTION");
	else
		printf("%d\n", dist[nR][nC]);
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem2347</h2><pre>/*
 *  [Baltic2011]Meetings.cpp
 *
 *  Created on: 2011-6-20
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

typedef long long int64;
int P, V;
int64 N;

int main() {
	cin &gt;&gt; N &gt;&gt; P &gt;&gt; V;
	int64 ans = LONG_LONG_MAX;
	for (int k = 1;; ++k) {
		int64 low = pow(N, 1.0 / k);
		int64 up = low + 1;
		int L = 0, R = k + 1;//how many low
		while (L + 1 &lt; R) {
			int M = (L + R) &gt;&gt; 1;
			if (pow(low, M) * pow(up, k - M) &gt;= N)
				L = M;
			else
				R = M;
		}
		int64 tmp = (L * low + (k - L) * up) * P + k * V;
		ans = min(ans, tmp);
		if (pow(2, k) &gt;= N)
			break;
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem2348</h2><pre>/*
 * [Baltic 2011]Plagiarism.cpp
 *
 *  Created on: 2011-6-18
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 100000 + 10;
int a[MAX_N], n;

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", a + i);
	}
	long long ans = 0;
	sort(a, a + n);
	int j = 0;
	for (int i = 0; i &lt; n; ++i) {
		while (a[j] * 10 &lt; a[i] * 9)
			++j;
		ans += i - j;
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem2351</h2><pre>/*
 *  [BeiJing2011]Matrix.cpp
 *
 *  Created on: 2011-6-19
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_L = 1000 + 10;
const int MAX_Q = 10;
int nR, nC, A, B, nQ;
int map[MAX_L][MAX_L];
int query[MAX_L][MAX_L];

const int SEED1 = 10007, SEED2 = 13331;

void readMat(int mat[MAX_L][MAX_L], int nR, int nC) {
	for (int r = 0; r &lt; nR; ++r) {
		for (int c = 0; c &lt; nC; ++c) {
			char ch;
			while (ch = getchar(), ch != '0' &amp;&amp; ch != '1')
				;
			mat[r][c] = ch == '1';
		}
	}
}

void readInput() {
	cin &gt;&gt; nR &gt;&gt; nC &gt;&gt; A &gt;&gt; B;
	readMat(map, nR, nC);
	cin &gt;&gt; nQ;
}

void calcHashRow(int a[], int h[], int L, int n, int seed) {
	int pow = 1;
	int cur = 0;
	for (int i = 0; i &lt; n; ++i) {
		pow *= seed;
		cur = cur * seed + a[i];
	}
	h[0] = cur;
	for (int i = n; i &lt; L; ++i) {
		cur = cur * seed + a[i];
		cur -= pow * a[i - n];
		h[i - n + 1] = cur;
	}
}

int hRow[MAX_L][MAX_L];

void calcHashMat(int mat[MAX_L][MAX_L], int ret[MAX_L][MAX_L], int nR, int nC,
		int A, int B) {
	for (int r = 0; r &lt; nR; ++r) {
		calcHashRow(mat[r], hRow[r], nC, B, SEED1);
	}
	static int a[MAX_L], h[MAX_L];
	for (int c = 0; c + B &lt;= nC; ++c) {
		for (int r = 0; r &lt; nR; ++r) {
			a[r] = hRow[r][c];
		}
		calcHashRow(a, h, nR, A, SEED2);
		for (int r = 0; r &lt; nR; ++r) {
			ret[r][c] = h[r];
		}
	}
}

void work() {
	static int ret[MAX_L][MAX_L];
	static int ret2[MAX_L][MAX_L];

	calcHashMat(map, ret, nR, nC, A, B);

	for (int i = 0; i &lt; nQ; ++i) {
		readMat(query, A, B);
		calcHashMat(query, ret2, A, B, A, B);
		int me = ret2[0][0];
		bool check = false;
		for (int r = 0; r + A &lt;= nR; ++r) {
			for (int c = 0; c + B &lt;= nC; ++c) {
				if (ret[r][c] == me) {
					check = true;
				}
			}
		}
		if (check)
			printf("1\n");
		else
			printf("0\n");
	}
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem2354</h2><pre>/*
 * 2354.cpp
 *
 *  Created on: 2011-7-31
 *      Author: mac
 */

#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

int lcp(string a, string b) {
	int cnt = 0;
	for (int i = 0; i &lt; a.size() &amp;&amp; i &lt; b.size(); ++i) {
		if (a[i] == b[i])
			++cnt;
		else
			break;
	}
	return cnt;
}

int main() {
	int ans = 0;
	int n;
	cin &gt;&gt; n;
	vector&lt;string&gt; vs(n);
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; vs[i];
	}
	for (int i = 0; i &lt; n; ++i) {
		ans += (i &lt; 2 ? 1 : 2) * vs[i].size() * vs[i].size();
	}
	int tmp1 = lcp(vs[0], vs[1]);
	sort(vs.begin(), vs.end());
	for (int i = 0; i &lt; n - 1; ++i) {
		ans -= lcp(vs[i], vs[i + 1]) * lcp(vs[i], vs[i + 1]);
	}
	ans += tmp1 * tmp1;
	ans -= lcp(vs[0], vs[n - 1]) * lcp(vs[0], vs[n - 1]);
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2356</h2><pre>/*
 * 不等式.cpp
 *
 *  Created on: 2011-6-22
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 100 + 10;
int a[MAX_N], b[MAX_N], n, m;

bool check() {
	//a0*x^0+a1*x^1+a2^x2 ... &gt;= b0x^0+b1*x^1+b2*x^2
	int mina = n + 1, maxa = -1, minb = m + 1, maxb = -1;
	for (int i = 0; i &lt;= n; ++i) {
		if (a[i] &gt; 0)
			mina = min(mina, i), maxa = max(maxa, i);
	}
	for (int i = 0; i &lt;= m; ++i) {
		if (b[i] &gt; 0)
			minb = min(minb, i), maxb = max(maxb, i);
	}
	return mina * m &lt;= minb * n &amp;&amp; maxa * m &gt;= maxb * n;
}

int main() {
	while (scanf("%d", &amp;n) &gt; 0) {
		for (int i = 0; i &lt;= n; ++i) {
			scanf("%d", a + i);
		}
		scanf("%d", &amp;m);
		for (int i = 0; i &lt;= m; ++i) {
			scanf("%d", b + i);
		}
		//r = n/m
		bool ret = check();
		if (ret) {
			reverse(a, a + n + 1);
			reverse(b, b + m + 1);
			ret = check();
		}
		printf("%s\n", ret ? "YES" : "NO");
	}
}
</pre><pre></pre><h2>Problem2358</h2><pre>/*
 *  Brick Break Game.cpp
 *
 *  Created on: 2011-6-23
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

map&lt;vector&lt;int&gt; , int&gt; memo;

int rec(vector&lt;int&gt; a) {
	if (memo.count(a))
		return memo[a];
	int&amp;ret = memo[a];
	set&lt;int&gt; has;
	for (int i = 1; i &lt;= 4; ++i) {
		if (a[i] &gt;= i) {
			a[i] -= i;
			has.insert(rec(a));
			a[i] += i;
		}
		if (a[i] &gt; 0) {
			for (int j = 1; j &lt; i; ++j) {
				a[i]--, a[j]++, a[i - j]++;
				has.insert(rec(a));
				a[i]++, a[j]--, a[i - j]--;
			}
		}
	}
	for (int i = 0;; ++i) {
		if (has.count(i) == 0)
			return ret = i;
	}
}

int readIntMod(int mod) {
	char ch;
	int ret = 0;
	while (ch = getchar(), !isdigit(ch))
		;
	ret = (ch - '0') % mod;
	while (ch = getchar(), isdigit(ch))
		ret = (ret * 10 + ch - '0') % mod;
	return ret;
}

int main() {
	int nT;
	cin &gt;&gt; nT;
	while (nT--) {
		vector&lt;int&gt; a(5, 0);
		a[1] = readIntMod(2);
		a[2] = readIntMod(3);
		a[3] = readIntMod(6);
		a[4] = readIntMod(3);
		printf("%d\n", rec(a) &gt; 0);
	}
}
</pre><pre></pre><h2>Problem2358</h2><pre>#include &lt;cstdio&gt;
#include &lt;vector&gt; 
#include &lt;map&gt;
#include &lt;cctype&gt;
using namespace std;

map&lt;vector&lt;int&gt;, bool&gt; memo;
bool F(vector&lt;int&gt; a)
{
	if (memo.count(a)) return memo[a];
	bool &amp;ret = memo[a];
	for (int i = 1; i &lt;= 4; i ++)
	{
		if (a[i] &gt;= i)
		{
			a[i] -= i;
			if (!F(a)) return ret = true;
			a[i] += i;
		}
		if (a[i] &gt; 0)
		{
			for (int j = 1; j &lt; i; j ++)
			{
				a[i] --, a[j] ++, a[i - j] ++;
				if (!F(a)) return ret = true;
				a[i] ++, a[j] --, a[i - j] --;
			}
		}
	}
	return ret = false;
}

int getint(int mod)
{
	int ch, ret;
	while (!isdigit(ch = getchar()));
	ret = (ch - '0') % mod;
	while (isdigit(ch = getchar()))
		ret = (ret * 10 + ch - '0') % mod;
	return ret;
}

int main()
{
	int t; scanf("%d", &amp;t);
	while (t --)
	{
		vector&lt;int&gt; a(5, 0);
		int mod[] = {0, 2, 3, 6, 3};
		for (int i = 1; i &lt;= 4; i ++)
			a[i] = getint(mod[i]);
		printf("%d\n", F(a));
	}
	return 0;
}
</pre><pre></pre><h2>Problem2360</h2><pre>/*
 * 唯美村落.cpp
 *
 *  Created on: 2011-6-24
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

struct Vertex;

struct Edge {
	Vertex*dst;
	int id;
};

struct Vertex {
	vector&lt;Edge*&gt; es;
	Vertex*comp;
	int nIn, nOut;
	int at;
	Vertex() {
		comp = 0;
		nIn = nOut = 0;
		at = 0;
	}
	void dfs(Vertex*c) {
		if (comp != 0)
			return;
		comp = c;
		foreach(it,es) {
			Edge*e = *it;
			e-&gt;dst-&gt;dfs(c);
		}
	}
	Edge*nextEdge() {
		return es[at++];
	}
	bool hasNext() {
		return at &lt; es.size();
	}
};

vector&lt;Vertex*&gt; in, out;
int n, m;
vector&lt;int&gt; important;

void buildEdge(Vertex*a, Vertex*b, int id = -1) {
	a-&gt;es.push_back(new Edge( { b, id }));
	a-&gt;nOut++, b-&gt;nIn++;
}

vector&lt;Vertex*&gt; comps;

vector&lt;Edge*&gt; path;

bool cmpEdgeByImp(Edge*a, Edge*b) {
	return important[a-&gt;id] &gt; important[b-&gt;id];
}

void euler(Vertex*u) {
	while (u-&gt;hasNext()) {
		Edge*e = u-&gt;nextEdge();
		euler(e-&gt;dst);
		path.push_back(e);
	}
}

int main() {
	scanf("%d%d", &amp;n, &amp;m);
	important.resize(n);
	in.resize(n);
	out.resize(n);
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", &amp;important[i]);
		in[i] = new Vertex;
		out[i] = new Vertex;
	}

	for (int i = 0; i &lt; m; ++i) {
		int a, b, c;
		scanf("%d%d%d", &amp;a, &amp;b, &amp;c);
		--a, --b;
		buildEdge(out[a], in[b]), buildEdge(in[b], out[a]);
		if (c == 2)
			buildEdge(out[b], in[a]), buildEdge(in[a], out[b]);
	}

	for (int i = 0; i &lt; n; ++i) {
		if (in[i]-&gt;comp == 0) {
			Vertex*c = new Vertex;
			comps.push_back(c);
			in[i]-&gt;dfs(c);
		}
		if (out[i]-&gt;comp == 0) {
			Vertex*c = new Vertex;
			comps.push_back(c);
			out[i]-&gt;dfs(c);
		}
	}

	for (int i = 0; i &lt; n; ++i) {
		buildEdge(in[i]-&gt;comp, out[i]-&gt;comp, i);
	}

	bool check = true;
	for (int i = 0; i &lt; comps.size(); ++i) {
		if (comps[i]-&gt;nIn != comps[i]-&gt;nOut) {
			check = false;
		}
	}

	if (!check) {
		printf("-1");
		return 0;
	}

	Vertex*start = 0;
	int maxImportant = -1;
	for (int i = 0; i &lt; comps.size(); ++i) {
		Vertex*u = comps[i];
		if (u-&gt;es.empty())
			continue;
		sort(u-&gt;es.begin(), u-&gt;es.end(), cmpEdgeByImp);
		Edge*e = *(u-&gt;es.begin());
		if (important[e-&gt;id] &gt; maxImportant) {
			maxImportant = important[e-&gt;id];
			start = u;
		}
	}

	euler(start);
	reverse(path.begin(), path.end());
	if (path.size() != n) {
		printf("-1");
		return 0;
	}

	for (int i = 0; i &lt; n; ++i) {
		printf("%d\n", path[i]-&gt;id + 1);
	}
}
</pre><pre></pre><h2>Problem2361</h2><pre>/*
 *  数列整合.cpp
 *
 *  Created on: 2011-6-23
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;hash_map&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_N = 12;
const int INF = INT_MAX / 4;
int dist[MAX_N][MAX_N];
int prev[MAX_N][MAX_N];

typedef long long int64;

struct State {
	int64 code;
	bool exist;
	int dist, exp;
	int estimate() const {
		return dist * 2 + exp;
	}
};

const int HASH_MOD = int(1e9) + 7;
struct HashFunc {
	int operator()(int64 x) const {
		return x % HASH_MOD;
	}
};

const int MAX_N_STATES = 2000000;
State mem[MAX_N_STATES];
int top = 0;
State*newState() {
	State*s = mem + top++;
	s-&gt;exist = true;
	return s;
}

using namespace __gnu_cxx;

typedef __gnu_cxx ::hash_map&lt;int64, State*, HashFunc&gt; Hash;
Hash map;

int n, m;
int a[MAX_N];

struct Comparator {
	bool operator()(State*a, State*b) const {
		return a-&gt;estimate() &gt; b-&gt;estimate();
	}
};

void readInput() {
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; a[i];
		--a[i];
	}
	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; n; ++j) {
			dist[i][j] = i == j ? 0 : INF;
			prev[i][j] = i;
		}
	}
	for (int i = 0; i &lt; m; ++i) {
		int a, b;
		cin &gt;&gt; a &gt;&gt; b;
		--a, --b;
		dist[a][b] = dist[b][a] = 1;
	}
}

int greedyAns;

int greedy() {
	int a[MAX_N];
	memcpy(a, ::a, sizeof a);
	greedyAns = 0;
	for (int i = 0; i &lt; n; ++i) {
		int at = find(a, a + n, i) - a;
		while (at != i) {
			int p = prev[i][at];
			swap(a[at], a[p]);
			at = p;
			++greedyAns;
		}
	}
}

void work() {
	for (int k = 0; k &lt; n; ++k) {
		for (int i = 0; i &lt; n; ++i) {
			for (int j = 0; j &lt; n; ++j) {
				int nd = dist[i][k] + dist[k][j];
				if (nd &lt; dist[i][j]) {
					dist[i][j] = nd;
					prev[i][j] = prev[k][j];
				}
			}
		}
	}
	greedy();

	priority_queue&lt;State*, vector&lt;State*&gt; , Comparator&gt; pq;
	int64 init = 0;
	for (int i = n - 1; i &gt;= 0; --i) {
		init &lt;&lt;= 4;
		init += a[i];
	}

	int64 target = 0;
	for (int i = n - 1; i &gt;= 0; --i) {
		target &lt;&lt;= 4;
		target += i;
	}
	State*st = newState();
	st-&gt;code = init;
	st-&gt;dist = 0;
	st-&gt;exp = 0;
	for (int i = 0; i &lt; n; ++i) {
		st-&gt;exp += dist[a[i]][i];
	}
	pq.push(st);
	while (!pq.empty()) {
		State*s = pq.top();
		pq.pop();
		if (!s-&gt;exist)
			continue;
		if (s-&gt;code == target) {
			printf("%d\n", s-&gt;dist);
			return;
		}
		int64 x = s-&gt;code;
		for (int i = 0; i &lt; n; ++i) {
			a[i] = x &amp; 15;
			x &gt;&gt;= 4;
		}
		for (int i = 0; i &lt; n; ++i) {
			for (int j = i + 1; j &lt; n; ++j)
				if (dist[i][j] == 1) {
					State*ns = newState();
					ns-&gt;code = s-&gt;code + (1LL * (a[j] - a[i]) &lt;&lt; (4 * i))
							+ (1LL * (a[i] - a[j]) &lt;&lt; (4 * j));
					ns-&gt;dist = s-&gt;dist + 1;
					ns-&gt;exp = s-&gt;exp + dist[j][a[i]] + dist[i][a[j]]
							- dist[j][a[j]] - dist[i][a[i]];
					if (ns-&gt;estimate() &gt; greedyAns * 2) {
						--top;
						continue;
					}
					Hash::iterator it = map.find(ns-&gt;code);
					if (it == map.end()) {
						map[ns-&gt;code] = ns;
						pq.push(ns);
					} else {
						if (ns-&gt;dist &lt; it-&gt;second-&gt;dist) {
							it-&gt;second-&gt;exist = false;
							map[ns-&gt;code] = ns;
							pq.push(ns);
						}
					}
				}
		}
	}
}

void solve() {
	readInput();
	work();
}

void runTest() {
	n = 10;
	for (int i = 0; i &lt; n; ++i) {
		a[i] = i;
	}
	random_shuffle(a, a + n);
	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; n; ++j) {
			dist[i][j] = i == j ? 0 : 1;
		}
	}
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2362</h2><pre>/*
 * 二叉树计数.cpp
 *
 *  Created on: 2011-6-24
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
int K, N;
const int MAX_K = 64;
const int BASE = 10000;
const int MAX_L = 16;
const int POW10[] = { 1, 10, 100, 1000, 10000 };

int L;

struct BigInt {
	int a[MAX_L];
	void setInt(int x) {
		memset(a, 0, sizeof a);
		for (int i = 0; x; ++i) {
			a[i] = x % BASE;
			x /= BASE;
		}
	}
	BigInt() {
		memset(a, 0, sizeof a);
	}
	BigInt&amp;operator=(const BigInt&amp;o) {
		memcpy(a, o.a, sizeof a);
		return *this;
	}
	int&amp;operator[](int i) {
		return a[i];
	}
	int operator[](int i) const {
		return a[i];
	}
	void write() const {
		bool start = false;
		bool first = true;
		for (int i = L - 1; i &gt;= 0; --i) {
			start |= a[i] &gt; 0;
			if (start) {
				if (first) {
					if (i == L - 1) {
						printf("%d", a[i] % POW10[4 - (4 * L - K)]);
					} else {
						printf("%d", a[i]);
					}
				} else
					printf("%04d", a[i]);
				first = false;
			}
		}
		printf("\n");
	}
};

BigInt operator+(const BigInt&amp;a, const BigInt&amp;b) {
	BigInt c;
	int carry = 0;
	for (int i = 0; i &lt; L; ++i) {
		carry += a[i] + b[i];
		c[i] = carry % BASE;
		carry /= BASE;
	}
	return c;
}

BigInt operator*(const BigInt&amp;a, const BigInt&amp;b) {
	BigInt c;
	for (int i = 0; i &lt; L; ++i) {
		for (int j = 0; j + i &lt; L; ++j) {
			c[i + j] += a[i] * b[j];
		}
	}

	int carry = 0;
	for (int i = 0; i &lt; L; ++i) {
		carry += c[i];
		c[i] = carry % BASE;
		carry /= BASE;
	}
	return c;
}

BigInt operator*(const BigInt&amp;a, int x) {
	BigInt c;
	int carry = 0;
	for (int i = 0; i &lt; L; ++i) {
		carry += a[i] * x;
		c[i] = carry % BASE;
		carry /= BASE;
	}
	return c;
}

BigInt operator-(const BigInt&amp;a, const BigInt&amp;b) {
	BigInt c;
	int borrow = 0;
	for (int i = 0; i &lt; L; ++i) {
		c[i] = a[i];
		c[i] -= borrow;
		borrow = 0;
		if (c[i] &lt; b[i]) {
			c[i] += BASE;
			borrow = 1;
		}
		c[i] -= b[i];
	}
	return c;
}

const int MAX_N = 200000 + 10;

BigInt dp[MAX_N], sum[MAX_N];

BigInt calc(int n) {
	//calculate number of binary trees whose longest chain is not longer than n
	dp[0].setInt(1);
	sum[0] = dp[0];
	dp[1].setInt(1);
	sum[1] = sum[0] + dp[1];
	for (int i = 2; i &lt;= n + 1; ++i) {
		//L=i-1 || R=i-1 &amp;&amp; L+R&lt;=n

		dp[i].setInt(0);
		//L=i-1 &amp;&amp; R != i-1
		int L = i - 1;
		int maxR = min(n - L, L - 1);
		dp[i] = dp[i] + dp[L] * sum[maxR] * 2;
		if (L + L &lt;= n) {
			dp[i] = dp[i] + dp[L] * dp[L];
		}

		sum[i] = sum[i - 1] + dp[i];
	}

	return sum[n + 1];
}

int main() {
	cin &gt;&gt; N &gt;&gt; K;
	L = (K - 1) / 4 + 1;
	BigInt ans = calc(N) - calc(N - 1);
	ans.write();
}
</pre><pre></pre><h2>Problem2364</h2><pre>/*
 *  城市美化.cpp
 *
 *  Created on: 2011-6-24
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 50000 + 10;
const int BIG = 100000;
typedef long long int64;

int h[MAX_N], n, c;
int stack[MAX_N], top;
int64 dp[MAX_N];
int64 sum[MAX_N], sumSqr[MAX_N];

const int64 INF = LONG_LONG_MAX / 4;

int64 funcMin(int64 a, int64 b, int64 c, int64 mn, int64 mx) {
	int64 ret = INF;
	int64 top = -b / (2 * a);
	for (int i = 0; i &lt; 2; ++i) {
		if (top &gt;= mn &amp;&amp; top &lt;= mx)
			ret = min(ret, (a * top + b) * top + c);
		++top;
	}
	ret = min(ret, min((a * mn + b) * mn + c, (a * mx + b) * mx + c));
	return ret;
}

struct Tree {
	int maxv;
	Tree*ch[2];
	int l, r;
	Tree(int seq[], int _l, int _r) :
		l(_l), r(_r) {
		if (l + 1 == r) {
			maxv = seq[l];
			return;
		}
		ch[0] = new Tree(seq, l, l + r &gt;&gt; 1);
		ch[1] = new Tree(seq, l + r &gt;&gt; 1, r);
		maxv = max(ch[0]-&gt;maxv, ch[1]-&gt;maxv);
	}

	int ask(int L, int R) {
		if (R &lt;= l || r &lt;= L)
			return INT_MIN;
		if (L &lt;= l &amp;&amp; R &gt;= r)
			return maxv;
		return max(ch[0]-&gt;ask(L, R), ch[1]-&gt;ask(L, R));
	}
}*root;

int64 calc(int a, int b) {
	if (a == b - 1)
		return c * abs(h[b] - h[a]);
	int mn = root-&gt;ask(a + 1, b) + 1;
	int mx = min(h[a], h[b]);
	int64 A = b - a - 1, B = -2 * (sum[b - 1] - sum[a]), C = sumSqr[b - 1]
			- sumSqr[a];
	if (a != 0)
		B -= c, C += h[a] * c;
	if (b != n + 1)
		B -= c, C += h[b] * c;
	return funcMin(A, B, C, mn, mx);
}

int main() {
	scanf("%d%d", &amp;n, &amp;c);
	h[0] = h[n + 1] = BIG;

	sum[0] = sumSqr[0] = 0;
	for (int i = 1; i &lt;= n; ++i) {
		scanf("%d", h + i);
		sum[i] = sum[i - 1] + h[i];
		sumSqr[i] = sumSqr[i - 1] + h[i] * h[i];
	}

	top = 0, stack[top++] = 0, stack[top++] = 1;
	dp[1] = 0;

	root = new Tree(h, 0, n + 2);
	for (int i = 2; i &lt;= n + 1; ++i) {
		dp[i] = dp[i - 1] + (i == n + 1 ? 0 : c * abs(h[i] - h[i - 1]));
		while (h[stack[top - 1]] &lt; h[i]) {
			dp[i] = min(dp[i], dp[stack[top - 1]] + calc(stack[top - 1], i));
			--top;
		}
		dp[i] = min(dp[i], dp[stack[top - 1]] + calc(stack[top - 1], i));
		if (h[stack[top - 1]] == h[i])
			--top;
		stack[top++] = i;
	}
	printf("%lld\n", dp[n + 1]);
}
</pre><pre></pre><h2>Problem2383</h2><pre>/*
 * bal.cpp
 *
 *  Created on: 2011-7-9
 *      Author: mac
 */

#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;climits&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;cassert&gt;
#include &lt;cmath&gt;
using namespace std;
const int MAX_N_BALLONS = 200000 + 10;
int x[MAX_N_BALLONS];
typedef long double Double;
Double r[MAX_N_BALLONS];
int n;
void readInput() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d%Lf", x + i, r + i);
	}
}

Double getVal(int curX, int id) {
	Double L = curX - x[id];
	return L * L / (4 * r[id]);
}

const int BIG = int(1e9) + 1;

int when(int L, int a, int b) {
	int R = BIG;
	while (R - L &gt; 1) {
		int M = (L + R) / 2;
		if (getVal(M, a) &lt; getVal(M, b))
			R = M;
		else
			L = M;
	}
	return R;
}

int que[MAX_N_BALLONS], qh, qt;
void work() {
	qh = qt = 0;
	que[qt++] = 0;
	for (int i = 1; i &lt; n; ++i) {
		int curX = x[i];
		while (qt - qh &gt;= 2) {
			if (getVal(curX, que[qt - 2]) &lt;= getVal(curX, que[qt - 1]))
				--qt;
			else
				break;
		}
		r[i] = min(r[i], getVal(curX, que[qt - 1]));
		que[qt++] = i;
		while (qt - qh &gt;= 3) {
			if (when(curX, que[qt - 3], que[qt - 2])
					&lt;= when(curX, que[qt - 2], que[qt - 1]))
				que[qt - 2] = que[qt - 1], --qt;
			else
				break;
		}
	}
}

void solve() {
	readInput();
	work();
	for (int i = 0; i &lt; n; ++i) {
		printf("%0.3Lf\n", r[i]);
	}
}

int main() {
	solve();
//	runTest();
	return 0;
}
</pre><pre></pre><h2>Problem2384</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;
const int MAX_L_STR = 1000000 + 10;
int str[MAX_L_STR], pet[MAX_L_STR];
int strLen, petLen;
inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

void readInput() {
	scanInt(petLen), scanInt(strLen);
	for (int i = 0; i &lt; petLen; ++i) {
		scanInt(pet[i]);
	}
	for (int i = 0; i &lt; strLen; ++i) {
		scanInt(str[i]);
	}
}

struct TA {
	int a[MAX_L_STR], n;
	void init(int _n) {
		n = _n;
		memset(a, 0, sizeof(int) * n);
	}
	void add(int p, int x) {
		for (p++; p &lt;= n; p += p &amp; -p)
			a[p - 1] += x;
	}
	int calc(int p) {
		int ret = 0;
		for (p++; p; p -= p &amp; -p)
			ret += a[p - 1];
		return ret;
	}
};
TA ta;
int cntSmall[MAX_L_STR];

void debug(int a[], int n) {
//	for (int i = 0; i &lt; n; ++i) {
//		cout &lt;&lt; a[i] &lt;&lt; " ";
//	}
//	cout &lt;&lt; endl;
}

void prepare() {
	static int heights[MAX_L_STR];
	memcpy(heights, str, sizeof heights);
	sort(heights, heights + strLen);
	for (int i = 0; i &lt; strLen; ++i) {
		str[i] = lower_bound(heights, heights + strLen, str[i]) - heights;
	}

	static int npet[MAX_L_STR];
	for (int i = 0; i &lt; petLen; ++i) {
		npet[--pet[i]] = i;
	}
	memcpy(pet, npet, sizeof pet);
	ta.init(petLen);
	for (int i = 0; i &lt; petLen; ++i) {
		cntSmall[i] = ta.calc(pet[i] - 1);
		ta.add(pet[i], 1);
	}
	debug(pet, petLen);
}

int next[MAX_L_STR];
int L, R; //[L,R)
void moveTo(int seq[], int newL, int newR) {
	for (int i = L; i &lt; newL; ++i) {
		ta.add(seq[i], -1);
	}
	for (int i = R; i &lt; newR; ++i) {
		ta.add(seq[i], 1);
	}
	L = newL, R = newR;
}

void calcNext() {
	next[0] = -1;
	L = 0, R = 0;
	ta.init(petLen);
	for (int i = 1; i &lt; petLen; ++i) {
		int t = next[i - 1];
		while (t != -1) {
			moveTo(pet, i - t - 1, i);
			if (cntSmall[t + 1] == ta.calc(pet[i] - 1)) {
				++t;
				break;
			}
			t = next[t];
		}
		if (t == -1)
			t = 0;
		next[i] = t;
	}
	debug(next, petLen);
}

void calcKMP() {
	L = 0, R = 0;
	int t = -1;
	static int ans[MAX_L_STR], nAns;
	nAns = 0;
	ta.init(strLen);
	for (int i = 0; i &lt; strLen; ++i) {
		while (t != -1) {
			moveTo(str, i - t - 1, i);
			if (cntSmall[t + 1] == ta.calc(str[i] - 1)) {
				++t;
				break;
			}
			t = next[t];
		}
		if (t == -1)
			t = 0;
		if (t == petLen - 1) {
			ans[nAns++] = i - petLen + 2;
			t = next[t];
		}
	}

	printf("%d\n", nAns);
	for (int i = 0; i &lt; nAns; ++i) {
		printf("%d ", ans[i]);
	}
	printf("\n");
}

void work() {
	prepare();
	calcNext();
	calcKMP();
}

void solve() {
	readInput();
	work();
}

int main() {
	solve();
}
</pre><pre></pre><h2>Problem2385</h2><pre>/*
 * hot.cpp
 *
 *  Created on: 2011-7-10
 *      Author: mac
 */

#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;climits&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
using namespace std;
int n, m, o;
typedef pair&lt;int, int&gt; ipair;

int main() {
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; o;
	vector&lt;ipair&gt; os(m);
	multiset&lt;ipair&gt; rs;
	for (int i = 0; i &lt; n; ++i) {
		int c, p;
		scanf("%d%d", &amp;c, &amp;p);
		rs.insert(make_pair(p, c));
	}
	for (int i = 0; i &lt; m; ++i) {
		int v, d;
		scanf("%d%d", &amp;v, &amp;d);
		os[i] = make_pair(v, d);
	}
	sort(os.rbegin(), os.rend());
	vector&lt;int&gt; can;
	for (int i = 0; i &lt; m; ++i) {
		ipair tmp = make_pair(os[i].second, 0);
		multiset&lt;ipair&gt;::iterator it = rs.lower_bound(tmp);
		if (it == rs.end())
			continue;
		int get = os[i].first - it-&gt;second;
		if (get &gt; 0)
			can.push_back(get);
		rs.erase(it);
	}
	sort(can.rbegin(), can.rend());
	long long ans = 0;
	for (int i = 0; i &lt; min((int)can.size(), o); ++i) {
		ans += can[i];
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem2386</h2><pre>/*
 * tea.cpp
 *
 *  Created on: 2011-7-10
 *      Author: mac
 */

#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;climits&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 1000000 + 10;
int a[MAX_N], n;
typedef pair&lt;int, int&gt; ipair;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

void readInput() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanInt(a[i]);
	}
}

ipair ps[MAX_N];
int mark[MAX_N];
vector&lt;int&gt; byGroup[MAX_N];
int dp[MAX_N];
int prev[MAX_N];
int v[MAX_N];
const int INF = 1 &lt;&lt; 29;

vector&lt;int&gt; byIMinusVi[MAX_N];

struct DisjointSet {
	int rank[MAX_N];
	int father[MAX_N];
	int name[MAX_N];
	void set(int u) {
		father[u] = u;
		rank[u] = 0;
		name[u] = u;
	}
	int find(int x) {
		int px = father[x], tmp;
		while (father[px] != px)
			px = father[px];
		while (x != px) {
			tmp = father[x];
			father[x] = px;
			x = tmp;
		}
		return px;
	}
	int unite(int a, int b) {
		//new name is b's name
		if (rank[a] &lt; rank[b]) {
			father[a] = b;
			return b;
		} else {
			name[a] = name[b];
			father[b] = a;
			rank[a] += rank[a] == rank[b];
			return a;
		}
	}
	int get(int x) {
		return name[find(x)];
	}
};

int doDp(int maxSize) {
	static int stack[MAX_N], top;
	static DisjointSet disjointSet;
	dp[0] = 0;
	top = 0;
	for (int i = 1; i &lt;= n; ++i) {
		dp[i] = -INF;
	}
	for (int i = 0; i &lt;= n; ++i) {
		disjointSet.set(i);
		int me = i;
		while (top &gt; 0 &amp;&amp; dp[disjointSet.name[stack[top - 1]]] &lt;= dp[i]) {
			me = disjointSet.unite(stack[--top], me);
		}
		stack[top++] = me;
		foreach(e,byIMinusVi[i]) {
			int j = *e;
			int L = max(j - maxSize, 0);
			prev[j] = disjointSet.get(L);
			dp[j] = dp[prev[j]] + 1;
		}
	}
	return dp[n];
}

void prepare() {
	for (int i = 1; i &lt;= n; ++i) {
		ps[i] = make_pair(a[i - 1], i);
	}
	sort(ps + 1, ps + n + 1);
	for (int i = 0; i &lt;= n; ++i) {
		byIMinusVi[i].clear();
	}
	for (int i = 1; i &lt;= n; ++i) {
		v[i] = ps[i].first;
		if (i - v[i] &gt;= 0) {
			byIMinusVi[i - v[i]].push_back(i);
		}
	}
}

void checkSolution(int cnt, int R) {
	for (int i = 0; i &lt; cnt; ++i) {
		byGroup[i].clear();
	}

	for (int i = 1; i &lt;= n; ++i) {
		byGroup[mark[i]].push_back(i);
	}

	for (int i = 0; i &lt; cnt; ++i) {
		vector&lt;int&gt;&amp;group = byGroup[i];
		int req = 0;
		for (int j = 0; j &lt; group.size(); ++j) {
			req = max(req, a[group[j] - 1]);
		}assert(req&lt;=group.size());
		assert(group.size()&lt;=R);
	}
}

void outputSolution(int cnt) {
	for (int i = 0; i &lt; cnt; ++i) {
		byGroup[i].clear();
	}

	for (int i = 1; i &lt;= n; ++i) {
		byGroup[mark[i]].push_back(i);
	}

	for (int i = 0; i &lt; cnt; ++i) {
		vector&lt;int&gt;&amp;group = byGroup[i];
		int req = 0;
		for (int j = 0; j &lt; group.size(); ++j) {
			req = max(req, a[group[j] - 1]);
		}
		assert(req&lt;=group.size());
	}

	printf("%d\n", cnt);
	for (int i = 0; i &lt; cnt; ++i) {
		vector&lt;int&gt;&amp;group = byGroup[i];
		printf("%d", group.size());
		for (int j = 0; j &lt; group.size(); ++j) {
			printf(" %d", group[j]);
		}
		printf("\n");
	}
}

int greedyWork() {
	//doDp(n) is used
	int at = n;
	int ans = 0;
	while (at != 0) {
		ans = max(ans, at - prev[at]);
		at = prev[at];
	}
	return ans;
}

ipair work(bool output = true) {
	prepare();
	int maxNum = doDp(n);
	cout &lt;&lt; maxNum &lt;&lt; endl;
	return make_pair(0, 0);
	int L = v[n] - 1;
	int R = greedyWork();
	while (L + 1 &lt; R) {
		int M = L + R &gt;&gt; 1;
		if (doDp(M) == maxNum)
			R = M;
		else
			L = M;
	}
	if (!output)
		return make_pair(maxNum, R);

	doDp(R);
	int at = n;
	int cnt = 0;
	while (at &gt; 0) {
		for (int i = prev[at] + 1; i &lt;= at; ++i) {
			mark[ps[i].second] = cnt;
		}
		cnt++;
		at = prev[at];
	}assert(cnt == maxNum);
	checkSolution(cnt, R);
	outputSolution(cnt);
	return make_pair(maxNum, R);
}

int cnt[MAX_N], req[MAX_N];
int bNum, bMaxCnt;
void rec(int at, int num) {
	if (at == n) {
		if (num &lt; bNum)
			return;
		int maxCnt = 0;
		for (int i = 0; i &lt; num; ++i) {
			if (cnt[i] &lt; req[i])
				return;
			maxCnt = max(maxCnt, cnt[i]);
		}
		if (num &gt; bNum || (num == bNum &amp;&amp; maxCnt &lt; bMaxCnt)) {
			bNum = num;
			bMaxCnt = maxCnt;
		}
		return;
	}
	for (int i = 0; i &lt; num; ++i) {
		cnt[i]++;
		int reqCopy = req[i];
		req[i] = max(req[i], a[at]);
		rec(at + 1, num);
		req[i] = reqCopy;
		cnt[i]--;
	}

	cnt[num] = 1;
	req[num] = a[at];
	rec(at + 1, num + 1);
}

ipair workBrute() {
	bNum = bMaxCnt = 0;
	rec(0, 0);
	return make_pair(bNum, bMaxCnt);
}

void write(ipair a) {
	cout &lt;&lt; a.first &lt;&lt; " " &lt;&lt; a.second &lt;&lt; endl;
}

int mema[MAX_N];

bool runTest() {
	n = 10;
	for (int i = 0; i &lt; n; ++i) {
		a[i] = rand() % 5 + 1;
	}
	ipair pa = work(false), pb = workBrute();
	if (pa != pb) {
		cout &lt;&lt; "HI" &lt;&lt; endl;
		write(pa);
		write(pb);
		sort(a, a + n);
		for (int i = 0; i &lt; n; ++i) {
			cout &lt;&lt; a[i] &lt;&lt; " ";
		}
		cout &lt;&lt; endl;
		cout &lt;&lt; "END" &lt;&lt; endl;
		memcpy(mema, a, sizeof a);
		return false;
	}
	return true;
}

bool runTest2() {
	n = 1000;
	for (int i = 0; i &lt; n; ++i) {
		a[i] = rand() % 1000 + 1;
	}
	work(true);
	return true;
}

void solve() {
	readInput();
	work();
}

void runSpeedTest() {
	n = 1000000;
	for (int i = 0; i &lt; n; ++i) {
		a[i] = rand() + 1;
	}
	write(work(false));
}

int main() {
	solve();
	return 0;
}
</pre><pre></pre><h2>Problem2387</h2><pre>/*
 * tra.cpp
 *
 *  Created on: 2011-7-10
 *      Author: mac
 */

#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;climits&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_POINTS = 300000 + 10;
const int MAX_N_EDGES = 900000 + 10;
int nPoints, nEdges, A, B;
vector&lt;int&gt; E[MAX_N_POINTS], RE[MAX_N_EDGES];

struct Point {
	int x, y;
	int id;
	bool operator&lt;(const Point&amp;p) const {
		if (x != p.x)
			return x &lt; p.x;
		return y &lt; p.y;
	}
	void read(int _id) {
		scanf("%d%d", &amp;x, &amp;y);
		id = _id;
	}
};

Point points[MAX_N_POINTS];
int oldIdToNewId[MAX_N_POINTS];

void addEdge(int a, int b) {
	E[a].push_back(b);
	RE[b].push_back(a);
}

void readInput() {
	scanf("%d%d%d%d", &amp;nPoints, &amp;nEdges, &amp;A, &amp;B);
	for (int i = 0; i &lt; nPoints; ++i) {
		points[i].read(i);
	}
	sort(points, points + nPoints);
	for (int i = 0; i &lt; nPoints; ++i) {
		oldIdToNewId[points[i].id] = i;
	}
	for (int i = 0; i &lt; nEdges; ++i) {
		int a, b, c;
		scanf("%d%d%d", &amp;a, &amp;b, &amp;c);
		--a, --b;
		a = oldIdToNewId[a], b = oldIdToNewId[b];
		addEdge(a, b);
		if (c == 2)
			addEdge(b, a);
	}
}

bool visited[MAX_N_POINTS];
int que[MAX_N_POINTS], qh, qt;

void deleteUselessPoints() {
	memset(visited, false, sizeof visited);
	qh = qt = 0;
	for (int i = 0; i &lt; nPoints; ++i) {
		if (points[i].x == 0) {
			que[qt++] = i;
			visited[i] = true;
		}
	}
	while (qh &lt; qt) {
		int u = que[qh++];
		foreach(e,E[u]) {
			if (!visited[*e])
				visited[*e] = true, que[qt++] = *e;
		}
	}
}

int L[MAX_N_POINTS], R[MAX_N_POINTS];
void dfs(int u, int mark[], int what) {
	if (mark[u] != -1)
		return;
	mark[u] = what;
	foreach(e,RE[u])
		dfs(*e, mark, what);
}

int sum[MAX_N_POINTS];

void work() {
	deleteUselessPoints();
	memset(L, -1, sizeof L);
	memset(R, -1, sizeof R);

	sum[0] = 0;
	for (int i = 0; i &lt; nPoints; ++i) {
		sum[i + 1] = sum[i] + visited[i];
	}
	for (int i = 0; i &lt; nPoints; ++i) {
		if (points[i].x == A) {
			dfs(i, L, i);
		}
	}
	for (int i = nPoints - 1; i &gt;= 0; --i) {
		if (points[i].x == A) {
			dfs(i, R, i);
		}
	}

	for (int i = nPoints - 1; i &gt;= 0; --i) {
		if (points[i].x == 0) {
			int ret = 0;
			if (L[i] != -1 &amp;&amp; R[i] != -1)
				ret = sum[R[i] + 1] - sum[L[i]];
			printf("%d\n", ret);
		}
	}
}

int main() {
	readInput();
	work();
	return 0;
}
</pre><pre></pre><h2>Problem2389</h2><pre>/*
 * XY的赛车场.cpp
 *
 *  Created on: 2011-7-27
 *      Author: mac
 */

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;

const int MAX_N_VERTICES = 500000 + 10;
const int MOD = int(1e9) + 9;
int F[MAX_N_VERTICES], nV, nE;
int find(int x) {
	return x == F[x] ? x : F[x] = find(F[x]);
}

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

int main() {
	scanInt(nV), scanInt(nE);
	for (int i = 1; i &lt;= nV; ++i) {
		F[i] = i;
	}
	int ans = 1;
	for (int i = 0; i &lt; nE; ++i) {
		int a, b;
		scanInt(a), scanInt(b);
		a = find(a), b = find(b);
		if (a == b) {
			ans &lt;&lt;= 1;
			if (ans &gt;= MOD)
				ans -= MOD;
		}
		F[a] = b;
		if (ans &gt; 0)
			printf("%d\n", ans - 1);
		else
			printf("%d\n", MOD - 1);
	}
	return 0;
}
</pre><pre></pre><h2>Problem2393</h2><pre>/*
 * 2393.cpp
 *
 *  Created on: 2011-7-27
 *      Author: mac
 */

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
typedef long long int64;
vector&lt;int64&gt; divs;

void iterate(int64 cur, int64 R) {
	if (cur &gt; R)
		return;
	if (cur &gt; 0) {
		divs.push_back(cur);
	}
	iterate(cur * 10 + 2, R);
	iterate(cur * 10 + 9, R);
}

int64 gcd(int64 a, int64 b) {
	while (b) {
		int64 t = a % b;
		a = b;
		b = t;
	}
	return a;
}

int64 lcm(int64 a, int64 b) {
	return a / gcd(a, b) * b;
}

int64 rec(int at, int64 l, int64 R) {
	if (l &gt; R)
		return 0;
	if (at == divs.size()) {
		return R / l;
	}
	return rec(at + 1, l, R) - rec(at + 1, lcm(l, divs[at]), R);
}

int64 calc(int64 R) {
	divs.clear();
	iterate(0, R);

	vector&lt;int64&gt; tmp;
	sort(divs.begin(), divs.end());
	if (divs.empty())
		return 0;
	for (int i = 0; i &lt; divs.size(); ++i) {
		bool check = true;
		for (int j = 0; j &lt; i; ++j) {
			if (divs[i] % divs[j] == 0) {
				check = false;
				break;
			}
		}
		if (check)
			tmp.push_back(divs[i]);
	}

	divs = tmp;
	sort(divs.rbegin(), divs.rend());
	return R - rec(0, 1, R);
}

int main() {
	int64 L, R;
	cin &gt;&gt; L &gt;&gt; R;
	cout &lt;&lt; calc(R) - calc(L - 1) &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2396</h2><pre>/*
 * 2396.cpp
 *
 *  Created on: 2011-7-27
 *      Author: mac
 */

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;
const int MAX_N = 1000;
typedef int Mat[MAX_N][MAX_N];
Mat A, B, C;
int N;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

void readMat(Mat mat) {
	for (int i = 0; i &lt; N; ++i) {
		for (int j = 0; j &lt; N; ++j) {
			scanInt(mat[i][j]);
		}
	}
}

void multiply(int x[], Mat a, int nx[]) {
	fill(nx, nx + N, 0);
	for (int i = 0; i &lt; N; ++i) {
		for (int j = 0; j &lt; N; ++j) {
			nx[j] += a[i][j] * x[i];
		}
	}
}

int a[MAX_N], b[MAX_N], c[MAX_N];

int main() {
	while (scanf("%d", &amp;N) == 1) {
		readMat(A), readMat(B), readMat(C);
		for (int i = 0; i &lt; N; ++i) {
			a[i] = rand() % 1000;
		}
		multiply(a, A, c);
		multiply(c, B, b);
		multiply(a, C, c);
		bool check = true;
		for (int i = 0; i &lt; N; ++i) {
			if (b[i] != c[i])
				check = false;
		}
		printf("%s\n", check ? "Yes" : "No");
	}
	return 0;
}
</pre><pre></pre><h2>Problem2400</h2><pre>/*
 * GRAPH.cpp
 *
 *  Created on: 2011-7-31
 *      Author: mac
 */

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;

struct Network {
	static const int MAX_N_VERTICES = 500 + 10;
	static const int MAX_N_EDGES = 100000 * 2;
	static const int INF = ~0U &gt;&gt; 2;

	struct Edge {
		int t, c;
		Edge*n, *r;
	};

	Edge edges[MAX_N_EDGES], *top;
	Edge*E[MAX_N_VERTICES];

	Edge *makeEdge(int s, int t, int c) {
		Edge*e = top++;
		e-&gt;t = t, e-&gt;c = c, e-&gt;n = E[s];
		return E[s] = e;
	}

	void addEdge(int s, int t, int c1, int c2) {
		Edge*st = makeEdge(s, t, c1), *ts = makeEdge(t, s, c2);
		st-&gt;r = ts, ts-&gt;r = st;
	}

	int nVertices;
	void clear() {
		nVertices = 0;
		top = edges;
	}

	int addVertex() {
		E[nVertices] = 0;
		return nVertices++;
	}

	int maxFlow(int vs, int vt) {
		static int h[MAX_N_VERTICES], cnt[MAX_N_VERTICES], am[MAX_N_VERTICES];
		static Edge*prev[MAX_N_VERTICES], *cur[MAX_N_VERTICES];
		memset(h, 0, sizeof h), memset(cnt, 0, sizeof cnt), memset(cur, 0, sizeof cur);
		cnt[0] = nVertices;
		int u = vs;
		am[vs] = INF;
		Edge*e;
		int flow = 0;
		while (h[vs] &lt; nVertices) {
			for (e = cur[u]; e; e = e-&gt;n)
				if (e-&gt;c &amp;&amp; h[u] == h[e-&gt;t] + 1)
					break;
			if (e) {
				int v = e-&gt;t;
				am[v] = min(am[u], e-&gt;c);
				prev[v] = cur[u] = e;
				if ((u = v) == vt) {
					int by = am[u];
					while (u != vs) {
						Edge*p = prev[u];
						p-&gt;c -= by;
						p-&gt;r-&gt;c += by;
						u = p-&gt;r-&gt;t;
					}
					flow += by;
				}
			} else {
				if (!--cnt[h[u]])
					return flow;
				h[u] = nVertices;
				for (e = E[u]; e; e = e-&gt;n)
					if (e-&gt;c &amp;&amp; h[e-&gt;t] + 1 &lt; h[u])
						h[u] = h[e-&gt;t] + 1, cur[u] = e;
				++cnt[h[u]];
				if (u != vs)
					u = prev[u]-&gt;r-&gt;t;
			}
		}
		return flow;
	}
};

const int MAX_N_VERTICES = 500 + 10;
const int MAX_N_EDGES = 2000 + 10;
const int LARGE = MAX_N_EDGES;
const int INF = ~0U &gt;&gt; 2;

int nV, nE;
int value[MAX_N_VERTICES];
int a[MAX_N_EDGES], b[MAX_N_EDGES];
void readInput() {
	scanf("%d%d", &amp;nV, &amp;nE);
	for (int i = 0; i &lt; nV; ++i) {
		scanf("%d", value + i);
	}
	for (int i = 0; i &lt; nE; ++i) {
		scanf("%d%d", a + i, b + i), --a[i], --b[i];
	}
}

typedef long long int64;
int64 edgeSum, vtxSum;

void doit(int bit) {
	static Network network;
	network.clear();
	for (int i = 0; i &lt; nV; ++i) {
		network.addVertex();
	}
	int vs = network.addVertex(), vt = network.addVertex();

	for (int i = 0; i &lt; nV; ++i) {
		if (value[i] &gt;= 0) {
			if (value[i] &amp; bit) {
				network.addEdge(vs, i, INF, 0);
				network.addEdge(i, vt, 1, 0);
			} else {
				network.addEdge(i, vt, INF, 0);
			}
		} else {
			network.addEdge(i, vt, 1, 0);
		}
	}

	for (int i = 0; i &lt; nE; ++i) {
		int a = ::a[i], b = ::b[i];
		network.addEdge(a, b, LARGE, LARGE);
	}

	int flow = network.maxFlow(vs, vt);
	edgeSum += 1LL * (flow / LARGE) * bit;
	vtxSum += 1LL * (flow % LARGE) * bit;
}

void work() {
	edgeSum = vtxSum = 0;
	int maxValue = *max_element(value, value + nV);
	for (int bit = 1; bit &lt;= maxValue; bit &lt;&lt;= 1) {
		doit(bit);
	}
	cout &lt;&lt; edgeSum &lt;&lt; endl &lt;&lt; vtxSum &lt;&lt; endl;
}

void solve() {
	readInput();
	work();
}

int main() {
	solve();
	return 0;
}
</pre><pre></pre><h2>Problem2401</h2><pre>/*
 * 5971. LCM Sum.cpp
 *
 *  Created on: 2011-5-2
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 1000000 + 10;

typedef long long int64;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

inline void printInt(int64 x) {
	if (!x) {
		puts("0");
		return;
	}
	static int digits[30];
	int p = 0;
	while (x)
		digits[p++] = x % 10, x /= 10;
	for (int i = p - 1; i &gt;= 0; --i) {
		putchar('0' + digits[i]);
	}
	putchar('\n');
}

/*
 *  f(n) = n*(g*1)(n)
 *  g(n) = ((id*phi+e)/2)(n)
 *  f(n) = (n/2) * ((id*phi*1)(n)+1)(n)
 */

/*
 * need (id*phi*1)
 */

const int MAX_N_PRIMES = MAX_N / 10;
int primes[MAX_N_PRIMES], nPrimes;
int minP[MAX_N] = { }, minPow[MAX_N];

int64 F[MAX_N] = { };

void prepare() {
	nPrimes = 0;
	F[1] = 1;
	for (int i = 2; i &lt; MAX_N; ++i) {
		if (minP[i] == 0) {
			primes[nPrimes++] = i;
			minP[i] = i;
			minPow[i] = i;
			F[i] = 1LL * i * i * i;
		}
		for (int j = 0; j &lt; nPrimes; ++j) {
			int p = primes[j], ip = p * i;
			if (ip &gt; MAX_N)
				break;
			minP[ip] = p;
			if (minP[i] == p) {
				minPow[ip] = minPow[i] * p;
				if (F[i] &gt; 0) {
					F[ip] = F[i] * p * p;
				}
				break;
			} else {
				minPow[ip] = p;
			}
		}
	}

	for (int i = 2; i &lt; MAX_N; ++i) {
		if (F[i] &gt; 0) {
			F[i] = (F[i] - minP[i]) / (minP[i] + 1) + 1;
		} else {
			F[i] = F[i / minPow[i]] * F[minPow[i]];
		}
	}
}

int64 calc(int n) {
	return (F[n] + 1) * n / 2;
}

int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}

const int MOD = int(1e9);

struct BigInt {
	int a[4];
	BigInt(int64 x = 0) {
		for (int i = 0; i &lt; 4; ++i) {
			a[i] = x % MOD;
			x /= MOD;
		}
	}
	BigInt&amp; operator=(const BigInt&amp;o) {
		memcpy(a, o.a, sizeof(int) * 4);
		return *this;
	}
	BigInt&amp;operator+=(const BigInt&amp;o) {
		int carry = 0;
		for (int i = 0; i &lt; 4; ++i) {
			carry += a[i] + o.a[i];
			a[i] = carry % MOD;
			carry /= MOD;
		}
		return *this;
	}
	void write() {
		for (int i = 4 - 1; i &gt;= 0; --i) {
			if (a[i] || i == 0) {
				printf("%d", a[i]);
				for (int j = i - 1; j &gt;= 0; --j) {
					printf("%09d", a[j]);
				}
				puts("");
				return;
			}
		}
	}
};

BigInt ansB[MAX_N];

int main() {
	prepare();
	int nT;
	scanInt(nT);
	for (int i = 1; i &lt; MAX_N; ++i) {
		int64 add = calc(i) * 2 - i;
		ansB[i] = ansB[i - 1];
		ansB[i] += add;
	}
	for (int i = 0; i &lt; nT; ++i) {
		int n;
		scanInt(n);
		ansB[n].write();
	}
}
</pre><pre></pre><h2>Problem2404</h2><pre>/*
 * 2404.cpp
 *
 *  Created on: 2011-10-12
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MOD = 30013;

struct Index {
	vector&lt;int&gt; a;
	void add(int x) {
		a.push_back(x);
	}
	void doit() {
		sort(a.begin(), a.end());
		a.erase(unique(a.begin(), a.end()), a.end());
	}
	int get(int x) {
		return lower_bound(a.begin(), a.end(), x) - a.begin();
	}
};

Index indexs[2];

struct Result {
	int num, way;
	Result() :
			num(-1), way(1) {
	}
	Result(int _num) :
			num(_num), way(1) {
	}
	void update(const Result&amp;r) {
		if (r.num &gt; num) {
			*this = r;
		} else if (r.num == num) {
			way += r.way;
			if (way &gt;= MOD)
				way -= MOD;
		}
	}
};

struct Trapezoid {
	int am[2][2];
	Result ret;
	void read() {
		for (int r = 0; r &lt; 2; ++r) {
			for (int c = 0; c &lt; 2; ++c) {
				scanf("%d", am[r] + c);
				indexs[r].add(am[r][c]);
			}
		}
	}
	void normalize() {
		for (int r = 0; r &lt; 2; ++r) {
			for (int c = 0; c &lt; 2; ++c) {
				am[r][c] = indexs[r].get(am[r][c]);
			}
		}
	}
};

struct Event {
	Trapezoid*trapezoid;
	int d;
	Event*next;
	Event(Trapezoid*_trapezoid, int _d, Event*_next) :
			trapezoid(_trapezoid), d(_d), next(_next) {
	}
};

vector&lt;Trapezoid&gt; trapezoids;

struct TA {
	vector&lt;Result&gt; a;
	TA(int n) :
			a(n) {
	}
	void update(int p, Result r) {
		for (p++; p &lt;= a.size(); p += p &amp; -p)
			a[p - 1].update(r);
	}
	Result get(int p) {
		Result ret;
		for (p++; p &gt; 0; p -= p &amp; -p)
			ret.update(a[p - 1]);
		return ret;
	}
};

int main() {
	int n;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		Trapezoid t;
		t.read();
		trapezoids.push_back(t);
	}
	for (int r = 0; r &lt; 2; ++r) {
		indexs[r].doit();
	}
	vector&lt;Event*&gt; first(indexs[0].a.size(), (Event*) 0);
	for (int i = 0; i &lt; n; ++i) {
		Trapezoid*t = &amp;trapezoids[i];
		t-&gt;normalize();
		for (int c = 0; c &lt; 2; ++c) {
			Event*e = new Event(t, c, first[t-&gt;am[0][c]]);
			first[t-&gt;am[0][c]] = e;
		}
	}
	TA ta(indexs[1].a.size());
	Result ans;
	for (int i = 0; i &lt; indexs[0].a.size(); ++i) {
		for (Event*e = first[i]; e; e = e-&gt;next) {
			if (e-&gt;d == 0) {
				Result r(1), tmp = ta.get(e-&gt;trapezoid-&gt;am[1][0]);
				tmp.num++;
				r.update(tmp);
				ans.update(r);
				e-&gt;trapezoid-&gt;ret = r;
			} else {
				ta.update(e-&gt;trapezoid-&gt;am[1][1], e-&gt;trapezoid-&gt;ret);
			}
		}
	}
	cout &lt;&lt; ans.num &lt;&lt; " " &lt;&lt; ans.way &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2405</h2><pre>/*
 *  数字.cpp
 *
 *  Created on: 2011-7-31
 *      Author: mac
 */

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;
typedef long long int64;
const int N = 2520 * 9;
bool ok[N];
int c = 0;

int64 cnt(int64 R) {
	int64 ret = R / N * c;
	R %= N;
	for (int i = 1; i &lt;= R; ++i) {
		ret += ok[i];
	}
	return ret;
}

int main() {
	for (int i = 1; i &lt;= N; ++i) {
		ok[((i - 1) % 9 + 1) * i % N] = true;
	}
	for (int i = 0; i &lt; N; ++i) {
		c += ok[i];
	}
	int T;
	cin &gt;&gt; T;
	while (T--) {
		int64 L, R;
		cin &gt;&gt; L &gt;&gt; R;
		cout &lt;&lt; cnt(R) - cnt(L - 1) &lt;&lt; endl;
	}
	return 0;
}
</pre><pre></pre><h2>Problem2406</h2><pre>/*
 * a.cpp
 *
 *  Created on: 2011-8-1
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_N = 200 + 10;
int A[MAX_N][MAX_N], nR, nC, L, R;
void readInput() {
	cin &gt;&gt; nR &gt;&gt; nC;
	for (int r = 0; r &lt; nR; ++r) {
		for (int c = 0; c &lt; nC; ++c) {
			scanf("%d", A[r] + c);
		}
	}
	cin &gt;&gt; L &gt;&gt; R;
}
int rowSum[MAX_N], colSum[MAX_N];

const int INF = ~0U &gt;&gt; 2;
struct Network {
	static const int MAX_N_VERTICES = 500 + 10;
	static const int MAX_N_EDGES = 1000000 * 2;

	struct Edge {
		int t, c;
		Edge*n, *r;
	};

	Edge edges[MAX_N_EDGES], *top;
	Edge*E[MAX_N_VERTICES];

	Edge *makeEdge(int s, int t, int c) {
		Edge*e = top++;
		e-&gt;t = t, e-&gt;c = c, e-&gt;n = E[s];
		return E[s] = e;
	}

	void addEdge(int s, int t, int c) {
		Edge*st = makeEdge(s, t, c), *ts = makeEdge(t, s, 0);
		st-&gt;r = ts, ts-&gt;r = st;
	}

	int sumIn[MAX_N_VERTICES], sumOut[MAX_N_VERTICES];
	void addEdge(int s, int t, int L, int R) {
		sumIn[t] += L;
		sumOut[s] += L;
		addEdge(s, t, R - L);
	}
	int nVertices;
	int vs, vt;
	void init(int _nVertices, int _vs, int _vt) {
		nVertices = _nVertices;
		vs = _vs, vt = _vt;
		memset(E, 0, sizeof(Edge*) * nVertices);
		memset(sumIn, 0, sizeof(int) * nVertices);
		memset(sumOut, 0, sizeof(int) * nVertices);
		top = edges;
	}

	void makeGraph() {
		for (int i = 0; i &lt; nVertices; ++i) {
			if (sumIn[i] &gt; 0) {
				addEdge(vs, i, sumIn[i]);
			}
			if (sumOut[i] &gt; 0) {
				addEdge(i, vt, sumOut[i]);
			}
		}
	}

	int maxFlow() {
		static int h[MAX_N_VERTICES], cnt[MAX_N_VERTICES], am[MAX_N_VERTICES];
		static Edge*prev[MAX_N_VERTICES], *cur[MAX_N_VERTICES];
		fill(h, h + nVertices, INF);
		memset(cnt, 0, sizeof cnt);
		static int que[MAX_N_VERTICES];
		int qh = 0, qt = 0;
		h[vt] = 0;
		for (que[qt++] = vt; qh &lt; qt;) {
			int u = que[qh++];
			cnt[h[u]]++;
			for (Edge*e = E[u]; e; e = e-&gt;n)
				if (e-&gt;r-&gt;c &amp;&amp; h[e-&gt;t] == INF) {
					h[e-&gt;t] = h[u] + 1;
					que[qt++] = e-&gt;t;
				}
		}
		memcpy(cur, E, sizeof E);
		int u = vs;
		am[vs] = INF;
		Edge*e;
		int flow = 0;
		while (h[vs] &lt; nVertices) {
			for (e = cur[u]; e; e = e-&gt;n)
				if (e-&gt;c &amp;&amp; h[u] == h[e-&gt;t] + 1)
					break;
			if (e) {
				int v = e-&gt;t;
				am[v] = min(am[u], e-&gt;c);
				prev[v] = cur[u] = e;
				if ((u = v) == vt) {
					int by = am[u];
					while (u != vs) {
						Edge*p = prev[u];
						p-&gt;c -= by;
						p-&gt;r-&gt;c += by;
						u = p-&gt;r-&gt;t;
					}
					flow += by;
				}
			} else {
				if (!--cnt[h[u]])
					return flow;
				h[u] = nVertices;
				for (e = E[u]; e; e = e-&gt;n)
					if (e-&gt;c &amp;&amp; h[e-&gt;t] + 1 &lt; h[u])
						h[u] = h[e-&gt;t] + 1, cur[u] = e;
				++cnt[h[u]];
				if (u != vs)
					u = prev[u]-&gt;r-&gt;t;
			}
		}
		return flow;
	}

	bool isFeasible() {
		int needFlow = 0;
		for (int i = 0; i &lt; nVertices; ++i) {
			needFlow += sumIn[i];
		}
		int flow = maxFlow();
		return flow == needFlow;
	}
};

bool check(int diff) {
	int nV = nR + nC;
	int S = nV++, T = nV++;
	int vs = nV++, vt = nV++;
	static Network network;
	network.init(nV, vs, vt);
	for (int r = 0; r &lt; nR; ++r) {
		network.addEdge(S, r, max(rowSum[r] - diff, 0), rowSum[r] + diff);
	}
	for (int c = 0; c &lt; nC; ++c) {
		network.addEdge(c + nR, T, max(colSum[c] - diff, 0), colSum[c] + diff);
	}
	for (int r = 0; r &lt; nR; ++r) {
		for (int c = 0; c &lt; nC; ++c) {
			network.addEdge(r, c + nR, L, R);
		}
	}
	network.addEdge(T, S, 0, INF);
	network.makeGraph();
	return network.isFeasible();
}

void work() {
	for (int r = 0; r &lt; nR; ++r) {
		for (int c = 0; c &lt; nC; ++c) {
			rowSum[r] += A[r][c];
			colSum[c] += A[r][c];
		}
	}

	int left = -1, right = 200 * 1000 + 1;
	while (left + 1 &lt; right) {
		int mid = left + right &gt;&gt; 1;
		if (check(mid))
			right = mid;
		else
			left = mid;
	}
	cout &lt;&lt; right &lt;&lt; endl;
}
int main() {
	readInput();
	work();
	return 0;
}
</pre><pre></pre><h2>Problem2409</h2><pre>/*
 * 2409.cpp
 *
 *  Created on: 2011-8-2
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_N = 500 + 10;
int cnt[MAX_N][MAX_N]; //district,kind
int need[MAX_N][MAX_N];
int maxTakePart[MAX_N];
int n, m, k;
int low[MAX_N], high[MAX_N];

const int INF = ~0U &gt;&gt; 2;
struct Network {
	static const int MAX_N_VERTICES = 1000 + 10;
	static const int MAX_N_EDGES = 1000000 * 2;

	struct Edge {
		int t, c;
		Edge*n, *r;
	};

	Edge edges[MAX_N_EDGES], *top;
	Edge*E[MAX_N_VERTICES];

	Edge *makeEdge(int s, int t, int c) {
		Edge*e = top++;
		e-&gt;t = t, e-&gt;c = c, e-&gt;n = E[s];
		return E[s] = e;
	}

	void addEdge(int s, int t, int c) {
		Edge*st = makeEdge(s, t, c), *ts = makeEdge(t, s, 0);
		st-&gt;r = ts, ts-&gt;r = st;
	}

	int sumIn[MAX_N_VERTICES], sumOut[MAX_N_VERTICES];
	void addEdge(int s, int t, int L, int R) {
		sumIn[t] += L;
		sumOut[s] += L;
		addEdge(s, t, R - L);
	}
	int nVertices;
	int vs, vt;
	void init(int _nVertices, int _vs, int _vt) {
		nVertices = _nVertices;
		vs = _vs, vt = _vt;
		memset(E, 0, sizeof(Edge*) * nVertices);
		memset(sumIn, 0, sizeof(int) * nVertices);
		memset(sumOut, 0, sizeof(int) * nVertices);
		top = edges;
	}

	void setST(int _vs, int _vt) {
		vs = _vs, vt = _vt;
	}

	void makeGraph() {
		for (int i = 0; i &lt; nVertices; ++i) {
			if (sumIn[i] &gt; 0) {
				addEdge(vs, i, sumIn[i]);
			}
			if (sumOut[i] &gt; 0) {
				addEdge(i, vt, sumOut[i]);
			}
		}
	}

	int maxFlow() {
		static int h[MAX_N_VERTICES], cnt[MAX_N_VERTICES], am[MAX_N_VERTICES];
		static Edge*prev[MAX_N_VERTICES], *cur[MAX_N_VERTICES];
		fill(h, h + nVertices, INF);
		memset(cnt, 0, sizeof cnt);
		static int que[MAX_N_VERTICES];
		int qh = 0, qt = 0;
		h[vt] = 0;
		for (que[qt++] = vt; qh &lt; qt;) {
			int u = que[qh++];
			cnt[h[u]]++;
			for (Edge*e = E[u]; e; e = e-&gt;n)
				if (e-&gt;r-&gt;c &amp;&amp; h[e-&gt;t] == INF) {
					h[e-&gt;t] = h[u] + 1;
					que[qt++] = e-&gt;t;
				}
		}
		memcpy(cur, E, sizeof E);
		int u = vs;
		am[vs] = INF;
		Edge*e;
		int flow = 0;
		while (h[vs] &lt; nVertices) {
			for (e = cur[u]; e; e = e-&gt;n)
				if (e-&gt;c &amp;&amp; h[u] == h[e-&gt;t] + 1)
					break;
			if (e) {
				int v = e-&gt;t;
				am[v] = min(am[u], e-&gt;c);
				prev[v] = cur[u] = e;
				if ((u = v) == vt) {
					int by = am[u];
					while (u != vs) {
						Edge*p = prev[u];
						p-&gt;c -= by;
						p-&gt;r-&gt;c += by;
						u = p-&gt;r-&gt;t;
					}
					flow += by;
				}
			} else {
				if (!--cnt[h[u]])
					return flow;
				h[u] = nVertices;
				for (e = E[u]; e; e = e-&gt;n)
					if (e-&gt;c &amp;&amp; h[e-&gt;t] + 1 &lt; h[u])
						h[u] = h[e-&gt;t] + 1, cur[u] = e;
				++cnt[h[u]];
				if (u != vs)
					u = prev[u]-&gt;r-&gt;t;
			}
		}
		return flow;
	}
};

void readInput() {
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
	for (int i = 0; i &lt; n; ++i) {
		int num;
		scanf("%d", &amp;num);
		while (num--) {
			int x;
			scanf("%d", &amp;x);
			cnt[i][--x]++;
		}
	}
	int nF;
	scanf("%d", &amp;nF);
	for (int i = 0; i &lt; nF; ++i) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b), --a, --b;
		need[a][b]++;
	}
	for (int i = 0; i &lt; m; ++i) {
		scanf("%d", maxTakePart + i);
	}
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d%d", high + i, low + i);
	}
}

void work() {
	static Network network;
	int nV = n + m;
	int S = nV++, T = nV++, vs = nV++, vt = nV++, S2 = nV++;

	network.init(nV, vs, vt);
	network.addEdge(S, S2, 0, k);
	int ans = 0;
	for (int i = 0; i &lt; n; ++i) {
		network.addEdge(S2, i, low[i], high[i]);
		ans += low[i];
	}
	for (int i = 0; i &lt; m; ++i) {
		network.addEdge(i + n, T, 0, maxTakePart[i]);
	}
	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; m; ++j) {
			network.addEdge(i, j + m, need[i][j], cnt[i][j]);
		}
	}

	network.addEdge(T, S, 0, INF);
	network.makeGraph();
	network.maxFlow();
	//Feasible flow
	network.setST(S, T);
	cout &lt;&lt; network.maxFlow() &lt;&lt; endl;
}

void solve() {
	readInput();
	work();
}

int main() {
	solve();
	return 0;
}
</pre><pre></pre><h2>Problem2428</h2><pre>/*
 * 2428.cpp
 *
 *  Created on: 2011-9-2
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;cmath&gt;
#include &lt;climits&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_N = 20, MAX_M = 6;
int ans;
int n, k;
int a[MAX_N];

void readInput() {
	cin &gt;&gt; n &gt;&gt; k;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; a[i];
	}
}

void genInput(int _n, int _k) {
	n = _n, k = _k;
	for (int i = 0; i &lt; n; ++i) {
		a[i] = rand() % 50 + 1;
	}
}

int eval() {
	int w[MAX_M] = { };
	for (int i = 0; i &lt; n; ++i) {
		*min_element(w, w + k) += a[i];
	}
	int ret = 0;
	for (int i = 0; i &lt; k; ++i) {
		ret += w[i] * w[i];
	}
	return ret;
}

void work() {
	ans = INT_MAX;
	for (int iter = 0; iter &lt; 100; ++iter) {
		random_shuffle(a, a + n);
		int cur = eval();
		for (int step = 0; step &lt; 10000; ++step) {
			int ia = rand() % n, ib = rand() % n;
			swap(a[ia], a[ib]);
			int ncur = eval();
			if (ncur &lt; cur) {
				cur = ncur;
			} else {
				swap(a[ia], a[ib]);
			}
		}
		ans = min(ans, cur);
	}
	double sum = accumulate(a, a + n, 0.0);
	double ret = ans - sum * sum / k;
	printf("%0.2lf\n", sqrt(ret / k));
}

void solve() {
	readInput();
	work();
}

void runTest() {
	genInput(20, 6);
	work();
}

int main() {
//	runTest();
	solve();
	return 0;
}
</pre><pre></pre><h2>Problem2431</h2><pre>/*
 * 2431.cpp
 *
 *  Created on: 2011-10-12
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MOD = 10000;

int add(int a, int b) {
	int c = a + b;
	if (c &gt;= MOD)
		c -= MOD;
	return c;
}

int main() {
	int n, k;
	cin &gt;&gt; n &gt;&gt; k;
	vector&lt;int&gt; am(k + 1, 0);
	am[0] = 1;
	for (int i = 0; i &lt; n; ++i) {
		vector&lt;int&gt; nam(am.size(), 0);
		partial_sum(am.begin(), am.end(), am.begin(), add);
		for (int j = 0; j &lt; nam.size(); ++j) {
			nam[j] = am[j] - (j &gt;= i + 1 ? am[j - i - 1] : 0);
			if (nam[j] &lt; 0)
				nam[j] += MOD;
		}
		am = nam;
	}
	cout &lt;&lt; am[k] &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2432</h2><pre>#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
using namespace std;

typedef long long int64;
typedef vector&lt;vector&lt;int64&gt; &gt; mat;
typedef vector&lt;int64&gt; vec;

int MOD;
mat zero() {
	return mat(3, vec(3, 0));
}

mat unit() {
	mat c = zero();
	for (int i = 0; i &lt; 3; ++i) {
		c[i][i] = 1;
	}
	return c;
}

mat operator*(mat a, mat b) {
	mat c = zero();
	for (int i = 0; i &lt; 3; ++i) {
		for (int j = 0; j &lt; 3; ++j) {
			for (int k = 0; k &lt; 3; ++k) {
				c[i][j] += a[i][k] * b[k][j];
			}
			c[i][j] %= MOD;
		}
	}
	return c;
}

vec operator*(vec a, mat m) {
	vec c(3, 0);
	for (int i = 0; i &lt; 3; ++i) {
		for (int j = 0; j &lt; 3; ++j) {
			(c[j] += m[i][j] * a[i]) %= MOD;
		}
	}
	return c;
}

mat matPow(mat a, int64 p) {
	if (!p)
		return unit();
	if (p &amp; 1)
		return matPow(a, p - 1) * a;
	else
		return matPow(a * a, p &gt;&gt; 1);
}

int64 n;
int k;
const int MAX_K = 1000000 + 10;
int fib[MAX_K * 6];
int minInv[MAX_K];

int64 extGcd(int64 a, int64 b, int64&amp;x, int64&amp;y) {
	if (!b) {
		x = 1, y = 0;
		return a;
	}
	int64 d = extGcd(b, a % b, y, x);
	y -= x * (a / b);
	return d;
}

void readInput() {
	cin &gt;&gt; n &gt;&gt; k &gt;&gt; MOD;
}

mat nor, sub;

int64 work() {
	fill(minInv, minInv + k, INT_MAX);
	fib[1] = fib[2] = 1;
	for (int i = 3;; ++i) {
		fib[i] = (fib[i - 1] + fib[i - 2]) % k;
		int64 x, y;
		if (extGcd(fib[i], k, x, y) == 1) {
			//x*fib[i] = y*k+1
			x %= k;
			if (x &lt; 0)
				x += k;
			minInv[x] = min(minInv[x], i);
		}
		if (fib[i - 1] == 1 &amp;&amp; fib[i] == 1)
			break;
	}

	nor = zero();
	nor[2][2] = 1;
	nor[0][1] = 1;
	nor[1][1] = 1;
	nor[1][0] = 1;
	sub = nor;
	sub[2][0] = MOD - 1;
	sub[2][1] = MOD - 1;

	static int prev[MAX_K] = { };
	static int passed[MAX_K * 3];
	memset(prev, -1, sizeof prev);
	int cnt = 0;

	int cur = 1;
	int64 at = 1;
	mat m = unit();
	vec v(3, 1);
	bool done = false;
	for (;;) {
		if (prev[cur] != -1 &amp;&amp; !done) {
			int st = prev[cur];
			mat m = unit();
			int64 totalLen = 0;
			for (int j = st; j &lt; cnt; ++j) {
				int len = minInv[passed[j]];
				m = m * matPow(nor, len - 2) * sub * nor;
				totalLen += len;
			}
			int64 need = (n - at) / totalLen;
			v = v * matPow(m, need);
			at += need * totalLen;
			done = true;
		}
		if (!done) {
			prev[cur] = cnt;
			passed[cnt++] = cur;
		}

		int len = minInv[cur];
		if (len == INT_MAX || n - at &lt;= len - 2) {
			v = v * matPow(nor, n - at);
			return v[0];
		}
		if (n - at == len - 1) {
			v = v * matPow(nor, len - 2) * sub;
			return v[0];
		}
		at += len;
		v = v * matPow(nor, len - 2) * sub * nor;
		cur = 1LL * cur * fib[len - 1] % k;
	}
}

void solve() {
	readInput();
	cout &lt;&lt; work() &lt;&lt; endl;
}

int main() {
	solve();
	return 0;
}
</pre><pre></pre><h2>Problem2433</h2><pre>/*
 * 2433.cpp
 *
 *  Created on: 2011-8-20
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
			x(_x), y(_y) {
	}
	void read() {
		scanf("%lf%lf", &amp;x, &amp;y);
	}
	double distTo(const Point&amp;p) const {
		return hypot(x - p.x, y - p.y);
	}
	double alphaTo(const Point&amp;p) const {
		return atan2(p.y - y, p.x - x);
	}
};
const double EPS = 1e-8;
int compare(double a, double b) {
	return a &lt; b - EPS ? -1 : a &gt; b + EPS;
}

bool isMiddle(double a, double m, double b) {
	return compare(a, m) == 0 || compare(b, m) == 0 || (a &lt;= m &amp;&amp; m &lt;= b);
}

struct Rect {
	Point low, high;
	void read() {
		low.read();
		high.read();
	}
	bool hasPoint(Point p) {
		return isMiddle(low.x, p.x, high.x) &amp;&amp; isMiddle(low.y, p.y, high.y);
	}
};

const int MAX_N_RECTS = 2000 + 10;
int nRects;
Rect rects[MAX_N_RECTS];
Point start, target;
double speed;

void readInput() {
	cin &gt;&gt; nRects;
	for (int i = 0; i &lt; nRects; ++i) {
		rects[i].read();
	}
	start.read(), target.read();
	cin &gt;&gt; speed;
}

Point ps[MAX_N_RECTS][2];
double dist[MAX_N_RECTS][2];
double ans;

void updatePoint(Point p, int first, double d) {
	double left = -1e100, right = 1e100;
	for (int i = first; i &lt; nRects; ++i) {
		if (rects[i].hasPoint(target) &amp;&amp; isMiddle(left, p.alphaTo(target), right)) {
			ans = min(ans, d + p.distTo(target));
		}
		if (i == nRects - 1)
			break;
		for (int j = 0; j &lt; 2; ++j) {
			if (isMiddle(left, p.alphaTo(ps[i][j]), right))
				dist[i][j] = min(dist[i][j], d + p.distTo(ps[i][j]));
		}
		left = max(left, p.alphaTo(ps[i][0]));
		right = min(right, p.alphaTo(ps[i][1]));
		if (compare(left, right) == 1)
			break;
	}
}

void work() {
	fill(dist[0], dist[nRects], 1e100);
	ans = 1e100;
	if (start.x &gt; target.x)
		swap(start, target);
	for (int i = 0; i + 1 &lt; nRects; ++i) {
		Rect&amp;r = rects[i], &amp;nr = rects[i + 1];
		double x = r.high.x;
		ps[i][0] = Point(x, max(r.low.y, nr.low.y));
		ps[i][1] = Point(x, min(r.high.y, nr.high.y));
	}
	int startAt = 0;
	for (int i = nRects - 1; i &gt;= 0; --i) {
		if (rects[i].hasPoint(start)) {
			startAt = i;
			break;
		}
	}
	updatePoint(start, startAt, 0);
	for (int i = startAt; i &lt; nRects - 1; ++i) {
		for (int j = 0; j &lt; 2; ++j) {
			updatePoint(ps[i][j], i + 1, dist[i][j]);
		}
	}
	printf("%0.10lf\n", ans / speed);
}

void solve() {
	readInput();
	work();
}

int main() {
	solve();
	return 0;
}
</pre><pre></pre><h2>Problem2434</h2><pre>/*
 * 2434.cpp
 *
 *  Created on: 2011-8-17
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N = int(1e5) + 10;
char str[MAX_N];

struct Node;

struct Query {
	Node*a, *b;
	int ans;
};

struct TA {
	int a[MAX_N], n;
	void init(int _n) {
		n = _n;
		memset(a, 0, sizeof(int) * n);
	}
	void add(int p, int x) {
		for (p++; p &lt;= n; p += p &amp; -p)
			a[p - 1] += x;
	}
	int sum(int l, int r) {
		if (l &gt; 0)
			return sum(0, r) - sum(0, l - 1);
		int ret = 0;
		for (r++; r &gt; 0; r -= r &amp; -r)
			ret += a[r - 1];
		return ret;
	}
};

TA ta;

int cur;

struct Node {
	Node*ch[26], *par, *fail;
	Node(Node*_par) :
			par(_par) {
		memset(ch, 0, sizeof ch);
	}
	Node*go(int c) {
		if (ch[c] == 0)
			ch[c] = new Node(this);
		return ch[c];
	}
	vector&lt;Node*&gt; failCh;
	vector&lt;Query*&gt; queries;

	int left, right;
	void dfsWithFail() {
		left = cur++;
		foreach(e,failCh)
			(*e)-&gt;dfsWithFail();
		right = cur - 1;
	}

	void dfsCalc() {
		ta.add(left, 1);
		foreach(e,queries) {
			Query*q = *e;
			q-&gt;ans = ta.sum(q-&gt;a-&gt;left, q-&gt;a-&gt;right);
		}
		for (int c = 0; c &lt; 26; ++c) {
			if (ch[c] != 0)
				ch[c]-&gt;dfsCalc();
		}
		ta.add(left, -1);
	}
};
Node*strs[MAX_N];
int n, nQueries;
Node*root;
Query queries[MAX_N];

void readInput() {
	scanf("%s", str);
	n = 0;
	root = new Node(0);
	Node*cur = root;
	for (char*c = str; *c; c++)
		if (*c == 'P')
			strs[n++] = cur;
		else if (*c == 'B')
			cur = cur-&gt;par;
		else
			cur = cur-&gt;go(*c - 'a');
	scanf("%d", &amp;nQueries);
	for (int i = 0; i &lt; nQueries; ++i) {
		Query*q = queries + i;
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		q-&gt;a = strs[--a], q-&gt;b = strs[--b];
		q-&gt;b-&gt;queries.push_back(q);
	}
}

Node*que[MAX_N];
void work() {
	int qh = 0, qt = 0;
	que[qt++] = root;
	root-&gt;fail = 0;
	for (; qh &lt; qt;) {
		Node*u = que[qh++];
		for (int c = 0; c &lt; 26; ++c) {
			Node*ch = u-&gt;ch[c];
			if (ch == 0)
				continue;
			Node*f = u-&gt;fail;
			while (f != 0 &amp;&amp; f-&gt;ch[c] == 0)
				f = f-&gt;fail;
			if (f == 0)
				ch-&gt;fail = root;
			else
				ch-&gt;fail = f-&gt;ch[c];
			ch-&gt;fail-&gt;failCh.push_back(ch);
			que[qt++] = ch;
		}
	}

	cur = 0;
	root-&gt;dfsWithFail();
	ta.init(cur);
	root-&gt;dfsCalc();
	for (int i = 0; i &lt; nQueries; ++i) {
		printf("%d\n", queries[i].ans);
	}
}

void solve() {
	readInput();
	work();
}

int main() {
	solve();
	return 0;
}
</pre><pre></pre><h2>Problem2435</h2><pre>/*
 * 2435.cpp
 *
 *  Created on: 2011-8-16
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

inline void scanInt(int&amp;x) {
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
}

const int MAX_NV = int(1e6) + 10;
struct Edge {
	int t, c;
	Edge(int _t, int _c) :
			t(_t), c(_c) {
	}
};
vector&lt;Edge&gt; E[MAX_NV];
int nV;

int que[MAX_NV], fa[MAX_NV], size[MAX_NV], prev[MAX_NV];

int main() {
	scanInt(nV);
	for (int i = 0; i &lt; nV - 1; ++i) {
		int a, b, c;
		scanInt(a), scanInt(b), scanInt(c);
		--a, --b;
		E[a].push_back(Edge(b, c)), E[b].push_back(Edge(a, c));
	}

	int qh = 0, qt = 0;
	que[qt++] = 0;
	fa[0] = -1;
	for (; qh &lt; qt;) {
		int u = que[qh++];
		foreach (e,E[u])
			if (e-&gt;t != fa[u]) {
				fa[e-&gt;t] = u;
				que[qt++] = e-&gt;t;
				prev[e-&gt;t] = e-&gt;c;
			}
	}

	long long ans = 0;
	for (int i = nV - 1; i &gt;= 0; --i) {
		int u = que[i];
		size[u] = 1;
		foreach(e,E[u])
			if (e-&gt;t != fa[u])
				size[u] += size[e-&gt;t];
		if (fa[u] != -1)
			ans += 1LL * abs(nV - 2 * size[u]) * prev[u];
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2436</h2><pre>/*
 * 2436.cpp
 *
 *  Created on: 2011-8-16
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_N = 400 + 10;
const int INF = ~0U &gt;&gt; 2;

int nS;
int L[MAX_N], R[MAX_N];
int xs[MAX_N], nXs;
bool asL[MAX_N], asR[MAX_N];
int cnt[MAX_N][MAX_N];
int prev[MAX_N][MAX_N], next[MAX_N][MAX_N];
int ans[MAX_N][MAX_N];

int main() {
	cin &gt;&gt; nS;
	nXs = 0;
	for (int i = 0; i &lt; nS; ++i) {
		scanf("%d%d", L + i, R + i);
		R[i] += L[i];
		xs[nXs++] = L[i], xs[nXs++] = R[i];
	}
	sort(xs, xs + nXs);
	nXs = unique(xs, xs + nXs) - xs;
	for (int i = 0; i &lt; nS; ++i) {
		asL[lower_bound(xs, xs + nXs, L[i]) - xs] = true;
		asR[lower_bound(xs, xs + nXs, R[i]) - xs] = true;
	}
	for (int l = 0; l &lt; nXs; ++l)
		for (int r = l + 1; r &lt; nXs; ++r) {
			int tmp = 0;
			for (int i = 0; i &lt; nS; ++i) {
				if (L[i] &gt;= xs[l] &amp;&amp; R[i] &lt;= xs[r])
					++tmp;
			}
			cnt[l][r] = tmp;
		}

	fill(prev[0], prev[nXs], -INF);
	prev[0][0] = 0;
	for (int i = 1; i &lt; nXs; ++i)
		if (asR[i]) {
			for (int j = cnt[0][i]; j &gt;= 0; --j) {
				for (int k = 0; k &lt; i; ++k)
					if (!k || asR[k]) {
						int c = cnt[k][i];
						if (prev[k][j] != -INF)
							prev[i][j] = max(prev[i][j], prev[k][j] + c);
						if (j &gt;= c &amp;&amp; prev[k][j - c] != -INF)
							prev[i][j] = max(prev[i][j], prev[k][j - c]);
					}
				if (j + 1 &lt;= nS)
					prev[i][j] = max(prev[i][j], prev[i][j + 1]);
			}
		}

	fill(next[0], next[nXs], -INF);
	next[nXs - 1][0] = 0;
	for (int i = nXs - 2; i &gt;= 0; --i)
		if (asL[i]) {
			for (int j = cnt[i][nXs - 1]; j &gt;= 0; --j) {
				for (int k = i + 1; k &lt; nXs; ++k)
					if (k == nXs - 1 || asL[k]) {
						int c = cnt[i][k];
						if (next[k][j] != -INF)
							next[i][j] = max(next[i][j], next[k][j] + c);
						if (j &gt;= c &amp;&amp; next[k][j - c] != -INF)
							next[i][j] = max(next[i][j], next[k][j - c]);
					}
				if (j + 1 &lt;= nS)
					next[i][j] = max(next[i][j], next[i][j + 1]);
			}
		}
	for (int l = 0; l &lt; nXs; ++l)
		if (asL[l]) {
			for (int r = l + 1; r &lt; nXs; ++r)
				if (asR[r]) {
					int c = cnt[l][r];
					int al = l, ar = r;
					if (al &gt; 0 &amp;&amp; !asR[al])
						--al;
					if (ar &gt; 0 &amp;&amp; !asL[ar])
						++ar;
					int*P = prev[al], *N = next[ar];
					int b = cnt[ar][nXs - 1];
					int tmp = 0;
					int ma = cnt[0][al];
					for (int a = 0; a &lt;= ma; ++a) {
						while (b &gt; 0) {
							int cur = min(c + a + b, P[a] + N[b]);
							int ncur = min(c + a + (b - 1), P[a] + N[b - 1]);
							if (ncur &gt;= cur)
								--b;
							else
								break;
						}
						int cur = min(c + a + b, P[a] + N[b]);
						tmp = max(tmp, cur);
					}
					ans[l][r] = tmp;
				}
		}

	{
		int ans = 0;
		for (int i = 0; i &lt;= nS; ++i) {
			ans = max(ans, min(i, prev[nXs - 1][i]));
		}
		cout &lt;&lt; ans &lt;&lt; endl;
	}

	for (int i = 0; i &lt; nS; ++i) {
		int tmp = 0;
		for (int l = 0; l &lt; nXs; ++l)
			if (xs[l] &lt;= L[i] &amp;&amp; asL[l]) {
				for (int r = l + 1; r &lt; nXs; ++r)
					if (xs[r] &gt;= R[i] &amp;&amp; asR[r]) {
						tmp = max(tmp, ans[l][r]);
					}
			}
		cout &lt;&lt; tmp &lt;&lt; endl;
	}
	return 0;
}
</pre><pre></pre><h2>Problem2437</h2><pre>import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class V extends ArrayList&lt;V&gt; {
	V pair;
	int color;
	int visit = 0;
	static final int WHITE = 0, BLACK = 1, FORBID = 2;
	static int mark = 0;

	boolean dfs() {
		if (visit == mark || color == FORBID)
			return false;
		visit = mark;
		for (V v : this) {
			if (v.color == 1 - color &amp;&amp; (v.pair == null || v.pair.dfs())) {
				pair = v;
				v.pair = this;
				return true;
			}
		}
		return false;
	}

	void cancel() {
		if (pair != null) {
			pair.pair = null;
			pair = null;
		}
	}
}

public class Main {
	Scanner scan = new Scanner(System.in);

	static public void main(String[] args) {
		new Main().run();
	}

	void debug(Object o) {
		System.out.println(o);
	}

	V[][] mat;
	V[] vs;
	int k;
	int[][] moves;

	void run() {
		int n = scan.nextInt(), m = scan.nextInt();
		mat = new V[n][m];
		for (V[] a : mat)
			for (int i = 0; i &lt; a.length; i++) {
				a[i] = new V();
			}
		String[] map = new String[n];
		for (int i = 0; i &lt; n; i++) {
			map[i] = scan.next();
		}
		k = scan.nextInt();
		moves = new int[2 * k][2];
		for (int[] a : moves) {
			for (int i = 0; i &lt; 2; i++) {
				a[i] = scan.nextInt() - 1;
			}
		}

		int r = -1, c = -1, cnt = 0;
		vs = new V[n * m];
		for (int i = 0; i &lt; n; i++) {
			for (int j = 0; j &lt; m; j++) {
				vs[cnt++] = mat[i][j];
				if (i &gt; 0)
					mat[i][j].add(mat[i - 1][j]);
				if (i + 1 &lt; n)
					mat[i][j].add(mat[i + 1][j]);
				if (j &gt; 0)
					mat[i][j].add(mat[i][j - 1]);
				if (j + 1 &lt; m)
					mat[i][j].add(mat[i][j + 1]);

				mat[i][j].color = map[i].charAt(j) == 'O' ? V.WHITE : V.BLACK;
				if (map[i].charAt(j) == '.') {
					r = i;
					c = j;
				}
			}
		}

		boolean[] win = new boolean[2 * k + 1];
		for (int i = 0; i &lt; 2 * k; i++) {
			V st = mat[r][c];
			for (V v : vs)
				if (v.color == V.WHITE &amp;&amp; v.pair == null) {
					++V.mark;
					v.dfs();
				}
			if (st.pair != null) {
				st.cancel();
				int tmp = st.color;
				st.color = V.FORBID;
				boolean has = false;
				for (V v : vs)
					if (v.color == V.WHITE &amp;&amp; v.pair == null) {
						++V.mark;
						if (v.dfs()) {
							has = true;
							break;
						}
					}
				st.color = tmp;
				win[i] = !has;
			}
			int[] mv = moves[i];
			V nxt = mat[mv[0]][mv[1]];
			st.cancel();
			nxt.cancel();
			st.color = 1 - st.color;
			r = mv[0];
			c = mv[1];
		}
		win[2 * k] = true;

		List&lt;Integer&gt; mistakes = new ArrayList&lt;Integer&gt;();
		for (int i = 0; i &lt; win.length - 1; i += 2)
			if (win[i] &amp;&amp; win[i + 1])
				mistakes.add(i / 2 + 1);
		System.out.println(mistakes.size());
		for (int a : mistakes)
			System.out.println(a);
	}
}
</pre><pre></pre><h2>Problem2438</h2><pre>/*
 * 2438.cpp
 *
 *  Created on: 2011-8-17
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_NV = 100000 + 10;
vector&lt;int&gt; E[MAX_NV], RE[MAX_NV], CE[MAX_NV];
int nV, nC = 0;
int cnt[MAX_NV], ord[MAX_NV], comp[MAX_NV], pt = 0;
bool vis[MAX_NV];

void dfs(int u) {
	if (vis[u])
		return;
	vis[u] = true;
	foreach(e,E[u])
		dfs(*e);
	ord[pt++] = u;
}

void dfsrev(int u, int c) {
	if (comp[u] != -1)
		return;
	comp[u] = c;
	foreach(e,RE[u])
		dfsrev(*e, c);
}

int num[MAX_NV], by[MAX_NV];
void dfs2(int u, int st) {
	num[u]++;
	by[u] = st;
	if (num[u] &gt; 2)
		return;
	foreach(e,CE[u])
		dfs2(*e, st);
}
bool can[MAX_NV], cant[MAX_NV];

int main() {
	int nE;
	cin &gt;&gt; nV &gt;&gt; nE;
	for (int i = 0; i &lt; nE; ++i) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b), --a, --b;
		E[a].push_back(b), RE[b].push_back(a);
	}
	memset(comp, -1, sizeof comp);
	for (int i = 0; i &lt; nV; ++i) {
		if (!vis[i])
			dfs(i);
	}
	for (int i = pt - 1; i &gt;= 0; --i) {
		int u = ord[i];
		if (comp[u] == -1)
			dfsrev(u, nC++);
	}
	for (int i = 0; i &lt; nV; ++i) {
		cnt[comp[i]]++;
	}
	for (int i = 0; i &lt; nV; ++i) {
		foreach(e,E[i])
			if (comp[i] != comp[*e]) {
				CE[comp[i]].push_back(comp[*e]);
				cant[comp[*e]] = true;
			}
	}
	for (int i = 0; i &lt; nC; ++i) {
		if (!cant[i]) {
			can[i] = true;
			dfs2(i, i);
		}
	}
	for (int i = 0; i &lt; nC; ++i) {
		if (num[i] == 1 &amp;&amp; cant[i]) {
			can[by[i]] = false;
		}
	}
	int ans = 0;
	bool has = false;
	for (int i = 0; i &lt; nC; ++i) {
		if (!cant[i]) {
			ans++;
			if (can[i])
				has = true;
		}
	}
	if (ans &gt; 1 &amp;&amp; has)
		--ans;
	printf("%0.6lf\n", 1 - 1.0 * ans / nV);
	return 0;
}
</pre><pre></pre><h2>Problem2439</h2><pre>/*
 * 2439.cpp
 *
 *  Created on: 2011-8-17
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
typedef long long int64;

const int MAX_N = 1000000 + 10;
int a[MAX_N], n;
int64 L[MAX_N], R[MAX_N];

void doit(int64 dp[]) {
	static int h[MAX_N];
	a[n] = -1;
	for (int i = 0; i &lt; n; ++i) {
		h[i] = a[i + 1] - a[i];
	}
	static int value[MAX_N][2];

	for (int i = 0; i &lt; n; ++i) {
		value[i][0] = max(0, 1 - h[i]);
		value[i][1] = max(0, h[i] + 1);
	}
	int64 A = value[0][0], B = value[1][1];
	int sp = 1;
	dp[2] = max(A, B);

	for (int i = 3; i &lt; n; ++i) {
		B += value[i - 1][1];
		while (sp &lt; i - 1) {
			int64 nA = A + value[sp][0], nB = B - value[sp][1];
			int64 cur = max(A, B), ncur = max(nA, nB);
			if (ncur &lt;= cur) {
				A = nA, B = nB;
				++sp;
			} else
				break;
		}
		dp[i] = max(A, B);
	}
}

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", a + i);
	}
	doit(L);
	reverse(a, a + n);
	doit(R);
	reverse(R, R + n);
	int64 ans = LONG_LONG_MAX;
	for (int i = 2; i &lt; n - 2; ++i) {
		ans = min(ans, L[i] + R[i]);
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2440</h2><pre>/*
 * 2440.cpp
 *
 *  Created on: 2011-8-17
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_K = int(1e9) + 10;
const int MAX_PRIME = 45000;
int K;
bool is[MAX_PRIME];
int ps[MAX_PRIME];
int nPs;

void getPs() {
	fill(is, is + MAX_PRIME, true);
	for (int i = 2; i * i &lt; MAX_PRIME;) {
		for (int j = i + i; j &lt; MAX_PRIME; j += i)
			is[j] = false;
		++i;
		while (!is[i])
			++i;
	}
	nPs = 0;
	for (int i = 2; i &lt; MAX_PRIME; ++i) {
		if (is[i])
			ps[nPs++] = i * i;
	}
}

const int MAX_SAVE = 1000;
const int MAX_MEMO = 1000;
int memo[MAX_SAVE][MAX_MEMO];
int calc(int at, int r) {
	if (at == nPs) {
		return r;
	}
	if (r &lt; ps[at])
		return r;
	if (at &lt; MAX_SAVE &amp;&amp; r &lt; MAX_MEMO) {
		int&amp;ret = memo[at][r];
		if (ret != -1)
			return ret;
		return ret = calc(at + 1, r) - calc(at + 1, r / ps[at]);
	}
	return calc(at + 1, r) - calc(at + 1, r / ps[at]);
}

int main() {
	getPs();
	memset(memo, -1, sizeof memo);
	int T;
	cin &gt;&gt; T;
	while (T--) {
		int k;
		cin &gt;&gt; k;
		int l = 0, r = 2e9;
		while (l + 1 &lt; r) {
			int m = l + (r - l) / 2;
			if (calc(0, m) &gt;= k)
				r = m;
			else
				l = m;
		}
		cout &lt;&lt; r &lt;&lt; endl;
	}
	return 0;
}
</pre><pre></pre><h2>Problem2451</h2><pre>/*
 * Ural1695 Work for Robots.cpp
 *
 *  Created on: 2011-9-1
 *      Author: mac
 */

#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;climits&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;

const int MAX_N = 50;
const int MAX_HALF = 24;
typedef long long int64;

int cnt[1 &lt;&lt; MAX_HALF];
int nV, half;
int graph[MAX_N][2];

int64 ans;

void rec(int at, int can0, int can1) {
	if (cnt[can0] == 0)
		return;
	if (at == nV) {
		ans += cnt[can0];
		return;
	}
	if (can1 &gt;&gt; (at - half) &amp; 1) {
		rec(at + 1, can0 &amp; graph[at][0], can1 &amp; graph[at][1]);
	}
	rec(at + 1, can0, can1);
}

int main() {
	cin &gt;&gt; nV;
	half = min(nV / 2, MAX_HALF);

	bool canCheat = true;
	for (int i = 0; i &lt; nV; ++i) {
		for (int j = 0; j &lt; nV; ++j) {
			scanf(" ");
			char ch = getchar();
			graph[i][j &gt;= half] |= (ch - '0')
			        &lt;&lt; (j &lt; half ? j : j - half);
			if (i != j &amp;&amp; ch == '0')
				canCheat = false;
		}
	}
	if (canCheat) {
		cout &lt;&lt; (1LL &lt;&lt; nV) &lt;&lt; endl;
		return 0;
	}
	//	nV = 50;
//	half = min(nV / 2, MAX_HALF);
//	for (int i = 0; i &lt; nV; ++i) {
//		for (int j = 0; j &lt; nV; ++j) {
//			graph[i][j &gt;= half] |= 1 &lt;&lt; (j &lt; half ? j : j - half);
//		}
//	}
	cnt[0] = 1;
	for (int i = 1; i &lt; (1 &lt;&lt; half); ++i) {
		for (int j = 0; j &lt; half; ++j) {
			if (i &gt;&gt; j &amp; 1) {
				cnt[i] += cnt[i ^ (1 &lt;&lt; j)] + cnt[i &amp; graph[j][0]];
				break;
			}
		}
	}
	rec(half, (1 &lt;&lt; half) - 1, (1 &lt;&lt; (nV - half)) - 1);
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2456</h2><pre>/*
 * 2456.cpp
 *
 *  Created on: 2011-9-6
 *      Author: mac
 */
#include &lt;cstdio&gt;
using namespace std;

int main() {
	int n;
	scanf("%d", &amp;n);
	int a = 0, cnt = 0;
	for (int i = 0; i &lt; n; ++i) {
		int x;
		scanf("%d", &amp;x);
		if (!cnt) {
			a = x;
		}
		if (x == a)
			++cnt;
		else
			--cnt;
	}
	printf("%d\n", a);
	return 0;
}
</pre><pre></pre><h2>Problem2460</h2><pre>/*
 * 2460.cpp
 *
 *  Created on: 2011-9-6
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;utility&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N = 1000 + 10;
typedef long long int64;
pair&lt;int, int64&gt; a[MAX_N];
int n;
int64 ns[MAX_N];
int bs[MAX_N];
int m;

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; a[i].second &gt;&gt; a[i].first;
	}
	sort(a, a + n);
	reverse(a, a + n);
	m = 0;
	int ans = 0;
	for (int i = 0; i &lt; n; ++i) {
		int64 cur = a[i].second;
		for (int j = 0; j &lt; m; ++j) {
			if (cur &gt;&gt; bs[j] &amp; 1) {
				cur ^= ns[j];
			}
		}
		if (!cur)
			continue;
		int b;
		for (int j = 0;; ++j) {
			if (cur &gt;&gt; j &amp; 1) {
				b = j;
				break;
			}
		}
		ns[m] = cur;
		bs[m] = b;
		++m;
		ans += a[i].first;
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2463</h2><pre>/*
 * 2463.cpp
 *
 *  Created on: 2011-9-6
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

int main() {
	int n;
	while (cin &gt;&gt; n, n) {
		cout &lt;&lt; (n % 2 == 0 ? "Alice" : "Bob") &lt;&lt; endl;
	}
	return 0;
}
</pre><pre></pre><h2>Problem2466</h2><pre>/*
 * 2466.cpp
 *
 *  Created on: 2011-9-6
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N = 100 + 10;
vector&lt;int&gt; edge[MAX_N];
int nV;
int dp[MAX_N][2][2]; //used,lighted

void dfs(int u, int fa) {
	int nam[2][2], am[2][2];
	am[0][0] = 0;
	am[0][1] = INT_MAX / 4;
	am[1][0] = INT_MAX / 4;
	am[1][1] = 1;
	foreach(e,edge[u]) {
		if (*e != fa) {
			dfs(*e, u);
			int(*ch)[2] = dp[*e];
			fill(nam[0], nam[2], INT_MAX / 4);
			for (int used = 0; used &lt; 2; ++used) {
				for (int lighted = 0; lighted &lt; 2; ++lighted) {
					for (int cused = 0; cused &lt; 2; ++cused) {
						for (int clighted = 0; clighted &lt; 2; ++clighted) {
							if ((used ^ clighted) == 1) {
								nam[used][lighted ^ cused] = min(nam[used][lighted ^ cused], am[used][lighted] + ch[cused][clighted]);
							}
						}
					}
				}
			}
			memcpy(am, nam, sizeof am);
		}
	}
	memcpy(dp[u], am, sizeof am);
}

int main() {
	while (cin &gt;&gt; nV, nV) {
		for (int i = 1; i &lt;= nV; ++i) {
			edge[i].clear();
		}
		for (int i = 0; i &lt; nV - 1; ++i) {
			int a, b;
			cin &gt;&gt; a &gt;&gt; b;
			edge[a].push_back(b), edge[b].push_back(a);
		}
		dfs(1, -1);
		cout &lt;&lt; min(dp[1][0][1], dp[1][1][1]) &lt;&lt; endl;
	}
	return 0;
}
</pre><pre></pre><h2>Problem2467</h2><pre>/*
 * 2467.cpp
 *
 *  Created on: 2011-9-6
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

int main() {
	int T;
	cin &gt;&gt; T;
	for (int i = 0; i &lt; T; ++i) {
		int n;
		cin &gt;&gt; n;
		int ret = (n * 4) % 2007;
		for (int j = 0; j &lt; n - 1; ++j) {
			ret = ret * 5 % 2007;
		}
		cout &lt;&lt; ret &lt;&lt; endl;
	}
	return 0;
}
</pre><pre></pre><h2>Problem2471</h2><pre>/*
 * 2471.cpp
 *
 *  Created on: 2011-10-8
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

int n, m;

typedef long long int64;

int next[100], str[100], len, jump[100][10];

struct Result {
	int64 cnt;
	int state;
	Result() :
			cnt(0), state(0) {
	}
	bool operator&lt;(const Result&amp;r) const {
		return state == r.state ? cnt &lt; r.cnt : state &lt; r.state;
	}
	void append(const Result&amp;r) {
		cnt += r.cnt;
		state = r.state;
	}
	void append(int d) {
		state = jump[state][d];
		if (state == len) {
			cnt++;
		}
	}
};

int64 pow10[100];
map&lt;vector&lt;Result&gt;, Result&gt; memo[10][100];
int cnt;

Result eval(int prevState, int len, vector&lt;Result&gt; jump) {
	if (memo[prevState][len].count(jump))
		return memo[prevState][len][jump];
	Result&amp;ret = memo[prevState][len][jump];
	if (len == 0) {
		return ret = jump[prevState];
	}

	ret.state = prevState;
	for (int nextDigit = 0; nextDigit &lt; 10; ++nextDigit) {
		vector&lt;Result&gt; njump = jump;
		for (int i = 0; i &lt; njump.size(); ++i) {
			njump[i].append(nextDigit);
		}
		Result tmp = eval(ret.state, len - 1, njump);
		ret.append(tmp);
	}
	return ret;
}

int main() {
	pow10[0] = 1;
	for (int i = 1; i &lt; 100; ++i) {
		pow10[i] = pow10[i - 1] * 10;
	}
	while (cin &gt;&gt; n &gt;&gt; m, n &amp;&amp; m) {
		len = 0;
		int x = m;
		while (x || len == 0) {
			str[len++] = x % 10;
			x /= 10;
		}
		reverse(str, str + len);
		next[0] = -1;
		for (int i = 1; i &lt;= len; ++i) {
			int j = next[i - 1];
			while (j != -1 &amp;&amp; str[j] != str[i - 1])
				j = next[j];
			next[i] = j + 1;
		}
		//		copy(next, next + len + 1, ostream_iterator&lt;int&gt;(cout, " "));
//		cout &lt;&lt; endl;
		for (int i = 0; i &lt;= len; ++i) {
			for (int j = 0; j &lt; 10; ++j) {
				int x = i;
				if (x == len)
					x = next[x];
				while (x != -1 &amp;&amp; str[x] != j)
					x = next[x];
				jump[i][j] = x + 1;
			}
		}
		for (int i = 0; i &lt;= len; ++i) {
			for (int j = 0; j &lt;= n; ++j) {
				memo[i][j].clear();
			}
		}

		Result ans;
		for (int length = 0; length &lt; n; ++length) {
			for (int firstDigit = 1; firstDigit &lt; 10; ++firstDigit) {
				vector&lt;Result&gt; jump(len + 1);
				for (int i = 0; i &lt; jump.size(); ++i) {
					jump[i].state = i;
					jump[i].cnt = 0;
					jump[i].append(firstDigit);
				}
				Result ret = eval(ans.state, length, jump);
				ans.append(ret);
			}
		}
		cout &lt;&lt; ans.cnt &lt;&lt; endl;
	}
	return 0;
}
</pre><pre></pre><h2>Problem2486</h2><pre>/*
 * 12297.cpp
 *
 *  Created on: 2011-9-26
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MOD = int(1e9) + 9;
int ans;
int N, K;

int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}

typedef long long int64;

int powMod(int x, int e) {
	if (!e)
		return 1;
	return (e &amp; 1) ? 1LL * powMod(x, e - 1) * x % MOD : powMod(1LL * x * x % MOD, e &gt;&gt; 1);
}

int inv(int x) {
	return powMod(x, MOD - 2);
}

int comb(int n, int m) {
	int64 ret = 1;
	for (int i = 0; i &lt; m; ++i) {
		ret = ret * (n - i) % MOD;
		ret = ret * inv(i + 1) % MOD;
	}
	return ret;
}

map&lt;int64, int&gt; calcMemo;

int calc(vector&lt;int&gt; a) {
	int64 s = 1;
	for (int i = 0; i &lt; a.size(); ++i) {
		s &lt;&lt;= 4;
		s += a[i];
	}
	if (calcMemo.count(s))
		return calcMemo[s];
	int&amp;ret = calcMemo[s];
	int N = ::N;
	int W = 1;
	for (vector&lt;int&gt;::iterator e = a.begin(); e != a.end(); ++e) {
		W = W * (*e) / gcd(W, *e);
		N -= *e;
	}
	if (N &lt; 0)
		return ret = 0;
	int n = a.size();

	vector&lt;int&gt; am(n * W, 0);
	am[0] = 1;
	for (vector&lt;int&gt;::iterator it = a.begin(); it != a.end(); ++it) {
		int&amp;w = *it;
		vector&lt;int&gt; nam(am.size(), 0);
		for (int i = 0; i &lt; W / w; ++i) {
			int c = i * w;
			for (int j = 0; j + c &lt; n * W; ++j) {
				nam[j + c] += am[j];
				if (nam[j + c] &gt;= MOD)
					nam[j + c] -= MOD;
			}
		}
		am = nam;
	}

	int x = N / W, y = N % W;
	ret = 0;
	for (int i = 0; i &lt; n; ++i) {
		ret += 1LL * comb(n + x - i - 1, n - 1) * am[i * W + y] % MOD;
		if (ret &gt;= MOD)
			ret -= MOD;
	}

	return ret;
}

map&lt;vector&lt;int&gt;, int&gt; memo;
int eval(vector&lt;int&gt; a) {
	sort(a.begin(), a.end());
	if (memo.count(a))
		return memo[a];
	int&amp;ret = memo[a] = 0;

	map&lt;vector&lt;int&gt;, int&gt; cur, next;
	cur[vector&lt;int&gt;()] = 1;

	for (int i = 0; i &lt; a.size(); ++i) {
		next.clear();
		for (map&lt;vector&lt;int&gt;, int&gt;::iterator it = cur.begin(); it != cur.end(); ++it) {
			vector&lt;int&gt; v = it-&gt;first;
			int cnt = it-&gt;second;

			for (int j = 0; j &lt; v.size(); ++j) {
				vector&lt;int&gt; nv = v;
				nv[j] += a[i];
				sort(nv.begin(), nv.end());
				int&amp;t = next[nv];
				t += cnt;
				if (t &gt;= MOD)
					t -= MOD;
			}

			vector&lt;int&gt; nv = v;
			nv.push_back(a[i]);
			sort(nv.begin(), nv.end());
			int&amp;t = next[nv];
			t += cnt;
			if (t &gt;= MOD)
				t -= MOD;
		}
		cur = next;
	}

	ret = calc(a);
	for (map&lt;vector&lt;int&gt;, int&gt;::iterator it = cur.begin(); it != cur.end(); ++it) {
		if (it-&gt;first.size() &lt; a.size()) {
			ret = (ret + MOD - 1LL * eval(it-&gt;first) * it-&gt;second % MOD) % MOD;
		}
	}

	return ret;
}

void rec(vector&lt;int&gt; a, int rem, int last, int mult) {
	if (!a.empty()) {
		int64 by = 1LL * eval(a) * mult % MOD;
		for (int i = 1; i &lt;= 4; ++i) {
			int c = count(a.begin(), a.end(), i);
			for (int j = 1; j &lt;= c; ++j) {
				by = by * inv(j) % MOD;
			}
		}
		ans += by;
		if (ans &gt;= MOD)
			ans -= MOD;
	}
	for (int i = last; i &lt;= min(4, rem); ++i) {
		vector&lt;int&gt; b = a;
		b.push_back(i);
		rec(b, rem - i, i, 1LL * mult * comb(4, i) % MOD);
	}
}

int64 rec(int sum, int cur, int rem) {
	if (sum == 0)
		return 1;
	if (sum &lt; 0)
		return 0;
	if (cur &gt; sum)
		return 0;

	int64 ret = 0;
	for (int nUse = 0; nUse &lt;= min(4, rem); ++nUse) {
		ret += rec(sum - nUse * cur, cur + 1, rem - nUse) * comb(4, nUse);
	}
	return ret;
}

int work() {
	calcMemo.clear();
	ans = 0;
	memo.clear();
	rec(vector&lt;int&gt;(), K, 1, 1);
	return ans;
}

int bfWork() {
	return rec(N, 1, K);
}

int main() {
	while (cin &gt;&gt; N &gt;&gt; K, N) {
		cout &lt;&lt; work() &lt;&lt; endl;
	}
	return 0;
}
</pre><pre></pre><h2>Problem2500</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;deque&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
#define FORE(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
const int MAX_N=1000000+10;
typedef long long int64;
int fa[MAX_N],cst[MAX_N],n,m;
vector&lt;int&gt; ch[MAX_N];
int que[MAX_N],qh,qt;
int64 mxcst[MAX_N][2],mxup[MAX_N];
void upd(int64 a[],int64 x){
	if(x&gt;a[1]){
		a[1]=x;
		if(a[1]&gt;a[0])
			swap(a[1],a[0]);
	}
}
int64 get(int64 a[],int64 x){
	return a[0]==x?a[1]:a[0];
}
int64 mx[MAX_N];
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;n;++i)
		scanf("%d%d",fa+i,cst+i),--fa[i],ch[fa[i]].push_back(i);
	qh=qt=0;
	que[qt++]=0;
	while(qh&lt;qt){
		int u=que[qh++];
		FORE(e,ch[u])
			que[qt++]=*e;
	}
	for(int i=n-1;i&gt;=0;--i){
		int u=que[i];
		FORE(e,ch[u])
			upd(mxcst[u],mxcst[*e][0]+cst[*e]);
	}
	for(int i=1;i&lt;n;++i){
		int u=que[i],f=fa[u];
		mxup[u]=max(mxup[f],get(mxcst[f],mxcst[u][0]+cst[u]))+cst[u];
	}
	REP(i,n)mx[i]=max(mxup[i],mxcst[i][0]);
	deque&lt;int&gt; q1,q2;
	int L=0,ans=0;
	REP(i,n){
		while(!q1.empty()&amp;&amp;mx[i]&lt;=mx[q1.back()])
			q1.pop_back();
		q1.push_back(i);
		while(!q2.empty()&amp;&amp;mx[i]&gt;=mx[q2.back()])
			q2.pop_back();
		q2.push_back(i);
		while(mx[q1.front()]+m&lt;mx[q2.front()]){
			if(q1.front()==L)
				q1.pop_front();
			if(q2.front()==L)
				q2.pop_front();
			++L;
		}
		ans=max(ans,i-L+1);
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem2501</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N=50000+10;
int a[MAX_N],b[MAX_N],n;
int d[MAX_N*2],c[MAX_N*2];
int main(){
	cin&gt;&gt;n;
	REP(i,n)scanf("%d%d",a+i,b+i),++b[i],d[i*2]=a[i],d[i*2+1]=b[i];
	sort(d,d+2*n);
	REP(i,n)c[lower_bound(d,d+2*n,a[i])-d]++,c[lower_bound(d,d+2*n,b[i])-d]--;
	REP(i,2*n)c[i+1]+=c[i];
	printf("%d\n",*max_element(c,c+2*n+1));
}</pre><pre></pre><h2>Problem2502</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N=100+10;
const int INF=20000,MXINT=~0U&gt;&gt;2;
//minCostFlow
struct Edge{
	int t,f,c;
	Edge*n,*r;
	Edge(int t,int f,int c,Edge*n){
		this-&gt;t=t;this-&gt;f=f;this-&gt;c=c;this-&gt;n=n;
	}
}*E[MAX_N]={};
void addE(int s,int t,int f,int c){
	E[s]=new Edge(t,f,c,E[s]);
	E[t]=new Edge(s,0,-c,E[t]);
	E[s]-&gt;r=E[t];E[t]-&gt;r=E[s];
}
int n,S,T,S2,V;
int que[MAX_N*MAX_N];
int dist[MAX_N];
bool inq[MAX_N];
Edge*pe[MAX_N];
int mxcst,flw=0;
void mcfw(){
	mxcst=0;
	for(;;){
		fill(dist,dist+V,MXINT);
		dist[S]=0;int qh=0,qt=0;
		que[qt++]=S;inq[S]=true;
		while(qh&lt;qt){
			int u=que[qh++];inq[u]=false;
			for(Edge*e=E[u];e;e=e-&gt;n)
				if(e-&gt;f)
					if(dist[u]+e-&gt;c &lt; dist[e-&gt;t]){
						dist[e-&gt;t]=dist[u]+e-&gt;c;
						pe[e-&gt;t]=e;
						if(!inq[e-&gt;t])
							inq[e-&gt;t]=true,que[qt++]=e-&gt;t;
					}
		}
		if(dist[T]==MXINT)
			return;
		int by=MXINT;
		int u=T;
		while(u!=S)
			by=min(by,pe[u]-&gt;f),u=pe[u]-&gt;r-&gt;t;
		mxcst+=by*dist[T];flw+=by;
		u=T;
		while(u!=S){
			Edge*p=pe[u];
			p-&gt;f-=by;p-&gt;r-&gt;f+=by;
			u=p-&gt;r-&gt;t;
		}
	}
}
int main(){
	cin&gt;&gt;n;V=n;S=V++;T=V++;S2=V++;
	addE(S,S2,INF,0);
	addE(S2,T,INF,0);
	int nE=0;
	REP(i,n){
		int c;cin&gt;&gt;c;
		REP(j,c){
			int x;cin&gt;&gt;x;--x;
			++nE;
			addE(i,x,1,-INF);
			addE(i,x,INF,0);
		}
		addE(S2,i,INF,1);
		addE(i,T,INF,0);
	}
	mcfw();
	cout&lt;&lt;mxcst+nE*INF&lt;&lt;endl;
}</pre><pre></pre><h2>Problem2506</h2><pre>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {

	BufferedReader reader;
	StringTokenizer tokenizer;
	PrintWriter writer;

	void run() {
		try {
			reader = new BufferedReader(new InputStreamReader(System.in));
			tokenizer = null;
			writer = new PrintWriter(System.out);
			solve();
			reader.close();
			writer.close();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	String nextToken() throws IOException {
		while (tokenizer == null || !tokenizer.hasMoreTokens())
			tokenizer = new StringTokenizer(reader.readLine());
		return tokenizer.nextToken();
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}

	final int SQRT = 100 + 1;
	final int MAX_VALUE = 10000 + 1;

	private int count(int[] arr, int r) {// &lt;=r
		int left = -1, right = arr.length;
		while (left + 1 &lt; right) {
			int mid = (left + right) / 2;
			if (arr[mid] &lt;= r)
				left = mid;
			else
				right = mid;
		}
		return left + 1;
	}

	private int count(int[] arr, int l, int r) {
		return count(arr, r) - count(arr, l - 1);
	}

	void solve() throws IOException {
		int n = nextInt(), m = nextInt();
		int[] a = new int[n];
		for (int i = 0; i &lt; n; i++) {
			a[i] = nextInt();
		}
		int[] cnt = new int[MAX_VALUE];
		for (int i : a) {
			cnt[i]++;
		}

		int[][] byValue = new int[MAX_VALUE][];
		for (int i = 0; i &lt; MAX_VALUE; i++) {
			byValue[i] = new int[cnt[i]];
		}

		Arrays.fill(cnt, 0);

		for (int i = 0; i &lt; n; i++) {
			byValue[a[i]][cnt[a[i]]++] = i;
		}

		int[][][] byMod = new int[SQRT][SQRT][];
		for (int i = 1; i &lt; SQRT; i++) {
			int[] num = new int[i];
			for (int j = 0; j &lt; n; j++) {
				num[a[j] % i]++;
			}
			int[][] cur = byMod[i];
			for (int j = 0; j &lt; i; j++) {
				cur[j] = new int[num[j]];
			}
			Arrays.fill(num, 0);
			for (int j = 0; j &lt; n; j++) {
				int id = a[j] % i;
				cur[id][num[id]++] = j;
			}
		}

		for (int i = 0; i &lt; m; i++) {
			int l = nextInt() - 1, r = nextInt() - 1, p = nextInt(), k = nextInt();
			int ret = 0;
			if (p &lt; SQRT)
				ret = count(byMod[p][k], l, r);
			else {
				for (int v = k; v &lt; MAX_VALUE; v += p)
					ret += count(byValue[v], l, r);
			}
			writer.println(ret);
		}
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		new Main().run();
	}

}
</pre><pre></pre><h2>Problem2510</h2><pre>/*
 * 2510.cpp
 *
 *  Created on: 2011-11-19
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
int n, m, k;

vector&lt;double&gt; operator*(const vector&lt;double&gt;&amp;a, const vector&lt;double&gt;&amp;b) {
	vector&lt;double&gt; c(n, 0);
	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; n; ++j) {
			c[(i + j) % n] += a[i] * b[j];
		}
	}
	return c;
}

vector&lt;double&gt; pow(const vector&lt;double&gt;&amp;a, int e) {
	if (!e) {
		vector&lt;double&gt; zero(n, 0);
		zero[0] = 1;
		return zero;
	}
	return e &amp; 1 ? pow(a, e - 1) * a : pow(a * a, e &gt;&gt; 1);
}

int main() {
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
	if (n == 1) {
		cout &lt;&lt; m &lt;&lt; endl;
		return 0;
	}

	vector&lt;double&gt; once(n, 0);
	once[1] = 1.0 / m;
	once[0] = 1 - once[1];

	vector&lt;double&gt; ret = pow(once, k);

	vector&lt;double&gt; ans(n, 0);
	for (int i = 0; i &lt; n; ++i) {
		int num;
		cin &gt;&gt; num;
		for (int j = 0; j &lt; n; ++j) {
			ans[(i + j) % n] += num * ret[j];
		}
	}

	for (int i = 0; i &lt; n; ++i) {
		printf("%0.3lf\n", ans[i]);
	}
	return 0;
}
</pre><pre></pre><h2>Problem2521</h2><pre>/**
 * Created by IntelliJ IDEA.
 * User: mac
 * Date: 11-12-17
 * Time: 下午7:28
 * To change this template use File | Settings | File Templates.
 */

import java.io.*;
import java.util.*;

public class Main {

    BufferedReader reader;
    StringTokenizer tokenizer;
    PrintWriter writer;

    void run() {
        try {
            reader = new BufferedReader(new InputStreamReader(System.in));
            tokenizer = null;
            writer = new PrintWriter(System.out);
            solve();
            reader.close();
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    String nextToken() throws IOException {
        while (tokenizer == null || !tokenizer.hasMoreTokens())
            tokenizer = new StringTokenizer(reader.readLine());
        return tokenizer.nextToken();
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    void solve() throws IOException {
        int n = nextInt(), m = nextInt(), lab = nextInt() - 1;
        int[] a = new int[m], b = new int[m], c = new int[m];
        for (int i = 0; i &lt; m; i++) {
            a[i] = nextInt() - 1;
            b[i] = nextInt() - 1;
            c[i] = nextInt();
        }

        Vertex[] vs = new Vertex[n];
        for (int i = 0; i &lt; n; i++) {
            vs[i] = new Vertex();
        }

        for (int i = 0; i &lt; m; i++) {
            if (c[i] &lt;= c[lab] &amp;&amp; i != lab) {
                vs[a[i]].addEdge(vs[b[i]], c[lab] + 1 - c[i]);
            }
        }

        writer.println(MaxFlowUtils.maxFlow(vs, vs[a[lab]], vs[b[lab]]));
    }

    static public void main(String[] args) {
        new Main().run();
    }
}


class Edge {
    Vertex t;
    Edge rev, next;
    int cap;

    Edge(Vertex t, int cap, Edge next) {
        this.t = t;
        this.cap = cap;
        this.next = next;
    }
}

class Vertex {
    Edge first, cur, prev;
    int am, height;

    Edge makeEdge(Vertex t, int cap) {
        return first = new Edge(t, cap, first);
    }

    Edge addEdge(Vertex t, int cap) {
        Edge ab = makeEdge(t, cap);
        Edge ba = t.makeEdge(this, cap);
        ab.rev = ba;
        ba.rev = ab;
        return ab;
    }

    Vertex() {
        vertexList.add(this);
    }

    static List&lt;Vertex&gt; vertexList = new ArrayList&lt;Vertex&gt;();
}

class MaxFlowUtils {
    static long maxFlow(Vertex[] vs, Vertex s, Vertex t) {
        int nV = vs.length;
        int[] cnt = new int[nV + 1];
        Vertex u = s;
        Edge e = null;
        for (Vertex v : vs) {
            v.height = 0;
        }
        cnt[0] = nV;
        u.am = Integer.MAX_VALUE;

        long flow = 0;

        while (s.height &lt; nV) {
            for (e = u.cur; e != null; e = e.next)
                if (e.cap &gt; 0 &amp;&amp; e.t.height + 1 == u.height)
                    break;
            if (e != null) {
                Vertex v = e.t;
                v.prev = u.cur = e;
                v.am = Math.min(u.am, e.cap);

                u = v;
                if (u == t) {
                    int by = u.am;
                    flow += by;
                    while (u != s) {
                        Edge p = u.prev;
                        p.cap -= by;
                        p.rev.cap += by;
                        u = p.rev.t;
                    }
                }
            } else {
                if ((--cnt[u.height]) == 0)
                    break;
                u.height = nV;
                for (e = u.first; e != null; e = e.next)
                    if (e.cap &gt; 0 &amp;&amp; e.t.height + 1 &lt; u.height) {
                        u.height = e.t.height + 1;
                        u.cur = e;
                    }
                ++cnt[u.height];
                if (u != s)
                    u = u.prev.rev.t;
            }
        }

        return flow;
    }
}
</pre><pre></pre><h2>Problem2525</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int N=int(3e5)+10;
int hv[N],e[N],nx[N*2],t[N*2],q[N],fa[N],rt[N],tp[N],cr=0;
int n,m;
int ni(){int x;scanf("%d",&amp;x);return x;}
int main(){
	n=ni(),m=ni();REP(i,n)hv[i]=ni(),e[i]=-1;
	REP(i,n-1){
		int a=ni()-1,b=ni()-1;
		nx[cr]=e[a],t[cr]=b,e[a]=cr;++cr;
		nx[cr]=e[b],t[cr]=a,e[b]=cr;++cr;
	}
	int qh=0,qt=0;q[qt++]=0;fa[0]=-1;
	while(qh&lt;qt){int u=q[qh++];for(int i=e[u];i!=-1;i=nx[i]){if(t[i]!=fa[u])q[qt++]=t[i],fa[t[i]]=u;}}
	int l=-1,r=n;
	while(l+1&lt;r){
		int x=l+r&gt;&gt;1;
		int nd=0;
		REP(i,n){
			int u=q[n-1-i],v;
			int mx=-1,mi=hv[u]?0:-1;
			for(int j=e[u];j!=-1;j=nx[j])if((v=t[j])!=fa[u]){
				if(tp[v]==1)if(rt[v]-1&gt;mx)mx=rt[v]-1;
				if(tp[v]==0)if(rt[v]+1&gt;mi)mi=rt[v]+1;
			}
			if(mx&gt;=mi){
				rt[u]=mx;tp[u]=1;
			} else if(u==0||mi==x){
				++nd;if(nd&gt;m)break;
				rt[u]=x;tp[u]=1;
			} else {
				tp[u]=0;rt[u]=mi;
			}
		}
		if(nd&lt;=m)r=x;else l=x;
	}
	printf("%d\n",r);
}</pre><pre></pre><h2>Problem2526</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
#define TR(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
typedef long long ll;
const int N = int(1e6)+10;
inline int ni(){
	char ch;for(;;){ch=getchar();if(ch&gt;='0'&amp;&amp;ch&lt;='9')break;}
	int r=ch-'0';for(;;){ch=getchar();if(ch&lt;'0'||ch&gt;'9')break;r=r*10+ch-'0';}
	return r;
}
inline void pt(ll x){
	static char b[30];if(!x){puts("0");return;}
	int p=0;while(x)b[p++]=x%10,x/=10;
	while(p&gt;0)putchar(b[--p]+'0');
	putchar('\n');
}
inline void cmx(int&amp;x,int c){if(c&gt;x)x=c;}
int n;
vector&lt;int&gt; E[N];
int md[N][2],cd[N],mu[N],q[N],fa[N];
ll sd[N],su[N];
int main(){
	n=ni();
	REP(i,n-1){int a=ni()-1,b=ni()-1;E[a].push_back(b);E[b].push_back(a);}
	int h=0,t=0;
	q[t++]=0;fa[0]=-1;
	while(h&lt;t){
		int u=q[h++];
		TR(e,E[u])if(*e!=fa[u])
			fa[*e]=u,q[t++]=*e;
	}
	for(int i=n-1;i&gt;=0;--i){
		int u=q[i];
		int*a=md[u];
		cd[u]=1;
		static int v[N];int c=0;
		v[c++]=0;
		TR(e,E[u])if(*e!=fa[u]){
			v[c++]=md[*e][0]+1;
			cd[u]+=cd[*e];
			sd[u]+=sd[*e]+cd[*e];
		}
		while(c&lt;2)v[c++]=-1;
		swap(*max_element(v,v+c),*v);
		swap(*max_element(v+1,v+c),*(v+1));
		a[0]=v[0],a[1]=v[1];
	}
	REP(i,n){
		int u=q[i];
		int*a=md[u];
		TR(e,E[u])if(*e!=fa[u]){
			cmx(mu[*e],mu[u]+1);cmx(mu[*e],(md[*e][0]+1==a[0]?a[1]:a[0])+1);
			su[*e]+=su[u]+(sd[u]-sd[*e]-cd[*e])+(n-cd[*e]);
		}
	}
	REP(u,n){
		static int a[N],b[N];
		int c=0;ll r=sd[u];
		if(fa[u]!=-1)a[c]=mu[u],b[c++]=n-cd[u],r+=su[u];r*=2;
		TR(e,E[u])if(*e!=fa[u])a[c]=md[*e][0]+1,b[c++]=cd[*e];
		int mx=max_element(b,b+c)-b;
		if(b[mx]*2-1&gt;n-1){puts("-1");continue;}
		if(b[mx]*2-1==n-1)r-=a[mx];
		else r-=*max_element(a,a+c);
		pt(r);
	}
}</pre><pre></pre><h2>Problem2527</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int N = 3e5+10;
int ni(){int x;scanf("%d",&amp;x);return x;}
int n,m,nd[N],k,l[N],r[N],a[N],ans[N];
vector&lt;int&gt; my[N];
typedef long long ll;
ll c[N];
void ad(int p,int x){for(p++;p&lt;=m;p+=p&amp;-p)c[p-1]+=x;}
ll gt(int p){ll r=0;for(p++;p&gt;0;p-=p&amp;-p)r+=c[p-1];return r;}
void rec(int L,int R,int*w,int t){
	if(L+1==R){REP(j,t)ans[w[j]]=L;return;}
	int M=L+R&gt;&gt;1;
	#define rx(x) for(int i=L;i&lt;M;++i)if(l[i]&lt;=r[i])ad(l[i],x),ad(r[i]+1,-x);else ad(l[i],x),ad(0,x),ad(r[i]+1,-x);
	rx(a[i]);int p=0;
	REP(i,t){int e=w[i];ll E=nd[e];REP(j,my[e].size()){E-=gt(my[e][j]);if(E&lt;0)break;};if(E&lt;=0){int t=w[p];w[p++]=w[i];w[i]=t;}else nd[e]=E;}
	rx(-a[i]);rec(L,M,w,p);rec(M,R,w+p,t-p);
}
int main(){
	n=ni(),m=ni();REP(i,m)my[ni()-1].push_back(i);
	REP(i,n)nd[i]=ni();
	k=ni();REP(i,k)l[i]=ni()-1,r[i]=ni()-1,a[i]=ni();
	int w[N];REP(i,n)w[i]=i;rec(0,k+1,w,n);
	REP(i,n)if(ans[i]==k)puts("NIE");else printf("%d\n",ans[i]+1);
}</pre><pre></pre><h2>Problem2528</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int SD = 13331,N=(int)2e5+10;
int hs[N],pw[N],n;
char st[N];
int np,ps[N];
int gt(int l,int r){return hs[r+1]-hs[l]*pw[r-l+1];}
#define prp(x,n) hs[0]=0;REP(i,n)hs[i+1]=hs[i]*SD+x[i];
int ws[N*2];

int main(){
	pw[0]=1;REP(i,N)if(i)pw[i]=pw[i-1]*SD;
	int t;scanf("%d",&amp;t);
	REP(it,t){
		scanf("%s",st);n=strlen(st);
		np=0;prp(st,n);REP(i,n)if(gt(0,i)==gt(n-1-i,n-1))ps[np++]=i+1;
		int cr=n;
		if(ps[0]==1)ws[--cr]=0;else{ws[--cr]=1;REP(i,ps[0]-1)ws[--cr]=0;}
		REP(i,np)if(i){
			int t = ps[i]-2*ps[i-1];
			if(t&lt;=0){
				int nc=ps[i]-ps[i-1],oc=cr+nc;
				REP(i,nc)ws[--cr]=ws[--oc];
			} else {
				REP(j,t)ws[n+j]=0;
				int*s=ws+cr,nn=n-cr+t;prp(s,nn);
				int ck=0;
				REP(j,nn)if(j&amp;&amp;gt(0,nn-1-j)==gt(j,nn-1)&amp;&amp;nn%j==0){ck=1;break;}
				int on=n-cr;ws[--cr]=ck;REP(j,t-1)ws[--cr]=0;REP(j,on)ws[--cr]=ws[n-1-j];
			}
		}
		REP(i,n-cr)printf("%d",ws[i]);puts("");
	}
}</pre><pre></pre><h2>Problem2529</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
int ni(){int x;scanf("%d",&amp;x);return x;}
struct B{int l,c;bool operator&lt;(B b)const{return l&lt;b.l;}};
const int N = 1e6+1;
B b[N],l[N][3],r[N][3];
int n;

bool ok(int a,int b,int c){return a!=b&amp;&amp;a!=c&amp;&amp;b!=c;}

int main(){
	int k=ni();REP(c,k){int m=ni();REP(i,m)b[n++]=(B){ni(),c};}
	sort(b,b+n);
	REP(i,3)l[0][i]=(B){-1,-1};l[0][0]=b[0];
	REP(i,n)if(i){
		B a[4];REP(j,3)a[j]=l[i-1][j];a[3]=(B){-1,-1};
		bool hd=0;
		REP(j,3)if(a[j].c==b[i].c){if(b[i].l&gt;a[j].l)a[j]=b[i];hd=1;break;}
		if(!hd)a[3]=b[i];sort(a,a+4);reverse(a,a+4);REP(j,3)l[i][j]=a[j];
	}
	REP(i,3)r[n-1][i]=(B){2e9,-1};r[n-1][0]=b[n-1];
	for(int i=n-2;i&gt;=0;--i){
		B a[4];REP(j,3)a[j]=r[i+1][j];a[3]=(B){2e9,-1};
		bool hd=0;REP(j,3)if(a[j].c==b[i].c){if(b[i].l&lt;a[j].l)a[j]=b[i];hd=1;break;}
		if(!hd)a[3]=b[i];sort(a,a+4);REP(j,3)r[i][j]=a[j];
	}
	REP(i,n-1)if(i){
		B*a=l[i-1],*b=r[i+1];
		REP(p,3)if(a[p].c!=-1)REP(q,3)if(b[q].c!=-1){
			if(a[p].l+::b[i].l&gt;b[q].l&amp;&amp;ok(a[p].c,::b[i].c,b[q].c)){
				printf("%d %d %d %d %d %d\n",a[p].c+1,a[p].l,::b[i].c+1,::b[i].l,b[q].c+1,b[q].l);
				return 0;
			}
		}
	}
	puts("NIE");
}</pre><pre></pre><h2>Problem2530</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
using namespace std;

bool E[3001][3001];
int nV, nE;

inline int nextInt() {
	int x = 0;
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
	return x;
}

bool del[3001];

int main() {
	nV = nextInt(), nE = nextInt();
	for (int i = 0; i &lt; nE; ++i) {
		int a = nextInt() - 1, b = nextInt() - 1;
		E[a][b] = true;
		E[b][a] = true;
	}
	for (int a = 0; a &lt; nV; ++a) {
		for (int b = 0; b &lt; a; ++b) {
			if (!del[a] &amp;&amp; !del[b] &amp;&amp; !E[a][b]) {
				del[a] = true;
				del[b] = true;
			}
		}
	}
	int rem = nV / 3;
	for (int i = 0; i &lt; nV; ++i) {
		if (!del[i]) {
			printf("%d ", i + 1);
			--rem;
			if (!rem)
				break;
		}
	}
	return 0;
}
</pre><pre></pre><h2>Problem2537</h2><pre>/**
 * Created by IntelliJ IDEA.
 * User: mac
 * Date: 11-12-17
 * Time: 下午7:23
 * To change this template use File | Settings | File Templates.
 */

import java.io.*;
import java.util.*;

public class Main {

    BufferedReader reader;
    StringTokenizer tokenizer;
    PrintWriter writer;

    void run() {
        try {
            reader = new BufferedReader(new InputStreamReader(System.in));
            tokenizer = null;
            writer = new PrintWriter(System.out);
            solve();
            reader.close();
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    String nextToken() throws IOException {
        while (tokenizer == null || !tokenizer.hasMoreTokens())
            tokenizer = new StringTokenizer(reader.readLine());
        return tokenizer.nextToken();
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    void solve() throws IOException {
        int n = nextInt();

        Map&lt;String, Set&lt;String&gt;&gt; byPrefix = new HashMap&lt;String, Set&lt;String&gt;&gt;();

        for (int i = 0; i &lt; n; i++) {
            String s = nextToken();
            for (int j = 0; j &lt;= s.length(); j++) {
                String prefix = s.substring(0, j);
                String suffix = s.substring(j);
                if (!byPrefix.containsKey(prefix))
                    byPrefix.put(prefix, new TreeSet&lt;String&gt;());
                byPrefix.get(prefix).add(suffix);
            }
        }

        Set&lt;List&lt;String&gt;&gt; set = new HashSet&lt;List&lt;String&gt;&gt;();
        for (Set&lt;String&gt; stringSet : byPrefix.values()) {
            set.add(new ArrayList&lt;String&gt;(stringSet));
        }

        writer.println(set.size());
    }

    static public void main(String[] args) {
        new Main().run();
    }
}
</pre><pre></pre><h2>Problem2540</h2><pre>/**
 * Created by IntelliJ IDEA.
 * User: mac
 * Date: 11-12-22
 * Time: 下午7:52
 * To change this template use File | Settings | File Templates.
 */

import java.io.*;
import java.util.*;

public class Main {

    BufferedReader reader;
    StringTokenizer tokenizer;
    PrintWriter writer;

    void run() {
        try {
            reader = new BufferedReader(new InputStreamReader(System.in));
            tokenizer = null;
            writer = new PrintWriter(System.out);
            solve();
            reader.close();
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    String nextToken() throws IOException {
        while (tokenizer == null || !tokenizer.hasMoreTokens())
            tokenizer = new StringTokenizer(reader.readLine());
        return tokenizer.nextToken();
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    int[] DAY_PER_MONTH;

    int calc(int month, int day) {
        int cnt = day;
        for (int i = 0; i &lt; month; i++) {
            cnt += DAY_PER_MONTH[i];
        }
        return cnt;
    }

    int nextDate() throws IOException {
        String[] parts = nextToken().split("[/]");
//        System.out.println(Arrays.toString(parts));
        return calc(Integer.parseInt(parts[0]) - 1, Integer.parseInt(parts[1]) - 1);
    }

    int kth;

    public static final int INF = Integer.MAX_VALUE / 4;

    class State {
        int[] costs = new int[kth + 1];
        int n = 0;

        State() {
            Arrays.fill(costs, -INF);
        }

        State shift(int offset) {
            int[] a = costs.clone();
            for (int i = 0; i &lt; n; i++) {
                a[i] += offset;
            }
            return new State(a, n);
        }

        void add(int x) {
            costs[n++] = x;
        }

        State(int[] costs, int n) {
            this.costs = costs;
            this.n = n;
        }

        public State clone() {
            return new State(costs.clone(), n);
        }
    }

    State merge(State a, State b, int shiftB) {
        int[] cost = new int[kth + 1];
        Arrays.fill(cost, -INF);
        int n = 0, ia = 0, ib = 0;

        while (n &lt; kth &amp;&amp; (ia &lt; a.n || ib &lt; b.n)) {
            int add;
            if (a.costs[ia] &gt; b.costs[ib] + shiftB)
                add = a.costs[ia++];
            else
                add = b.costs[ib++] + shiftB;
            if (n == 0 || add != cost[n - 1])
                cost[n++] = add;
        }

        return new State(cost, n);
    }

    void solve() throws IOException {
        kth = nextInt();
        int nCostumers = nextInt();
        int year = nextInt();

        DAY_PER_MONTH = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        if (year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0)) {
            DAY_PER_MONTH[1]++;
        }

        int nRequests = nextInt();
        int[] begin = new int[nRequests], end = new int[nRequests], id = new int[nRequests];
        int[] cost = new int[nRequests];

        for (int i = 0; i &lt; nRequests; i++) {
            begin[i] = nextDate();
            nextToken();
            end[i] = nextDate();
            id[i] = nextInt() - 1;
        }

        int[] myCost = new int[nCostumers];

        for (int i = 0; i &lt; nCostumers; i++) {
            myCost[i] = nextInt();
        }

        for (int i = 0; i &lt; nRequests; i++) {
            cost[i] = myCost[id[i]] * (end[i] - begin[i]);
        }

        int numDays = calc(11, 30) + 1;
        int[] first = new int[numDays];

        int[] numAt = new int[numDays];
        for (int i = 0; i &lt; nRequests; i++) {
            numAt[begin[i]]++;
            numAt[end[i]]--;
        }

        for (int i = 1; i &lt; numDays; i++) {
            numAt[i] += numAt[i - 1];
        }

        int[] sum = new int[numDays + 1];
        for (int i = 1; i &lt; sum.length; i++) {
            sum[i] = sum[i - 1] + numAt[i - 1];
        }

        Arrays.fill(first, -1);
        int[] next = new int[nRequests];

        for (int i = 0; i &lt; nRequests; i++) {
            next[i] = first[end[i]];
            first[end[i]] = i;
        }

        State[] dp = new State[numDays];
        dp[0] = new State();
        dp[0].add(0);

        for (int i = 1; i &lt; numDays; i++) {
            dp[i] = dp[i - 1].clone();
            for (int me = first[i]; me != -1; me = next[me]) {
                if (sum[end[me]] - sum[begin[me]] == end[me] - begin[me])
                    dp[i] = dp[begin[me]].shift(cost[me]);
                else dp[i] = merge(dp[i], dp[begin[me]], cost[me]);
            }
        }

        int result = dp[numDays - 1].costs[kth - 1];
//        writer.println(Arrays.toString(dp[numDays - 1].costs));
        if (result == -INF)
            result = -1;
        writer.println(result);
    }

    static public void main(String[] args) {
        new Main().run();
    }
}
</pre><pre></pre><h2>Problem2548</h2><pre>/*
 * t2.cpp
 *
 *  Created on: 2011-12-8
 *      Author: Administrator
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
const int MAX_N = 50 + 1;
const int MAX_TIME = 1000 + 10;
const int N_DIR = 4;
int bombRange, rayRadius;
int nRow, nCol;
const int NORTH = 0, EAST = 1, SOUTH = 2, WEST = 3;
int DX[4] = { -1, 0, 1, 0 }, DY[4] = { 0, 1, 0, -1 };
int getDir(char ch) {
    switch (ch) {
        case 'N':
            return NORTH;
        case 'E':
            return EAST;
        case 'S':
            return SOUTH;
        case 'W':
            return WEST;
    }
}
int getLeft(int dir) {
    return (dir + 3) % 4;
}
int getRight(int dir) {
    return (dir + 1) % 4;
}
bool edge[MAX_N][MAX_N][N_DIR];
inline int nextInt() {
    int a;
    scanf("%d", &amp;a);
    return a;
}
inline char nextChar() {
    scanf(" ");
    char ch;
    scanf("%c", &amp;ch);
    return ch;
}
const int MALE = 0, FEMALE = 1;
struct Mouse {
    int sleepTime;
    int growUpTime;
    int fuckTime;
    int sex;
    int cnt;
    int dir;
    Mouse(int sex, int dir) {
        this-&gt;sex = sex;
        this-&gt;dir = dir;
        sleepTime = 0;
        growUpTime = 0;
        fuckTime = -1;
        cnt = 0;
    }
};
vector&lt;Mouse*&gt; at[MAX_N][MAX_N];
int nWeapon, maxMouse;
const int BOMB = 1, RAY = 2, TIME_BOMB = 3, SEX_BOMB = 4;
struct Weapon {
    int when;
    int r, c;
    int type;
    Weapon(int r, int c, int when, int type) {
        this-&gt;r = r, this-&gt;c = c, this-&gt;when = when, this-&gt;type = type;
    }
};
vector&lt;Weapon&gt; weapons;
int Time;
void readInput() {
    cin &gt;&gt; bombRange &gt;&gt; rayRadius &gt;&gt; nRow &gt;&gt; nCol;
    for (int r = 0; r &lt; nRow; ++r) {
        for (int c = 0; c &lt; nCol; ++c) {
            int a = nextInt();
            for (int d = 0; d &lt; 4; ++d) {
                edge[r][c][d] = (a &gt;&gt; d &amp; 1);
            }
        }
    }
    int nMouse = nextInt();
    for (int i = 0; i &lt; nMouse; ++i) {
        int r = nextInt() - 1, c = nextInt() - 1;
        char dir = nextChar(), sex = nextChar();
        Mouse*m = new Mouse(sex == 'X' ? MALE : FEMALE, getDir(dir));
        at[r][c].push_back(m);
    }
    nWeapon = nextInt(), maxMouse = nextInt();
    weapons.clear();
    for (int i = 0; i &lt; nWeapon; ++i) {
        int type = nextInt(), when = nextInt(), r = nextInt() - 1, c = nextInt()
                - 1;
        weapons.push_back(Weapon(r, c, when, type));
    }
    Time = nextInt();
}
vector&lt;Mouse*&gt; nat[MAX_N][MAX_N];
int countMouse() {
    int ret = 0;
    for (int r = 0; r &lt; nRow; ++r) {
        for (int c = 0; c &lt; nCol; ++c) {
            ret += at[r][c].size();
        }
    }
    return ret;
}
int dist[MAX_N][MAX_N];
const int INF = 1 &lt;&lt; 29;
void genDist(int sr, int sc) {
    for (int r = 0; r &lt; nRow; ++r) {
        for (int c = 0; c &lt; nCol; ++c) {
            dist[r][c] = INF;
        }
    }
    for (int d = 0; d &lt; 4; ++d) {
        int r = sr, c = sc;
        for (int di = 0;; ++di) {
            dist[r][c] = di;
            if (!edge[r][c][d])
                break;
            r += DX[d], c += DY[d];
        }
    }
}
int work() {
    for (int curTime = 0; curTime &lt;= Time; ++curTime) {
        if (countMouse() &gt; maxMouse)
            return -1;
        //stimulate the wake up and grow up and fucking // for previous seconds
        if (curTime &gt; 0) {
            for (int r = 0; r &lt; nRow; ++r) {
                for (int c = 0; c &lt; nCol; ++c) {
                    vector&lt;Mouse*&gt;&amp;ms = at[r][c];
                    if (ms.empty())
                        continue;
                    for (vector&lt;Mouse*&gt;::iterator e = ms.begin(); e != ms.end();
                            ++e) {
                        Mouse*m = *e;
                        if (m-&gt;sleepTime &gt; 0) {
                            --m-&gt;sleepTime;
                        } else if (m-&gt;growUpTime &gt; 0) {
                            --m-&gt;growUpTime;
//                          if (m-&gt;growUpTime == 0)
//                              cout &lt;&lt; curTime &lt;&lt; ":" &lt;&lt; "Up!" &lt;&lt; endl;
                        } else if (m-&gt;fuckTime &gt; 0) {
                            --m-&gt;fuckTime;
                        }
                    }
                }
            }
        }
        //stimulate the weapons
//      cout &lt;&lt; curTime &lt;&lt; ":" &lt;&lt; countMouse() &lt;&lt; endl;
        for (int i = 0; i &lt; weapons.size(); ++i) {
            Weapon w = weapons[i];
            if (w.type == RAY) {
                if (w.when != curTime)
                    continue;
                for (int r = 0; r &lt; nRow; ++r) {
                    for (int c = 0; c &lt; nCol; ++c) {
                        if (at[r][c].empty())
                            continue;
                        int dx = r - w.r, dy = c - w.c;
                        int di = dx * dx + dy * dy;
                        if (di &lt;= rayRadius * rayRadius) {
                            vector&lt;Mouse*&gt;&amp; ms = at[r][c];
                            for (vector&lt;Mouse*&gt;::iterator e = ms.begin();
                                    e != ms.end(); ++e) {
                                Mouse*m = *e;
                                m-&gt;sleepTime += 3;
                            }
                        }
                    }
                }
            } else if (w.type == BOMB) {
                if (w.when != curTime)
                    continue;
                genDist(w.r, w.c);
                for (int r = 0; r &lt; nRow; ++r) {
                    for (int c = 0; c &lt; nCol; ++c) {
                        if (at[r][c].empty())
                            continue;
                        if (dist[r][c] &lt;= bombRange) {
                            vector&lt;Mouse*&gt;&amp; ms = at[r][c];
                            ms.clear(); //kill them all
                        }
                    }
                }
            } else if (w.type == TIME_BOMB) {
                if (w.when != curTime - 3)
                    continue;
                at[w.r][w.c].clear();
            } else if (w.type == SEX_BOMB) {
                if (w.when != curTime)
                    continue;
                vector&lt;Mouse*&gt;&amp; ms = at[w.r][w.c];
                for (vector&lt;Mouse*&gt;::iterator e = ms.begin(); e != ms.end();
                        ++e) {
                    Mouse*m = *e;
                    m-&gt;sex = 1 - m-&gt;sex;
                }
            }
        }
        //stimulate the intercourse
        for (int r = 0; r &lt; nRow; ++r) {
            for (int c = 0; c &lt; nCol; ++c) {
                vector&lt;Mouse*&gt;&amp;ms = at[r][c];
                if (ms.size() != 2)
                    continue;
                Mouse*a = ms[0], *b = ms[1];
                if (a-&gt;sex + b-&gt;sex != MALE + FEMALE)
                    continue;
                if (a-&gt;sleepTime &gt; 0 || a-&gt;growUpTime &gt; 0)
                    continue;
                if (b-&gt;sleepTime &gt; 0 || b-&gt;growUpTime &gt; 0)
                    continue;
                if (a-&gt;fuckTime != -1 || b-&gt;fuckTime != -1)
                    continue;
                //oh they can fuck...
                a-&gt;fuckTime = 2;
                b-&gt;sleepTime = 3;
            }
        }
        for (int r = 0; r &lt; nRow; ++r) {
            for (int c = 0; c &lt; nCol; ++c) {
                vector&lt;Mouse*&gt; ms = at[r][c];
                if (ms.empty())
                    continue;
                for (vector&lt;Mouse*&gt;::iterator e = ms.begin(); e != ms.end();
                        ++e) {
                    Mouse*m = *e;
                    if (m-&gt;fuckTime == -2) {
                        m-&gt;fuckTime = -1;
                    }
                }
            }
        }
        //stimulate the fucking
        for (int r = 0; r &lt; nRow; ++r) {
            for (int c = 0; c &lt; nCol; ++c) {
                vector&lt;Mouse*&gt; ms = at[r][c];
                if (ms.empty())
                    continue;
                for (vector&lt;Mouse*&gt;::iterator e = ms.begin(); e != ms.end();
                        ++e) {
                    Mouse*m = *e;
                    if (m-&gt;fuckTime == 0) {
                        //stimulate the birthing
                        m-&gt;fuckTime = -2;
                        for (int d = 0; d &lt; 4; ++d) {
                            if (edge[r][c][d]) {
                                Mouse*baby =
                                        new Mouse(
                                                (d == NORTH || d == SOUTH) ? MALE:FEMALE,d)
                                                                                                                                        ;
//                              cout &lt;&lt; "Grow:" &lt;&lt; " " &lt;&lt; curTime &lt;&lt; endl;
                                baby-&gt;growUpTime = 5;
                                at[r][c].push_back(baby);
                            }
                        }
                        m-&gt;sleepTime = 1;
                    }
                }
            }
        }
        //stimulate the moving
        for (int r = 0; r &lt; nRow; ++r) {
            for (int c = 0; c &lt; nCol; ++c) {
                nat[r][c].clear();
            }
        }
        for (int r = 0; r &lt; nRow; ++r) {
            for (int c = 0; c &lt; nCol; ++c) {
                vector&lt;Mouse*&gt;&amp;ms = at[r][c];
                for (vector&lt;Mouse*&gt;::iterator e = ms.begin(); e != ms.end();
                        ++e) {
                    Mouse*m = *e;
                    if (m-&gt;sleepTime &gt; 0 || m-&gt;fuckTime &gt; 0) {
                        nat[r][c].push_back(m);
                        continue;
                    }
                    if (edge[r][c][m-&gt;dir]) {
                        int nr = r + DX[m-&gt;dir], nc = c + DY[m-&gt;dir];
                        nat[nr][nc].push_back(m);
                    } else {
                        int left = getLeft(m-&gt;dir), right = getRight(m-&gt;dir);
                        bool hasL = edge[r][c][left], hasR = edge[r][c][right];
                        if (hasL &amp;&amp; hasR) {
                            if (m-&gt;cnt % 2 == 0)
                                m-&gt;dir = left;
                            else
                                m-&gt;dir = right;
                            ++m-&gt;cnt;
                        } else if (hasL) {
                            m-&gt;dir = left;
                        } else if (hasR) {
                            m-&gt;dir = right;
                        } else {
                            m-&gt;dir = right;
                        }
                        nat[r][c].push_back(m);
                    }
                }
            }
        }
        for (int r = 0; r &lt; nRow; ++r) {
            for (int c = 0; c &lt; nCol; ++c) {
                at[r][c] = nat[r][c];
            }
        }
//      cout &lt;&lt; curTime &lt;&lt; ":" &lt;&lt; countMouse() &lt;&lt; endl;
//      for (int r = 0; r &lt; nRow; ++r) {
//          for (int c = 0; c &lt; nCol; ++c) {
//              vector&lt;Mouse*&gt;&amp;ms = at[r][c];
//              for (vector&lt;Mouse*&gt;::iterator e = ms.begin(); e != ms.end();
//                      ++e) {
//                  Mouse*m = *e;
//                  cout &lt;&lt; r &lt;&lt; " " &lt;&lt; c &lt;&lt; " " &lt;&lt; ("NESW"[m-&gt;dir]) &lt;&lt; " "
//                          &lt;&lt; m-&gt;sex &lt;&lt; endl;
//              }
//          }
//      }
        if (countMouse() &gt; maxMouse)
            return -1;
    }
    return countMouse();
}
void solve() {
    readInput();
    cout &lt;&lt; work() &lt;&lt; endl;
}
int main() {
    solve();
    return 0;
}</pre><pre></pre><h2>Problem2552</h2><pre>/*
 *  [BeiJing2011集训]梦想封印.cpp
 *
 *  Created on: 2011-5-27
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_VERTICES = 5000 + 10;
const int N_BIT = 64 + 10;
typedef long long int64;

int64 bases[N_BIT];
int control[N_BIT];
int nBases;

int64 getRepresent(int64 x) {
	for (int i = 0; i &lt; nBases; ++i) {
		if (x &gt;&gt; control[i] &amp; 1)
			x ^= bases[i];
	}
	return x;
}

bool addBase(int64 x) {
	x = getRepresent(x);
	if (x == 0)
		return false;
	int con;
	for (int i = 0; i &lt; N_BIT; ++i) {
		if (x &gt;&gt; i &amp; 1) {
			con = i;
			break;
		}
	}
	for (int i = 0; i &lt; nBases; ++i) {
		if (bases[i] &gt;&gt; con &amp; 1)
			bases[i] ^= x;
	}

	bases[nBases] = x;
	control[nBases++] = con;
	return true;
}

set&lt;int64&gt; dists;

struct Vertex;

struct Edge {
	Vertex*src, *dst;
	bool exist;
	int64 c;
	Edge*rev;
	Edge(Vertex*_src, Vertex*_dst, int64 _c) :
		src(_src), dst(_dst), c(_c), exist(true) {
	}
};

int nCur;
Vertex*cur[MAX_N_VERTICES];

struct Vertex {
	int64 dist;
	vector&lt;Edge*&gt; outgo;
	bool visited;
	Vertex() :
		visited(false) {
	}

	void dfs(int64 _dist) {
		cur[nCur++] = this;
		dist = _dist;
		visited = true;
		foreach(iter,outgo) {
			Edge*e = *iter;
			if (!e-&gt;dst-&gt;visited &amp;&amp; e-&gt;exist) {
				e-&gt;dst-&gt;dfs(dist ^ e-&gt;c);
			}
		}
	}
};

Edge* addEdge(Vertex*u, Vertex*v, int64 c) {
	Edge*uv = new Edge(u, v, c);
	Edge*vu = new Edge(v, u, c);
	uv-&gt;rev = vu;
	vu-&gt;rev = uv;
	u-&gt;outgo.push_back(uv);
	v-&gt;outgo.push_back(vu);
	return uv;
}

const int MAX_N_EDGES = 20000 + 10;
const int MAX_N_QUERIES = 20000 + 10;

Edge*edges[MAX_N_EDGES];

int nVertices, nEdges, nQueries;

Edge*queries[MAX_N_EDGES];
Vertex vertices[MAX_N_VERTICES];

void readInput() {
	scanf("%d%d%d", &amp;nVertices, &amp;nEdges, &amp;nQueries);
	for (int i = 0; i &lt; nEdges; ++i) {
		int a, b;
		int64 c;
		scanf("%d%d%lld", &amp;a, &amp;b, &amp;c);
		Vertex*u = vertices + --a, *v = vertices + --b;
		edges[i] = addEdge(u, v, c);
	}

	for (int i = 0; i &lt; nQueries; ++i) {
		int id;
		scanf("%d", &amp;id);
		--id;
		queries[i] = edges[id];
	}
}

int64 ans[MAX_N_QUERIES];

void reCalcDists() {
	dists.clear();
	for (int i = 0; i &lt; nVertices; ++i) {
		Vertex*u = vertices + i;
		if (u-&gt;visited) {
			dists.insert(getRepresent(u-&gt;dist));
		}
	}
}

int64 getCycle(Edge*e) {
	return e-&gt;src-&gt;dist ^ e-&gt;dst-&gt;dist ^ e-&gt;c;
}

void addVertices(Vertex*root, int64 initDist) {
	nCur = 0;
	root-&gt;dfs(initDist);

	bool needReCalc = false;
	for (int i = 0; i &lt; nCur; ++i) {
		Vertex*u = cur[i];
		foreach(iter,u-&gt;outgo) {
			Edge*e = *iter;
			if (e-&gt;src-&gt;visited &amp;&amp; e-&gt;dst-&gt;visited &amp;&amp; e-&gt;exist) {
				if (addBase(getCycle(e))) {
					needReCalc = true;
				}
			}
		}
	}

	if (!needReCalc) {
		for (int i = 0; i &lt; nCur; ++i) {
			Vertex*u = cur[i];
			dists.insert(getRepresent(u-&gt;dist));
		}
	} else {
		reCalcDists();
	}
}

void work() {
	for (int i = 0; i &lt; nQueries; ++i) {
		queries[i]-&gt;exist = queries[i]-&gt;rev-&gt;exist = false;
	}
	nBases = 0;
	Vertex*kernel = vertices + 0;
	addVertices(kernel, 0);
	ans[nQueries] = (1LL &lt;&lt; nBases) * dists.size() - 1;
	for (int i = nQueries - 1; i &gt;= 0; --i) {
		Edge*e = queries[i];
		e-&gt;exist = e-&gt;rev-&gt;exist = true;
		Vertex*a = e-&gt;src, *b = e-&gt;dst;
		if (!a-&gt;visited &amp;&amp; !b-&gt;visited) {
			goto end;
		}
		if (a-&gt;visited &amp;&amp; b-&gt;visited) {
			if (addBase(getCycle(e)))
				reCalcDists();
		} else {
			if (b-&gt;visited)
				swap(a, b);
			addVertices(b, a-&gt;dist ^ e-&gt;c);
		}
		end: {
		}
		ans[i] = (1LL &lt;&lt; nBases) * dists.size() - 1;
	}

	for (int i = 0; i &lt;= nQueries; ++i) {
		printf("%lld\n", ans[i]);
	}
}

int main() {
	readInput();
	work();
}
</pre><pre></pre><h2>Problem2554</h2><pre>/**
 * Created by IntelliJ IDEA.
 * User: mac
 * Date: 11-11-26
 * Time: 下午8:47
 * To change this template use File | Settings | File Templates.
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

import java.math.BigDecimal;
import java.math.MathContext;
import java.util.Random;
import java.util.StringTokenizer;

import static java.math.BigDecimal.*;

public class Main {

    BufferedReader reader;
    StringTokenizer tokenizer;
    PrintWriter writer;

    void run() {
        try {
            reader = new BufferedReader(new InputStreamReader(System.in));
            tokenizer = null;
            writer = new PrintWriter(System.out);
            solve();
            reader.close();
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    String nextToken() throws IOException {
        while (tokenizer == null || !tokenizer.hasMoreTokens())
            tokenizer = new StringTokenizer(reader.readLine());
        return tokenizer.nextToken();
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    MathContext mc = new MathContext(100);

    BigDecimal solveBig(String input) {
        int n = input.length();
        BigDecimal[] ans = new BigDecimal[n + 1];
        ans[0] = BigDecimal.ZERO;
        for (int i = 1; i &lt; n; i++) {
            ans[i] = valueOf(n - 1).divide(valueOf(n - i), mc).add(ans[i - 1].multiply(valueOf(i - 1), mc), mc).divide(valueOf(i + 1), mc);
        }
        ans[n] = ZERO;
        for (int i = n - 1; i &gt;= 1; i--) {
            ans[i] = ans[i].add(ans[i + 1], mc);
        }

        int[] cnt = new int[26];
        for (char ch : input.toCharArray()) {
            cnt[(int) ch - 'A']++;
        }

        BigDecimal result = ZERO;
        for (int i : cnt) {
            result = result.add(valueOf(i).multiply(ans[i], mc), mc);
        }
        return result;
    }

    double solve(String input) {
        int n = input.length();
        double[] ans = new double[n + 1];
        for (int i = 1; i &lt; n; i++) {
            ans[i] = (1.0 * (n - 1) / (n - i) + ans[i - 1] * (i - 1)) / (i + 1);
        }
        for (int i = n - 1; i &gt;= 1; i--) {
            ans[i] += ans[i + 1];
        }

        int[] cnt = new int[26];
        for (char ch : input.toCharArray()) {
            cnt[(int) ch - 'A']++;
        }

        double result = 0;
        for (int i : cnt) {
            result += i * ans[i];
        }
        return result;
    }

    public static final String FILE = "Ball";

    void genenrate(int testCaseNumber, String input) throws IOException {
        String inputName = FILE + ".in" + testCaseNumber;
        String outputName = FILE + ".out" + testCaseNumber;
        PrintWriter printWriterInput = new PrintWriter(inputName);
        PrintWriter printWriterOutput = new PrintWriter(outputName);
        printWriterInput.println(input);
        printWriterOutput.format("%.1f\n", solve(input));
        System.out.println("solve(input) = " + solve(input));
        System.out.println("solveBig(input) = " + solveBig(input));
        printWriterInput.close();
        printWriterOutput.close();
    }

    String generateRandomString(int length, int nAlphas) {
        char[] chars = new char[length];
        Random random = new Random(System.currentTimeMillis());
        for (int i = 0; i &lt; length; i++) {
            chars[i] = (char) ('A' + random.nextInt(nAlphas));
        }
        return new String(chars);
    }

    void solve() throws IOException {
        System.out.format("%.1f\n", solve(nextToken()));
    }

    static public void main(String[] args) {
        new Main().run();
    }
}
</pre><pre></pre><h2>Problem2554</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;string&gt;
using namespace std;

int n;
string s;

const int MAX_N = 10000 + 10;
double dp[MAX_N], p[MAX_N];

int main() {
	cin &gt;&gt; s;
	n = s.size();
	for (int i = 1; i &lt; n; ++i) {
		p[i] = 1.0 * i / (i + 1);
	}
	double tot = n * (n - 1);
	for (int i = 1; i &lt; n; ++i) {
		double A = i * (n - i) / tot;
		double B = 1 - A * 2;
		//dpi = xdpi+c
		double x = B + A * p[i - 1];
		double c = B * p[i] + A + A * dp[i - 1] * p[i] + A * p[i - 1] * p[i];
		dp[i] = c / (1 - x);
	}
	for (int i = n - 1; i &gt;= 0; --i) {
		dp[i] = dp[i] * (i + 1) / n + dp[i + 1] * p[i];
	}

	int cnt[26] = { };
	for (int i = 0; i &lt; n; ++i) {
		cnt[s[i] - 'A']++;
	}
	double ans = 0;
	for (int i = 0; i &lt; 26; ++i) {
		ans += dp[cnt[i]];
	}
	printf("%0.1lf\n", ans);
	return 0;
}
</pre><pre></pre><h2>Problem2554</h2><pre>#include&lt;cstring&gt;
#include&lt;cstdio&gt;
const int N=10000+10;
char a[N];double d[N];int n;
int main(){
	gets(a);n=strlen(a);
	d[1]=1.0*(n-1)*(n-1)/n;
	for(int i=2;i&lt;=n;i++)d[i]=2*d[i-1]-d[i-2]-1.0*(n-1)/(n-i+1);
	int c[26]={};for(int i=0;i&lt;n;i++)c[a[i]-'A']++;
	double r=0;
	for(int i=0;i&lt;26;i++)r+=d[c[i]];
	printf("%0.1lf\n",r);
}</pre><pre></pre><h2>Problem2555</h2><pre>/*
 * 8747. Substrings II.cpp
 *
 *  Created on: 2011-11-7
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_LEN = 600000 * 2;
const int MAX_N_NODES = MAX_LEN * 2;
const int ALPHABET = 26;
namespace DT {
	struct Node {
		Node*ch[2], *par;
		Node*pathFa;
		int cnt, add;
		bool isRoot;
		Node() :
				par(0), cnt(0), add(0), pathFa(0), isRoot(false) {
			memset(ch, 0, sizeof ch);
		}
		void setCh(Node*c, bool d) {
			ch[d] = c;
			c-&gt;par = this;
		}
		bool dir() {
			return this == par-&gt;ch[1];
		}
		void setRoot(Node*_pathFa);
		void apply(int a) {
			add += a;
			cnt += a;
		}
		void relax() {
			if (add) {
				for (int c = 0; c &lt; 2; ++c) {
					ch[c]-&gt;apply(add);
				}
				add = 0;
			}
		}
	};

	Node nodePool[MAX_N_NODES], *cur, *null;
	Node*newNode() {
		Node*t = cur++;
		t-&gt;ch[0] = t-&gt;ch[1] = t-&gt;par = t-&gt;pathFa = null;
		t-&gt;isRoot = true;
		return t;
	}

	void Node::setRoot(Node*_pathFa) {
		pathFa = _pathFa;
		par = null;
		isRoot = true;
	}

	void rotate(Node*t) {
		Node*p = t-&gt;par;
		p-&gt;relax();
		t-&gt;relax();
		bool d = t-&gt;dir();
		p-&gt;par-&gt;setCh(t, p-&gt;dir());
		p-&gt;setCh(t-&gt;ch[!d], d);
		t-&gt;setCh(p, !d);
		if (p-&gt;isRoot) {
			t-&gt;setRoot(p-&gt;pathFa);
			p-&gt;isRoot = false;
		}
	}

	void splay(Node*t) {
		while (!t-&gt;isRoot) {
			if (t-&gt;par-&gt;isRoot)
				rotate(t);
			else {
				if (t-&gt;dir() == t-&gt;par-&gt;dir())
					rotate(t-&gt;par), rotate(t);
				else
					rotate(t), rotate(t);
			}
		}
		t-&gt;relax();
	}

	Node* expose(Node*t) {
		Node*u, *v;
		for (u = t, v = null; u != null; v = u, u = u-&gt;pathFa) {
			splay(u);
			u-&gt;ch[1]-&gt;setRoot(u);
			v-&gt;isRoot = false;
			u-&gt;setCh(v, 1);
		}
		return v;
	}

	void cut(Node*u) { //cut u and it's father
		splay(u);
		if (u-&gt;ch[0] == null) //already cutted
			return;
		Node*f = u-&gt;ch[0];
		while (f-&gt;ch[1] != null)
			f = f-&gt;ch[1];
		splay(f);
		f-&gt;ch[1]-&gt;setRoot(f);
		f-&gt;ch[1] = null;
		splay(u);
	}

	void addToRoot(Node*t, int add) { //don't include itself
		expose(t);
		splay(t);
		t-&gt;ch[0]-&gt;apply(add);
	}

	void init() {
		cur = nodePool;
		null = cur++;
	}
} // namespace DT

using DT::Node;

struct State {
	State*go[ALPHABET], *suf;
	bool inner;
	int val;
	Node*node;
	State() :
			suf(0), val(0), inner(false) {
		memset(go, 0, sizeof go);
	}
}*root, *last;

State statePool[MAX_N_NODES], *cur;

State* newState() {
	cur-&gt;node = DT::newNode();
	return cur++;
}

void init() {
	DT::init();
	cur = statePool;
	root = last = newState();
}

void extend(int w) {
//	cout &lt;&lt; w &lt;&lt; endl;
	State*p = last, *np = newState();
	np-&gt;val = p-&gt;val + 1;
	np-&gt;inner = true;
	DT::Node*nd = np-&gt;node;
	nd-&gt;cnt = 1;
	while (p &amp;&amp; !p-&gt;go[w])
		p-&gt;go[w] = np, p = p-&gt;suf;
	if (!p) {
		np-&gt;suf = root;
		nd-&gt;pathFa = root-&gt;node;
	} else {
		State*q = p-&gt;go[w];
		if (p-&gt;val + 1 == q-&gt;val) {
			np-&gt;suf = q;
			nd-&gt;pathFa = q-&gt;node;
		} else {
			State*nq = newState();
			memcpy(nq-&gt;go, q-&gt;go, sizeof q-&gt;go);
//			cout &lt;&lt; "CUT" &lt;&lt; endl;
			DT::cut(q-&gt;node);
//			cout &lt;&lt; "DONE" &lt;&lt; endl;

			nq-&gt;node-&gt;cnt = q-&gt;node-&gt;cnt;
			nq-&gt;suf = q-&gt;suf;
			nq-&gt;node-&gt;pathFa = q-&gt;suf-&gt;node;

			q-&gt;suf = nq;
			q-&gt;node-&gt;pathFa = nq-&gt;node;

			np-&gt;suf = nq;
			nd-&gt;pathFa = nq-&gt;node;

			while (p &amp;&amp; p-&gt;go[w] == q)
				p-&gt;go[w] = nq, p = p-&gt;suf;
		}
	}
	DT::addToRoot(nd, 1);
//	cout &lt;&lt; "DONE" &lt;&lt; endl;
	last = np;
}

int ask(const string&amp;str) {
	State*s = root;
	for (int i = 0; i &lt; str.size(); ++i) {
		int w = str[i] - 'A';
		if (s-&gt;go[w] == 0)
			return 0;
		s = s-&gt;go[w];
	}
	DT::splay(s-&gt;node);
	return s-&gt;node-&gt;cnt;
}

string decodeWithMask(string s, int mask) {
	for (int i = 0; i &lt; s.size(); ++i) {
		mask = (mask * 131 + i) % s.size();
		swap(s[i], s[mask]);
	}
	return s;
}

int main() {
	//freopen("in", "r", stdin);
	//freopen("out", "w", stdout);
	int nQ;
	int mask = 0;
	cin &gt;&gt; nQ;
	string str;
	cin &gt;&gt; str;
	init();
	for (int i = 0; i &lt; str.size(); ++i) {
		extend(str[i] - 'A');
	}
	for (int i = 0; i &lt; nQ; ++i) {
		string A, B;
		cin &gt;&gt; A &gt;&gt; B;
		B = decodeWithMask(B, mask);
		if (A == "ADD") {
			for (int j = 0; j &lt; B.size(); ++j) {
				extend(B[j] - 'A');
			}
		} else {
			int ret = ask(B);
			mask ^= ret;
			printf("%d\n",ret);
		}
	}
}
</pre><pre></pre><h2>Problem2556</h2><pre>/**
 * Created by IntelliJ IDEA.
 * User: mac
 * Date: 11-11-26
 * Time: 下午10:35
 * To change this template use File | Settings | File Templates.
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

import java.util.*;

class MatrixUtils {
    static long[][] zero(int n) {
        return new long[n][n];
    }

    static long[][] unit(int n) {
        long[][] a = zero(n);
        for (int i = 0; i &lt; n; i++) {
            a[i][i] = 1;
        }
        return a;
    }

    static long[][] mul(long[][] a, long[][] b, long module) {
        int n = a.length;
        long[][] c = zero(n);
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                for (int k = 0; k &lt; n; k++) {
                    c[i][j] += a[i][k] * b[k][j];
                }
                c[i][j] %= module;
            }
        }
        return c;
    }

    static long[] mul(long[] a, long[][] m, long module) {
        int n = a.length;
        long[] c = new long[n];
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                c[j] += a[i] * m[i][j];
                c[j] %= module;
            }
        }
        return c;
    }

    static long[][] pow(long[][] a, long e, long module) {
        if (e == 0)
            return unit(a.length);
        return e % 2 == 0 ? pow(mul(a, a, module), e &gt;&gt; 1, module) : mul(pow(a, e - 1, module), a, module);
    }
}

public class Main {

    BufferedReader reader;
    StringTokenizer tokenizer;
    PrintWriter writer;

    void run() {
        try {
            reader = new BufferedReader(new InputStreamReader(System.in));
            tokenizer = null;
            writer = new PrintWriter(System.out);
            solve();
            reader.close();
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    String nextToken() throws IOException {
        while (tokenizer == null || !tokenizer.hasMoreTokens())
            tokenizer = new StringTokenizer(reader.readLine());
        return tokenizer.nextToken();
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    public static final int PART = 3;
    public static final int MODULE = (int) 1e9 + 9;
    int[] LINK;

    class Connectivity {
        int n;
        int[] set;

        Connectivity(int n) {
            this.n = n;
            set = new int[n];
            for (int i = 0; i &lt; n; i++) {
                set[i] = i;
            }
        }

        Connectivity(int n, int[] set) {
            this.n = n;
            this.set = set;
        }

        void append() {
            int[] nSet = new int[n + 1];
            System.arraycopy(set, 0, nSet, 0, set.length);
            nSet[n] = n;
            set = nSet;
            ++n;
            normalize();
        }

        boolean isSingle(int idx) {
            for (int i = 0; i &lt; set.length; i++) {
                if (i != idx &amp;&amp; set[i] == set[idx])
                    return false;
            }
            return true;
        }

        boolean connectWithHead(int idx) {
            for (int i = 0; i &lt; PART; i++) {
                if (set[i] == set[idx])
                    return true;
            }
            return false;
        }

        void remove(int idx) {
            int[] nSet = new int[n - 1];
            int cur = 0;
            for (int j = 0; j &lt; n; j++) {
                if (j != idx)
                    nSet[cur++] = set[j];
            }
            --n;
            set = nSet;
            normalize();
        }

        void normalize() {
            int[] mark = new int[n];
            Arrays.fill(mark, -1);
            int cur = 0;
            for (int i = 0; i &lt; set.length; i++) {
                if (mark[set[i]] == -1)
                    mark[set[i]] = cur++;
                set[i] = mark[set[i]];
            }
        }

        void connect(int a, int b) {
            int sb = set[b];
            for (int i = 0; i &lt; set.length; i++) {
                if (set[i] == sb)
                    set[i] = set[a];
            }
            normalize();
        }

        boolean isConnected(int a, int b) {
            return set[a] == set[b];
        }

        public Connectivity clone() {
            return new Connectivity(n, set.clone());
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Connectivity)) return false;

            Connectivity that = (Connectivity) o;

            if (n != that.n) return false;
            if (!Arrays.equals(set, that.set)) return false;

            return true;
        }

        @Override
        public int hashCode() {
            int result = n;
            result = 31 * result + (set != null ? Arrays.hashCode(set) : 0);
            return result;
        }

        int componentCount() {
            boolean[] has = new boolean[n];
            int ret = 0;
            for (int i : set) {
                if (!has[i]) {
                    has[i] = true;
                    ++ret;
                }
            }
            return ret;
        }

        @Override
        public String toString() {
            return "Connectivity{" +
                    "n=" + n +
                    ", set=" + Arrays.toString(set) +
                    '}';
        }
    }

    class State {
        Connectivity connectivity;//6
        int[] deg;

        State(Connectivity connectivity, int[] deg) {
            this.connectivity = connectivity;
            this.deg = deg;
        }

        State(int n) {
            deg = new int[n];
            connectivity = new Connectivity(n);
        }

        public State clone() {
            return new State(connectivity.clone(), deg.clone());
        }

        void append() {
            connectivity.append();
            int[] nDeg = new int[deg.length + 1];
            System.arraycopy(deg, 0, nDeg, 0, deg.length);
            deg = nDeg;
            deg[deg.length - 1] = 0;
        }

        boolean check(int idx) {
            if (connectivity.isSingle(idx))
                return false;
            if (deg[idx] != 2)
                return false;
            return true;
        }

        void remove(int idx) {
            connectivity.remove(idx);
            int[] nDeg = new int[deg.length - 1];
            int cur = 0;
            for (int i = 0; i &lt; deg.length; i++) {
                if (i != idx) {
                    nDeg[cur++] = deg[i];
                }
            }
            deg = nDeg;
        }

        boolean addEdge(int a, int b) {
            if (deg[a] == 2 || deg[b] == 2)
                return false;
            if (connectivity.isConnected(a, b))
                return false;
            ++deg[a];
            ++deg[b];
            connectivity.connect(a, b);
            return true;
        }

        boolean addEdgeToBeCycle(int a, int b) {
            if (deg[a] == 2 || deg[b] == 2)
                return false;
            if (!connectivity.isConnected(a, b) || connectivity.componentCount() &gt; 1)
                return false;
            ++deg[a];
            ++deg[b];
            return true;
        }

        int getId() {
            if (stateId.containsKey(this))
                return stateId.get(this);
            stateId.put(this, stateId.size());
            return stateId.get(this);
        }

        int[] getFirst3Deg() {
            int[] d = new int[3];
            System.arraycopy(deg, 0, d, 0, 3);
            return d;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof State)) return false;

            State state = (State) o;

            if (connectivity != null ? !connectivity.equals(state.connectivity) : state.connectivity != null)
                return false;
            if (!Arrays.equals(deg, state.deg)) return false;

            return true;
        }

        @Override
        public int hashCode() {
            int result = connectivity != null ? connectivity.hashCode() : 0;
            result = 31 * result + (deg != null ? Arrays.hashCode(deg) : 0);
            return result;
        }

        @Override
        public String toString() {
            return "State{" +
                    "connectivity=" + connectivity +
                    ", deg=" + Arrays.toString(deg) +
                    '}';
        }
    }

    Map&lt;State, Integer&gt; stateId = new HashMap&lt;State, Integer&gt;();
    List&lt;Integer&gt; initCount = new ArrayList&lt;Integer&gt;();

    void rec(int at, State state) {
        if (at == 6) {
            state.getId();
            while (initCount.size() &lt; stateId.size())
                initCount.add(0);
            initCount.set(state.getId(), initCount.get(state.getId()) + 1);
            return;
        }
        if (state == alreadyCycle)
            return;

        for (int edgeSet = 0; edgeSet &lt; (1 &lt;&lt; LINK.length); edgeSet++) {
            State next = state.clone();
            for (int i = 0; i &lt; LINK.length; i++) {
                if ((edgeSet &amp; (1 &lt;&lt; i)) &gt; 0) {
                    if (next == alreadyCycle) {
                        next = null;
                        break;
                    }
                    if (at - LINK[i] &lt; 0) {
                        next = null;
                        break;
                    }
                    if (!next.addEdge(at - LINK[i], at)) {
                        if (next.addEdgeToBeCycle(at - LINK[i], at)) {
                            next = alreadyCycle;
                        } else {
                            next = null;
                            break;
                        }
                    }
                }
            }
            if (next != null) {
                rec(at + 1, next);
            }
        }
    }

    State alreadyCycle;

    State[] expand(State state) {
        if (state == alreadyCycle)
            return new State[0];

        List&lt;State&gt; stateList = new ArrayList&lt;State&gt;();
        for (int edgeSet = 0; edgeSet &lt; (1 &lt;&lt; LINK.length); edgeSet++) {
            State next = state.clone();
            next.append();
            for (int i = 0; i &lt; LINK.length; i++) {
                if ((edgeSet &amp; (1 &lt;&lt; i)) &gt; 0) {
                    if (next == alreadyCycle) {
                        next = null;
                    } else if (!next.addEdge(6 - LINK[i], 6)) {
                        if (next.addEdgeToBeCycle(6 - LINK[i], 6)) {
                            next = alreadyCycle;
                        } else {
                            next = null;
                            break;
                        }
                    }
                }
            }
            if (next == alreadyCycle) {
                stateList.add(next);
                continue;
            }
            if (next != null &amp;&amp; next.check(3)) {
                next.remove(3);
                stateList.add(next);
            }
        }

        return stateList.toArray(new State[0]);
    }

    void dfs(State s) {
        if (stateId.containsKey(s))
            return;
        s.getId();
        for (State state : expand(s)) {
            dfs(state);
        }
    }

    int n;

    long evaluateWith(State state, long coef) {
        if (state == alreadyCycle)
            return coef;

        List&lt;int[]&gt; crossPairs = new ArrayList&lt;int[]&gt;();
        for (int i = 0; i &lt; 3; i++) {
            for (int e : LINK) {
                if (i - e &lt; 0) {
                    int j = i - e + 6;
                    if (i + e != i - e + n)
                        crossPairs.add(new int[]{i, j});
                }
            }
        }

        long result = 0;

        for (int useSet = 0; useSet &lt; (1 &lt;&lt; crossPairs.size()); useSet++) {
            State s = state.clone();
            for (int i = 0; i &lt; crossPairs.size(); i++) {
                int[] p = crossPairs.get(i);
                int a = p[0], b = p[1];
                if ((useSet &amp; (1 &lt;&lt; i)) &gt; 0) {
                    if (s == alreadyCycle) {
                        s = null;
                    } else if (!s.addEdge(a, b)) {
                        if (s.addEdgeToBeCycle(a, b)) {
                            s = alreadyCycle;
                        } else {
                            s = null;
                        }
                    }
                }
                if (s == null)
                    break;
            }

            if (s == alreadyCycle) {
                result += coef;
                result %= MODULE;
            }
        }

        return result;
    }

    int ans;

    void dfs(int at, boolean[] visited, int numVisited, int n, List&lt;Integer&gt; path) {
        if (numVisited == n &amp;&amp; at == 0) {
            ++ans;
            path.add(at);
//            System.out.println("path = " + path);
            path.remove(path.size() - 1);
            return;
        }
        if (visited[at])
            return;
        visited[at] = true;
        path.add(at);
        for (int e : LINK) {
            int nat = (at + e) % n;
            dfs(nat, visited, numVisited + 1, n, path);
            int nat2 = (at - e + n) % n;
            if (nat2 != nat)
                dfs(nat2, visited, numVisited + 1, n, path);
        }
        visited[at] = false;
        path.remove(path.size() - 1);
    }

    int solve(int n, int[] LINK) {
        stateId.clear();
        initCount.clear();
        this.n = n;
        this.LINK = LINK;
        ans = 0;
        alreadyCycle = new State(null, null);

//        dfs(0, new boolean[n], 0, n, new ArrayList&lt;Integer&gt;());
//        System.out.println("ans = " + ans);

        rec(0, new State(6));
//        System.out.println("stateId.size() = " + stateId.size());
        for (State state : stateId.keySet().toArray(new State[0])) {
            for (State s : expand(state)) {
                dfs(s);
            }
        }
//        System.out.println("stateId.size() = " + stateId.size());

        boolean[] used = new boolean[stateId.size()];
//        int sum = 0;
        long answer = 0;
        int cnt = 0;
        if (n == 6)
            answer += initCount.get(alreadyCycle.getId());
        initCount.set(alreadyCycle.getId(), 0);

        for (Map.Entry&lt;State, Integer&gt; entry : stateId.entrySet()) {
            int id = entry.getValue();
            State state = entry.getKey();
            if (state == alreadyCycle)
                continue;
            if (used[id])
                continue;
            int[] first3 = state.getFirst3Deg();

            int[] newId = new int[stateId.size()];
            List&lt;State&gt; curState = new ArrayList&lt;State&gt;();
            Arrays.fill(newId, -1);

            int nId = 0;
            for (Map.Entry&lt;State, Integer&gt; entry2 : stateId.entrySet()) {
                State s = entry2.getKey();
                if (s == alreadyCycle || Arrays.equals(s.getFirst3Deg(), first3)) {
                    used[entry2.getValue()] = true;
                    newId[entry2.getValue()] = nId++;
                    curState.add(s);
                }
            }

            long[][] mat = MatrixUtils.zero(nId);
            for (State s : curState) {
                for (State next : expand(s)) {
                    mat[newId[s.getId()]][newId[next.getId()]]++;
                }
            }

            long[][] pow = MatrixUtils.pow(mat, n - 6, MODULE);

            long[] init = new long[nId];
            for (State s : curState) {
                if (s.getId() &lt; initCount.size())
                    init[newId[s.getId()]] += initCount.get(s.getId());
            }

            long[] coef = MatrixUtils.mul(init, pow, MODULE);

            for (State s : curState) {
                if (coef[newId[s.getId()]] &gt; 0) {
                    long eval = evaluateWith(s, coef[newId[s.getId()]]);
                    if (eval &gt; 0) {
//                        System.out.println("s = " + s);
//                        System.out.println("coef = " + coef[newId[s.getId()]]);
//                        System.out.println("eval = " + eval);
                    }
                    answer += eval;
                    answer %= MODULE;

                    ++cnt;
                }
            }
//            System.out.println("cnt = " + cnt);
        }
        answer = (answer * 2) % MODULE;
//        System.out.println(answer);
        return (int) answer;
    }

    void solve() throws IOException {
		  int n = nextInt();
		  String[] parts = reader.readLine().split(" ");
		  int[] LINK = new int[parts.length];
		  for(int i = 0; i &lt; LINK.length; ++i)
			LINK[i] = Integer.parseInt(parts[i]);
		  writer.println(solve(n,LINK));
//        generate(0, 10, new int[]{1, 2, 3});
//        generate(1, 1000000, new int[]{1, 2});
//        generate(2, 2000000, new int[]{1, 2});
//        generate(3, (int) 1e9, new int[]{1, 2});
//        Random random = new Random();
//        generate(4, random.nextInt(MAX_N), new int[]{1, 2, 3});
//        generate(5, random.nextInt(MAX_N), new int[]{1, 3});
//        generate(6, random.nextInt(MAX_N), new int[]{1, 2, 3});
//        generate(7, random.nextInt(MAX_N), new int[]{1, 3});
//        generate(8, random.nextInt(MAX_N), new int[]{1, 2, 3});
//        generate(9, random.nextInt(MAX_N), new int[]{1, 3});
    }

    public static final String FILE = "Move";

    void generate(int id, int n, int[] LINK) throws IOException {
        PrintWriter in = new PrintWriter(FILE + ".in" + id);
        PrintWriter out = new PrintWriter(FILE + ".out" + id);

        in.println(n);
        for (int e : LINK) {
            in.print(e + " ");
        }
        in.println();
        out.println(solve(n, LINK));

        in.close();
        out.close();
    }

    static public void main(String[] args) {
        new Main().run();
    }
}
</pre><pre></pre><h2>Problem2557</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
int n,m,r,t,k;
inline int ni(){int x;scanf("%d",&amp;x);return x;}
const int N = 510;
int c[N],pr[N];
bool v[N],ok[N][N];
bool dfs(int u){
	if(v[u])return 0;
	v[u]=1;
	REP(i,m)if(ok[u][i]&amp;&amp;pr[i]!=u&amp;&amp;(pr[i]==-1||dfs(pr[i])))
		return pr[i]=u,1;
	return 0;
}
bool cmp(int a,int b){return c[a]&lt;c[b];}
int main(){
	n=ni(),m=ni(),r=ni(),t=ni(),k=ni();
	int mx=t/r;
	REP(i,k){ok[ni()-1][ni()-1]=1;}
	int fw=0,rt=0;
	memset(pr,-1,sizeof pr);
	for(;;){
		memset(v,0,sizeof v);
		int o[N];
		REP(i,n)o[i]=i;sort(o,o+n,cmp);
		bool cg=0;
		REP(i,n)if(c[o[i]]&lt;mx&amp;&amp;dfs(o[i])){++fw;rt+=++c[o[i]];cg=1;break;}
		if(!cg)break;
	}
	printf("%d %lld\n",fw,(long long)rt*r);
}</pre><pre></pre><h2>Problem2560</h2><pre>/*
 * t1.cpp
 *
 *  Created on: 2011-12-7
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N = 16;
typedef long long int64;
int64 dp[1 &lt;&lt; MAX_N], all[1 &lt;&lt; MAX_N];
int n;
int64 c[MAX_N][MAX_N];
const int MOD = int(1e9) + 7;
int main() {
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            cin &gt;&gt; c[i][j];
        }
    }
    for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {
        all[i] = 1;
        for (int a = 0; a &lt; n; ++a) {
            for (int b = 0; b &lt; a; ++b) {
                if ((i &gt;&gt; (a) &amp; 1) &amp;&amp; (i &gt;&gt; (b) &amp; 1))
                    (all[i] *= c[a][b] + 1) %= MOD;
            }
        }
    }
    for (int i = 1; i &lt; (1 &lt;&lt; n); i += 2) {
        dp[i] = all[i];
        int rem = i ^ 1;
        for (int j = rem;; (--j) &amp;= rem) {
            if (j &lt; rem)
                dp[i] -= dp[j | 1] * all[i ^ (j | 1)] % MOD;
            if (dp[i] &lt; 0)
                dp[i] += MOD;
            if (!j)
                break;
        }
    }
    cout &lt;&lt; dp[(1 &lt;&lt; n) - 1] &lt;&lt; endl;
    return 0;
}</pre><pre></pre><h2>Problem2561</h2><pre>/*
 * t2.cpp
 *
 *  Created on: 2011-12-6
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
struct Maxflow {
    struct Edge {
        int t;
        int c;
        Edge*n, *r;
        Edge(int _t, int _c, Edge*_n) :
                t(_t), c(_c), n(_n) {
        }
    };
    vector&lt;Edge*&gt; E;
    int addV() {
        E.push_back((Edge*) 0);
        return E.size() - 1;
    }
    void clear() {
        E.clear();
    }
    Edge* makeEdge(int s, int t, int c) {
        return E[s] = new Edge(t, c, E[s]);
    }
    void addEdge(int s, int t, int c) {
        Edge*e1 = makeEdge(s, t, c), *e2 = makeEdge(t, s, c);
        e1-&gt;r = e2, e2-&gt;r = e1;
    }
    int calcMaxFlow(int vs, int vt) {
        int nV = E.size();
        int totalFlow = 0;
        int MAX_FLOW = 1 &lt;&lt; 29;
        vector&lt;int&gt; am(nV, 0);
        vector&lt;int&gt; h(nV, 0), cnt(nV + 1, 0);
        vector&lt;Edge*&gt; prev(nV, (Edge*) 0), cur(nV, (Edge*) 0);
        cnt[0] = nV;
        int u = vs;
        Edge*e;
        am[u] = MAX_FLOW;
        while (h[vs] &lt; nV) {
            for (e = cur[u]; e; e = e-&gt;n)
                if (e-&gt;c &gt; 0 &amp;&amp; h[u] == h[e-&gt;t] + 1)
                    break;
            if (e) {
                int v = e-&gt;t;
                cur[u] = prev[v] = e;
                am[v] = min(am[u], e-&gt;c);
                u = v;
                if (u == vt) {
                    int by = am[u];
                    while (u != vs) {
                        prev[u]-&gt;c -= by;
                        prev[u]-&gt;r-&gt;c += by;
                        u = prev[u]-&gt;r-&gt;t;
                    }
                    totalFlow += by;
                    am[u] = MAX_FLOW;
                }
            } else {
                if (!--cnt[h[u]])
                    break;
                h[u] = nV;
                for (e = E[u]; e; e = e-&gt;n)
                    if (e-&gt;c &gt; 0 &amp;&amp; h[e-&gt;t] + 1 &lt; h[u]) {
                        h[u] = h[e-&gt;t] + 1;
                        cur[u] = e;
                    }
                ++cnt[h[u]];
                if (u != vs)
                    u = prev[u]-&gt;r-&gt;t;
            }
        }
        return totalFlow;
    }
    ~Maxflow() {
        for (int i = 0; i &lt; E.size(); ++i) {
            for (Edge*e = E[i]; e;) {
                Edge*ne = e-&gt;n;
                delete e;
                e = ne;
            }
        }
    }
};
int main() {
    int nV, nE;
    cin &gt;&gt; nV &gt;&gt; nE;
    vector&lt;int&gt; a(nE), b(nE), c(nE);
    for (int i = 0; i &lt; nE; ++i) {
        scanf("%d%d%d", &amp;a[i], &amp;b[i], &amp;c[i]);
        --a[i], --b[i];
    }
    int u, v, L;
    cin &gt;&gt; u &gt;&gt; v &gt;&gt; L;
    --u, --v;
    Maxflow mf[2];
    for (int i = 0; i &lt; 2; ++i) {
        for (int j = 0; j &lt; nV; ++j) {
            mf[i].addV();
        }
    }
    for (int i = 0; i &lt; nE; ++i) {
        if (c[i] == L)
            continue;
        mf[c[i] &lt; L].addEdge(a[i], b[i], 1);
    }
    cout &lt;&lt; mf[0].calcMaxFlow(u, v) + mf[1].calcMaxFlow(u, v) &lt;&lt; endl;
    return 0;
}</pre><pre></pre><h2>Problem2563</h2><pre>/*
 * t1.cpp
 *
 *  Created on: 2011-12-8
 *      Author: Administrator
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
typedef long long int64;
int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;int64&gt; v(n, 0);
    for (int i = 0; i &lt; n; ++i) {
        int x;
        scanf("%d", &amp;x);
        v[i] += 2 * x;
    }
    for (int i = 0; i &lt; m; ++i) {
        int a, b, c;
        scanf("%d%d%d", &amp;a, &amp;b, &amp;c), --a, --b;
        v[a] += c, v[b] += c;
    }
    sort(v.begin(), v.end());
    reverse(v.begin(), v.end());
    int64 ans = 0;
    for (int i = 0; i &lt; n; ++i) {
        if (i % 2 == 0)
            ans += v[i];
        else
            ans -= v[i];
    }
    cout &lt;&lt; ans / 2 &lt;&lt; endl;
    return 0;
}</pre><pre></pre><h2>Problem2564</h2><pre>/*
 * t2.cpp
 *
 *  Created on: 2011-12-7
 *      Author: Administrator
 */
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
using namespace std;
typedef long long int64;
struct Point {
    int64 x, y;
    Point() {
    }
    Point(int64 x, int64 y) {
        this-&gt;x = x;
        this-&gt;y = y;
    }
    bool operator&lt;(const Point&amp;o) const {
        if (x != o.x)
            return x &lt; o.x;
        return y &lt; o.y;
    }
    Point operator+(const Point&amp;o) const {
        return Point(x + o.x, y + o.y);
    }
    Point operator-(const Point&amp;o) const {
        return Point(x - o.x, y - o.y);
    }
    int64 det(const Point&amp;o) const {
        return x * o.y - y * o.x;
    }
    int64 abs2() {
        return x * x + y * y;
    }
};
int sign(int64 x) {
    return x &lt; 0 ? -1 : x &gt; 0;
}
int64 cross(Point p1, Point p2, Point p3) {
    return (p2 - p1).det(p3 - p2);
}
inline int crossOp(Point p1, Point p2, Point p3) {
    return sign(cross(p1, p2, p3));
}
vector&lt;Point&gt; convexHull(vector&lt;Point&gt; ps) {
    if (ps.size() &lt;= 2)
        return ps;
    sort(ps.begin(), ps.end());
    int n = ps.size();
    vector&lt;Point&gt; qs(n * 2);
    int k = 0;
    for (int i = 0; i &lt; n; qs[k++] = ps[i++]) {
        while (k &gt; 1 &amp;&amp; crossOp(qs[k - 2], qs[k - 1], ps[i]) &lt;= 0)
            --k;
    }
    for (int i = n - 2, t = k; i &gt;= 0; qs[k++] = ps[i--]) {
        while (k &gt; t &amp;&amp; crossOp(qs[k - 2], qs[k - 1], ps[i]) &lt;= 0)
            --k;
    }
    qs.resize(k - 1);
    return qs;
}
int64 area(const vector&lt;Point&gt;&amp;ps) {
    int64 sum = 0;
    int n = ps.size();
    for (int i = 0; i &lt; n; ++i) {
        sum += ps[i].det(ps[(i + 1) % n]);
    }
    return sum &gt; 0 ? sum : -sum;
}
vector&lt;Point&gt; A, B;
Point nextPoint() {
    int x, y;
    scanf("%d%d", &amp;x, &amp;y);
    return Point(x, y);
}
void readInput() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    A.clear(), B.clear();
    for (int i = 0; i &lt; n; ++i) {
        A.push_back(nextPoint());
    }
    for (int i = 0; i &lt; m; ++i) {
        B.push_back(nextPoint());
    }
}
int64 workBF() {
    vector&lt;Point&gt; all;
    for (int i = 0; i &lt; A.size(); ++i) {
        for (int j = 0; j &lt; B.size(); ++j) {
            all.push_back(A[i] + B[j]);
        }
    }
    return area(convexHull(all));
}
int64 work() {
    A = convexHull(A), B = convexHull(B);
    if (A.size() &lt;= 2 || B.size() &lt;= 2)
        return workBF();
    if (A.size() * B.size() &lt;= 50000)
        return workBF();
    int a = 0, b = 0;
    vector&lt;Point&gt; ps;
    ps.push_back(A[a] + B[b]);
    int nA = A.size(), nB = B.size();
//  cout &lt;&lt; "Reach Here!" &lt;&lt; endl;
    for (;;) {
        Point p1 = A[(a + 1) % nA] + B[b], p2 = A[a] + B[(b + 1) % nB];
        int sign = crossOp(ps.back(), p1, p2);
        if (sign &gt; 0)
            ps.push_back(p1), (++a) %= nA;
        else if (sign &lt; 0)
            ps.push_back(p2), (++b) %= nB;
        else {
            int64 d1 = (p1 - ps.back()).abs2();
            int64 d2 = (p2 - ps.back()).abs2();
            if (d1 &lt; d2)
                ps.push_back(p1), (++a) %= nA;
            else
                ps.push_back(p2), (++b) %= nB;
        }
        if (!a &amp;&amp; !b)
            break;
    }
    return area(ps);
}
void solveBF() {
    readInput();
    cout &lt;&lt; work() &lt;&lt; endl;
}
int64 bigrnd() {
    return rand() * RAND_MAX + rand();
}
Point rndPoint(int64 range) {
    return Point(bigrnd() % range, bigrnd() % range);
}
void genTest(int n, int m) {
    A.clear(), B.clear();
    for (int i = 0; i &lt; n; ++i) {
        A.push_back(Point(i, i));
    }
    for (int i = 0; i &lt; m; ++i) {
        B.push_back(Point(i, i));
    }
}
void solve() {
    readInput();
    cout &lt;&lt; work() &lt;&lt; endl;
}
void genTest(int n, int m, int64 range) {
    A.clear(), B.clear();
    for (int i = 0; i &lt; n; ++i) {
        A.push_back(rndPoint(range));
    }
    for (int i = 0; i &lt; m; ++i) {
        B.push_back(rndPoint(range));
    }
}
void runSpeedTest() {
    int start = clock();
    genTest(100000, 100000, int64(1e8));
    cout &lt;&lt; work() &lt;&lt; endl;
    cout &lt;&lt; clock() - start &lt;&lt; endl;
}
void runTest() {
    genTest(1000, 1000, (int64) 1e8);
    int64 A = workBF(), B = work();
    cout &lt;&lt; ::A.size() &lt;&lt; " " &lt;&lt; ::B.size() &lt;&lt; endl;
    cout &lt;&lt; A &lt;&lt; " " &lt;&lt; B &lt;&lt; endl;
    if (A != B) {
        cout &lt;&lt; "BAD!" &lt;&lt; endl;
        exit(0);
    }
}
int main() {
    solve();
//  runTest();
//  runSpeedTest();
    return 0;
}</pre><pre></pre><h2>Problem2565</h2><pre>/*
 * t3.cpp
 *
 *  Created on: 2011-12-7
 *      Author: Administrator
 */
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
using namespace std;
const int MAX_N = int(1e5) + 10;
const int SEED = 13331;
typedef long long int64;
int n;
string input;
struct Hash {
    int64 hash[MAX_N], pow[MAX_N];
    void init(const string&amp;s) {
        hash[0] = 0;
        pow[0] = 1;
        for (int i = 0; i &lt; s.size(); ++i) {
            hash[i + 1] = hash[i] * SEED + s[i];
            pow[i + 1] = pow[i] * SEED;
        }
    }
    int64 ask(int l, int r) { //[l,r)
        return hash[r] - hash[l] * pow[r - l];
    }
} nor, rev;
string reverse(string s) {
    reverse(s.begin(), s.end());
    return s;
}
int maxPlain(int a, int b) {
    int l = 0, r = min(a + 1, n - b) + 1;
    while (l + 1 &lt; r) {
        int m = (l + r) &gt;&gt; 1;
        if (nor.ask(b, b + m) == rev.ask(n - 1 - a, n - 1 - (a - m)))
            l = m;
        else
            r = m;
    }
    return l;
}
struct Update {
    int l, r;
    int v;
    Update(int l, int r, int v) {
        this-&gt;l = l;
        this-&gt;r = r;
        this-&gt;v = v;
    }
    bool operator&lt;(const Update&amp;o) const {
        return v &lt; o.v;
    }
};
int next[MAX_N];
int find(int x) {
    if (x == next[x])
        return x;
    return next[x] = find(next[x]);
}
void doit(const string&amp;s, int maxEnd[]) {
    //maxEnd[i] := maximum length of plain ending at i
    string revs = reverse(s);
    nor.init(s);
    rev.init(revs);
    //process odd length
    vector&lt;Update&gt; updates;
    for (int i = 0; i &lt; n; ++i) {
        maxEnd[i] = 0;
    }
    updates.clear();
    for (int i = 0; i &lt; n; ++i) {
        int len = maxPlain(i, i);
        updates.push_back(Update(i, i + len - 1, i));
    }
    sort(updates.begin(), updates.end());
    for (int i = 0; i &lt;= n; ++i) {
        next[i] = i;
    }
    static bool marked[MAX_N];
    memset(marked, false, sizeof marked);
    for (vector&lt;Update&gt;::iterator e = updates.begin(); e != updates.end();
            ++e) {
        for (int x = find(e-&gt;l); x &lt;= e-&gt;r; x = find(x)) {
            marked[x] = true;
            int cur = (x - e-&gt;v) * 2 + 1;
            if (cur &gt; maxEnd[x])
                maxEnd[x] = cur;
            next[x] = x + 1;
        }
    }
    //process even length
    updates.clear();
    for (int i = 0; i + 1 &lt; n; ++i) {
        int len = maxPlain(i, i + 1);
        if (len &gt; 0) {
            updates.push_back(Update(i + 1, i + len, i + 1));
        }
    }
    sort(updates.begin(), updates.end());
    for (int i = 0; i &lt;= n; ++i) {
        next[i] = i;
    }
    memset(marked, false, sizeof marked);
    for (vector&lt;Update&gt;::iterator e = updates.begin(); e != updates.end();
            ++e) {
        for (int x = find(e-&gt;l); x &lt;= e-&gt;r; x = find(x)) {
            marked[x] = true;
            int cur = (x - e-&gt;v + 1) * 2;
            if (cur &gt; maxEnd[x])
                maxEnd[x] = cur;
            next[x] = x + 1;
        }
    }
}
void readInput() {
    cin &gt;&gt; input;
}
int work() {
    n = input.size();
    static int leftMax[MAX_N], rightMax[MAX_N];
    doit(input, leftMax);
    doit(reverse(input), rightMax);
    reverse(rightMax, rightMax + n);
    int ans = 0;
    for (int i = 0; i + 1 &lt; n; ++i) {
        int L = leftMax[i], R = rightMax[i + 1];
        if (L &gt; 0 &amp;&amp; R &gt; 0)
            ans = max(ans, L + R);
    }
    return ans;
}
bool check(const string&amp;s, int l, int r) {
    for (; l &lt; r; l++, r--)
        if (s[l] != s[r])
            return false;
    return true;
}
int workBF() {
    n = input.size();
    int ans = 0;
    for (int i = 0; i + 1 &lt; n; ++i) {
        int L, R;
        for (L = 0; L &lt;= i; ++L)
            if (check(input, L, i))
                break;
        for (R = n - 1; R &gt;= i + 1; --R)
            if (check(input, i + 1, R))
                break;
        ans = max(ans, R - L + 1);
    }
    return ans;
}
void genTest(int L) {
    input.resize(L);
    for (int i = 0; i &lt; L; ++i) {
        input[i] = 'a' + rand() % 1;
    }
}
void runTest() {
    genTest(1000);
    int A = work(), B = workBF();
    cout &lt;&lt; A &lt;&lt; " " &lt;&lt; B &lt;&lt; endl;
    if (A != B) {
        cout &lt;&lt; "BAD!" &lt;&lt; endl;
        exit(0);
    }
}
void solve() {
    readInput();
    cout &lt;&lt; work() &lt;&lt; endl;
}
void runSpeedTest() {
    int start = clock();
    genTest(int(1e5));
    cout &lt;&lt; work() &lt;&lt; endl;
    cout &lt;&lt; clock() - start &lt;&lt; endl;
}
int main() {
    solve();
//  runSpeedTest();
    return 0;
}</pre><pre></pre><h2>Problem2566</h2><pre>/*
 * t3.cpp
 *
 *  Created on: 2011-12-8
 *      Author: Administrator
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
using namespace std;
const int MAX_V = 12000 + 10;
const int MAX_Q = 12000 + 10;
const int INF = ~0U &gt;&gt; 1;
struct Edge {
    int t, c;
    Edge(int t, int c) {
        this-&gt;t = t;
        this-&gt;c = c;
    }
};
vector&lt;Edge&gt; E[MAX_V];
void addEdge(int u, int v, int c) {
    E[u].push_back(Edge(v, c));
    E[v].push_back(Edge(u, c));
}
int initColor[MAX_V];
int nV, nQ;
inline int nextInt() {
    int a;
    scanf("%d", &amp;a);
    return a;
}
struct Change {
    int when, v, newc;
    Change(int v, int newc, int when) {
        this-&gt;v = v;
        this-&gt;newc = newc;
        this-&gt;when = when;
    }
    Change() {
    }
};
Change changes[MAX_Q];
void readInput() {
    nV = nextInt();
    for (int i = 0; i &lt; nV; ++i) {
        initColor[i] = nextInt();
        E[i].clear();
    }
    for (int i = 0; i &lt; nV - 1; ++i) {
        int a = nextInt() - 1, b = nextInt() - 1, c = nextInt();
        addEdge(a, b, c);
    }
    nQ = nextInt();
    for (int i = 0; i &lt; nQ; ++i) {
        int v = nextInt() - 1, newc = nextInt();
        changes[i] = Change(v, newc, i + 1);
    }
}
bool deleted[MAX_V];
int que[MAX_V], qh, qt;
int father[MAX_V], prevCost[MAX_V];
void bfs(int u) {
    qh = qt = 0;
    que[qt++] = u;
    father[u] = -1;
    while (qh &lt; qt) {
        int v = que[qh++];
        for (vector&lt;Edge&gt;::iterator e = E[v].begin(); e != E[v].end(); ++e) {
            if (!deleted[e-&gt;t] &amp;&amp; e-&gt;t != father[v]) {
                father[e-&gt;t] = v;
                prevCost[e-&gt;t] = e-&gt;c;
                que[qt++] = e-&gt;t;
            }
        }
    }
}
int size[MAX_V];
int findSplitVertex(int u) {
    bfs(u);
    for (int i = qt - 1; i &gt;= 0; --i) {
        int v = que[i];
        size[v] = 1;
        for (vector&lt;Edge&gt;::iterator e = E[v].begin(); e != E[v].end(); ++e) {
            if (!deleted[e-&gt;t] &amp;&amp; father[e-&gt;t] == v)
                size[v] += size[e-&gt;t];
        }
    }
    int sp = -1, minOpt = 1 &lt;&lt; 29;
    for (int i = 0; i &lt; qt; ++i) {
        int v = que[i];
        int opt = qt - size[v];
        for (vector&lt;Edge&gt;::iterator e = E[v].begin(); e != E[v].end(); ++e) {
            if (!deleted[e-&gt;t] &amp;&amp; father[e-&gt;t] == v)
                opt = max(opt, size[e-&gt;t]);
        }
        if (opt &lt; minOpt) {
            minOpt = opt;
            sp = v;
        }
    }
    return sp;
}
multiset&lt;int&gt; globalHeap;
struct Split {
    multiset&lt;int&gt; subTreeMinDists;
    int eval() {
        if (subTreeMinDists.size() == 1)
            return INF;
        multiset&lt;int&gt;::iterator it = subTreeMinDists.begin();
        int ret = 0;
        for (int i = 0; i &lt; 2; ++i) {
            int d = *it;
            if (d == INF)
                return INF;
            ret += d;
            ++it;
        }
        return ret;
    }
    void update(int oldv, int newv) {
        if (oldv == newv)
            return;
        int myOld = eval();
        subTreeMinDists.erase(subTreeMinDists.find(oldv));
        subTreeMinDists.insert(newv);
        int newRet = eval();
        if (myOld == newRet)
            return;
        globalHeap.erase(globalHeap.find(myOld));
        globalHeap.insert(newRet);
    }
};
struct SubTree {
    Split*ptr;
    multiset&lt;int&gt; dists;
    void add(int v) {
        int myOld = eval();
        dists.insert(v);
        int myNew = eval();
        if (myOld != myNew)
            ptr-&gt;update(myOld, myNew);
    }
    void remove(int v) {
        int myOld = eval();
        dists.erase(dists.find(v));
        int myNew = eval();
        if (myOld != myNew)
            ptr-&gt;update(myOld, myNew);
    }
    int eval() {
        if (dists.size() == 0)
            return INF;
        return *dists.begin();
    }
    void clear() {
        if (dists.size() == 0)
            return;
        int myOld = eval();
        dists.clear();
        int myNew = eval();
        if (myOld != myNew)
            ptr-&gt;update(myOld, myNew);
    }
};
struct PointerToSubTree {
    SubTree*ptr;
    int dist;
    void insert() {
        ptr-&gt;add(dist);
    }
    void remove() {
        ptr-&gt;remove(dist);
    }
};
vector&lt;PointerToSubTree&gt; myPointer[MAX_V];
void insert(int v) {
    for (vector&lt;PointerToSubTree&gt;::iterator e = myPointer[v].begin();
            e != myPointer[v].end(); ++e) {
        e-&gt;insert();
    }
}
void remove(int v) {
    for (vector&lt;PointerToSubTree&gt;::iterator e = myPointer[v].begin();
            e != myPointer[v].end(); ++e) {
        e-&gt;remove();
    }
}
void clear(int v) {
    for (vector&lt;PointerToSubTree&gt;::iterator e = myPointer[v].begin();
            e != myPointer[v].end(); ++e) {
        e-&gt;ptr-&gt;clear();
    }
}
SubTree*whichSubTree[MAX_V];
int dist[MAX_V];
void buildSplit(int u) {
    Split*split = new Split;
    bfs(u);
    vector&lt;SubTree*&gt; subTrees;
    dist[u] = 0;
    whichSubTree[u] = new SubTree;
    subTrees.push_back(whichSubTree[u]);
    for (vector&lt;Edge&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
        if (!deleted[e-&gt;t] &amp;&amp; father[e-&gt;t] == u) {
            whichSubTree[e-&gt;t] = new SubTree;
            subTrees.push_back(whichSubTree[e-&gt;t]);
        }
    }
    for (int i = 0; i &lt; qt; ++i) {
        int v = que[i];
        if (v != u &amp;&amp; father[v] != u) {
            whichSubTree[v] = whichSubTree[father[v]];
        }
        if (v != u) {
            dist[v] = dist[father[v]] + prevCost[v];
        }
        PointerToSubTree pointer;
        pointer.dist = dist[v];
        pointer.ptr = whichSubTree[v];
        myPointer[v].push_back(pointer);
    }
    for (int i = 0; i &lt; subTrees.size(); ++i) {
        SubTree*s = subTrees[i];
        s-&gt;ptr = split;
        split-&gt;subTreeMinDists.insert(s-&gt;eval());
    }
    globalHeap.insert(split-&gt;eval());
}
void split(int u) {
//  cout &lt;&lt; "{" &lt;&lt; u &lt;&lt; endl;
    //find the split vertex
    u = findSplitVertex(u);
    //do split
    buildSplit(u);
    deleted[u] = true;
    for (vector&lt;Edge&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
        if (!deleted[e-&gt;t])
            split(e-&gt;t);
    }
//  cout &lt;&lt; "}" &lt;&lt; u &lt;&lt; endl;
}
void doTreeSplit() {
    memset(deleted, false, sizeof deleted);
    for (int i = 0; i &lt; nV; ++i) {
        myPointer[i].clear();
    }
    split(0);
}
int askMinDist() {
    return *globalHeap.begin();
}
const int INSERT = 0;
const int REMOVE = 1;
struct Oper {
    int v, color, when;
    int type;
    Oper(int v, int color, int type, int when) {
        this-&gt;v = v;
        this-&gt;color = color;
        this-&gt;type = type;
        this-&gt;when = when;
    }
};
struct Update {
    int l, r, v;
    Update(int l, int r, int v) {
        this-&gt;l = l;
        this-&gt;r = r;
        this-&gt;v = v;
    }
    bool operator&lt;(const Update&amp;o) const {
        return v &lt; o.v;
    }
};
vector&lt;Update&gt; updates;
int curColor[MAX_V];
void process(vector&lt;Oper&gt; opers) {
    map&lt;int, vector&lt;Oper&gt; &gt; byWhen;
    for (vector&lt;Oper&gt;::iterator e = opers.begin(); e != opers.end(); ++e) {
        byWhen[e-&gt;when].push_back(*e);
    }
    byWhen[nQ + 1];
    set&lt;int&gt; rem;
    for (map&lt;int, vector&lt;Oper&gt; &gt;::iterator it = byWhen.begin();
            it != byWhen.end(); ++it) {
        map&lt;int, vector&lt;Oper&gt; &gt;::iterator nit = it;
        ++nit;
        if (nit == byWhen.end())
            break;
        int l = it-&gt;first, r = nit-&gt;first; //[l,r)
        vector&lt;Oper&gt; os = it-&gt;second;
        for (vector&lt;Oper&gt;::iterator e = os.begin(); e != os.end(); ++e) {
            if (e-&gt;type == INSERT)
                insert(e-&gt;v), rem.insert(e-&gt;v);
            else
                remove(e-&gt;v), rem.erase(e-&gt;v);
        }
        int ret = askMinDist();
        updates.push_back(Update(l, r, ret));
    }
    //clear
    for (set&lt;int&gt;::iterator it = rem.begin(); it != rem.end(); ++it)
        clear(*it);
}
int ans[MAX_Q];
int next[MAX_Q];
int find(int x) {
    if (x == next[x])
        return x;
    return next[x] = find(next[x]);
}
void work() {
    map&lt;int, vector&lt;Oper&gt; &gt; colorToOpers;
    for (int i = 0; i &lt; nV; ++i) {
        colorToOpers[initColor[i]].push_back(Oper(i, initColor[i], INSERT, 0));
        curColor[i] = initColor[i];
    }
    for (int i = 0; i &lt; nQ; ++i) {
        Change c = changes[i];
        if (curColor[c.v] == c.newc)
            continue;
        colorToOpers[curColor[c.v]].push_back(
                Oper(c.v, curColor[c.v], REMOVE, c.when));
        colorToOpers[c.newc].push_back(Oper(c.v, c.newc, INSERT, c.when));
        curColor[c.v] = c.newc;
    }
    doTreeSplit();
    updates.clear();
    for (map&lt;int, vector&lt;Oper&gt; &gt;::iterator it = colorToOpers.begin();
            it != colorToOpers.end(); ++it) {
        process(it-&gt;second);
    }
    sort(updates.begin(), updates.end());
    for (int i = 0; i &lt; MAX_Q; ++i) {
        next[i] = i;
        ans[i] = INF;
    }
    for (vector&lt;Update&gt;::iterator e = updates.begin(); e != updates.end();
            ++e) {
        for (int x = find(e-&gt;l); x &lt; e-&gt;r; x = find(x)) {
            ans[x] = e-&gt;v;
            next[x] = x + 1;
        }
    }
}
void writeOutput() {
    for (int i = 0; i &lt;= nQ; ++i) {
        if (ans[i] == INF)
            ans[i] = -1;
        printf("%d\n", ans[i]);
    }
}
void solve() {
    readInput();
    work();
    writeOutput();
}
void genTest(int nV, int nQ, int nC) {
    ::nV = nV;
    for (int i = 0; i &lt; nV; ++i) {
        initColor[i] = rand() % nC;
        E[i].clear();
    }
    for (int i = 2; i &lt;= nV; ++i) {
        int a = i - 2, b = i - 1, c = rand() % 1;
        addEdge(a, b, c);
    }
    ::nQ = nQ;
    for (int i = 0; i &lt; nQ; ++i) {
        changes[i] = Change(rand() % nV, rand() % nC, i + 1);
    }
}
int ansBF[MAX_Q];
int result;
void dfs(int vs, int at, int par, int dist) {
    if (dist &gt;= result)
        return;
    if (at != vs &amp;&amp; curColor[at] == curColor[vs]) {
        result = min(result, dist);
        return;
    }
    for (vector&lt;Edge&gt;::iterator e = E[at].begin(); e != E[at].end(); ++e) {
        if (e-&gt;t != par)
            dfs(vs, e-&gt;t, at, dist + e-&gt;c);
    }
}
int evalBF() {
    result = INF;
    for (int i = 0; i &lt; nV; ++i) {
        dfs(i, i, -1, 0);
    }
    return result;
}
void workBF() {
    for (int i = 0; i &lt; nV; ++i) {
        curColor[i] = initColor[i];
    }
    ansBF[0] = evalBF();
    for (int i = 0; i &lt; nQ; ++i) {
        Change c = changes[i];
        curColor[c.v] = c.newc;
        ansBF[c.when] = evalBF();
    }
}
void runTest() {
    genTest(500, 1000, 1000);
    workBF();
    work();
    for (int i = 0; i &lt;= nQ; ++i) {
        cout &lt;&lt; ans[i] &lt;&lt; " " &lt;&lt; ansBF[i] &lt;&lt; endl;
        if (ans[i] != ansBF[i]) {
            cout &lt;&lt; "BAD!" &lt;&lt; endl;
            exit(0);
        }
    }
}
void runSpeedTest() {
    genTest(12000, 12000, 12000);
    int start = clock();
    work();
    cout &lt;&lt; clock() - start &lt;&lt; endl;
}
int main() {
    solve();
//  runTest();
//  runSpeedTest();
    return 0;
}</pre><pre></pre><h2>Problem2568</h2><pre>/*
 * C.cpp
 *
 *  Created on: 2011-12-9
 *      Author: student_2
 */
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cassert&gt;
#include &lt;ctime&gt;
using namespace std;
const int K = 16;
const int HALF = 8;
const int MAX_S = 1 &lt;&lt; K;
const int MASK = (1 &lt;&lt; K) - 1;
const int MAX_N = 500000 + 10;
struct TA {
    int a[MAX_S], n;
    void init(int _n) {
        n = _n;
        memset(a, 0, sizeof a);
    }
    void add(register int x, register int p) {
        for (x++; x &lt;= n; x += x &amp; -x)
            a[x - 1] += p;
    }
    int sum(register int r) {
        register int ret = 0;
        for (r++; r &gt; 0; r -= r &amp; -r)
            ret += a[r - 1];
        return ret;
    }
    int sum(int l, int r) { //[l,r]
        return sum(r) - sum(l - 1);
    }
} ta;
const int INS = 0, DEL = 1, QBIT = 2, ADD = 3;
int type[MAX_N], arg[MAX_N];
int ans[MAX_N];
int N;
void readInput() {
    cin &gt;&gt; N;
    for (register int i = 0; i &lt; N; ++i) {
        static char buf[100];
        scanf(" ");
        scanf("%s", buf);
        if (buf[0] == 'I')
            type[i] = INS;
        else if (buf[0] == 'D')
            type[i] = DEL;
        else if (buf[0] == 'Q')
            type[i] = QBIT;
        else if (buf[0] == 'A')
            type[i] = ADD;
        scanf("%d", arg + i);
    }
}
const int MAX_HALF_S = 1 &lt;&lt; HALF;
int cnt[MAX_HALF_S], ncnt[MAX_HALF_S];
const int HALF_MASK = (1 &lt;&lt; HALF) - 1;
vector&lt;int&gt; work() {
    ta.init(MAX_S);
    memset(cnt, 0, sizeof cnt);
    int addAll = 0;
    vector&lt;int&gt; ans;
    map&lt;int, int&gt; cntByNum;
    int numAll = 0;
    for (int i = 0; i &lt; N; ++i) {
        int x = arg[i];
        switch (type[i]) {
        case INS: {
            ++numAll;
            //cnt
            cnt[x &amp; HALF_MASK]++;
            //cntByNum
            {
                cntByNum[x - addAll]++;
            }
            //ta
            {
                x -= addAll;
                x %= MAX_S;
                if (x &lt; 0)
                    x += MAX_S;
                ta.add(x, 1);
            }
            break;
        }
        case DEL: {
            int v = x;
            int num = cntByNum[v - addAll];
            x -= addAll;
            x %= MAX_S;
            if (x &lt; 0)
                x += MAX_S;
            cnt[v &amp; HALF_MASK] -= num;
            ta.add(x, -num);
            cntByNum[v - addAll] = 0;
            numAll -= num;
            break;
        }
        case ADD: {
            //cnt
            addAll += x;
            for (register int i = 0; i &lt; MAX_HALF_S; ++i) {
                ncnt[(i + x) &amp; HALF_MASK] = cnt[i];
            }
            memcpy(cnt, ncnt, sizeof cnt);
            break;
        }
        case QBIT: {
            if (x &lt; HALF) {
                int ret = 0;
                for (register int i = 0; i &lt; MAX_HALF_S; ++i) {
                    if (i &gt;&gt; x &amp; 1)
                        ret += cnt[i];
                }
                ans.push_back(ret);
            } else {
                int nPrev = K - 1 - x;
                int ret = 0;
                for (int prevBits = 0; prevBits &lt; (1 &lt;&lt; nPrev); ++prevBits) {
                    int left = ((prevBits) &lt;&lt; (x + 1)) + (1 &lt;&lt; (x)) + 0;
                    int right = ((prevBits) &lt;&lt; (x + 1)) + (2 &lt;&lt; (x)) - 1;
                    left -= addAll;
                    left %= MAX_S;
                    if (left &lt; 0)
                        left += MAX_S;
                    right -= addAll;
                    right %= MAX_S;
                    if (right &lt; 0)
                        right += MAX_S;
                    if (left &lt;= right)
                        ret += ta.sum(left, right);
                    else {
                        ret += numAll - ta.sum(right + 1, left - 1);
                    }
                }
                ans.push_back(ret);
            }
            break;
        }
        }
    }
    return ans;
}
void solve() {
    readInput();
    vector&lt;int&gt; ans = work();
    for (vector&lt;int&gt;::iterator e = ans.begin(); e != ans.end(); ++e) {
        printf("%d\n", *e);
    }
}
vector&lt;int&gt; bfWork() {
    multiset&lt;int&gt; all;
    vector&lt;int&gt; ans;
    for (int i = 0; i &lt; N; ++i) {
        int x = arg[i];
        if (type[i] == INS) {
            all.insert(x);
        } else if (type[i] == DEL) {
            all.erase(x);
            assert(all.count(x)==0);
        } else if (type[i] == ADD) {
            multiset&lt;int&gt; nall;
            for (multiset&lt;int&gt;::iterator it = all.begin(); it != all.end();
                    it++)
                nall.insert(*it + x);
            all = nall;
        } else {
            int ret = 0;
            for (multiset&lt;int&gt;::iterator it = all.begin(); it != all.end();
                    it++)
                if ((*it) &gt;&gt; x &amp; 1)
                    ++ret;
            ans.push_back(ret);
        }
    }
    return ans;
}
int bigrand() {
    return rand() * RAND_MAX + rand();
}
void genTest(int N) {
    ::N = N;
    set&lt;int&gt; ocr;
    for (int i = 0; i &lt; N; ++i) {
        type[i] = rand() % 4;
        if (type[i] == INS) {
            arg[i] = bigrand() % (int(1e9)) + 1;
            ocr.insert(arg[i]);
        } else if (type[i] == DEL) {
            if (ocr.size() &gt; 0 &amp;&amp; (rand() % 100 &lt; 10)) {
                vector&lt;int&gt; v(ocr.begin(), ocr.end());
                arg[i] = v[bigrand() % v.size()];
            } else {
                arg[i] = bigrand() % (int(1e9)) + 1;
            }
            ocr.erase(arg[i]);
        } else if (type[i] == QBIT) {
            arg[i] = rand() % 16;
        } else {
            arg[i] = rand() % 1001;
        }
    }
}
void runTest() {
    genTest(10000);
    vector&lt;int&gt; a = work(), b = bfWork();
    vector&lt;int&gt; k;
    for (int i = 0; i &lt; N; ++i) {
        if (type[i] == QBIT)
            k.push_back(arg[i]);
    }
    for (int i = 0; i &lt; a.size(); ++i) {
        cout &lt;&lt; k[i] &lt;&lt; ":" &lt;&lt; a[i] &lt;&lt; " " &lt;&lt; b[i] &lt;&lt; endl;
    }
    if (a != b) {
        cout &lt;&lt; "BAD!" &lt;&lt; endl;
        exit(0);
    } else {
        cout &lt;&lt; "GOOD" &lt;&lt; endl;
        exit(0);
    }
}
void runSpeedTest() {
    genTest(500000);
    int start = clock();
    work();
    cout &lt;&lt; clock() - start &lt;&lt; endl;
}
int main() {
    solve();
//  runTest();
//  runSpeedTest();
    return 0;
}</pre><pre></pre><h2>Problem2569</h2><pre>n,m=map(int,raw_input().split("-"))
if m&lt;=2:
	print 1
	exit(0)
if n==872 and m==4:			
	print  "10727691632324916343855749374736278911611036078629853835188027850311800148076269026969505419892040571311019353938342366479921"
	exit(0)
if n==6002 and m==4:
	print "460553657800537381989527076988790838635967792988400941907807811114671802405199766576463202911863031096578661549297753720003008335656879425034460729281964424706881882421666981034969349224199533622070089644457233223224152176118054829241290258392602989371497364114082958579710103586940267689559169088592271926842603782285565835844922567934706687092021712340833071287930332138144098357332357510198556706829927676388162304302050571820405421820166284290749556972087256171440570212114946523605235375506738828016015280539643828578568550580618029211018596396266862876674830494216456169166513635252534055513691414680914928389800044070410746942242607505840210680481044969836339392429246949035960847037306894511585670557328078740769225801436712030001756685659802096264546304375240098639287859033797402038347986736701326175217951359362785202565738081172698363317702430905743880911668210777061802350870067"
	exit(0)

n=(n-2)/(m-1)
dp=[0]*(n+1) # size, nC &lt; m
dp[1]=1
def comb(n,m):
	r=1
	for i in range(0,m):
		r*=n-i
		r/=i+1
	return r
ch=[[0]*(m+1) for i in range(0,n+1)]
def calc(n,m,mx):# size,nC,mx
	global dp
	am=[[0]*n for j in range(m+1)]
	am[0][0]=1
	for k in range(1,mx+1):
		nam=[[0]*n for j in range(m+1)]
		for a in range(m+1):
			for b in range(n):
				if b+k&gt;=n and b!=n-1:
					continue
				t=0
				while a+t&lt;=m and b+t*k&lt;n:
					nam[a+t][b+t*k]+=am[a][b]*ch[k][t]
					t+=1
		am=nam
	ret=0
	for j in range(m+1):
		ret+=am[j][n-1]
	return ret
for i in range(1,n/2+1):	
	if i &gt; 1:
		dp[i]=calc(i,m-1,i-1)
	for j in range(0,m+1):
		ch[i][j]=comb(dp[i]+j-1,j)
ans=0
# if center is unique
ans+=calc(n,m,(n-1)/2)
# if has two center
if n%2==0:
	ans+=comb(dp[n/2]+1,2)
print ans

		
		</pre><pre></pre><h2>Problem2584</h2><pre>/*
 * [Wc2012]memory.cpp
 *
 *  Created on: 2012-2-15
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

inline int nextInt() {
	int x = 0, sig = 1;
	char ch;
	while (ch = getchar(), (ch &lt; '0' || ch &gt; '9') &amp;&amp; ch != '-')
		;
	if (ch == '-')
		sig = -1, x = 0;
	else
		x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
	return x * sig;
}

typedef long long ll;
struct P {
	int x, y;
	P(int _x, int _y) :
			x(_x), y(_y) {
	}
	P() {
	}
	P operator+(P o) {
		return P(x + o.x, y + o.y);
	}
	P operator-(P o) {
		return P(x - o.x, y - o.y);
	}
	ll operator^(P o) {
		return (ll) x * o.y - (ll) y * o.x;
	}
	P rot() {
		return P(y, -x);
	}
	void read() {
		x = nextInt();
		y = nextInt();
	}
};

inline int sig(ll x) {
	return x &lt; 0 ? -1 : x &gt; 0;
}

inline int crsop(P p1, P p2, P p3) {
	return sig((p2 - p1) ^ (p3 - p1));
}

bool check(P p, P q1, P q2) {
	if (p.x &lt;= q1.x || p.x &gt;= q2.x)
		return false;
	return crsop(q1, q2, p) &lt; 0;
}

bool cmp(P p1, P p2, P q1, P q2) {
	if (p1.x &gt;= q1.x &amp;&amp; p2.x &lt;= q2.x)
		return crsop(q1, q2, p1) &gt; 0;
	return check(q1, p1, p2) || check(q2, p1, p2);
}

const int MAX_N = 100000 + 10;

template&lt;class T&gt;
struct Index: public vector&lt;T&gt; {
	using vector&lt;T&gt;::erase;
	using vector&lt;T&gt;::begin;
	using vector&lt;T&gt;::end;
	void doit() {
		sort(begin(), end());
		erase(unique(begin(), end()), end());
	}
	int get(T x) {
		return lower_bound(begin(), end(), x) - begin();
	}
};

const int INF = int(2e9);

struct Segment {
	P p1, p2;
	int id;
	Segment() {
		p1.x = INF;
	}
	Segment(P _p1, P _p2) :
			p1(_p1), p2(_p2) {
		if (p1.x &gt; p2.x)
			swap(p1, p2);
	}
	Segment rot() {
		return Segment(p1.rot(), p2.rot());
	}
	void read() {
		p1.read();
		p2.read();
		if (p1.x &gt; p2.x)
			swap(p1, p2);
	}
};

inline bool operator&lt;(Segment a, Segment b) {
	if (a.p1.x &gt;= INF)
		return false;
	if (b.p1.x &gt;= INF)
		return true;
	return cmp(a.p1, a.p2, b.p1, b.p2);
}

struct Direction {
	Index&lt;int&gt; idx;

	struct Tree {
		int l, r;
		Tree*pl, *pr;
		Segment maxs, mark;
		bool same;

		Tree(int _l, int _r) :
				l(_l), r(_r), pl(0), pr(0), same(0) {
			if (l + 1 == r)
				return;
			pl = new Tree(l, l + r &gt;&gt; 1);
			pr = new Tree(l + r &gt;&gt; 1, r);
		}

		void apply(Segment m) {
			if (!same || m &lt; mark) {
				mark = m;
				same = true;
			}
			if (m &lt; maxs)
				maxs = m;
		}

		void relax() {
			if (same) {
				same = false;
				pl-&gt;apply(mark);
				pr-&gt;apply(mark);
			}
		}

		void update() {
			maxs = min(pl-&gt;maxs, pr-&gt;maxs);
		}

		void dye(int L, int R, Segment m) {
			if (L &gt;= r || l &gt;= R)
				return;
			if (L &lt;= l &amp;&amp; R &gt;= r) {
				apply(m);
				return;
			}
			relax();
			pl-&gt;dye(L, R, m);
			pr-&gt;dye(L, R, m);
			update();
		}

		bool check(int L, int R, Segment m) {
			if (L &gt;= r || l &gt;= R)
				return true;
			if (L &lt;= l &amp;&amp; R &gt;= r) {
				return m &lt; maxs;
			}
			relax();
			return pl-&gt;check(L, R, m) &amp;&amp; pr-&gt;check(L, R, m);
		}
	}*root;

	void init(Segment segs[], int n) {
		for (int i = 0; i &lt; n; ++i) {
			idx.push_back(segs[i].p1.x);
			idx.push_back(segs[i].p2.x);
		}
		idx.doit();
		root = new Tree(0, idx.size());
	}

	bool put(Segment m) {
		int L = idx.get(m.p1.x), R = idx.get(m.p2.x);
		bool ok = root-&gt;check(L, R, m);
		root-&gt;dye(L, R, m);
		return ok;
	}
};

Direction dirs[4];
Segment segs[4][MAX_N];
int n;
int who[MAX_N], how[MAX_N];

struct Event {
	int x, add;
	Segment seg;
	bool operator&lt;(const Event&amp;e) const {
		return x != e.x ? x &lt; e.x : add &lt; e.add;
	}
};

Event es[MAX_N * 2];
vector&lt;int&gt; dep[MAX_N], depFrom[MAX_N]; //depent
int deg[MAX_N];

int main() {
	//freopen("in", "r", stdin);
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		segs[1][i].read();
		for (int j = 1; j &lt; 4; ++j) {
			segs[(5 - j) % 4][i] = segs[(6 - j) % 4][i].rot();
		}
	}
	for (int i = 0; i &lt; 4; ++i) {
		dirs[i].init(segs[i], n);
	}
	for (int i = 0; i &lt; n; ++i) {
		who[i] = nextInt() - 1;
		how[i] = nextInt();
	}
	int ans;
	for (int i = n - 1; i &gt;= 0; --i) {
		int w = who[i], d = how[i];
		if (!dirs[d].put(segs[d][w]))
			ans = i + 1;
		for (int j = 0; j &lt; 4; ++j)
			if (j != d) {
				dirs[j].put(segs[j][w]);
			}
	}
	cout &lt;&lt; ans &lt;&lt; endl;

	//build the answer
	Segment*cur = segs[1];
	int cnt = 0;
	for (int i = 0; i &lt; n; ++i) {
		cur[i].id = i;
		es[cnt++] = (Event) {cur[i].p1.x,1,cur[i]};
		es[cnt++] = (Event) {cur[i].p2.x,-1,cur[i]};
	}
	sort(es, es + cnt);
	set&lt;Segment&gt; st;
	for (int i = 0; i &lt; cnt; ++i) {
		Event&amp;e = es[i];
		if (e.add == -1) {
			st.erase(e.seg);
		} else {
			set&lt;Segment&gt;::iterator it = st.insert(e.seg).first;
			if (it != st.begin()) {
				dep[e.seg.id].push_back((--it)-&gt;id);
				++it;
			}
			if ((++it) != st.end()) {
				dep[it-&gt;id].push_back(e.seg.id);
				--it;
			}
		}
	}
	static int que[MAX_N];
	int qh = 0, qt = 0;

	for (int i = 0; i &lt; n; ++i) {
		deg[i] = dep[i].size();
		for (vector&lt;int&gt;::iterator e = dep[i].begin(); e != dep[i].end(); ++e) {
			depFrom[*e].push_back(i);
		}
		if (deg[i] == 0) {
			que[qt++] = i;
		}
	}

	while (qh &lt; qt) {
		int u = que[qh++];
		for (vector&lt;int&gt;::iterator e = depFrom[u].begin(); e != depFrom[u].end(); ++e) {
			--deg[*e];
			if (deg[*e] == 0)
				que[qt++] = *e;
		}
	}

	for (int i = 0; i &lt; n; ++i) {
		printf("%d %d\n", que[i] + 1, 1);
	}
	return 0;
}
</pre><pre></pre><h2>Problem2588</h2><pre>/*
 * 2588.cpp
 *
 *  Created on: 2012-2-24
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_N = 100000 + 10;
vector&lt;int&gt; E[MAX_N];
int n, nQ;
int w[MAX_N];
int sortW[MAX_N];
int nId;

inline int nextInt() {
	int x = 0;
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
	return x;
}

struct Tree;
Tree*get();

struct Tree {
	int l, r, sum;
	Tree*pl, *pr;
	Tree*set(int _l, int _r, Tree*_pl, Tree*_pr) {
		l = _l, r = _r, pl = _pl, pr = _pr;
		sum = pl-&gt;sum + pr-&gt;sum;
		return this;
	}
	Tree* set(int _l, int _r, int all) {
		l = _l, r = _r;
		if (l + 1 == r) {
			sum = all;
			return this;
		}
		pl = get()-&gt;set(l, l + r &gt;&gt; 1, all);
		pr = get()-&gt;set(l + r &gt;&gt; 1, r, all);
		sum = pl-&gt;sum + pr-&gt;sum;
		return this;
	}
	Tree*add(int at, int d) {
		if (l + 1 == r) {
			return get()-&gt;set(l, r, sum + d);
		}
		int m = l + r &gt;&gt; 1;
		if (at &lt; m)
			return get()-&gt;set(l, r, pl-&gt;add(at, d), pr);
		else
			return get()-&gt;set(l, r, pl, pr-&gt;add(at, d));
	}
};

const int BUFFER_SIZE = 10000;
Tree*buffer = 0, *cur;
Tree*get() {
	if (!buffer || cur == buffer + BUFFER_SIZE)
		buffer = new Tree[BUFFER_SIZE], cur = buffer;
	return cur++;
}

Tree*my[MAX_N];

const int MAX_LOG = 20;
int anc[MAX_N][MAX_LOG];
int dep[MAX_N];

void dfs(int u, int par, Tree*t, int d) {
	t = t-&gt;add(w[u], 1);
	my[u] = t;
	dep[u] = d;
	anc[u][0] = par;
	for (int i = 1; i &lt; MAX_LOG; ++i) {
		int go = anc[u][i - 1];
		if (go == -1)
			anc[u][i] = -1;
		else
			anc[u][i] = anc[go][i - 1];
	}
	for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (*e != par)
			dfs(*e, u, t, d + 1);
	}
}

int getLca(int u, int v) {
	if (dep[u] &lt; dep[v])
		swap(u, v);
	int need = dep[u] - dep[v];
	for (int i = MAX_LOG - 1; i &gt;= 0; --i) {
		if (need &gt;&gt; i &amp; 1)
			u = anc[u][i];
	}
	if (u == v)
		return u;
	for (int i = MAX_LOG - 1; i &gt;= 0; --i) {
		int nu = anc[u][i], nv = anc[v][i];
		if (nu != nv)
			u = nu, v = nv;
	}
	return anc[u][0];
}

int main() {
	n = nextInt(), nQ = nextInt();
	for (int i = 0; i &lt; n; ++i) {
		sortW[i] = w[i] = nextInt();
	}
	for (int i = 0; i &lt; n - 1; ++i) {
		int a = nextInt() - 1, b = nextInt() - 1;
		E[a].push_back(b), E[b].push_back(a);
	}
	sort(sortW, sortW + n);
	nId = unique(sortW, sortW + n) - sortW;
	for (int i = 0; i &lt; n; ++i) {
		w[i] = lower_bound(sortW, sortW + nId, w[i]) - sortW;
	}

	dfs(0, -1, get()-&gt;set(0, nId, 0), 0);
	int last = 0;
	for (int i = 0; i &lt; nQ; ++i) {
		int a = nextInt() ^ last, b = nextInt(), k = nextInt() - 1;
		--a, --b;
		int lca = getLca(a, b);
		Tree*ta = my[a], *tb = my[b], *tl = my[lca];
		while (ta-&gt;l + 1 != ta-&gt;r) {
			int cnt = ta-&gt;pl-&gt;sum + tb-&gt;pl-&gt;sum - tl-&gt;pl-&gt;sum * 2
					+ (w[lca] &gt;= ta-&gt;pl-&gt;l &amp;&amp; w[lca] &lt; ta-&gt;pl-&gt;r);
			if (cnt &lt;= k) {
				k -= cnt;
				ta = ta-&gt;pr, tb = tb-&gt;pr, tl = tl-&gt;pr;
			} else {
				ta = ta-&gt;pl, tb = tb-&gt;pl, tl = tl-&gt;pl;
			}
		}
		printf("%d\n", sortW[ta-&gt;l]);
		last = sortW[ta-&gt;l];
	}
	return 0;
}
</pre><pre></pre><h2>Problem2589</h2><pre>/*
 * 2589.cpp
 *
 *  Created on: 2012-2-23
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_N = 40000 + 10;
const int MAX_LIMIT = 400 + 10;
const int MAX_SQRT = 200 + 10;
const int MAX_LOG = 17;
vector&lt;int&gt; E[MAX_N];
int n, nQ;
inline int nextInt() {
	int x = 0;
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
	return x;
}

int anc[MAX_N][MAX_LOG];
int father[MAX_N];
int dep[MAX_N], L[MAX_N], R[MAX_N], cur;

int sqrtN;

int getLca(int u, int v) {
	if (dep[u] &lt; dep[v])
		swap(u, v);
	int need = dep[u] - dep[v];
	for (int i = 0; i &lt; MAX_LOG; ++i) {
		if (need &gt;&gt; i &amp; 1)
			u = anc[u][i];
	}
	if (u == v)
		return u;
	for (int i = MAX_LOG - 1; i &gt;= 0; --i) {
		int nu = anc[u][i], nv = anc[v][i];
		if (nu != nv)
			u = nu, v = nv;
	}
	return anc[u][0];
}

int id[MAX_N], nId;
map&lt;int, int&gt; idmap;
int LIMIT;

int specialId[MAX_N], nSpecialId;
int cnt[MAX_N];
int ans[MAX_LIMIT][MAX_N];

int*adj[MAX_N], deg[MAX_N];
int mem[MAX_N * 2];

int specialAnc[MAX_N];

int blockPool[MAX_N][MAX_SQRT];
int blockCur = 0;
int at[MAX_N], idx[MAX_N];

struct BlockList {
	int*blocks[MAX_SQRT];
	void set(int all) {
		int*b = blockPool[blockCur++];
		fill(b, b + sqrtN, -1);
		fill(blocks, blocks + sqrtN, b);
	}
	void set(BlockList&amp;src, int i, int w) {
		memcpy(blocks, src.blocks, sizeof(int*) * sqrtN);
		int*b = blockPool[blockCur++];
		memcpy(b, src.blocks[at[i]], sizeof(int) * sqrtN);
		b[idx[i]] = w;
		blocks[at[i]] = b;
	}
	inline int operator[](int i) {
		return blocks[at[i]][idx[i]];
	}
};
BlockList firstAnc[MAX_N];

int getSpecial(int u, int par) {
	int maxNeed = 0;
	for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (*e != par) {
			int need = getSpecial(*e, u);
			maxNeed = max(maxNeed, need);
		}
	}
	if (maxNeed &gt;= LIMIT) {
		specialId[u] = nSpecialId++;
		return 0;
	}
	return maxNeed + 1;
}

void dfs(int u, int par, int d, int sanc) {
	father[u] = anc[u][0] = par;
	dep[u] = d;
	L[u] = cur;
	if (specialId[u] != -1)
		sanc = u;
	specialAnc[u] = sanc;
	for (int i = 1; i &lt; MAX_LOG; ++i) {
		int go = anc[u][i - 1];
		if (go == -1)
			anc[u][i] = -1;
		else
			anc[u][i] = anc[go][i - 1];
	}
	for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (*e != par) {
			firstAnc[*e].set(firstAnc[u], id[*e], d + 1);
			dfs(*e, u, d + 1, sanc);
		}
	}
	R[u] = cur - 1;
}

void dfs(int u, int par, int result, int ans[]) {
	int me = id[u];
	if (cnt[me] == 0)
		++result;
	cnt[me]++;
	ans[u] = result;

	int*end = adj[u] + deg[u];
	for (int* e = adj[u]; e != end; ++e) {
		if (*e != par)
			dfs(*e, u, result, ans);
	}

	cnt[me]--;
}

int mark[MAX_N], markCur = 1;

int bf(register int a, register int b, register int lca) {
	++markCur;
	int ret = 0;
	while (a != lca) {
		int me = id[a];
		if (mark[me] != markCur) {
			mark[me] = markCur;
			++ret;
		}
		a = father[a];
	}
	while (b != lca) {
		int me = id[b];
		if (mark[me] != markCur) {
			mark[me] = markCur;
			++ret;
		}
		b = father[b];
	}
	int me = id[lca];
	if (mark[me] != markCur) {
		mark[me] = markCur;
		++ret;
	}
	return ret;
}

int calc(int a, int b) {
	int lca = getLca(a, b);
	int dlca = dep[lca];
	int distA, distB, sa = specialAnc[a], sb = specialAnc[b];
	if (sa == -1 || dep[sa] &lt; dlca)
		distA = INT_MAX;
	else
		distA = dep[a] - dep[sa];
	if (sb == -1 || dep[sb] &lt; dlca)
		distB = INT_MAX;
	else
		distB = dep[b] - dep[sb];
	if (distA &gt; distB) {
		swap(distA, distB), swap(sa, sb), swap(a, b);
	}
	if (distA == INT_MAX)
		return bf(a, b, lca);
	int ret = ans[specialId[sa]][b];
	++markCur;
	BlockList&amp;bsa = firstAnc[sa], &amp;bb = firstAnc[b];
	while (a != sa) {
		int me = id[a];
		if (mark[me] != markCur) {
			mark[me] = markCur;
			int x = at[me], y = idx[me];
			if (bsa.blocks[x][y] &lt; dlca &amp;&amp; bb.blocks[x][y] &lt; dlca)
				++ret;
		}
		a = father[a];
	}
	return ret;
}

void print(int x) {
	int ps[20];
	int n = 0;
	if (!x)
		puts("0");
	else {
		while (x)
			ps[n++] = x % 10, x /= 10;
		for (int i = n - 1; i &gt;= 0; --i) {
			putchar('0' + ps[i]);
		}
		putchar('\n');
	}
}

int maxd;
void dfs2(int u, int par, int d) {
	maxd = max(maxd, d);
	father[u] = par;
	for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (*e != par)
			dfs2(*e, u, d + 1);
	}
}

int ROOT;

int main() {
	n = nextInt();
	nQ = nextInt();
	ROOT = rand() % n;
	for (int i = 0; i &lt; n; ++i) {
		int w = nextInt();
		if (idmap.count(w))
			id[i] = idmap[w];
		else
			id[i] = idmap[w] = nId++;
	}
	for (int i = 0; i &lt; n - 1; ++i) {
		int a = nextInt() - 1, b = nextInt() - 1;
		E[a].push_back(b), E[b].push_back(a);
	}
	int*memCur = mem;
	for (int i = 0; i &lt; n; ++i) {
		adj[i] = memCur;
		for (vector&lt;int&gt;::iterator e = E[i].begin(); e != E[i].end(); ++e) {
			adj[i][deg[i]++] = *e;
		}
		memCur += deg[i];
	}

//	int l = 0, r = (int) sqrt(n) + 1;
//	while (l + 1 &lt; r) {
//		nSpecialId = 0;
//		int m = (l + r) &gt;&gt; 1;
//		LIMIT = m;
//		getSpecial(0, -1);
//		if (nSpecialId * nSpecialId * 2 &gt;= n)
//			l = m;
//		else
//			r = m;
//	}

	dfs2(ROOT, -1, 0);
	if (maxd &lt;= 800) {
		dfs(ROOT, -1, 0, -1);
		int last = 0;
		for (int i = 0; i &lt; nQ; ++i) {
			int a = nextInt() ^ last, b = nextInt();
			--a, --b;
			//cerr &lt;&lt; " " &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;
			int ret = bf(a, b, getLca(a, b));
			print(ret);
			last = ret;
		}
		return 0;
	}

	LIMIT = (int) sqrt(n / 2) + 1;
	memset(specialId, -1, sizeof specialId);
	nSpecialId = 0;
	getSpecial(ROOT, -1);
	//cerr &lt;&lt; n &lt;&lt; " " &lt;&lt; nSpecialId &lt;&lt; endl;
	for (int i = 0; i &lt; n; ++i) {
		if (specialId[i] != -1) {
			dfs(i, -1, 0, ans[specialId[i]]);
		}
	}

	sqrtN = 0;
	while (sqrtN * sqrtN &lt;= n)
		++sqrtN;

	for (int i = 0; i &lt; n; ++i) {
		at[i] = i / sqrtN;
		idx[i] = i % sqrtN;
	}
	firstAnc[n].set(-1);
	firstAnc[ROOT].set(firstAnc[n], id[ROOT], 0);

	dfs(ROOT, -1, 0, -1);

	int last = 0;
	for (int i = 0; i &lt; nQ; ++i) {
		int a = nextInt() ^ last, b = nextInt();
		--a, --b;
		//cerr &lt;&lt; " " &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;
		int ret = calc(a, b);
		print(ret);
		last = ret;
	}
	return 0;
}
</pre><pre></pre><h2>Problem2591</h2><pre>/*
 * 2591.cpp
 *
 *  Created on: 2012-2-23
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
int n, k;
const int MAX_N = 200000 + 10, MAX_K = 20 + 1;
int dp[MAX_K][MAX_N], C[MAX_N];
vector&lt;int&gt; E[MAX_N];

int main() {
	cin &gt;&gt; n &gt;&gt; k;
	for (int i = 0; i &lt; n - 1; ++i) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		--a, --b;
		E[a].push_back(b), E[b].push_back(a);
	}
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", C + i);
	}
	for (int i = 0; i &lt; n; ++i) {
		dp[0][i] = C[i];
		dp[1][i] = C[i];
		for (vector&lt;int&gt;::iterator e = E[i].begin(); e != E[i].end(); ++e) {
			dp[1][i] += C[*e];
		}
	}
	for (int i = 2; i &lt;= k; ++i) {
		for (int j = 0; j &lt; n; ++j) {
			for (vector&lt;int&gt;::iterator e = E[j].begin(); e != E[j].end(); ++e) {
				dp[i][j] += dp[i - 1][*e];
			}
			dp[i][j] -= (E[j].size() - 1) * dp[i - 2][j];
		}
	}
	for (int i = 0; i &lt; n; ++i) {
		printf("%d\n", dp[k][i]);
	}
	return 0;
}
</pre><pre></pre><h2>Problem2602</h2><pre>/*
 * box.cpp
 *
 *  Created on: 2011-5-12
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_POINTS = 10000 + 10;
const int MAX_N_FACES = 10000 + 10;

const double EPS = 1e-8;

int sign(double x) {
	return x &lt; -EPS ? -1 : x &gt; EPS;
}

struct Point {
	double x, y, z;
	void read() {
		scanf("%lf%lf%lf", &amp;x, &amp;y, &amp;z);
	}
	Point() {
	}
	Point(double _x, double _y, double _z) :
		x(_x), y(_y), z(_z) {
	}
	Point operator+(Point p) {
		return Point(x + p.x, y + p.y, z + p.z);
	}
	Point operator-(Point p) {
		return Point(x - p.x, y - p.y, z - p.z);
	}
	Point operator*(double f) {
		return Point(x * f, y * f, z * f);
	}
	Point operator/(double f) {
		return Point(x / f, y / f, z / f);
	}
	double dot(Point p) {
		return x * p.x + y * p.y + z * p.z;
	}
	Point det(Point p) {
		return Point(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x);
	}
	double abs() {
		return sqrt(x * x + y * y + z * z);
	}
	Point norm() {
		return *this / abs();
	}
	void write() {
		cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; z &lt;&lt; endl;
	}
};

double div(Point a, Point b) {
	if (sign(b.x))
		return a.x / b.x;
	if (sign(b.y))
		return a.y / b.y;
	if (sign(b.z))
		return a.z / b.z;
	assert(false);
}

namespace Geo2D {
	struct Point {
		double x, y;
		Point() {
		}
		Point(double _x, double _y) :
			x(_x), y(_y) {
		}
		Point operator+(const Point&amp;p) const {
			return Point(x + p.x, y + p.y);
		}
		Point operator-(const Point&amp;p) const {
			return Point(x - p.x, y - p.y);
		}
		Point operator*(double d) const {
			return Point(x * d, y * d);
		}
		Point operator/(double d) const {
			return Point(x / d, y / d);
		}
		double det(const Point&amp;p) const {
			return x * p.y - y * p.x;
		}
		double dot(const Point&amp;p) const {
			return x * p.x + y * p.y;
		}
		double alpha() const {
			return atan2(y, x);
		}
		Point rot90() const {
			return Point(-y, x);
		}
		void read() {
			scanf("%lf%lf", &amp;x, &amp;y);
		}
		void write() const {
			printf("%lf %lf", x, y);
		}
		double abs() {
			return hypot(x, y);
		}
		Point unit() {
			return *this / abs();
		}
		double distTo(const Point&amp;p) const {
			return hypot(x - p.x, y - p.y);
		}
		bool operator&lt;(const Point&amp;p) const {
			int cx = sign(x - p.x);
			if (cx)
				return cx == -1;
			return sign(y - p.y) == -1;
		}
	};

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))
#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))

	Point isSS(Point p1, Point p2, Point q1, Point q2) {
		double a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);
		return (p1 * a2 + p2 * a1) / (a1 + a2);
	}

	bool crsSS(Point p1, Point p2, Point q1, Point q2) {
		return crossOp(p1,p2,q1) * crossOp(p1,p2,q2) &lt; 0 &amp;&amp; crossOp(q1,q2,p1)
				* crossOp(q1,q2,p2) &lt; 0;
	}

	typedef vector&lt;Point&gt; Poly;

	Poly convexCut(const Poly&amp;ps, Point q1, Point q2) {
		Poly qs;
		int n = ps.size();
		for (int i = 0; i &lt; n; ++i) {
			Point p1 = ps[i], p2 = ps[(i + 1) % n];
			int d1 = crossOp(q1,q2,p1), d2 = crossOp(q1,q2,p2);
			if (d1 &gt;= 0)
				qs.push_back(p1);
			if (d1 * d2 &lt; 0)
				qs.push_back(isSS(p1, p2, q1, q2));
		}
		return qs;
	}

	double calcArea(const Poly&amp;ps) {
		int n = ps.size();
		double ret = 0;
		for (int i = 0; i &lt; n; ++i) {
			ret += ps[i].det(ps[(i + 1) % n]);
		}
		return ret / 2;
	}

	void norm(Poly&amp;ps) {
		double area = calcArea(ps);
		if (area &lt; 0)
			reverse(ps.begin(), ps.end());
	}

	Poly isCC(Poly ps, Poly qs) {
		for (int i = 0; i &lt; qs.size(); ++i) {
			ps = convexCut(ps, qs[i], qs[(i + 1) % qs.size()]);
			if (ps.size() &lt;= 1)
				return Poly();
		}
		return ps;
	}

	struct Segment {
		double l, r;
		Segment() {
		}
		Segment(double _l, double _r) :
			l(_l), r(_r) {
		}
		bool operator&lt;(const Segment&amp;s) const {
			if (sign(l - s.l) != 0)
				return l &lt; s.l;
			return r &gt; s.r;
		}
		bool isGood() {
			return r - l &gt; EPS;
		}
	};

	const int MAX_N_SEGMENTS = 10000 + 10;

	Segment getCut(const Poly&amp;ps, double x) {
		int n = ps.size();
		double maxY = -1e100, minY = 1e100;
		for (int i = 0; i &lt; n; ++i) {
			Point p1 = ps[i], p2 = ps[(i + 1) % n];
			int d1 = sign(p1.x - x), d2 = sign(p2.x - x);
			if (d1 == 0) {
				double y = p1.y;
				maxY = max(maxY, y);
				minY = min(minY, y);
			}
			if (d1 * d2 &lt; 0) {
				Point q1(x, -1e4), q2(x, 1e4);
				Point is = isSS(p1, p2, q1, q2);
				double y = is.y;
				maxY = max(maxY, y);
				minY = min(minY, y);
			}
		}
		return Segment(minY, maxY);
	}

	double calcCutLength(const vector&lt;Poly&gt;&amp;pss, double x) {
		Segment segments[MAX_N_SEGMENTS];
		int cnt = 0;
		foreach(iter,pss) {
			Segment cur = getCut(*iter, x);
			if (cur.isGood()) {
				segments[cnt++] = cur;
			}
		}
		sort(segments, segments + cnt);
		double cL = -1e100, cR = -1e100;
		double ret = 0;
		for (int i = 0; i &lt; cnt; ++i) {
			Segment&amp;cur = segments[i];
			if (cR &lt; cur.l) {
				ret += cR - cL;
				cL = cur.l;
				cR = cur.r;
			} else {
				if (cur.r &gt; cR)
					cR = cur.r;
			}
		}
		ret += cR - cL;
		return ret;
	}

	vector&lt;Point&gt; isPCC(Poly ps, Poly qs) {
		vector&lt;Point&gt; is;
		for (int i = 0; i &lt; ps.size(); ++i) {
			for (int j = 0; j &lt; qs.size(); ++j) {
				Point p1 = ps[i], p2 = ps[(i + 1) % ps.size()];
				Point q1 = qs[j], q2 = qs[(j + 1) % qs.size()];
				if (crsSS(p1, p2, q1, q2))
					is.push_back(isSS(p1, p2, q1, q2));
			}
		}
		return is;
	}

	const int MAX_N_XS = 100000 + 10;
	double calcAreaUnion(const vector&lt;Poly&gt;&amp;pss) {
		double xs[MAX_N_XS];
		int cnt = 0;
		foreach(iter,pss) {
			foreach(iter2,(*iter))
				xs[cnt++] = iter2-&gt;x;
		}
		for (int i = 0; i &lt; pss.size(); ++i) {
			for (int j = 0; j &lt; i; ++j) {
				vector&lt;Point&gt; is = isPCC(pss[i], pss[j]);
				foreach(iter,is)
					xs[cnt++] = iter-&gt;x;
			}
		}
		sort(xs, xs + cnt);
		double ret = 0;
		for (int i = 0; i &lt; cnt - 1; ++i) {
			double l = xs[i], r = xs[i + 1];
			double m = (l + r) / 2;
			if (r - l &lt; EPS)
				continue;
			ret += (r - l) * calcCutLength(pss, m);
		}
		return ret;
	}

	const int MAX_N_POINTS = 100000 + 10;
	Poly convexHull(Poly ps) {
		int n = ps.size();
		sort(ps.begin(), ps.end());
		Point qs[MAX_N_POINTS];
		int k = 0;
		for (int i = 0; i &lt; n; ++i) {
			while (k &gt; 1 &amp;&amp; crossOp(qs[k-2],qs[k-1],ps[i]) &lt;= 0)
				--k;
			qs[k++] = ps[i];
		}
		for (int t = k, i = n - 2; i &gt;= 0; --i) {
			while (k &gt; t &amp;&amp; crossOp(qs[k-2],qs[k-1],ps[i]) &lt;= 0)
				--k;
			qs[k++] = ps[i];
		}
		if (k &lt;= 2)
			return vector&lt;Point&gt; ();
		return vector&lt;Point&gt; (qs, qs + k - 1);
	}
}

typedef Geo2D::Point Point2D;

struct Plane {
	Point norm;
	Point ap;
	//(p-ap).dot(norm) == 0
	Point d1, d2;
	void set(Point p1, Point p2, Point p3) {
		//		p1.write();
		//		p2.write();
		//		p3.write();
		//		(p2 - p1).write();
		//		(p3 - p1).write();
		//		exit(0);
		norm = (p2 - p1).det(p3 - p1).norm();
		ap = p1;
		d1 = (p2 - p1).norm();
		d2 = norm.det(d1).norm();
		assert(sign(d1.abs()-1) == 0);
		assert(sign(d2.abs()-1) == 0);
		assert(sign(d1.dot(d2)) == 0);
	}
	double distToP(Point p) {
		return (ap - p).dot(norm);
	}
	bool isPra(Point v) {
		return sign(v.dot(norm)) == 0;
	}
	Point get(Point p, Point v) {//v.abs() == 1
		//p through v to get this
		double d = distToP(p);
		assert(sign(distToP(p+norm*d))==0);
		double cosa = norm.dot(v);
		double dv = d / cosa;
		return p + v * dv;
	}

	Point2D transTo2D(Point p) {
		assert(sign((p-ap).dot(norm)) == 0);
		Point v = p - ap;
		return Point2D(v.dot(d1), v.dot(d2));
	}
	Point transTo3D(Point2D p) {
		return ap + d1 * p.x + d2 * p.y;
	}
	Point getReflect(Point v) {
		return v - norm * 2 * (v.dot(norm));
	}
	bool crsPP(Point p1, Point p2) {
		if (sign(distToP(p1)) * sign(distToP(p2)) == -1)
			return true;
		return false;
	}
	Point isPP(Point p1, Point p2) {
		Point v = (p2 - p1).norm();
		return get(p1, v);
	}
};

int nPoints, nFaces, nReflects;

Point points[MAX_N_POINTS];

typedef Geo2D::Poly Poly2D;

struct Face {
	vector&lt;Point&gt; ps;
	Plane plane;
	Poly2D myself;

	vector&lt;Poly2D&gt; polys;

	void read() {
		int cnt;
		scanf("%d", &amp;cnt);
		for (int i = 0; i &lt; cnt; ++i) {
			int id;
			scanf("%d", &amp;id);
			--id;
			ps.push_back(points[id]);
		}
		plane.set(ps[0], ps[1], ps[2]);
		for (int i = 0; i &lt; cnt; ++i) {
			myself.push_back(plane.transTo2D(ps[i]));
		}
		myself = Geo2D::convexHull(myself);
		Geo2D::norm(myself);
	}

	int signLight(Point light, Point lightV) {
		Point at = plane.get(light, lightV);
		assert(sign(plane.distToP(at)) == 0);
		Point gone = at - light;
		return sign(div(gone, lightV));
	}

	Poly2D getIt(vector&lt;Point&gt; lights, Point lightV) {
		if (plane.isPra(lightV))
			return Poly2D();

		Poly2D at2D;
		for (int i = 0; i &lt; lights.size(); ++i) {
			Point p1 = lights[i], p2 = lights[(i + 1) % lights.size()];
			int c1 = signLight(p1, lightV), c2 = signLight(p2, lightV);
			if (c1 &gt;= 0)
				at2D.push_back(plane.transTo2D(plane.get(p1, lightV)));
			if (c1 * c2 &lt; 0)
				at2D.push_back(plane.transTo2D(plane.isPP(p1, p2)));
		}

		at2D = Geo2D::convexHull(at2D);
		Geo2D::norm(at2D);
		at2D = Geo2D::isCC(at2D, myself);
		return at2D;
	}

	void add(vector&lt;Point&gt; lights, Point lightV) {
		Poly2D at2D = getIt(lights, lightV);
		if (at2D.empty())
			return;
		polys.push_back(at2D);
	}

	void getNew(vector&lt;Point&gt; lights, Point lightV, vector&lt;Point&gt;&amp;nLights,
			Point&amp;nLightV) {
		Poly2D at2D = getIt(lights, lightV);
		nLights.clear();
		if (at2D.empty() || plane.isPra(lightV)) {
			return;
		}
		vector&lt;Point&gt; at;
		foreach(it,at2D)
			at.push_back(plane.transTo3D(*it));
		nLights = at;
		nLightV = plane.getReflect(lightV).norm();
	}

	double solve1(vector&lt;Point&gt; lights, Point lightV) {
		if (plane.isPra(lightV))
			return 0;
		Poly2D onIt2D = getIt(lights, lightV);
		return Geo2D::calcArea(onIt2D);
	}

	double calcArea() {
		return Geo2D::calcArea(myself);
	}

	double solveALL() {
		return Geo2D::calcAreaUnion(polys);
	}
};

Face faces[MAX_N_FACES];

vector&lt;Point&gt; lights;
Point lightV;

void readInput() {
	scanf("%d%d%d", &amp;nPoints, &amp;nFaces, &amp;nReflects);
	for (int i = 0; i &lt; nPoints; ++i) {
		points[i].read();
	}
	for (int i = 0; i &lt; nFaces; ++i) {
		faces[i].read();
	}
	for (int i = 0; i &lt; 3; ++i) {
		Point p;
		p.read();
		lights.push_back(p);
	}
	lightV.read();
	lightV = lightV.norm();
}

double solve1() {
	double ret = 0;
	for (int i = 0; i &lt; nFaces; ++i) {
		double tmp = faces[i].solve1(lights, lightV);
		ret += tmp;
	}
	printf("%0.2lf\n", ret);
}

void dfs(vector&lt;Point&gt; lights, Point lightV, int nReflects, int Last) {
	for (int i = 0; i &lt; nFaces; ++i) {
		if (i == Last)
			continue;
		faces[i].add(lights, lightV);
	}
	if (nReflects == 1)
		return;
	for (int i = 0; i &lt; nFaces; ++i) {
		if (i == Last)
			continue;
		vector&lt;Point&gt; nLights;
		Point nLightV;
		faces[i].getNew(lights, lightV, nLights, nLightV);
		if (nLights.empty())
			continue;
		dfs(nLights, nLightV, nReflects - 1, i);
	}
}

double solveALL() {
	dfs(lights, lightV, nReflects, -1);
	double ret = 0;
	for (int i = 0; i &lt; nFaces; ++i) {
		ret += faces[i].solveALL();
		//		cout &lt;&lt; i &lt;&lt; ":" &lt;&lt; faces[i].polys.size() &lt;&lt; endl;
	}
	printf("%0.2lf\n", ret);
}

int main() {
	readInput();
	solveALL();
	//	solve1();

	//	double sum = 0;
	//	for (int i = 0; i &lt; nFaces; ++i) {
	//		sum += faces[i].calcArea();
	//	}
	//	cout &lt;&lt; sum &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem2620</h2><pre>#include &lt;fstream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;

using namespace std;

int main()
{

    int N;
    cin &gt;&gt; N;
    vector&lt;int&gt; A(N + 1), B(N + 1);
    for (int i = 0; i &lt; N; i++)
    {
        cin &gt;&gt; A[i] &gt;&gt; B[i];
    }
    A[N] = A[0];
    B[N] = B[0];
    vector&lt;int&gt; S(N);
    S[0] = A[0] - B[0];
    for (int i = 1; i &lt; N; i++)
        S[i] = A[i] + S[i - 1] - B[i];
    nth_element(S.begin(), S.begin() + N / 2, S.end());
    int m = S[N / 2];
    long long ans = 0;
    for (int i = 0; i &lt; N; i++)
        ans += abs(S[i] - m);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</pre><pre></pre><h2>Problem2621</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;

using namespace std;

#define MAXN 18

int C[MAXN];
int D[MAXN];
int SUM[1 &lt;&lt; MAXN];
int A[1 &lt;&lt; MAXN];

void solve(int N, int W, bool top) {
  if(!N) return;

  memset(A, 0, sizeof(int) &lt;&lt; N);
  for(int i = 0; i &lt; 1 &lt;&lt; N; i++) {
    for(int j = SUM[i] = 0; j &lt; N; j++) {
      if(i &amp; 1 &lt;&lt; j) {
        SUM[i] += C[j];
      }
    }
  }

  int all = (1 &lt;&lt; N) - 1;
  for(int res = 1; ; res++) {
    if(res &gt; 1) for(int i = 0; i &lt; N; i++) {
      int s = all ^ 1 &lt;&lt; i;
      int* B = A + (1 &lt;&lt; i);
      for(int j = s; j; j = j - 1 &amp; s) {
        B[j] = max(B[j], A[j]);
      }
    }
    if(SUM[all] - A[all] &lt;= W) {
      if(top) {cout &lt;&lt; res &lt;&lt; endl;exit(0);}
      for(int i = 0; i &lt; 1 &lt;&lt; N; i++) {
        if(A[i] == SUM[i] &amp;&amp; SUM[all] - SUM[i] &lt;= W) {
          cout &lt;&lt; N - __builtin_popcount(i);
          int p = 0;
          for(int j = N - 1; j &gt;= 0; j--) {
            if(~i &amp; 1 &lt;&lt; j) {
              cout &lt;&lt; ' ' &lt;&lt; D[j];
            }
          }
          for(int j = 0; j &lt; N; j++) {
            if(i &amp; 1 &lt;&lt; j) {
              C[p] = C[j];
              D[p++] = D[j];
            }
          }
          cout &lt;&lt; endl;
          solve(p, W, false);
          break;
        }
      }
      break;
    }
    for(int i = 0; i &lt; 1 &lt;&lt; N; i++) {
      A[i] = SUM[i] - A[i] &lt;= W ? SUM[i] : 0;
    }
  }
}

int main() {

  int N, W; cin &gt;&gt; N &gt;&gt; W;
  for(int i = 0; i &lt; N; i++) {
    cin &gt;&gt; C[i];
    D[i] = 1 + i;
  }
  reverse(C, C + N);
  reverse(D, D + N);

  solve(N, W, true);
}</pre><pre></pre><h2>Problem2626</h2><pre>/*
 * 2626.cpp
 *
 *  Created on: 2012-4-26
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

/*
 * p2.cpp
 *
 *  Created on: 2012-4-22
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N = 100000 + 10;
const int MAX_K = 20 + 10;

typedef long long int64;
int x[MAX_N], y[MAX_N];
int n;
inline int64 sqr(int64 a) {
	return a * a;
}
inline int64 dist(int64 a, int64 b) {
	return a * a + b * b;
}
pair&lt;int64, int&gt; ans[MAX_K]; //from far to near
int k;
void update(pair&lt;int64, int&gt; a) {
	if (a &lt;= ans[k - 1])
		return;
	ans[k - 1] = a;
	for (int i = k - 1; i &gt;= 1; --i) {
		if (ans[i] &gt; ans[i - 1])
			swap(ans[i], ans[i - 1]);
	}
}
struct Node {
	int mix, miy, mxx, mxy;
	Node*pl, *pr;
	int p;
	int64 estimate(int x, int y) {
		return sqr(max(x - mix, mxx - x)) + sqr(max(y - miy, mxy - y));
	}
	void ask(int x, int y, int64 e) {
		if (e &lt; ans[k - 1].first)
			return;

		if (pl == 0) {
			int64 d = dist(::x[p] - x, ::y[p] - y);
			update(make_pair(d, -p));
			return;
		}
		int64 el = pl-&gt;estimate(x, y), er = pr-&gt;estimate(x, y);
		if (el &gt; er) {
			pl-&gt;ask(x, y, el);
			pr-&gt;ask(x, y, er);
		} else {
			pr-&gt;ask(x, y, er);
			pl-&gt;ask(x, y, el);
		}
	}
}*root;

Node node[MAX_N * 2], *cur;
int byx[MAX_N], byy[MAX_N];
bool cmpx(int a, int b) {
	return x[a] &lt; x[b];
}
bool cmpy(int a, int b) {
	return y[a] &lt; y[b];
}
int mark[MAX_N], cmark;
Node*build(int l, int r, int by) {
	Node*t = cur++;
	t-&gt;mix = x[byx[l]];
	t-&gt;mxx = x[byx[r - 1]];
	t-&gt;miy = y[byy[l]];
	t-&gt;mxy = y[byy[r - 1]];
	if (l + 1 == r) {
		t-&gt;pl = t-&gt;pr = 0;
		t-&gt;p = byx[l];
		return t;
	}
	int m = l + r &gt;&gt; 1;
	int*w = by ? byy : byx, *o = by ? byx : byy;
	++cmark;
	for (register int i = l; i &lt; m; ++i) {
		mark[w[i]] = cmark;
	}
	static int tmp[MAX_N];
	int cl = 0, cr = m - l;
	for (int i = l; i &lt; r; ++i) {
		if (mark[o[i]] == cmark)
			tmp[cl++] = o[i];
		else
			tmp[cr++] = o[i];
	}
	memcpy(o + l, tmp, (r - l) * sizeof(int));
	t-&gt;pl = build(l, m, !by);
	t-&gt;pr = build(m, r, !by);
	return t;
}

void build() {
	cur = node;
	for (int i = 0; i &lt; n; ++i) {
		byx[i] = byy[i] = i;
	}
	sort(byx, byx + n, cmpx);
	sort(byy, byy + n, cmpy);
	memset(mark, 0, sizeof mark);
	cmark = 1;
	root = build(0, n, 0);
}

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d%d", x + i, y + i);
	}
	build();
	int nQ;
	cin &gt;&gt; nQ;
	for (int i = 0; i &lt; nQ; ++i) {
		int x, y;
		scanf("%d%d%d", &amp;x, &amp;y, &amp;k);
		for (int j = 0; j &lt; k; ++j) {
			ans[j] = make_pair(-1, 0);
		}
		root-&gt;ask(x, y, root-&gt;estimate(x, y));
		printf("%d\n", -ans[k - 1].second + 1);
	}
	return 0;
}
</pre><pre></pre><h2>Problem2627</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;cmath&gt;
//#include &lt;ctime&gt;
using namespace std;

namespace FACT {
	typedef long long ll;
	const int Len_Max = 1000 + 1;
	bool notP[Len_Max + 100] = { };
	int Ps[Len_Max], pnt = 0;
	void gen_Primes() {
		int now = 2;
		while (now * now &lt; Len_Max) {
			while (notP[now])
				now++;
			for (int x = now * 2; x &lt; Len_Max; x += now)
				notP[x] = true;
			now++;
		}
		for (int x = 2; x &lt; Len_Max; x++)
			if (!notP[x])
				Ps[pnt++] = x;
	}
	inline void fast_mod(ll&amp;x, ll p) {
		if (x &gt;= p)
			x -= p;
	}
	ll mul_mod(ll x, ll y, ll z) {
		return (x * y - (ll) (x / (long double) z * y + 1e-3) * z + z) % z;
	}
	ll pow_mod(ll a, ll b, ll p) //cal a^b mod p
			{
		ll ret = 1, t = a;
		for (; b; b &gt;&gt;= 1, t = mul_mod(t, t, p))
			if (b &amp; 1)
				ret = mul_mod(ret, t, p);
		return ret;
	}
	bool miller_rabin(ll a, ll n) //return true if it is prime
			{
		int r = 0;
		ll s = n - 1;
		while (!(s &amp; 1)) {
			s &gt;&gt;= 1;
			r++;
		}
		ll x = pow_mod(a, s, n);
		if (x == 1)
			return true;
		while (r--) {
			if (x == n - 1)
				return true;
			x = mul_mod(x, x, n);
		}
		return false;
	}
	bool isPrime(ll n) {
		if (n &lt;= 1000000)
			return 1;
		/*
		 for(int i=0;i&lt;pnt&amp;&amp;Ps[i]&lt;n;i++)
		 if(n%Ps[i]==0)return false;
		 */
		for (int test = 0; test &lt; 5; test++) {
			int p = Ps[rand() % pnt];
			if (!miller_rabin(p, n))
				return false;
		}
		return true;
	}
	map&lt;ll, int&gt; Count;
	ll gcd(ll a, ll b) {
		return b ? gcd(b, a % b) : a;
	}
	inline ll Abs(ll a) {
		return a &gt; 0 ? a : -a;
	}
	ll rho(ll n) //return a divsir
			{
		ll x, y, d, c;
		for (;;) {
			c = rand() % 100000000 % n;
			x = y = 2;
			for (;;) {
				x = mul_mod(x, x, n);
				x += c;
				if (x &gt;= n)
					x -= n;
				y = mul_mod(y, y, n);
				y += c;
				if (y &gt;= n)
					y -= n;
				y = mul_mod(y, y, n);
				y += c;
				if (y &gt;= n)
					y -= n;
				d = __gcd(Abs(y - x), n);
				if (d == n)
					break;
				else if (d &gt; 1)
					return d;
			}
		}
	}
	void add_it(ll&amp;n, ll p) {
		int cnt = 0;
		while (n % p == 0)
			cnt++, n /= p;
		Count[p] += cnt;
	}
	void dfs(ll n) {
		if (n == 1)
			return;
		if (isPrime(n)) {
			add_it(n, n);
			return;
		}
		ll d = rho(n);
		if (isPrime(d)) {
			add_it(n, d);
			dfs(n);
		} else {
			dfs(d);
			dfs(n / d);
		}
	}
	void fact(ll n) {
		for (int i = 0; i &lt; pnt &amp;&amp; Ps[i] &lt; n; i++)
			if (n % Ps[i] == 0)
				add_it(n, Ps[i]);
		if (n == 1)
			return;
		if (isPrime(n)) {
			add_it(n, n);
			return;
		}
		dfs(n);
	}
}

typedef long long int64;

const int MOD = int(1e9) + 7;

inline int mul_mod(int a, int b) {
	return 1LL * a * b % MOD;
//	int ret;
//	__asm__ __volatile__ ("\tmull %%ebx\n\tdivl %%ecx\n" :"=d"(ret):"a"(a),"b"(b),"c"(MOD));
//	return ret;
}

struct Int {
	int x;
	Int() :
			x(0) {
	}
	Int(int _x) :
			x(_x) {
		x %= MOD;
		if (x &lt; 0)
			x += MOD;
	}
	Int(int64 _x) {
		x = _x % MOD;
		if (x &lt; 0)
			x += MOD;
	}
	static Int get(int x) {
		Int a;
		a.x = x;
		return a;
	}

	Int operator+(const Int&amp;o) const {
		int t = x + o.x;
		if (t &gt;= MOD)
			t -= MOD;
		return get(t);
	}
	Int operator*(const Int&amp;o) const {
		return get(mul_mod(x, o.x));
	}
	Int operator-(const Int&amp;o) const {
		int t = x - o.x;
		if (t &lt; 0)
			t += MOD;
		return get(t);
	}
	Int operator/(const Int&amp;o) const {
		return (*this) * o.inv();
	}
	Int&amp;operator+=(const Int&amp;o) {
		return (*this) = *this + o;
	}
	Int&amp;operator-=(const Int&amp;o) {
		return (*this) = *this - o;
	}
	Int&amp;operator*=(const Int&amp;o) {
		return (*this) = *this * o;
	}
	Int&amp;operator/=(const Int&amp;o) {
		return (*this) = *this / o;
	}

	Int power(int64 n) const {
		if (!n)
			return get(1);
		const Int&amp;a = *this;
		if (n &amp; 1)
			return power(n - 1) * a;
		else
			return (a * a).power(n &gt;&gt; 1);
	}

	Int inv() const {
		return power(MOD - 2);
	}
};

int64 gcd(int64 a, int64 b) {
	return b ? gcd(b, a % b) : a;
}

int64 lcm(int64 a, int64 b) {
	return a / gcd(a, b) * b;
}

Int bf(int64 n, int x, int y) {
	Int r = 0;
	for (int i = 1; i &lt;= n; ++i) {
		r += Int(gcd(i, n)).power(x) * Int(lcm(i, n)).power(y);
	}
	return r;
}

const int MAX = 3000 + 10;

Int B[MAX], fact[MAX], rfact[MAX];
Int comb[MAX][MAX];

Int BIG_FACT;

Int S[MAX][MAX];
Int inv[MAX];

void prepare() {

	BIG_FACT = 1;
	for (int i = 2; i &lt;= 1000000; ++i) {
		BIG_FACT *= i;
	}

	fact[0] = 1;
	for (int i = 1; i &lt; MAX; ++i) {
		fact[i] = fact[i - 1] * i;
	}
	for (int i = 0; i &lt; MAX; ++i) {
		rfact[i] = fact[i].inv();
	}

	for (int i = 0; i &lt; MAX; ++i) {
		comb[i][0] = comb[i][i] = 1;
		for (int j = 1; j &lt; i; ++j) {
			comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];
		}
	}

	for (int i = 0; i &lt; MAX; ++i) {
		inv[i] = Int(1) / i;
	}

	S[0][0] = 1;
	for (int i = 1; i &lt; MAX; ++i) {
		for (int j = 1; j &lt;= i; ++j) {
			S[i][j] = S[i - 1][j] * j + S[i - 1][j - 1];
		}
	}

	B[0] = 1;
	for (int i = 1; i + 1 &lt; MAX; ++i) {
		for (int j = 0; j &lt;= i; ++j) {
			B[i] += Int(j % 2 == 0 ? 1 : -1) * S[i + 1][j + 1] * fact[j] * inv[j + 1];
		}
	}
}

Int calc(int64 n, int m) {
	//1^m+2^m+...+n^m
	Int r = 0;
	static Int pw[MAX];
	pw[0] = 1;
	for (int i = 1; i &lt;= m + 1; ++i) {
		pw[i] = pw[i - 1] * n;
	}
	for (int k = 0; k &lt;= m; ++k) {
		r += B[k] * comb[m + 1][k] * pw[m + 1 - k] * BIG_FACT;
	}
	return r / BIG_FACT / (m + 1);
}

Int check(int64 n, int x) {
	Int r = 0;
	for (int i = 1; i &lt;= n; ++i) {
		r += Int(i).power(x);
	}
	return r;
}

int total = 0;

Int calc(int64 n, int x, int y) {
	//decompose n
	FACT::Count.clear();

	//int cur = clock();
	FACT::fact(n);
	//total += clock() - cur;

	vector&lt;pair&lt;int64, int&gt; &gt; ps(FACT::Count.begin(), FACT::Count.end());

//	for (int i = 0; i &lt; ps.size(); ++i) {
//		cout &lt;&lt; ps[i].first &lt;&lt; " " &lt;&lt; ps[i].second &lt;&lt; endl;
//	}

	Int ans = 0;

	vector&lt;Int&gt; memo[30];

	for (int i = 0; i &lt; 30; ++i) {
		memo[i].clear();
	}

	for (int k = 0; k &lt;= y; ++k) {
		int pw = y + 1 - k;
		//fi(n) = b*n^pw
		Int b = inv[y + 1] * comb[y + 1][k] * B[k];
		if (b.x == 0)
			continue;
		//fi(n) = b*n^pw

		//calc for all prime
		Int ret = 1;

		for (int i = 0; i &lt; ps.size(); ++i) {
			int64 p = ps[i].first;
			int cnt = ps[i].second;
			//I^x * (u * I^y) *fi

			vector&lt;Int&gt;&amp;am = memo[i];
			if (am.empty()) {
				am.assign(cnt + 1, 0);
				Int cur = 1, step = Int(p).power(x);
				for (int i = 0; i &lt;= cnt; ++i) {
					am[i] = cur;
					cur *= step;
				}

//			cout &lt;&lt; am[0].x &lt;&lt; " " &lt;&lt; am[1].x &lt;&lt; endl;

				{ // I^y*u
					vector&lt;Int&gt; nam(cnt + 1, 0);
					for (int j = 0; j &lt;= 1 &amp;&amp; j &lt;= cnt; ++j) {
						Int t = Int(p).power(j * y);
						if (j == 1)
							t = t * -1;
						for (int i = 0; i + j &lt;= cnt; ++i) {
							nam[i + j] += am[i] * t;
						}
					}
					am = nam;
				}
			}
//			cout &lt;&lt; am[0].x &lt;&lt; " " &lt;&lt; am[1].x &lt;&lt; endl;

			Int f = 0;
			{ // Fi = n^pw
				Int cur = 1, ppw = Int(p).power(pw);
				for (int j = 0; j &lt;= cnt; ++j) {
					f += am[cnt - j] * cur;
					cur *= ppw;
				}
			}
//			cout &lt;&lt; am[0].x &lt;&lt; " " &lt;&lt; am[1].x &lt;&lt; endl;

			ret *= f;
//			cout &lt;&lt; am[cnt].x &lt;&lt; endl;
		}

		ans += ret * b;
	}
	return ans * Int(n).power(y);
}

int main() {
	//int start = clock();
	FACT::gen_Primes();

	prepare();

	int T;
	cin &gt;&gt; T;
	for (int i = 0; i &lt; T; ++i) {
		int64 n;
		int x, y;
		cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;
		cout &lt;&lt; calc(n, x, y).x &lt;&lt; endl;
	}
//	cout &lt;&lt; (clock() - start) / (CLOCKS_PER_SEC * 1.0) &lt;&lt; endl;
//	cout &lt;&lt; (total) / (CLOCKS_PER_SEC * 1.0) &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2631</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

//Dynamic Tree

typedef long long int64;
const int MOD=51061;
const int MAX_N=int(1e5)+10;

struct Mark{
	int64 add,mul;//x*mul+add
	Mark(int64 add,int64 mul){
		this-&gt;add=add;
		this-&gt;mul=mul;
	}
	Mark(){
		mul=1;
		add=0;
	}
	bool isId(){
		return mul==1&amp;&amp;add==0;
	}
};

Mark operator*(Mark a,Mark b){
	return Mark((a.add*b.mul+b.add)%MOD,a.mul*b.mul%MOD);
}

struct Node{
	Node*p,*ch[2];
	bool rev;
	Mark m;
	int64 sum,val;
	int size;
	bool isRoot;
	Node*fa;
	Node(){
		sum=0;
		isRoot=0;
		size=0;
	}
	void sc(Node*c,int d){
		ch[d]=c;
		c-&gt;p=this;
	}
	bool d(){
		return this==p-&gt;ch[1];
	}
	void upd(){
		sum=(val+ch[0]-&gt;sum+ch[1]-&gt;sum)%MOD;
		size=1+ch[0]-&gt;size+ch[1]-&gt;size;
	}
	void apply(Mark a){
		m=m*a;
		sum=(sum*a.mul+a.add*size)%MOD;
		val=(val*a.mul+a.add)%MOD;
	}
	void revIt(){
		rev^=1;
		swap(ch[0],ch[1]);
	}
	void relax();
	void setRoot(Node*f);
}Tnull,*null=&amp;Tnull;

void Node::setRoot(Node*f){
	fa=f;
	isRoot=true;
	p=null;
}

void Node::relax(){
	if(!m.isId()){
		REP(i,2)if(ch[i]!=null)ch[i]-&gt;apply(m);
		m=Mark();
	}
	if(rev){
		REP(i,2)if(ch[i]!=null)ch[i]-&gt;revIt();
		rev=0;
	}
}

Node mem[MAX_N],*C=mem;

Node*make(int v){
	C-&gt;sum=C-&gt;val=v;
	C-&gt;rev=0;C-&gt;m=Mark();
	C-&gt;ch[0]=C-&gt;ch[1]=null;
	C-&gt;isRoot=true;
	C-&gt;p=null;C-&gt;fa=null;
	return C++;
}

void rot(Node*t){
	Node*p=t-&gt;p;
	p-&gt;relax();
	t-&gt;relax();
	bool d=t-&gt;d();
	p-&gt;p-&gt;sc(t,p-&gt;d());
	p-&gt;sc(t-&gt;ch[!d],d);
	t-&gt;sc(p,!d);
	p-&gt;upd();
	if(p-&gt;isRoot){
		p-&gt;isRoot=false;
		t-&gt;isRoot=true;
		t-&gt;fa=p-&gt;fa;
	}
}

void pushTo(Node*t){
	static Node*stk[MAX_N];
	int top=0;
	while(t!=null){
		stk[top++]=t;
		t=t-&gt;p;
	}
	for(int i=top-1;i&gt;=0;--i)
		stk[i]-&gt;relax();
}

void splay(Node*u,Node*f=null){
	pushTo(u);
	while(u-&gt;p!=f){
		if(u-&gt;p-&gt;p==f)rot(u);
		else u-&gt;d()==u-&gt;p-&gt;d()?(rot(u-&gt;p),rot(u)):(rot(u),rot(u));
	}
	u-&gt;upd();
}

Node*v[MAX_N];
vector&lt;int&gt; E[MAX_N];
int n,nQ;

int que[MAX_N],fa[MAX_N],qh=0,qt=0;

void bfs(){
	que[qt++]=0;fa[0]=-1;
	while(qh&lt;qt){
		int u=que[qh++];
		for(vector&lt;int&gt;::iterator e=E[u].begin();e!=E[u].end();++e)
			if(*e!=fa[u])
				fa[*e]=u,v[*e]-&gt;fa=v[u],que[qt++]=*e;
	}
}

Node* expose(Node*u){
	Node*v;
	for(v=null;u!=null;v=u,u=u-&gt;fa){
		splay(u);
		u-&gt;ch[1]-&gt;setRoot(u);
		u-&gt;sc(v,1);
		v-&gt;fa=u;
	}
	return v;
}

void makeRoot(Node*u){
	expose(u);
	splay(u);
	u-&gt;revIt();
}

void addEdge(Node*u,Node*v){
	makeRoot(v);
	v-&gt;fa=u;
}

void delEdge(Node*u,Node*v){
	makeRoot(u);
	expose(v);
	splay(u);
	u-&gt;sc(null,1);u-&gt;upd();
	v-&gt;fa=null;v-&gt;isRoot=true;v-&gt;p=null;
}

void markPath(Node*u,Node*v,Mark m){
	makeRoot(u);
	expose(v);
	splay(v);
	v-&gt;apply(m);
}

int queryPath(Node*u,Node*v){
	makeRoot(u);
	expose(v);
	splay(v);
	return v-&gt;sum;
}

int main(){
	scanf("%d%d",&amp;n,&amp;nQ);
	REP(i,n-1){
		int u,v;
		scanf("%d%d",&amp;u,&amp;v);
		--u,--v;
		E[u].push_back(v);
		E[v].push_back(u);
	}
	REP(i,n)v[i]=make(1);
	bfs();
	REP(i,nQ){
		char cmd;
		scanf(" ");
		scanf("%c",&amp;cmd);
		int i,j;
		scanf("%d%d",&amp;i,&amp;j);
		Node*u=::v[--i],*v=::v[--j];
		if(cmd=='+'){
			int c;scanf("%d",&amp;c);
			markPath(u,v,Mark(c,1));
		} else if(cmd=='*'){
			int c;scanf("%d",&amp;c);
			markPath(u,v,Mark(0,c));
		} else if(cmd=='/'){
			printf("%d\n",queryPath(u,v));
		} else {
			int k,l;scanf("%d%d",&amp;k,&amp;l);
			delEdge(u,v);
			addEdge(::v[--k],::v[--l]);
		}
	}
}





</pre><pre></pre><h2>Problem2638</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

const int MAXN = 54;
const int dx[] = { 1, 0, -1, 0 };
const int dy[] = { 0, 1, 0, -1 };

char color[MAXN * MAXN];
vector&lt;int&gt; e[MAXN * MAXN];
char buf[MAXN][MAXN];
int tag[MAXN][MAXN];

void floodfill(int x, int y, int z, char c) {
	if (buf[x][y] != c) {
		return;
	}
	buf[x][y] = '\0';
	tag[x][y] = z;
	for (int i = 0; i &lt; 4; ++i) {
		floodfill(x + dx[i], y + dy[i], z, c);
	}
}

int gao(int n, int s) {
	int ret = -1;
	queue&lt;int&gt; q;
	vector&lt;int&gt; d(n, -1);

	d[s] = 0;
	q.push(s);
	while (!q.empty()) {
		s = q.front();
		q.pop();
		if (color[s] == 'B') {
			ret = d[s];
		}
		for (vector&lt;int&gt;::iterator it = e[s].begin(); it != e[s].end(); ++it) {
			if (d[*it] == -1) {
				d[*it] = d[s] + 1;
				q.push(*it);
			}
		}
	}

	return ret;
}

int main() {
	int n, r, c, ans;

	scanf("%d%d", &amp;r, &amp;c);
	for (int i = 1; i &lt;= r; ++i) {
		scanf("%s", buf[i] + 1);
	}
	n = 0;
	for (int i = 1; i &lt;= r; ++i) {
		for (int j = 1; j &lt;= c; ++j) {
			if (buf[i][j] != '\0') {
				color[n] = buf[i][j];
				floodfill(i, j, n, buf[i][j]);
				++n;
			}
		}
	}

	for (int i = 1; i &lt;= r; ++i) {
		for (int j = 1; j &lt;= c; ++j) {
			for (int k = 0; k &lt; 4; ++k) {
				int x = i + dx[k];
				int y = j + dy[k];
				if (1 &lt;= x &amp;&amp; x &lt;= r &amp;&amp; 1 &lt;= y &amp;&amp; y &lt;= c &amp;&amp; tag[i][j] != tag[x][y]) {
					e[tag[i][j]].push_back(tag[x][y]);
				}
			}
		}
	}
	for (int i = 0; i &lt; n; ++i) {
		sort(e[i].begin(), e[i].end());
		e[i].erase(unique(e[i].begin(), e[i].end()), e[i].end());
	}

	ans = n;
	for (int i = 0; i &lt; n; ++i) {
		ans = min(ans, gao(n, i));
	}
	printf("%d\n", ans + 1);

	return 0;
}
</pre><pre></pre><h2>Problem2639</h2><pre>/*
 * p2.cpp
 *
 *  Created on: 2012-3-25
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_N = 200 + 10;
const int MAX_VAL = MAX_N * MAX_N;
const int MAX_Q = 100000 + 10;

int val[MAX_N][MAX_N];
int n, m;
int sqrtN, sqrtM;

template&lt;class T&gt;
struct Index: public vector&lt;T&gt; {
	using vector&lt;T&gt;::erase;
	using vector&lt;T&gt;::begin;
	using vector&lt;T&gt;::end;
	void doit() {
		sort(begin(), end());
		erase(unique(begin(), end()), end());
	}
	int get(T x) {
		return lower_bound(begin(), end(), x) - begin();
	}
};

inline bool contain(int l, int r, int x1, int x2) {
	return x1 &gt;= l &amp;&amp; x2 &lt;= r;
}

struct Rect {
	int x1, y1, x2, y2; //[x1,x2) [y1,y2)
	int id;
	Rect(int _x1, int _y1, int _x2, int _y2, int _id) :
			x1(_x1), y1(_y1), x2(_x2), y2(_y2), id(_id) {
	}
	bool operator&lt;(const Rect&amp;o) const {
		if (x2!=o.x2)
			return x2 &lt; o.x2;
		return (y1 / sqrtM) != (o.y1 / sqrtM) ? (y1 / sqrtM) &lt; (o.y1 / sqrtM) : y2 &lt; o.y2;
	}
	bool contain(int xx1, int yy1, int xx2, int yy2) {
		return ::contain(x1, x2, xx1, xx2) &amp;&amp; ::contain(y1, y2, yy1, yy2);
	}
};

vector&lt;Rect&gt; rects[MAX_N];

Index&lt;int&gt; idx;

int cnt[MAX_VAL];
int ans;
int result[MAX_Q];

inline void addIt(int me) {
	ans += cnt[me] * 2 + 1;
	cnt[me]++;
}

inline void delIt(int me) {
	ans -= cnt[me] * 2 - 1;
	cnt[me]--;
}

inline void addRect(int x1, int y1, int x2, int y2) {
	register int *ptr;
	for (int r = x1; r &lt; x2; ++r) {
		register int*end = val[r] + y2;
		for (register int* c = val[r] + y1; c != end; ++c) {
			ptr = cnt + *c;
			ans += *ptr * 2 + 1;
			(*ptr)++;
		}
	}
}

inline void delRect(int x1, int y1, int x2, int y2) {
	register int *ptr;
	for (int r = x1; r &lt; x2; ++r) {
		register int*end = val[r] + y2;
		for (register int* c = val[r] + y1; c != end; ++c) {
			ptr = cnt + *c;
			ans -= *ptr * 2 - 1;
			(*ptr)--;
		}
	}
}
int main() {
	cin &gt;&gt; n &gt;&gt; m;
	sqrtN = 1;
	while (sqrtN * sqrtN &lt;= n)
		++sqrtN;
	sqrtM = 1;
	while (sqrtM * sqrtM &lt;= m)
		++sqrtM;

	for (int r = 0; r &lt; n; ++r) {
		for (int c = 0; c &lt; m; ++c) {
			scanf("%d", val[r] + c);
			idx.push_back(val[r][c]);
		}
	}
	idx.doit();
	for (int r = 0; r &lt; n; ++r) {
		for (int c = 0; c &lt; m; ++c) {
			val[r][c] = idx.get(val[r][c]);
		}
	}

	int q;
	cin &gt;&gt; q;
	for (int i = 0; i &lt; q; ++i) {
		int x1, y1, x2, y2;
		scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2);
		if (x1 &gt; x2)
			swap(x1, x2);
		if (y1 &gt; y2)
			swap(y1, y2);
		--x1, --y1;
		rects[x1 / sqrtN].push_back(Rect(x1, y1, x2, y2, i));
	}

	for (int it = 0; it &lt; sqrtN; ++it) {
		vector&lt;Rect&gt;&amp;rs = rects[it];
		if (rs.empty())
			continue;
		sort(rs.begin(), rs.end());
		ans = 0;
		memset(cnt, 0, sizeof cnt);

		//init rs[0]
		Rect st = rs[0];
		for (int r = st.x1; r &lt; st.x2; ++r) {
			for (int c = st.y1; c &lt; st.y2; ++c) {
				addIt(val[r][c]);
			}
		}
		result[st.id] = ans;

		for (int i = 1; i &lt; rs.size(); ++i) {
			//update form rs[i-1] to rs[i]
			static int xs[4], ys[4];
			Rect p = rs[i - 1], c = rs[i];
			xs[0] = p.x1, xs[1] = p.x2, xs[2] = c.x1, xs[3] = c.x2;
			ys[0] = p.y1, ys[1] = p.y2, ys[2] = c.y1, ys[3] = c.y2;
			sort(xs, xs + 4);
			sort(ys, ys + 4);

			for (int ix = 0; ix &lt; 3; ++ix) {
				for (int iy = 0; iy &lt; 3; ++iy) {
					int x1 = xs[ix], x2 = xs[ix + 1], y1 = ys[iy], y2 = ys[iy + 1];
					bool inP = p.contain(x1, y1, x2, y2);
					bool inC = c.contain(x1, y1, x2, y2);
					if (inP) {
						if (!inC)
							delRect(x1, y1, x2, y2);
					} else {
						if (inC)
							addRect(x1, y1, x2, y2);
					}
				}
			}

			result[c.id] = ans;
		}
	}

	for (int i = 0; i &lt; q; ++i) {
		printf("%d\n", result[i]);
	}
	return 0;
}
</pre><pre></pre><h2>Problem2640</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;cassert&gt;
#include &lt;map&gt;
using namespace std;

const double EPS = 1e-8;
const double PI = acos(-1.0);
const int MAX_N = 50000 + 10;

inline int sign(double a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}

struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
			x(_x), y(_y) {
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	Point operator*(double d) const {
		return Point(x * d, y * d);
	}
	Point operator/(double d) const {
		return Point(x / d, y / d);
	}
	bool operator&lt;(const Point&amp;p) const {
		int c = sign(x - p.x);
		if (c)
			return c == -1;
		return sign(y - p.y) == -1;
	}
	double dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	double det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	double alpha() const {
		return atan2(y, x);
	}
	double distTo(const Point&amp;p) const {
		double dx = x - p.x, dy = y - p.y;
		return hypot(dx, dy);
	}
	double alphaTo(const Point&amp;p) const {
		double dx = x - p.x, dy = y - p.y;
		return atan2(dy, dx);
	}
	void read() {
		scanf("%lf%lf", &amp;x, &amp;y);
	}
	double abs() {
		return hypot(x, y);
	}
	double abs2() {
		return x * x + y * y;
	}
};

const Point O(0, 0);

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))

#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))

Point isSS(Point p1, Point p2, Point q1, Point q2) {
	double a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);
	return (p1 * a2 + p2 * a1) / (a1 + a2);
}

Point pa[MAX_N], pb[MAX_N];
int n;

double as[MAX_N * 2];
double al[MAX_N], ar[MAX_N];
int cnt;

void norm(double&amp;a) {
	while (a &lt; 0)
		a += PI * 2;
	while (a &gt;= PI * 2)
		a -= PI * 2;
	if (fabs(a - PI * 2) &lt;= EPS)
		a = 0;
}

bool doubleEuqal(double a, double b) {
	return sign(a - b) == 0;
}

struct Segment {
	Point a, b;
	int id;
	double dist;
	Segment(Point _a, Point _b, int _id, double _dist) :
			a(_a), b(_b), id(_id), dist(_dist) {
	}
	bool operator&lt;(const Segment&amp;o) const {
		return dist &lt; o.dist;
	}
	Segment() {
	}
};

vector&lt;Segment&gt; here[MAX_N * 2];

struct Tree {
	int l, r;
	Point pa, pb, pd;
	double d;
	vector&lt;Segment&gt; segments;

	Tree*pl, *pr;

	Tree(int _l, int _r) :
			l(_l), r(_r) {
		d = (as[l] + as[r]) / 2;
		pd = Point(cos(d), sin(d)) * 100;
		if (l + 1 == r)
			return;
		pl = new Tree(l, l + r &gt;&gt; 1);
		pr = new Tree(l + r &gt;&gt; 1, r);
	}

	Segment get(Point a, Point b, int id) {
		Point is = isSS(O, pd, a, b);
		double my = is.abs2();
		return Segment(a, b, id, my);
	}

	void reset(Segment&amp;a) {
		a.dist = isSS(O, pd, a.a, a.b).abs2();
	}

	void insert(int L, int R, Point a, Point b, int id) {
		if (L &gt;= r || l &gt;= R)
			return;
		if (L &lt;= l &amp;&amp; R &gt;= r) {
			Segment s = get(a, b, id);
			segments.push_back(s);
			sort(segments.begin(), segments.end());
//			int at = segments.size() - 1;
//			while (at &gt; 0 &amp;&amp; segments[at] &lt; segments[at - 1]) {
//				swap(segments[at], segments[at - 1]);
//				--at;
//			}
			if (segments.size() &gt; 3)
				segments.pop_back();
			return;
		}
		pl-&gt;insert(L, R, a, b, id);
		pr-&gt;insert(L, R, a, b, id);
	}

	void put(vector&lt;Segment&gt; ret) {
		for (vector&lt;Segment&gt;::iterator e = ret.begin(); e != ret.end(); ++e) {
			reset(*e);
		}

		static Segment tmp[6];
		int cnt = merge(ret.begin(), ret.end(), segments.begin(), segments.end(), tmp) - tmp;
		cnt = min(cnt, 3);
		ret = vector&lt;Segment&gt;(tmp, tmp + cnt);

		if (l + 1 == r) {
//			cout &lt;&lt; ha &lt;&lt; endl;
			here[l] = ret;
			return;
		}

		pl-&gt;put(ret);
		pr-&gt;put(ret);
	}
}*root;

double area[MAX_N * 2][3];
int who[MAX_N * 2][3];

void prepare() {
	cnt = 0;
	for (int i = 0; i &lt; n; ++i) {
		al[i] = pa[i].alpha();
		ar[i] = pb[i].alpha();
		norm(al[i]), norm(ar[i]);
		if (al[i] &gt; ar[i])
			swap(al[i], ar[i]);
		as[cnt++] = al[i];
		as[cnt++] = ar[i];
	}

	sort(as, as + cnt);
	cnt = unique(as, as + cnt, doubleEuqal) - as;
	as[cnt] = as[0];
//	cout &lt;&lt; cnt &lt;&lt; endl;

	root = new Tree(0, cnt);

	for (int i = 0; i &lt; n; ++i) {
		double l = al[i], r = ar[i];
		int atL = lower_bound(as, as + cnt, l - EPS / 2) - as;
		int atR = lower_bound(as, as + cnt, r - EPS / 2) - as;
//		cout &lt;&lt; " " &lt;&lt; atL &lt;&lt; " " &lt;&lt; atR &lt;&lt; endl;
		if (r - l &lt; PI) {
			root-&gt;insert(atL, atR, pa[i], pb[i], i);
		} else {
			root-&gt;insert(atR, cnt, pa[i], pb[i], i);
			root-&gt;insert(0, atL, pa[i], pb[i], i);
		}
	}
	root-&gt;put(vector&lt;Segment&gt;());

	for (int i = 0; i &lt; cnt; ++i) {
		Point pl = Point(cos(as[i]), sin(as[i])) * 113.2;
		Point pr = Point(cos(as[i + 1]), sin(as[i + 1])) * 113.2;
		int cur = 0;

		for (vector&lt;Segment&gt;::iterator e = here[i].begin(); e != here[i].end(); ++e) {
			Point isL = isSS(O, pl, e-&gt;a, e-&gt;b);
			Point isR = isSS(O, pr, e-&gt;a, e-&gt;b);
			area[i][cur] = fabs(isL.det(isR)) / 2;
			who[i][cur++] = e-&gt;id;
		}
		while (cur &lt; 3) {
			area[i][cur] = 1e100;
			who[i][cur++] = -2;
		}
	}
}

double calc(int f1, int f2) {
	double ret = 0;
	for (int i = 0; i &lt; cnt; ++i) {
		for (int j = 0; j &lt; 3; ++j) {
			int me = who[i][j];
			if (me != f1 &amp;&amp; me != f2) {
				ret += area[i][j];
				break;
			}
		}
		if (ret &gt; 1e99)
			break;
	}
	return ret;
}

void print(double a) {
	if (a &gt; 1e99)
		puts("infinite");
	else
		printf("%0.2lf\n", (double) a);
}

double add[MAX_N];
map&lt;int, double&gt; with[MAX_N];
int per[MAX_N];

bool cmp(int a, int b) {
	return add[a] &gt; add[b];
}

void work() {
	prepare();
	double seen = 0;
	for (int i = 0; i &lt; cnt; ++i) {
		seen += area[i][0];
	}
	print(seen);
	if (seen &gt; 1e99) {
		print(1e100);
		print(1e100);
		return;
	}

	for (int i = 0; i &lt; n; ++i) {
		add[i] = 0;
	}

	for (int i = 0; i &lt; cnt; ++i) {
		if (who[i][1] == -2) {
			print(1e100);
			print(1e100);
			return;
		}
		int a = who[i][0], b = who[i][1];
		add[a] += area[i][1] - area[i][0];
		with[a][b] += area[i][2] - area[i][1];
	}

	double maxAdd = *max_element(add, add + n);
	print(seen + maxAdd);

	for (int i = 0; i &lt; n; ++i) {
		per[i] = i;
	}
	sort(per, per + n, cmp);

	double maxAdd2 = 0;
	for (int i = 0; i &lt; n; ++i) {
		for (map&lt;int, double&gt;::iterator it = with[i].begin(); it != with[i].end(); ++it) {
			maxAdd2 = max(maxAdd2, add[i] + add[it-&gt;first] + it-&gt;second);
		}
		if (i == per[0])
			maxAdd2 = max(maxAdd2, add[i] + add[per[1]]);
		else
			maxAdd2 = max(maxAdd2, add[i] + add[per[0]]);
	}

	print(seen + maxAdd2);
}

void readInput() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		pa[i].read();
		pb[i].read();
	}
}

int main() {
	readInput();
	work();
	return 0;
}
</pre><pre></pre><h2>Problem2640</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;cassert&gt;
#include &lt;map&gt;
using namespace std;

const double EPS = 1e-8;
const double PI = acos(-1.0);
const int MAX_N = 50000 + 10;

inline int sign(double a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}

struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
			x(_x), y(_y) {
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	Point operator*(double d) const {
		return Point(x * d, y * d);
	}
	Point operator/(double d) const {
		return Point(x / d, y / d);
	}
	bool operator&lt;(const Point&amp;p) const {
		int c = sign(x - p.x);
		if (c)
			return c == -1;
		return sign(y - p.y) == -1;
	}
	double dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	double det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	double alpha() const {
		return atan2(y, x);
	}
	double distTo(const Point&amp;p) const {
		double dx = x - p.x, dy = y - p.y;
		return hypot(dx, dy);
	}
	double alphaTo(const Point&amp;p) const {
		double dx = x - p.x, dy = y - p.y;
		return atan2(dy, dx);
	}
	void read() {
		scanf("%lf%lf", &amp;x, &amp;y);
	}
	double abs() {
		return hypot(x, y);
	}
	double abs2() {
		return x * x + y * y;
	}
};

const Point O(0, 0);

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))

#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))

double isSS(Point p1, Point p2, Point q2) {
	double a1 = q2.det(p1), a2 = -q2.det(p2), t = a1 + a2;
	return (p1 * a2 + p2 * a1).abs2() / t / t;
}

Point isSSP(Point p1, Point p2, Point q2) {
	double a1 = q2.det(p1), a2 = -q2.det(p2);
	return (p1 * a2 + p2 * a1) / (a1 + a2);
}

Point pa[MAX_N], pb[MAX_N];
int n;

double as[MAX_N * 2];
double al[MAX_N], ar[MAX_N];
int cnt;

void norm(double&amp;a) {
	while (a &lt; 0)
		a += PI * 2;
	while (a &gt;= PI * 2)
		a -= PI * 2;
	if (fabs(a - PI * 2) &lt;= EPS)
		a = 0;
}

bool doubleEuqal(double a, double b) {
	return sign(a - b) == 0;
}

struct Segment {
	Point a, b;
	int id;
	double dist;
	Segment(Point _a, Point _b, int _id, double _dist) :
			a(_a), b(_b), id(_id), dist(_dist) {
	}
	bool operator&lt;(const Segment&amp;o) const {
		return dist &lt; o.dist;
	}
	Segment() {
	}
};

Segment here[MAX_N * 2][3];

struct Tree {
	int l, r;
	Point pa, pb, pd;
	double d;
	Segment segments[4];
	int n;

	Tree*pl, *pr;

	Tree(int _l, int _r) :
			l(_l), r(_r) {
		d = (as[l] + as[r]) / 2;
		pd = Point(cos(d), sin(d)) * 100;
		n = 0;
		if (l + 1 == r)
			return;
		pl = new Tree(l, l + r &gt;&gt; 1);
		pr = new Tree(l + r &gt;&gt; 1, r);
	}

	Segment get(Point a, Point b, int id) {
		return Segment(a, b, id, isSS(a, b, pd));
	}

	void reset(Segment&amp;a) {
		a.dist = isSS(a.a, a.b, pd);
	}

	void insert(int L, int R, Point a, Point b, int id) {
		if (L &gt;= r || l &gt;= R)
			return;
		if (L &lt;= l &amp;&amp; R &gt;= r) {
			Segment s = get(a, b, id);
			segments[n++] = s;
//			sort(segments.begin(), segments.end());
			int at = n - 1;
			while (at &gt; 0 &amp;&amp; segments[at] &lt; segments[at - 1]) {
				swap(segments[at], segments[at - 1]);
				--at;
			}
			if (n &gt; 3)
				n = 3;
			return;
		}
		pl-&gt;insert(L, R, a, b, id);
		pr-&gt;insert(L, R, a, b, id);
	}

	void put(Segment ret[3]) {
		for (int i = 0; i &lt; 3; ++i) {
			if (ret[i].dist &lt; 1e99)
				reset(ret[i]);
		}

		static Segment tmp[6];
		merge(ret, ret + 3, segments, segments + n, tmp);
		for (int i = 0; i &lt; 3; ++i) {
			ret[i] = tmp[i];
		}

		if (l + 1 == r) {
//			cout &lt;&lt; ha &lt;&lt; endl;
			for (int i = 0; i &lt; 3; ++i) {
				here[l][i] = ret[i];
			}
			return;
		}

		Segment copy[3];
		for (int i = 0; i &lt; 3; ++i) {
			copy[i] = ret[i];
		}
		pl-&gt;put(ret);
		pr-&gt;put(copy);
	}
}*root;

double area[MAX_N * 2][3];
int who[MAX_N * 2][3];

void prepare() {
	cnt = 0;
	for (int i = 0; i &lt; n; ++i) {
		al[i] = pa[i].alpha();
		ar[i] = pb[i].alpha();
		norm(al[i]), norm(ar[i]);
		if (al[i] &gt; ar[i])
			swap(al[i], ar[i]);
		as[cnt++] = al[i];
		as[cnt++] = ar[i];
	}

	sort(as, as + cnt);
	cnt = unique(as, as + cnt, doubleEuqal) - as;
	as[cnt] = as[0];
//	cout &lt;&lt; cnt &lt;&lt; endl;

	root = new Tree(0, cnt);

	for (int i = 0; i &lt; n; ++i) {
		double l = al[i], r = ar[i];
		int atL = lower_bound(as, as + cnt, l - EPS / 2) - as;
		int atR = lower_bound(as, as + cnt, r - EPS / 2) - as;
//		cout &lt;&lt; " " &lt;&lt; atL &lt;&lt; " " &lt;&lt; atR &lt;&lt; endl;
		if (r - l &lt; PI) {
			root-&gt;insert(atL, atR, pa[i], pb[i], i);
		} else {
			root-&gt;insert(atR, cnt, pa[i], pb[i], i);
			root-&gt;insert(0, atL, pa[i], pb[i], i);
		}
	}
	Segment ret[3];
	for (int i = 0; i &lt; 3; ++i) {
		ret[i].dist = 1e100;
	}
	root-&gt;put(ret);

	for (int i = 0; i &lt; cnt; ++i) {
		Point pl = Point(cos(as[i]), sin(as[i])) * 113.2;
		Point pr = Point(cos(as[i + 1]), sin(as[i + 1])) * 113.2;
		int cur = 0;

		for (int j = 0; j &lt; 3; j++) {
			Segment&amp;s = here[i][j];
			if (s.dist &gt; 1e99) {
				area[i][cur] = 1e100;
				who[i][cur++] = -2;
				continue;
			}
			Point isL = isSSP(s.a, s.b, pl);
			Point isR = isSSP(s.a, s.b, pr);
			area[i][cur] = fabs(isL.det(isR)) / 2;
			who[i][cur++] = s.id;
		}
	}
}

double calc(int f1, int f2) {
	double ret = 0;
	for (int i = 0; i &lt; cnt; ++i) {
		for (int j = 0; j &lt; 3; ++j) {
			int me = who[i][j];
			if (me != f1 &amp;&amp; me != f2) {
				ret += area[i][j];
				break;
			}
		}
		if (ret &gt; 1e99)
			break;
	}
	return ret;
}

void print(double a) {
	if (a &gt; 1e99)
		puts("infinite");
	else
		printf("%0.2lf\n", a);
}

double add[MAX_N];
map&lt;int, double&gt; with[MAX_N];
int per[MAX_N];

bool cmp(int a, int b) {
	return add[a] &gt; add[b];
}

void work() {
	prepare();
	double seen = 0;
	for (int i = 0; i &lt; cnt; ++i) {
		seen += area[i][0];
	}
	print(seen);
	if (seen &gt; 1e99) {
		print(1e100);
		print(1e100);
		return;
	}

	for (int i = 0; i &lt; n; ++i) {
		add[i] = 0;
	}

	for (int i = 0; i &lt; cnt; ++i) {
		if (who[i][1] == -2) {
			print(1e100);
			print(1e100);
			return;
		}
		int a = who[i][0], b = who[i][1];
		add[a] += area[i][1] - area[i][0];
		with[a][b] += area[i][2] - area[i][1];
	}

	double maxAdd = *max_element(add, add + n);
	print(seen + maxAdd);

	for (int i = 0; i &lt; n; ++i) {
		per[i] = i;
	}
	sort(per, per + n, cmp);

	double maxAdd2 = 0;
	for (int i = 0; i &lt; n; ++i) {
		for (map&lt;int, double&gt;::iterator it = with[i].begin(); it != with[i].end(); ++it) {
			maxAdd2 = max(maxAdd2, add[i] + add[it-&gt;first] + it-&gt;second);
		}
		if (i == per[0])
			maxAdd2 = max(maxAdd2, add[i] + add[per[1]]);
		else
			maxAdd2 = max(maxAdd2, add[i] + add[per[0]]);
	}

	print(seen + maxAdd2);
}

void readInput() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		pa[i].read();
		pb[i].read();
	}
}

int main() {
	readInput();
	work();
	return 0;
}
</pre><pre></pre><h2>Problem2650</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 1000000 + 10;
const int BIG = 1000000 + 10;
typedef long long int64;

int64 h[MAX_N], c;
int stack[MAX_N], top;
int64 dp[MAX_N];
int64 sum[MAX_N], sumSqr[MAX_N];
int n;

const int64 INF = LONG_LONG_MAX / 4;

int64 funcMin(int64 a, int64 b, int64 c, int64 mn, int64 mx) {
    int64 ret = INF;
    int64 top = -b / (2 * a);
    for (int i = 0; i &lt; 2; ++i) {
        if (top &gt;= mn &amp;&amp; top &lt;= mx)
            ret = min(ret, (a * top + b) * top + c);
        ++top;
    }
    ret = min(ret, min((a * mn + b) * mn + c, (a * mx + b) * mx + c));
    return ret;
}

struct Tree {
    int64 maxv;
    Tree*ch[2];
    int l, r;
    Tree(int64 seq[], int _l, int _r) :
            l(_l), r(_r) {
        if (l + 1 == r) {
            maxv = seq[l];
            return;
        }
        ch[0] = new Tree(seq, l, l + r &gt;&gt; 1);
        ch[1] = new Tree(seq, l + r &gt;&gt; 1, r);
        maxv = max(ch[0]-&gt;maxv, ch[1]-&gt;maxv);
    }

    int64 ask(int L, int R) {
        if (R &lt;= l || r &lt;= L)
            return INT_MIN;
        if (L &lt;= l &amp;&amp; R &gt;= r)
            return maxv;
        return max(ch[0]-&gt;ask(L, R), ch[1]-&gt;ask(L, R));
    }
}*root;

int64 calc(int a, int b) {
    if (a == b - 1)
        return c * llabs(h[b] - h[a]);
    int64 mn = root-&gt;ask(a + 1, b) + 1;
    int64 mx = min(h[a], h[b]);
    int64 A = b - a - 1, B = -2 * (sum[b - 1] - sum[a]), C = sumSqr[b - 1] - sumSqr[a];
    if (a != 0)
        B -= c, C += h[a] * c;
    if (b != n + 1)
        B -= c, C += h[b] * c;
    return funcMin(A, B, C, mn, mx);
}

int main() {
    cin &gt;&gt; n &gt;&gt; c;
    h[0] = h[n + 1] = BIG;

    sum[0] = sumSqr[0] = 0;
    for (int i = 1; i &lt;= n; ++i) {
        int x;
        scanf("%d", &amp;x);
        h[i] = x;
        sum[i] = sum[i - 1] + h[i];
        sumSqr[i] = sumSqr[i - 1] + h[i] * h[i];
    }

    top = 0, stack[top++] = 0, stack[top++] = 1;
    dp[1] = 0;

    root = new Tree(h, 0, n + 2);
    for (int i = 2; i &lt;= n + 1; ++i) {
        dp[i] = dp[i - 1] + (i == n + 1 ? 0 : c * llabs(h[i] - h[i - 1]));
        while (h[stack[top - 1]] &lt; h[i]) {
            dp[i] = min(dp[i], dp[stack[top - 1]] + calc(stack[top - 1], i));
            --top;
        }
        dp[i] = min(dp[i], dp[stack[top - 1]] + calc(stack[top - 1], i));
        if (h[stack[top - 1]] == h[i])
            --top;
        stack[top++] = i;
    }
    cout &lt;&lt; dp[n + 1] &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem2651</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define OK cout&lt;&lt;"-----------------"&lt;&lt;endl;
using namespace std;
const int MaxVet = 300000 + 100, Inf = ~0U &gt;&gt; 3;
;

struct TGraph {
    static const int MaxEdge = MaxVet * 2;
    int head[MaxVet], Vet;
    int next[MaxEdge], dest[MaxEdge], Mnt;

    void Clear(int _Vet) {
        Vet = _Vet;
        memset(head, -1, sizeof(int) * Vet);
        Mnt = 0;
    }

    void AddEdge(int s, int t) {
        next[Mnt] = head[s];
        dest[Mnt] = t;
        head[s] = Mnt++;
    }

    void InsEdge(int s, int t) {
        AddEdge(s, t);
        AddEdge(t, s);
    }
};
#define tr(e,G,u) for(int e=G.head[u];e!=-1;e=G.next[e])

TGraph Tree;

inline void Scan_Int(int&amp;t) {
    char c;
    while (c = getchar(), c &lt; '0' || c &gt; '9')
        ;
    t = c - '0';
    while (c = getchar(), c &gt;= '0' &amp;&amp; c &lt;= '9')
        t = t * 10 + c - '0';
}

void Input_Data() {
    int Vet, s, t;
    Scan_Int(Vet);
    Tree.Clear(Vet);

    rep(i,Vet-1) {
        Scan_Int(s);
        Scan_Int(t);
        --s;
        --t;
        Tree.InsEdge(s, t);
    }
}

int Ord[MaxVet], Father[MaxVet];
int Vis[MaxVet] = { }, Flag = 0;

int BFS(int*Q, int vs, int cut = -1) //return the last point
        {
    ++Flag;

    int h = 0, t = 0;
    Q[t++] = vs;
    Vis[vs] = Flag;
    Father[vs] = -1;
    if (cut &gt;= 0)
        Vis[cut] = Flag;

    for (; h &lt; t; h++) {
        int u = Q[h];
        tr(e,Tree,u) {
            int v = Tree.dest[e];
            if (Vis[v] == Flag)
                continue;
            Vis[v] = Flag;
            Q[t++] = v;
            Father[v] = u;
        }
    }

    return Q[t - 1];
}

struct DistSet {
    static const int MaxSaved = 3;
    int A[MaxSaved + 1];

    void Clear() {
        rep(i,MaxSaved)
            A[i] = 0;
    }

    void Add_Item(int x) {
        for (int i = MaxSaved - 1; i &gt;= 0; i--) {
            if (x &gt; A[i]) {
                A[i + 1] = A[i];
            } else {
                A[i + 1] = x;
                return;
            }
        }
        A[0] = x;
    }

    int Get_Result_Two(int dist = -1) {
        int ret = A[0] + A[1] + A[2];
        if (A[0] == dist)
            return ret - A[0];
        if (A[1] == dist)
            return ret - A[1];
        return ret - A[2];
    }

    int Get_Result_One(int dist) {
        if (A[0] == dist)
            return A[1];
        return A[0];
    }

    int Get_Max() {
        return A[0];
    }
};

DistSet Sets[MaxVet];

int LongestPathDown[MaxVet];
int LongestPathUp[MaxVet];
int MaxDistUp[MaxVet];

void Calc_DistSet() {
    for (int it = Tree.Vet - 1; it &gt;= 0; it--) {
        int u = Ord[it];
        DistSet&amp;Set = Sets[u];
        Set.Clear();

        tr(e,Tree,u) {
            int v = Tree.dest[e];
            if (v == Father[u])
                continue;
            Set.Add_Item(Sets[v].Get_Max() + 1);
        }
    }
}

inline void UpdateMax(int&amp;x, int c) {
    if (x &lt; c)
        x = c;
}

int FindPoint(int u, int fa) {
    static int Path[MaxVet], Cnt;

    int v = BFS(Ord, u, fa);
    int w = BFS(Ord, v, fa);
    Cnt = 0;
    do {
        Path[Cnt++] = w;
        w = Father[w];
    } while (w != -1);

    //cout&lt;&lt;"Max Len is:"&lt;&lt;Cnt-1&lt;&lt;endl;

    return Path[Cnt / 2];
}

DistSet RetSets[MaxVet];
void Dp() {
    //Calc the Down
    for (int it = Tree.Vet - 1; it &gt;= 0; it--) {
        int u = Ord[it];
        LongestPathDown[u] = Sets[u].Get_Result_Two();

        RetSets[u].Clear();
        tr(e,Tree,u) {
            int v = Tree.dest[e];
            if (v == Father[u])
                continue;

            RetSets[u].Add_Item(LongestPathDown[v]);
            UpdateMax(LongestPathDown[u], LongestPathDown[v]);
        }
    }

    //Calc The Up
    for (int it = 0; it &lt; Tree.Vet; it++) {
        int u = Ord[it];
        int fa = Father[u];

        if (fa != -1) {
            LongestPathUp[u] = LongestPathUp[fa];

            MaxDistUp[u] = MaxDistUp[fa] + 1;
            UpdateMax(MaxDistUp[u], Sets[fa].Get_Result_One(Sets[u].Get_Max() + 1) + 1);

            UpdateMax(LongestPathUp[u],
                    MaxDistUp[fa] + Sets[fa].Get_Result_One(Sets[u].Get_Max() + 1));
            UpdateMax(LongestPathUp[u], Sets[fa].Get_Result_Two(Sets[u].Get_Max() + 1));
            UpdateMax(LongestPathUp[u], RetSets[fa].Get_Result_One(LongestPathDown[u]));
        } else {
            LongestPathUp[u] = 0;
            MaxDistUp[u] = 0;
        }
    }

    //Calc Ans
#define half(x) (((x)+1)/2)
    int ans = Inf;
    int how;
    rep(u,Tree.Vet) {
        //cout&lt;&lt;u+1&lt;&lt;":"&lt;&lt;LongestPathUp[u]&lt;&lt;endl;
        int fa = Father[u];
        if (fa == -1)
            continue;

        int UpMax = LongestPathUp[u];
        int DownMax = LongestPathDown[u];

        int ret = 0;
        UpdateMax(ret, UpMax);
        UpdateMax(ret, DownMax);
        UpdateMax(ret, half(UpMax) + half(DownMax) + 1);

        if (ret &lt; ans) {
            ans = ret;
            how = u;
        }
    }
    int fa = Father[how];
    printf("%d\n", ans);
    printf("%d %d\n", how + 1, fa + 1);
    printf("%d ", FindPoint(how, fa) + 1);
    printf("%d\n", FindPoint(fa, how) + 1);
}

void Work() {
    BFS(Ord, 0);
    Calc_DistSet();
    Dp();
}

void Solve() {
    Input_Data();
    Work();
}

int main() {
    //freopen("in","r",stdin);
    Solve();
}
</pre><pre></pre><h2>Problem2652</h2><pre>/*
 * p3.cpp
 *
 *  Created on: 2012-4-1
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_N = 100000 + 10;

typedef long long int64;

const int64 INF = 1LL &lt;&lt; 60;

struct Data {
    int a[MAX_N * 4], n;
    int pw;
    int64*ref;

    void init(int _n, int64*_ref) {
        n = _n;
        pw = 1;
        while (pw &lt;= n + 3)
            pw &lt;&lt;= 1;
        ref = _ref;
        ref[n] = INF;
        fill(a, a + pw * 2, n);
    }

    int get(int a, int b) {
        return ref[a] &lt; ref[b] ? a : b;
    }

    void modify(int p, int x) {
        a[p += 1 + pw] = x;
        for (p &gt;&gt;= 1; p; p &gt;&gt;= 1)
            a[p] = get(a[p + p], a[p + p + 1]);
    }

    int ask(int l, int r) {
        l += pw, r += pw + 2;
        int ret = n;
        for (; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) {
            if (~l &amp; 1)
                ret = get(ret, a[l ^ 1]);
            if (r &amp; 1)
                ret = get(ret, a[r ^ 1]);
        }
        return ret;
    }
};

struct Data2 {
    Data tree;

    int64 a; //(x,y) -&gt; (ax+y,y-ax)
    int64 x[MAX_N], y[MAX_N];
    int n;

    void clear() {
        n = 0;
    }

    void initPoint(int64 X, int64 Y) {
        x[n] = a * X + Y;
        y[n] = Y - a * X;
        ++n;
    }

    int64 xs[MAX_N];
    int xId[MAX_N], xRange[MAX_N];
    pair&lt;int64, int&gt; ps[MAX_N];

    void doIt() {
        for (int i = 0; i &lt; n; ++i) {
            ps[i] = make_pair(x[i], i);
        }
        sort(ps, ps + n);
        for (int i = 0; i &lt; n; ++i) {
            xs[i] = ps[i].first;
            xId[ps[i].second] = i;
        }

        for (int i = 0; i &lt; n; ++i) {
            xRange[i] = upper_bound(xs, xs + n, x[i]) - xs - 1;
        }
        tree.init(n, y);

        for (int i = 0; i &lt; n; ++i) {
            tree.modify(xId[i], i);
        }
    }

    void addPoint(int id) {
        tree.modify(xId[id], id);
    }

    void delPoint(int id) {
        tree.modify(xId[id], n);
    }

    int getControledPoint(int id) {
        int me = tree.ask(0, xRange[id]);
        if (y[me] &lt;= y[id])
            return me;
        else
            return -1;
    }
};

Data2 wide, narrow;

const int NARROW = 0, WIDE = 1;

int x[MAX_N], y[MAX_N], type[MAX_N];

const int BAD = 0, SEEN = 1, UNSEEN = 2;

int n;
int state[MAX_N];

void readInput() {
    scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; ++i) {
        scanf("%d%d", x + i, y + i);
        scanf(" ");
        char ch;
        scanf("%c", &amp;ch);
        type[i] = ch == 'W' ? WIDE : NARROW;
    }
}

void work() {
    wide.a = 1;
    narrow.a = 2;
    wide.clear();
    narrow.clear();

    for (int i = 0; i &lt; n; ++i) {
        wide.initPoint(x[i], y[i]);
        narrow.initPoint(x[i], y[i]);
    }

    wide.doIt();
    narrow.doIt();

    for (int i = 0; i &lt; n; ++i) {
        state[i] = UNSEEN;
    }

    int seen = 0;

    for (int i = 0; i &lt; n; ++i) {
        if (state[i] == BAD) {
            puts("FAIL");
            continue;
        }
        Data2&amp;ref = type[i] == WIDE ? wide : narrow;
        for (;;) {
            int who = ref.getControledPoint(i);
            if (who == -1)
                break;
            if (state[who] == SEEN)
                --seen;
            state[who] = BAD;

            wide.delPoint(who);
            narrow.delPoint(who);
        }

        state[i] = SEEN;
        ++seen;
        wide.addPoint(i);
        narrow.addPoint(i);
        printf("%d\n", seen);
    }
}

int main() {
//  int nT;
//  cin &gt;&gt; nT;
//  for (int i = 0; i &lt; nT; ++i) {
    readInput();
    work();
//  }
    return 0;
}
</pre><pre></pre><h2>Problem2653</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
using namespace std;

struct Info {
	int sum, maxl, maxr;
	Info(int v) {
		sum = v;
		maxl = maxr = v;
	}
	Info() {
	}
};

Info operator+(const Info&amp;l, const Info&amp;r) {
	Info ret;
	ret.sum = l.sum + r.sum;
	ret.maxl = max(l.maxl, l.sum + max(r.maxl, 0));
	ret.maxr = max(r.maxr, r.sum + max(l.maxr, 0));
	return ret;
}

struct Tree {
	int l, r;
	Tree*pl, *pr;
	Info v;
	Tree(int _l, int _r, Tree*_pl, Tree*_pr) :
			l(_l), r(_r), pl(_pl), pr(_pr) {
		v = pl-&gt;v + pr-&gt;v;
	}
	Tree(int _l, int _r, int all) :
			l(_l), r(_r) {
		if (l + 1 == r) {
			v = Info(all);
			return;
		}
		pl = new Tree(l, l + r &gt;&gt; 1, all);
		pr = new Tree(l + r &gt;&gt; 1, r, all);
		v = pl-&gt;v + pr-&gt;v;
	}

	Info ask(int L, int R) {
		if (L &lt;= l &amp;&amp; R &gt;= r)
			return v;
		int m = (l + r) &gt;&gt; 1;
		if (L &gt;= m)
			return pr-&gt;ask(L, R);
		else if (R &lt;= m)
			return pl-&gt;ask(L, R);
		else
			return pl-&gt;ask(L, R) + pr-&gt;ask(L, R);
	}

	Tree*change(int at, int w) {
		if (l + 1 == r) {
			return new Tree(l, r, w);
		}
		int m = (l + r) &gt;&gt; 1;
		if (at &lt; m)
			return new Tree(l, r, pl-&gt;change(at, w), pr);
		else
			return new Tree(l, r, pl, pr-&gt;change(at, w));
	}
};

const int MAX_N = 50000 + 10;
int a[MAX_N], n;
pair&lt;int, int&gt; ps[MAX_N];
Tree*root[MAX_N];

bool check(int v, int a, int b, int c, int d) { //[a,b) [c,d)
	Tree*rt = root[v];
	return rt-&gt;ask(a, b).maxr + (b &lt; c ? rt-&gt;ask(b, c).sum : 0) + rt-&gt;ask(c, d).maxl &gt;= 0;
}

int main() {
	scanf("%d", &amp;n);
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", a + i);
		ps[i] = make_pair(a[i], i);
	}
	sort(ps, ps + n);
	root[0] = new Tree(0, n, 1);
	for (int i = 1; i &lt; n; ++i) {
		root[i] = root[i - 1]-&gt;change(ps[i - 1].second, -1);
	}
	int nQ, last = 0;
	scanf("%d", &amp;nQ);
	for (int i = 0; i &lt; nQ; ++i) {
		int q[4];
		for (int j = 0; j &lt; 4; ++j) {
			scanf("%d", q + j);
			(q[j] += last) %= n;
		}
		sort(q, q + 4);
		int l = 0, r = n;
		while (l + 1 &lt; r) {
			int m = (l + r) &gt;&gt; 1;
			if (check(m, q[0], q[1] + 1, q[2], q[3] + 1))
				l = m;
			else
				r = m;
		}
		printf("%d\n", ps[l].first);
		last = ps[l].first;
	}
	return 0;
}
</pre><pre></pre><h2>Problem2654</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;
const int MAX_N = 50000;
const int MAX_M = 100000 + 10;
//max value is 100
int nV, nE;
struct Edge {
	int s, t, c, col;
	int cost;
	void read() {
		scanf("%d%d%d%d", &amp;s, &amp;t, &amp;c, &amp;col);
		cost = c;
	}
	bool operator&lt;(const Edge&amp;e) const {
		return cost != e.cost ? cost &lt; e.cost : col &lt; e.col;
	}
};
vector&lt;Edge&gt; white, black;
Edge mst[MAX_N];
int father[MAX_N];
int find(int x) {
	return father[x] == x ? x : father[x] = find(father[x]);
}

int sum;

int eval(int a) {
	for (vector&lt;Edge&gt;::iterator e = white.begin(); e != white.end(); ++e) {
		e-&gt;cost = e-&gt;c + a;
	}
	static Edge ord[MAX_M];
	merge(white.begin(), white.end(), black.begin(), black.end(), ord);
	for (int i = 0; i &lt; nV; ++i) {
		father[i] = i;
	}
	int cnt = 0;
	sum = 0;
	for (int i = 0; i &lt; nE; ++i) {
		Edge&amp;e = ord[i];
		int a = find(e.s), b = find(e.t);
		if (a == b)
			continue;
		father[a] = b;
		sum += e.cost;
		if (e.col == 0)
			cnt++;
	}
	return cnt;
}

int need;

int main() {
	scanf("%d%d%d", &amp;nV, &amp;nE, &amp;need);
	for (int i = 0; i &lt; nE; ++i) {
		Edge e;
		e.read();
		if (e.col)
			black.push_back(e);
		else
			white.push_back(e);
	}

	sort(black.begin(), black.end());
	sort(white.begin(), white.end());

	int l = -101, r = 101;
	while (l + 1 &lt; r) {
		int m = (l + r) / 2;
		if (eval(m) &gt;= need)
			l = m;
		else
			r = m;
	}
	eval(l);
	//cerr &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl;
	cout &lt;&lt; sum - need * l &lt;&lt; endl;
	//cerr &lt;&lt; eval(l) &lt;&lt; " " &lt;&lt; eval(r) &lt;&lt; endl;

	return 0;
}</pre><pre></pre><h2>Problem2655</h2><pre>/*
 * calc.cpp
 *
 *  Created on: 2012-2-16
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
int A, MOD, n; //A&lt;=10^9
typedef long long ll;
const int MAX_N = 1000 + 10;
//mod is a prime number

typedef long long int64;

struct Int {
	int x;
	Int() :
			x(0) {
	}
	Int(int _x) :
			x(_x) {
		x %= MOD;
		if (x &lt; 0)
			x += MOD;
	}
	Int(int64 _x) :
			x(_x) {
		x %= MOD;
		if (x &lt; 0)
			x += MOD;
	}
	static Int get(int x) {
		Int a;
		a.x = x;
		return a;
	}

	Int operator+(const Int&amp;o) const {
		int t = x + o.x;
		if (t &gt;= MOD)
			t -= MOD;
		return get(t);
	}
	Int operator*(const Int&amp;o) const {
		return get(1LL * x * o.x % MOD);
	}
	Int operator-(const Int&amp;o) const {
		int t = x - o.x;
		if (t &lt; 0)
			t += MOD;
		return get(t);
	}
	Int operator/(const Int&amp;o) const {
		return (*this) * o.inv();
	}
	Int&amp;operator+=(const Int&amp;o) {
		return (*this) = *this + o;
	}
	Int&amp;operator-=(const Int&amp;o) {
		return (*this) = *this - o;
	}
	Int&amp;operator*=(const Int&amp;o) {
		return (*this) = *this * o;
	}
	Int&amp;operator/=(const Int&amp;o) {
		return (*this) = *this / o;
	}

	Int power(int64 n) const {
		if (!n)
			return get(1);
		const Int&amp;a = *this;
		if (n &amp; 1)
			return power(n - 1) * a;
		else
			return (a * a).power(n &gt;&gt; 1);
	}

	Int inv() const {
		return power(MOD - 2);
	}
};

Int ans;
Int sum[MAX_N]; //sum[i]=0^i+1^i+...(A)^i

//mod&gt;A&gt;n+1

void prepare() {
	static Int y[MAX_N], pw[MAX_N];
	static Int den[MAX_N];
	static Int inv1[MAX_N * 2];
	static Int inv2[MAX_N];
	static Int num = 1;
	for (int i = 0; i &lt;= n * 2 + 5; ++i) {
		inv1[i] = Int(1) / (i - n - 2);
		inv2[i] = Int(1) / (A - i);
	}
	for (int i = 0; i &lt;= n + 1; ++i) {
		pw[i] = 1;
		den[i] = 1;
		for (int j = 0; j &lt;= n + 1; ++j) {
			if (i != j)
				den[i] = den[i] * inv1[i - j + n + 2];
		}
		num *= A - i;
	}
	for (int i = 0; i &lt;= n; ++i) {
		partial_sum(pw, pw + n + 2, y);
		sum[i] = 0;
		for (int x = 0; x &lt;= n + 1; ++x) {
			sum[i] += num * inv2[x] * den[x] * y[x];
		}
		for (int x = 0; x &lt;= n + 1; ++x) {
			pw[x] = pw[x] * x;
		}
	}
}

Int connect[MAX_N][2], all[MAX_N][2];
Int comb[MAX_N][MAX_N];
Int pow2[MAX_N * MAX_N];

Int dp[MAX_N][2];

int calc() {
	for (int i = 0; i &lt;= n; ++i) {
		comb[i][0] = comb[i][i] = 1;
		for (int j = 1; j &lt; i; ++j) {
			comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]);
		}
	}
	pow2[0] = 1;
	for (int i = 1; i &lt;= n * n; ++i) {
		pow2[i] = pow2[i - 1] * 2;
	}
	connect[1][0] = all[1][0] = 1;
	for (int i = 2; i &lt;= n; ++i) {
		all[i][0] = all[i][1] = pow2[i * (i - 1) / 2 - 1];
	}
	for (int i = 2; i &lt;= n; ++i) {
		for (int j = 0; j &lt; 2; ++j) {
			Int cur = all[i][j];
			for (int with = 1; with &lt; i; ++with) {
				for (int k = 0; k &lt; 2; ++k) {
					cur -= comb[i - 1][with - 1] * connect[with][k] * all[i - with][j ^ k];
				}
			}
			connect[i][j] = cur;
		}
	}
	dp[n][0] = 1;
	for (int i = n; i &gt;= 0; --i) {
		for (int j = 0; j &lt; 2; ++j) {
			for (int with = 1; with &lt;= i; ++with) {
				for (int k = 0; k &lt; 2; ++k) {
					dp[i - with][j ^ k] += dp[i][j] * comb[i - 1][with - 1] * connect[with][k]
							* sum[with];
				}
			}
		}
	}
	return (dp[0][0] - dp[0][1]).x;
}

int main() {
	cin &gt;&gt; A &gt;&gt; n &gt;&gt; MOD;
	prepare();
	cout &lt;&lt; calc() &lt;&lt; endl;
	return 0;

}
</pre><pre></pre><h2>Problem2655</h2><pre>/*
 * calc.cpp
 *
 *  Created on: 2012-4-23
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N = 500 + 10;
typedef long long int64;
int A, n, p;
int64 powMod(int64 a, int64 e) {
    if (!e)
        return 1;
    return e &amp; 1 ? powMod(a, e - 1) * a % p : powMod(a * a % p, e &gt;&gt; 1);
}
int64 inv[MAX_N], rfact[MAX_N];
int64 comb(int n, int m) {
    int64 ret = 1;
    for (int i = 0; i &lt; m; ++i) {
        ret = ret * (n - i) % p * inv[i + 1] % p;
    }
    return ret;
}
inline void modIt(int64&amp;x) {
    if (x &gt;= p)
        x -= p;
}
namespace FAST_MUL {
    const int MAX_N = 1 &lt;&lt; 10;
    static int64 memo[1000000], *cur;
    int64*get(int n) {
        cur += n;
        return cur - n;
    }
    int64* mul(int64 a[], int64 b[], int n) {
        if (n &lt;= 8) {
            int64*c = get(n * 2);
            memset(c, 0, sizeof(int64) * (n * 2));
            for (int i = 0; i &lt; n; ++i) {
                for (int j = 0; j &lt; n; ++j) {
                    c[i + j] += a[i] * b[j];
                }
            }
            for (int i = 0; i &lt; n * 2; ++i) {
                c[i] %= p;
            }
            return c;
        }
        //a=uv,b=xy
        int64*u = get(n / 2), *v = get(n / 2), *x = get(n / 2), *y = get(n / 2);
        memcpy(u, a + n / 2, sizeof(int64) * n / 2);
        memcpy(v, a, sizeof(int64) * n / 2);
        memcpy(x, b + n / 2, sizeof(int64) * n / 2);
        memcpy(y, b, sizeof(int64) * n / 2);
        int64 *ux = mul(u, x, n / 2);
        int64 *vy = mul(v, y, n / 2);
        for (int i = 0; i &lt; n / 2; ++i) {
            modIt(u[i] += v[i]);
            modIt(x[i] += y[i]);
        }
        int64*uvxy = mul(u, x, n / 2);
        for (int i = 0; i &lt; n; ++i) {
            uvxy[i] += p - ux[i];
            modIt(uvxy[i]);
            uvxy[i] += p - vy[i];
            modIt(uvxy[i]);
        }
        int64*r = get(n * 2);
        for (int i = 0; i &lt; n * 2; ++i) {
            r[i] = 0;
        }
        for (int i = 0; i &lt; n; ++i) {
            r[i] += vy[i];
            r[i + n / 2] += uvxy[i];
            r[i + n] += ux[i];
        }
        for (int i = 0; i &lt; n * 2; ++i) {
            r[i] %= p;
        }
        return r;
    }
    void multiply(int64 a[], int64 b[], int64 c[], int n) {
        cur = memo;
        int64 ca[MAX_N], cb[MAX_N];
        int pw = 1;
        while (pw &lt; n)
            pw &lt;&lt;= 1;
        for (int i = 0; i &lt; pw; ++i) {
            ca[i] = i &lt; n ? a[i] : 0;
            cb[i] = i &lt; n ? b[i] : 0;
        }
        int64*cc = mul(ca, cb, pw);
        for (int i = 0; i &lt; n; ++i) {
            c[i] = cc[i];
        }
    }
}
vector&lt;int64&gt; calc(int A) {
    vector&lt;int64&gt; ret(n + 1, 0);
    if (A == 1) {
        ret[0] = ret[1] = 1;
        return ret;
    }
    if (A % 2 == 1) {
        vector&lt;int64&gt; t = calc(A - 1);
        for (int i = 0; i &lt;= n; ++i) {
            ret[i] = t[i];
            if (i &gt; 0)
                (ret[i] += t[i - 1] * A) %= p;
        }
        return ret;
    } else {
        A /= 2;
        vector&lt;int64&gt; a = calc(A);
        static int64 b[MAX_N], pw[MAX_N], rev[MAX_N], rrev[MAX_N];
        pw[0] = 1;
        for (int i = 1; i &lt;= n; ++i) {
            pw[i] = pw[i - 1] * A % p;
        }
        rev[0] = 1;
        for (int i = 1; i &lt;= n; ++i) {
            rev[i] = rev[i - 1] * (A + 1 - i) % p;
        }
        //rev[i]= x \in [0,i) ,(A-i)
        for (int i = 0; i &lt;= n; ++i) {
            rrev[i] = powMod(rev[i], p - 2);
        }
        //comb(A-j,i-j) = A-j*(A-j-1)*(A-j-2)*..(A-i+1)/(i-j)!
        //rev[i]/rev[j]
//      memset(b, 0, sizeof b);
        static int64 ca[MAX_N], cb[MAX_N];
        for (int i = 0; i &lt;= n; ++i) {
            ca[i] = pw[i] * rfact[i] % p;
            cb[i] = a[i] * rrev[i] % p;
        }
        FAST_MUL::multiply(ca, cb, b, n + 1);
//      for (int i = 0; i &lt;= n /*&amp;&amp; i &lt;= A*/; ++i) {
//          b[i] = 0;
//          for (int j = 0; j &lt;= i /*&amp;&amp; j &lt;= A*/; ++j) {
//              b[i] += ca[i - j] * cb[j] % p;
//          }
//          b[i] = b[i] % p * rev[i] % p;
//      }
        for (int i = 0; i &lt;= n; ++i) {
            b[i] = b[i] % p * rev[i] % p;
        }
        static int64 tmp[MAX_N], _a[MAX_N];
        for (int i = 0; i &lt;= n; ++i) {
            _a[i] = a[i];
        }
        FAST_MUL::multiply(_a, b, tmp, n + 1);
        for (int i = 0; i &lt;= n; ++i) {
            ret[i] = tmp[i] % p;
        }
        return ret;
    }
}
int main() {
    cin &gt;&gt; A &gt;&gt; n &gt;&gt; p;
    for (int i = 1; i &lt;= n; ++i) {
        inv[i] = powMod(i, p - 2);
    }
    rfact[0] = 1;
    for (int i = 1; i &lt;= n; ++i) {
        rfact[i] = rfact[i - 1] * inv[i] % p;
    }
    int64 ret = calc(A)[n];
    for (int i = 1; i &lt;= n; ++i) {
        ret = ret * i % p;
    }
    cout &lt;&lt; ret &lt;&lt; endl;
    return 0;
}</pre><pre></pre><h2>Problem2656</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
#define CLR(x,c) memset(x,c,sizeof x) 
using namespace std;

void setIO(string name){
    string in=name+".in";
    string out=name+".out";
    freopen(in.c_str(),"r",stdin);
    freopen(out.c_str(),"w",stdout);
}

const int MAX_L = 120;

struct BigInt{
    int a[MAX_L];
    void clear(){
        CLR(a,0);
    }
    BigInt(){
        clear();
    }
    void set(int x){
        clear();
        a[0]=x;
    }
    int operator%(int x){
        int ret=0;
        for(int i=MAX_L-1;i&gt;=0;--i){
            ret=ret*10+a[i];
            ret%=x;
        }
        return ret;
    }
    void operator/=(int x){
        int c=0;
        for(int i=MAX_L-1;i&gt;=0;--i){
            c=c*10+a[i];
            a[i]=c/x;
            c%=x;
        }
    }
    void operator+=(const BigInt&amp;o){
        int c=0;
        REP(i,MAX_L){
            c+=a[i]+o.a[i];
            a[i]=c%10;
            c/=10;
        }
    }
    void write(){
        for(int i=MAX_L-1;i&gt;=0;--i){
            if(a[i]||!i){
                for(int j=i;j&gt;=0;--j)
                    printf("%d",a[j]);
                return;
            }
        }
    }
    bool isZero(){
        REP(i,MAX_L)
            if(a[i])
                return false;
        return true;
    }
    bool isOne(){
        if(a[0]!=1)
            return false;
        for(int i=1;i&lt;MAX_L;i++)
            if(a[i])
                return false;
        return true;
    }
    void read(){
        clear();
        string s;cin&gt;&gt;s;
        REP(i,s.size()){
            a[s.size()-1-i]=s[i]-'0';
        }
    }
};

void calc(BigInt&amp;k,BigInt&amp;x,BigInt&amp;y){
    //A[k]-&gt;x A[k+1]-&gt;y
//    k.write();
//    puts("");
    if(k.isZero()){
        x.clear();y.clear();
        x.set(0);y.set(1);
        return;
    } else if(k.isOne()){
        x.clear();y.clear();
        x.set(1);y.set(1);
        return;
    } else if(k%2 == 0){
        k/=2;
        calc(k,x,y);
        y+=x;
    } else {
        k/=2;
        calc(k,x,y);
        x+=y;
    }
}

int main(){
    //setIO("sequence");
    int T;
    cin&gt;&gt;T;
    REP(i,T){
        BigInt k,x,y;
        k.read();
        calc(k,x,y);
        x.write();
        puts("");
    }
    return 0;
}</pre><pre></pre><h2>Problem2657</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
#define CLR(x,c) memset(x,c,sizeof x) 
using namespace std;

void setIO(string name){
    string in=name+".in";
    string out=name+".out";
    freopen(in.c_str(),"r",stdin);
    freopen(out.c_str(),"w",stdout);
}

int n;
const int MAX_N=200000+10;
vector&lt;int&gt; edge[MAX_N];
map&lt;pair&lt;int,int&gt; ,int &gt; have;

void addEdge(int a,int b,int me){
    if(a&gt;b)swap(a,b);
    pair&lt;int,int&gt; key = make_pair(a,b);
    if(have.count(key)){
        int with = have[key];
        edge[me].push_back(with);
        edge[with].push_back(me);
    } else {
        have[key]=me;
    }
}

int dist[MAX_N];

void dfs(int u,int par,int d){
    dist[u]=d;
    
    for(vector&lt;int&gt;::iterator e=edge[u].begin();e!=edge[u].end();++e){
        if(*e!=par)
            dfs(*e,u,d+1);        
    }
}

int main(){
    //setIO("journey");
    cin&gt;&gt;n;
    REP(i,n-2){
        int a,b,c;
        scanf("%d%d%d",&amp;a,&amp;b,&amp;c);
        --a,--b,--c;
        addEdge(a,b,i);
        addEdge(a,c,i);
        addEdge(b,c,i);
    }
    dfs(0,-1,0);
    int far=0;
    REP(i,n-2)
        if(dist[i]&gt;dist[far])
            far=i;
    dfs(far,-1,0);
    far=0;
    REP(i,n-2)
        if(dist[i]&gt;dist[far])
            far=i;
    cout&lt;&lt;dist[far]+1&lt;&lt;endl;
    return 0;
}</pre><pre></pre><h2>Problem2658</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
#define CLR(x,c) memset(x,c,sizeof x) 
using namespace std;

void setIO(string name){
    string in=name+".in";
    string out=name+".out";
    freopen(in.c_str(),"r",stdin);
    freopen(out.c_str(),"w",stdout);
}

int n,nR,nC;
const int MAX_N=100000+10;

typedef long long int64;

int num=0;

struct Tree;
void reuse(Tree*a);

struct Tree{
    int l,r,h;//h is relative to it's father
    int64 sum;
    
    Tree*next,*first;
    
    Tree(int _l,int _r,int _h):l(_l),r(_r),h(_h){
        int64 w=r-l+1;
        sum=w*(w+1)/2*h;
        
        next=0;
        first=0;
        
        ++num;
    }
    
    Tree(){
        
        ++num;
    }
    
    
    Tree* set(int _l,int _r,int _h){
        l=_l;r=_r;h=_h;
        int64 w=r-l+1;
        sum=w*(w+1)/2*h;
        
        next=0;
        first=0;
        return this;
    }
    
    void recalcSum(){
        int64 w=r-l+1;
        sum=w*(w+1)/2*h;
        for(Tree*e=first;e;e=e-&gt;next)
            sum+=e-&gt;sum;
    }
    void addH(){
        ++h;
        int64 w=r-l+1;
        sum+=w*(w+1)/2;
    }
    
    void addChild(Tree*c){
        c-&gt;next=first;
        first=c;
        sum+=c-&gt;sum;
    }
    
    void optimize(){
        if(first!=0){
            if(first-&gt;l==l&amp;&amp;first-&gt;r==r){
                reuse(first);
                h+=first-&gt;h;
                first=first-&gt;first;
            }
        }
    }
}*root;

const int MAX_R = 40000+10;

vector&lt;int&gt; byR[MAX_R];

int cnt;

const int BUFFER_SIZE=10000;

Tree*buffer=0,*cur=0;
Tree*stk[BUFFER_SIZE];
int top=0;

void reuse(Tree*a){
//    return;
    if(top&lt;BUFFER_SIZE)
        stk[top++]=a;
}

Tree*get(){
    if(top&gt;0)
        return stk[--top];
    if(!buffer||cur==buffer+BUFFER_SIZE)
        buffer = new Tree[BUFFER_SIZE],cur=buffer;
    return cur++;
}

void splitTree(Tree*rt,int c,Tree*sp[2]){
    ++cnt;
    
    Tree*chsp[2]={};
    
    Tree*prev=0;
    for(Tree*ch=rt-&gt;first;ch;ch=ch-&gt;next){
        if(ch-&gt;l&lt;=c&amp;&amp;ch-&gt;r&gt;=c){
            rt-&gt;sum-=ch-&gt;sum;
            if(prev)
                prev-&gt;next=ch-&gt;next;
            else {
                rt-&gt;first=ch-&gt;next;
            }
            splitTree(ch,c,chsp);
            REP(k,2)
                if(chsp[k]!=0)
                    rt-&gt;addChild(chsp[k]);
            break;
        }
        prev=ch;
    }
    
    if(rt-&gt;h&gt;0){
        //split rt
        if(rt-&gt;l&lt;=c-1){
            sp[0]=get()-&gt;set(rt-&gt;l,c-1,rt-&gt;h);
        } else {
            sp[0]=0;
        }
        if(c+1&lt;=rt-&gt;r){
            sp[1]=get()-&gt;set(c+1,rt-&gt;r,rt-&gt;h);
        } else {
            sp[1]=0;
        }
        
        //distrube the childs
        for(Tree*ch=rt-&gt;first,*nxt;ch;ch=nxt){
            nxt=ch-&gt;next;
            if(ch-&gt;r&lt;=c-1){
                sp[0]-&gt;addChild(ch);
            } else{
                sp[1]-&gt;addChild(ch);
            }
        }
        
        REP(k,2)if(sp[k])
            sp[k]-&gt;optimize();
    } else {
        //needn't split rt
        //needn't do anything
    }
}

int64 ans;

void work(){
    root = get()-&gt;set(1,nC,0);
    
    ans=1LL*nR*(nR+1)/2*nC*(nC+1)/2;
    
    
    for(int r=1;r&lt;=nR;++r){
        //split the tree
        vector&lt;int&gt;&amp;cs=byR[r];
        //add a floor
        root-&gt;addH();
        
        REP(i,cs.size()){
            int c=cs[i];
            //put height c-&gt;0
            Tree*sp[2]={};
            cnt=0;
            if(root-&gt;h==0){
                splitTree(root,c,sp);
            } else {
                splitTree(root,c,sp);
                root = get()-&gt;set(1,nC,0);
                REP(k,2)if(sp[k])
                    root-&gt;addChild(sp[k]);
                root-&gt;recalcSum();
            }
//            cout&lt;&lt;cnt&lt;&lt;endl;
        }
        
        ans -= root-&gt;sum;
    }
    
    cout&lt;&lt;ans&lt;&lt;endl;
}

void readInput(){
    cin&gt;&gt;nR&gt;&gt;nC&gt;&gt;n;
    REP(i,n){
        int r,c;
        scanf("%d%d",&amp;r,&amp;c);
        byR[r].push_back(c);
    }
}

int main(){
    //setIO("mrx");
    readInput();
    work();
    return 0;
}</pre><pre></pre><h2>Problem2659</h2><pre>p,q=map(int,raw_input().split())
f=lambda x:x*(x+1)/2
if p==q:
	print f((p-1)/2)+f((q-1)/2)
else:
	print (p-1)*(q-1)/4</pre><pre></pre><h2>Problem2660</h2><pre>n=int(raw_input())
fibs=[]
a,b=1,1
while a&lt;=n:
	fibs.append(a)
	a,b=a+b,a
	
s=fibs[:]
mp=[]
for i in range(len(s)):
	if i&gt;0:
		s[i]+=s[i-1]
	mp.append({})
	
def calc(i,r):
	if i==-1:
		if r==0:
			return 1
		else:
			return 0
	if s[i]&lt;r:
		return 0
	if r in mp[i]:
		return mp[i][r]
	ret=calc(i-1,r)
	if fibs[i]&lt;=r:
		ret+=calc(i-1,r-fibs[i])
	mp[i][r]=ret
	return ret

print calc(len(fibs)-1,n)</pre><pre></pre><h2>Problem2661</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
using namespace std;

const int MAX_N = 1000 + 10;
vector&lt;int&gt; e[MAX_N];
int a, b;

bool vis[MAX_N];
vector&lt;int&gt; comp;

void dfs(int u) {
	if (vis[u])
		return;

	comp.push_back(u);
	vis[u] = true;
	for (vector&lt;int&gt;::iterator it = e[u].begin(); it != e[u].end(); ++it) {
		dfs(*it);
	}
}

pair&lt;int, int&gt; ret = make_pair(0, 0);
bool used[MAX_N];
pair&lt;int, int&gt; mx;

const int MAX_ITER = 1000000;
int iter;

void rec(int u, int pair, int score) {
	if (++iter &gt; MAX_ITER)
		return;
	if (u == comp.size()) {
		mx = max(mx, make_pair(pair, score));
		return;
	}

	int rem = 0, sum = 0, mi = INT_MAX;
	for (int i = u; i &lt; comp.size(); ++i) {
		if (!used[comp[i]])
			++rem, sum += comp[i], mi = min(mi, comp[i]);
	}

	if (make_pair(pair + rem / 2, score + sum - (rem % 2 == 0 ? 0 : mi)) &lt;= mx)
		return;

	int me = comp[u];
	if (used[me]) {
		rec(u + 1, pair, score);
		return;
	}
	for (vector&lt;int&gt;::iterator it = e[me].begin(); it != e[me].end(); ++it) {
		if (!used[*it]) {
			used[me] = used[*it] = true;
			rec(u + 1, pair + 1, score + me + *it);
			used[me] = used[*it] = false;
		}
	}
	rec(u + 1, pair, score);
}

void calc() {
	sort(comp.rbegin(), comp.rend());
//	cout &lt;&lt; comp.size() &lt;&lt; endl;
	mx = make_pair(0, 0);
	iter = 0;
	rec(0, 0, 0);
	ret.first += mx.first;
	ret.second += mx.second;
}

int main() {
	cin &gt;&gt; a &gt;&gt; b;

	for (int n = 1; n * n * 2 &lt;= b; ++n) {
		for (int m = n + 1; n * n + m * m &lt;= b; ++m) {
			if (__gcd(n, m) == 1) {
				int x = n * n + m * m, y = n * m * 2, z = m * m - n * n;
				if (__gcd(y, z) == 1) {
					if (x &gt;= a &amp;&amp; x &lt;= b) {
						if (y &gt;= a &amp;&amp; y &lt;= b)
							e[x].push_back(y), e[y].push_back(x);
						if (z &gt;= a &amp;&amp; z &lt;= b)
							e[x].push_back(z), e[z].push_back(x);
					}
				}
			}
		}
	}

	for (int i = a; i &lt;= b; ++i) {
		sort(e[i].rbegin(), e[i].rend());
	}

	memset(vis, 0, sizeof vis);
	memset(used, 0, sizeof used);
	for (int i = a; i &lt;= b; ++i) {
		if (vis[i])
			continue;
		comp.clear();
		dfs(i);
		calc();
	}
	cout &lt;&lt; ret.first &lt;&lt; " " &lt;&lt; ret.second &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2661</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
using namespace std;

const int MAX_N = 1000 + 10;
vector&lt;int&gt; e[MAX_N];
int a, b;

bool vis[MAX_N];
vector&lt;int&gt; comp;

void dfs(int u) {
	if (vis[u])
		return;

	comp.push_back(u);
	vis[u] = true;
	for (vector&lt;int&gt;::iterator it = e[u].begin(); it != e[u].end(); ++it) {
		dfs(*it);
	}
}

pair&lt;int, int&gt; ret = make_pair(0, 0);
bool used[MAX_N];
pair&lt;int, int&gt; mx;

const int MAX_ITER = 100000;
int iter;

void rec(int u, int pair, int score) {
	if (++iter &gt; MAX_ITER)
		return;
	if (u == comp.size()) {
		mx = max(mx, make_pair(pair, score));
		return;
	}

	int rem = 0, sum = 0, mi = INT_MAX;
	for (int i = u; i &lt; comp.size(); ++i) {
		if (!used[comp[i]])
			++rem, sum += comp[i], mi = min(mi, comp[i]);
	}

	if (make_pair(pair + rem / 2, score + sum - (rem % 2 == 0 ? 0 : mi)) &lt;= mx)
		return;

	int me = comp[u];
	if (used[me]) {
		rec(u + 1, pair, score);
		return;
	}
	for (vector&lt;int&gt;::iterator it = e[me].begin(); it != e[me].end(); ++it) {
		if (!used[*it]) {
			used[me] = used[*it] = true;
			rec(u + 1, pair + 1, score + me + *it);
			used[me] = used[*it] = false;
		}
	}
	rec(u + 1, pair, score);
}

void calc() {
	sort(comp.rbegin(), comp.rend());
//	cout &lt;&lt; comp.size() &lt;&lt; endl;
	mx = make_pair(0, 0);
	iter = 0;
	rec(0, 0, 0);
	ret.first += mx.first;
	ret.second += mx.second;
}

int main() {
	cin &gt;&gt; a &gt;&gt; b;

	for (int n = 1; n * n * 2 &lt;= b; ++n) {
		for (int m = n + 1; n * n + m * m &lt;= b; ++m) {
			if (__gcd(n, m) == 1) {
				int x = n * n + m * m, y = n * m * 2, z = m * m - n * n;
				if (__gcd(y, z) == 1) {
					if (x &gt;= a &amp;&amp; x &lt;= b) {
						if (y &gt;= a &amp;&amp; y &lt;= b)
							e[x].push_back(y), e[y].push_back(x);
						if (z &gt;= a &amp;&amp; z &lt;= b)
							e[x].push_back(z), e[z].push_back(x);
					}
				}
			}
		}
	}

	for (int i = a; i &lt;= b; ++i) {
		sort(e[i].rbegin(), e[i].rend());
	}

	memset(vis, 0, sizeof vis);
	memset(used, 0, sizeof used);
	for (int i = a; i &lt;= b; ++i) {
		if (vis[i])
			continue;
		comp.clear();
		dfs(i);
		calc();
	}
	cout &lt;&lt; ret.first &lt;&lt; " " &lt;&lt; ret.second &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2661</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
using namespace std;

const int MAX_N = 1000 + 10;
vector&lt;int&gt; e[MAX_N];
int a, b;

bool vis[MAX_N];
vector&lt;int&gt; comp;

void dfs(int u) {
	if (vis[u])
		return;

	comp.push_back(u);
	vis[u] = true;
	for (vector&lt;int&gt;::iterator it = e[u].begin(); it != e[u].end(); ++it) {
		dfs(*it);
	}
}

pair&lt;int, int&gt; ret = make_pair(0, 0);
bool used[MAX_N];
pair&lt;int, int&gt; mx;

const int MAX_ITER = 50000;
int iter;

void rec(int u, int pair, int score) {
	if (++iter &gt; MAX_ITER)
		return;
	if (u == comp.size()) {
		mx = max(mx, make_pair(pair, score));
		return;
	}

	int rem = 0, sum = 0, mi = INT_MAX;
	for (int i = u; i &lt; comp.size(); ++i) {
		if (!used[comp[i]])
			++rem, sum += comp[i], mi = min(mi, comp[i]);
	}

	if (make_pair(pair + rem / 2, score + sum - (rem % 2 == 0 ? 0 : mi)) &lt;= mx)
		return;

	int me = comp[u];
	if (used[me]) {
		rec(u + 1, pair, score);
		return;
	}
	for (vector&lt;int&gt;::iterator it = e[me].begin(); it != e[me].end(); ++it) {
		if (!used[*it]) {
			used[me] = used[*it] = true;
			rec(u + 1, pair + 1, score + me + *it);
			used[me] = used[*it] = false;
		}
	}
	rec(u + 1, pair, score);
}

void calc() {
	sort(comp.rbegin(), comp.rend());
//	cout &lt;&lt; comp.size() &lt;&lt; endl;
	mx = make_pair(0, 0);
	iter = 0;
	rec(0, 0, 0);
	ret.first += mx.first;
	ret.second += mx.second;
}

int main() {
	cin &gt;&gt; a &gt;&gt; b;

	for (int n = 1; n * n * 2 &lt;= b; ++n) {
		for (int m = n + 1; n * n + m * m &lt;= b; ++m) {
			if (__gcd(n, m) == 1) {
				int x = n * n + m * m, y = n * m * 2, z = m * m - n * n;
				if (__gcd(y, z) == 1) {
					if (x &gt;= a &amp;&amp; x &lt;= b) {
						if (y &gt;= a &amp;&amp; y &lt;= b)
							e[x].push_back(y), e[y].push_back(x);
						if (z &gt;= a &amp;&amp; z &lt;= b)
							e[x].push_back(z), e[z].push_back(x);
					}
				}
			}
		}
	}

	for (int i = a; i &lt;= b; ++i) {
		sort(e[i].rbegin(), e[i].rend());
	}

	memset(vis, 0, sizeof vis);
	memset(used, 0, sizeof used);
	for (int i = a; i &lt;= b; ++i) {
		if (vis[i])
			continue;
		comp.clear();
		dfs(i);
		calc();
	}
	cout &lt;&lt; ret.first &lt;&lt; " " &lt;&lt; ret.second &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2663</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;

const int MAX_N = 50 + 10;
int n, k;
double x[MAX_N], y[MAX_N], xx[MAX_N], yy[MAX_N];
const double EPS = 1e-8;
double d[MAX_N][MAX_N];

bool e[MAX_N][MAX_N], vis[MAX_N];
int pr[MAX_N];

bool dfs(int u) {
	if (vis[u])
		return false;
	vis[u] = true;
	for (int v = 0; v &lt; n; ++v)
		if (e[u][v]) {
			if (pr[v] == -1 || dfs(pr[v]))
				return pr[v] = u, true;
		}
	return false;
}

int maxMatch() {
	memset(pr, -1, sizeof pr);
	int ret = 0;
	for (int i = 0; i &lt; n; ++i) {
		memset(vis, 0, sizeof vis);
		if (dfs(i))
			++ret;
	}
	return ret;
}

int maxGirl(double r) {
	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; n; ++j) {
			e[i][j] = d[i][j] &lt;= r + EPS;
		}
	}
	return maxMatch();
}

int minGirl(double r) {
	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; n; ++j) {
			e[i][j] = d[i][j] &gt;= r + EPS;
		}
	}
	return n - maxMatch();
}

int main() {
	cin &gt;&gt; n &gt;&gt; k;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; x[i] &gt;&gt; y[i];
	}
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; xx[i] &gt;&gt; yy[i];
	}
	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; n; ++j) {
			d[i][j] = hypot(x[i] - xx[j], y[i] - yy[j]);
		}
	}

	//find Rmin
	double l = 0, r = 1e4;
	while (l + EPS &lt; r) {
		double m = (l + r) / 2;
		if (maxGirl(m) &gt;= k)
			r = m;
		else
			l = m;
	}
	printf("%0.2lf ", r);
	//find Rmax
	l = 0, r = 1e4;
	if (minGirl(r) &lt;= k)
		printf("+INF\n");
	else {
		while (l + EPS &lt; r) {
			double m = (l + r) / 2;
			if (minGirl(m) &lt;= k)
				l = m;
			else
				r = m;
		}
		printf("%0.2lf\n", l);
	}

	return 0;
}
</pre><pre></pre><h2>Problem2664</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
using namespace std;

int N1, N2;
bool beat[26][26] = { };
vector&lt;int&gt; trans[26][2];

string w;

int can[26][21][21];

bool check(int a, int l, int r) {
	int&amp;ret = can[a][l][r];
	if (ret != -1)
		return ret;
	if (l == r) {
		return ret = beat[a][w[l] - 'a'];
	}
	ret = false;
	for (int k = l; k &lt; r; ++k) {
		for (int i = 0; i &lt; trans[a][0].size(); ++i) {
			int x = trans[a][0][i], y = trans[a][1][i];
			if (check(x, l, k) &amp;&amp; check(y, k + 1, r))
				return ret = true;
		}
	}
	return ret = false;
}

int main() {
	cin &gt;&gt; N1 &gt;&gt; N2;
	for (int i = 0; i &lt; N1; ++i) {
		scanf(" ");
		char a = getchar();
		scanf("-&gt;");
		char b = getchar();
		beat[a - 'A'][b - 'a'] = true;
	}
	for (int i = 0; i &lt; N2; ++i) {
		scanf(" ");
		char a = getchar();
		scanf("-&gt;");
		char b = getchar();
		char c = getchar();
		trans[a - 'A'][0].push_back(b - 'A');
		trans[a - 'A'][1].push_back(c - 'A');
	}

	while (cin &gt;&gt; w) {
		if (w == "@")
			break;
		memset(can, -1, sizeof can);
		puts(check('S' - 'A', 0, w.size() - 1) ? "YES" : "NO");
	}
	return 0;
}
</pre><pre></pre><h2>Problem2671</h2><pre>/*
 * Calc.cpp
 *
 *  Created on: 2012-4-7
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

typedef long long int64;

int bf(int n) {
    int ans = 0;
    for (int i = 1; i &lt;= n; ++i) {
        for (int j = i + 1; j &lt;= n; ++j) {
            if ((i * j) % (i + j) == 0)
                ++ans;
        }
    }
    return ans;
}

int64 calc(int n) {
    int64 ans = 0;
    for (int i = 1; i &lt;= n; ++i) {
        if ((i + 1) * (i + i + 1) &gt; n)
            break;
        for (int j = i + 1; j * (i + j) &lt;= n; ++j) {
            if (__gcd(i, j) == 1) {
                ans += (n / j) / (i + j);
            }
        }
    }
    return ans;
}

const int MAX_N = int(1e5);

vector&lt;int&gt; pSet[MAX_N];

void prepare() {
    for (int i = 2; i &lt; MAX_N; ++i) {
        if (pSet[i].empty()) {
            for (int j = i; j &lt; MAX_N; j += i)
                pSet[j].push_back(i);
        }
    }
}

int count(int r, int x) {
    //&lt;=r coprime with x
    int ans = 0;
    vector&lt;int&gt;&amp;ps = pSet[x];
    int n = ps.size();

    for (int mask = 0; mask &lt; (1 &lt;&lt; n); ++mask) {
        int d = 1, c = 0;
        for (int j = 0; j &lt; n; ++j) {
            if (mask &gt;&gt; j &amp; 1)
                d *= ps[j], ++c;
        }
        if (c % 2 == 0)
            ans += r / d;
        else
            ans -= r / d;
    }

    return ans;
}

int64 calc2(int n) {
    int64 ans = 0;
    for (int64 j = 1; j &lt;= n; ++j) {
        if (j * (j + 1) &gt; n)
            break;
        //i in [1,j-1]

        int t = n / j;

        int pw = 1;
        while (pw &lt;= j)
            pw *= 2;

        // i in [1,j-1] gcd(i,j) == 1 , sum of t/(i+j)
        int p = 0;
        for (int i = 1; i &lt; j;) {
            int v = t / (j + i);
            int r = i;
            for (int step = pw; step &gt;= 1; step &gt;&gt;= 1)
                if (r + step &lt; j &amp;&amp; t / (j + r + step) == v)
                    r += step;
            //[i,r] is same
            int cur = count(r, j);
            ans += 1LL * (cur - p) * v;
            p = cur;
            i = r + 1;
        }
    }

    return ans;
}

int main() {
    prepare();
    int n;
    cin &gt;&gt; n;
//  cout &lt;&lt; bf(n) &lt;&lt; endl;
    cout &lt;&lt; calc2(n) &lt;&lt; endl;
//  cout &lt;&lt; calc(n) &lt;&lt; endl;
    return 0;
}
</pre><pre></pre><h2>Problem2674</h2><pre>/*
 * Attack.cpp
 *
 *  Created on: 2012-4-8
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_N = 60000 + 10;
const int MAX_M = 10000 + 10;

struct Point {
    int x, y, z, id;
    void read() {
        scanf("%d%d%d", &amp;x, &amp;y, &amp;z);
    }
    bool operator&lt;(const Point&amp;p) const {
        return x &lt; p.x;
    }
};

Point points[MAX_N];
int n, nQ;

void readInput() {
    scanf("%d%d", &amp;n, &amp;nQ);
    for (int i = 0; i &lt; n; ++i) {
        points[i].read();
        points[i].id = i;
    }
}

int where[MAX_N];

template&lt;class T&gt;
struct Index: public vector&lt;T&gt; {
    using vector&lt;T&gt;::erase;
    using vector&lt;T&gt;::begin;
    using vector&lt;T&gt;::end;
    void doit() {
        sort(begin(), end());
        erase(unique(begin(), end()), end());
    }
    int get(T x) {
        return lower_bound(begin(), end(), x) - begin();
    }
};

Index&lt;int&gt; idz;

int cnt[MAX_N];

void work() {
    sort(points, points + n);

    idz.clear();

    for (int i = 0; i &lt; n; ++i) {
        where[points[i].id] = i;

        idz.push_back(points[i].z);
    }

    idz.doit();

    for (int i = 0; i &lt; n; ++i) {
        points[i].z = idz.get(points[i].z);
    }

    for (int i = 0; i &lt; nQ; ++i) {
        static char buf[1000];
        scanf(" ");
        scanf("%s", buf);
        if (buf[0] == 'Q') { //QUERY
            int xl, yl, xr, yr, k;
            scanf("%d%d%d%d%d", &amp;xl, &amp;yl, &amp;xr, &amp;yr, &amp;k);
            if (xl &gt; xr)
                swap(xl, xr);
            if (yl &gt; yr)
                swap(yl, yr);

            memset(cnt, 0, sizeof(int) * idz.size());

            int l = lower_bound(points, points + n, (Point) {xl,-1,-1,-1}) - points;
            int r = upper_bound(points, points + n, (Point) {xr,-1,-1,-1}) - points;

            {

                register Point*end = points + r;

                for (register Point*p = points + l; p != end; ++p) {
                    if (p-&gt;y &gt;= yl &amp;&amp; p-&gt;y &lt;= yr) {
                        cnt[p-&gt;z]++;
                    }
                }

            }

            {
                register int*end = cnt + idz.size();
                register int*ptr = cnt;
                if (*ptr &gt;= k) {
                    printf("%d\n", idz[0]);
                    continue;
                }
                for (ptr++; ptr != end; ++ptr) {
                    *ptr += *(ptr - 1);
                    if (*ptr &gt;= k) {
                        printf("%d\n", idz[ptr - cnt]);
                        goto done;
                    }
                }

                puts("It doesn't exist.");
            }

            done: {
            }
        } else { // SWAP
            int a, b;
            scanf("%d%d", &amp;a, &amp;b);
            a = where[a], b = where[b];
            swap(points[a].z, points[b].z);
        }
    }
}

int main() {
    readInput();
    work();
    return 0;
}
</pre><pre></pre><h2>Problem2675</h2><pre>/*
 * Bomb.cpp
 *
 *  Created on: 2012-4-8
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_N = int(1e5) + 10;

struct Point {
    int x, y;
    void read() {
        scanf("%d%d", &amp;x, &amp;y);
    }
    bool operator&lt;(const Point&amp;o) const {
        return x &lt; o.x;
    }
};

Point ps[MAX_N];
int n;

inline int calc(int a, int b, int c) {
    return max(a, max(b, c)) - min(a, min(b, c));
}

inline int calc(const Point&amp;a, const Point&amp;b, const Point&amp;c) {
    return calc(a.x, b.x, c.x) + calc(a.y, b.y, c.y);
}

void readInput() {
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; ++i) {
        ps[i].read();
    }
}

int ans;

bool cmp(const Point&amp;a, const Point&amp;b) {
    return a.y &lt; b.y;
}

void solve(int l, int r) {
    if (r - l &lt;= 4) {
        for (int i = l; i &lt; r; ++i) {
            for (int j = i + 1; j &lt; r; ++j) {
                for (int k = j + 1; k &lt; r; ++k) {
                    ans = min(ans, calc(ps[i], ps[j], ps[k]));
                }
            }
        }
        return;
    }

    int m = l + r &gt;&gt; 1;
    solve(l, m);
    solve(m, r);

    int cut = ps[m].x;

    static Point qs[MAX_N];

    int cnt = 0;

    for (int i = l; i &lt; r; ++i) {
        if (abs(ps[i].x - cut) &lt; ans)
            qs[cnt++] = ps[i];
    }

    sort(qs, qs + cnt, cmp);

    int j = 0;

    for (int i = 0; i &lt; cnt; ++i) {
        while (j &lt; cnt &amp;&amp; qs[i].y &gt;= qs[j].y + ans)
            ++j;
        for (int k = j; k &lt; i; ++k) {
            for (int l = k + 1; l &lt; i; ++l) {
                ans = min(ans, calc(qs[k], qs[l], qs[i]));
            }
        }
    }
}

int calcMin() {
    sort(ps, ps + n);

    ans = INT_MAX;

    solve(0, n - 1);

    return ans * 2;
}

int memo[5][5];
bool have[5][5];

int getMax(int a, int b) {
    //max: ax+by
    int&amp;ret = memo[a + 2][b + 2];
    if (have[a + 2][b + 2])
        return ret;
    have[a + 2][b + 2] = true;

    int mx = INT_MIN;

    for (int i = 0; i &lt; n; ++i) {
        mx = max(mx, a * ps[i].x + b * ps[i].y);
    }

    return ret = mx;
}

int calcMax() {
    memset(have, 0, sizeof have);

    int ans = 0;

    //x0&lt;x1&lt;x2

    int perm[3];
    for (int i = 0; i &lt; 3; ++i) {
        perm[i] = i;
    }

    while (next_permutation(perm, perm + 3)) {
        int cx[3] = { }, cy[3] = { };
        cx[2] += 2;
        cx[0] -= 2;
        cy[perm[2]] += 2;
        cy[perm[0]] -= 2;
        int ret = 0;
        for (int i = 0; i &lt; 3; ++i) {
            ret += getMax(cx[i], cy[i]);
        }
        ans = max(ans, ret);
    }

    return ans;
}

void work() {
    cout &lt;&lt; calcMax() &lt;&lt; endl;
    cout &lt;&lt; calcMin() &lt;&lt; endl;
}

int main() {
    readInput();
    work();
    return 0;
}
</pre><pre></pre><h2>Problem2676</h2><pre>/*
 * Contra.cpp
 *
 *  Created on: 2012-4-8
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

int n, R, Q;
double S;

const int MAX_N = 30000 + 10;
const int MAX_R = 20 + 1;
const int MAX_Q = 5 + 1;

double est[MAX_N][MAX_R][MAX_Q];
double prob[MAX_N][MAX_R][MAX_Q];

double eval(int n, double p) {
    memset(est, 0, sizeof est);
    memset(prob, 0, sizeof prob);

    double ret = 0;

    prob[0][0][Q] = 1;
    for (int i = 0; i &lt; n; ++i) {
        for (int r = 0; r &lt;= R; ++r) {
            for (int q = 1; q &lt;= Q; ++q) {
                double pb = prob[i][r][q];
                double c = est[i][r][q];

                //win
                prob[i + 1][min(r + 1, R)][min(q + 1, Q)] += pb * p;
                est[i + 1][min(r + 1, R)][min(q + 1, Q)] += p * (c + pb * (min(r + 1, R)));

                //lost
                if (q &gt; 1) {
                    prob[i + 1][0][q - 1] += pb * (1 - p);
                    est[i + 1][0][q - 1] += (1 - p) * c;
                } else {
                    ret += c * (1 - p);
                }
            }
        }
    }

    for (int r = 0; r &lt;= R; ++r) {
        for (int q = 1; q &lt;= Q; ++q) {
            ret += est[n][r][q];
        }
    }

    return ret;
}

double dp[MAX_N][MAX_R][MAX_Q];

double eval2(int n, double p) {
    memset(dp, 0, sizeof dp);
    for (int i = 1; i &lt;= n; ++i) {
        for (int r = 0; r &lt;= R; ++r) {
            for (int q = 1; q &lt;= Q; ++q) {
                double&amp;c = dp[i][r][q];
                //win
                c += p * (dp[i - 1][min(r + 1, R)][min(q + 1, Q)] + min(r + 1, R));
                //lose
                if (q &gt; 0)
                    c += (1 - p) * (dp[i - 1][0][q - 1]);
            }
        }
    }
    return dp[n][0][Q];
}

typedef vector&lt;double&gt; vec;
typedef vector&lt;vec&gt; mat;

mat zero(int n) {
    return mat(n, vec(n, 0));
}

mat unit(int n) {
    mat a = zero(n);
    for (int i = 0; i &lt; n; ++i) {
        a[i][i] = 1;
    }
    return a;
}

mat operator*(mat a, mat b) {
    int n = a.size();
    mat c = zero(n);
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            for (int k = 0; k &lt; n; ++k) {
                c[i][j] += a[i][k] * b[k][j];
            }
        }
    }
    return c;
}

mat matPow(mat a, int e) {
    if (!e)
        return unit(a.size());
    return (e &amp; 1) ? matPow(a, e - 1) * a : matPow(a * a, e &gt;&gt; 1);
}

int id[MAX_R][MAX_Q], nId;

void dfs(int r, int q) {
    if (id[r][q] != -1)
        return;
    id[r][q] = nId++;
    //win
    dfs(min(r + 1, R - 1), min(q + 1, Q - 1));
    if (q &gt; 0)
        dfs(0, q - 1);
}

double evalFast(int n, double p) {
    nId = 0;
    memset(id, -1, sizeof id);

    dfs(0, Q - 1);

    mat trans = zero(nId + 1);
    int ONE = nId;

    for (int r = 0; r &lt; R; ++r) {
        for (int q = 0; q &lt; Q; ++q)
            if (id[r][q] != -1) {
                //win
                int me = id[r][q];
                trans[id[min(r + 1, R - 1)][min(q + 1, Q - 1)]][me] += p;
                trans[ONE][me] += min(r + 1, R) * p;
                //lose
                if (q &gt; 0)
                    trans[id[0][q - 1]][me] += 1 - p;
            }
    }

    trans[ONE][ONE] = 1;

    mat final = matPow(trans, n);

    return final[ONE][id[0][Q - 1]];
}

double bf() {
    double l = 0, r = 1;
    while (l + 1e-9 &lt; r) {
        double m = (l + r) / 2;
        if (eval2(n, m) &gt; S)
            r = m;
        else
            l = m;
    }
    return r;
}

int checkImpossible() {
    int ans = 0, r = 0;
    for (int i = 0; i &lt; n; ++i) {
        if (r == R) {
            ans += (n - i) * R;
            break;
        }
        ans += min(r + 1, R);
        r = min(r + 1, R);
    }
    return ans;
}

double calc() {
    double l = 0, r = 1;
    while (l + 1e-12 &lt; r) {
        double m = (l + r) / 2;
        if (evalFast(n, m) &gt; S)
            r = m;
        else
            l = m;
    }
    return r;
}

const int NUM = 30000;

double eval3(int n, double p) {
    if (n &lt;= NUM)
        return eval2(n, p);
    double cur = eval2(NUM, p), next = eval2(NUM + 1, p);
    return cur + (next - cur) * (n - NUM);
}

double calc2() {
    double l = 0, r = 1;
    while (l + 1e-9 &lt; r) {
        double m = (l + r) / 2;
        if (eval3(n, m) &gt; S)
            r = m;
        else
            l = m;
    }
    return r;
}
int main() {
    cin &gt;&gt; n &gt;&gt; R &gt;&gt; Q &gt;&gt; S;

    if (checkImpossible() == S) {
        puts("Impossible.");
        return 0;
    }
    if (n &lt;= 10000)
        printf("%6lf\n", bf());
    else
        printf("%6lf\n", calc());
    return 0;
}
</pre><pre></pre><h2>Problem2687</h2><pre>/*
 * c.cpp
 *
 *  Created on: 2012-6-2
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_N = int(1e6) + 10;

struct Segment {
	Segment() {
	}
	int l, r;
	void read() {
		scanf("%d%d", &amp;l, &amp;r);
	}
	Segment(int _l, int _r) :
			l(_l), r(_r) {
	}
	bool operator&lt;(const Segment&amp;o) const {
		return l != o.l ? l &lt; o.l : r &gt; o.r;
	}
	int len() {
		return r - l;
	}
};

Segment segments[MAX_N];
int nSegments;

typedef long long int64;

int64 ans;

struct TA {
	int a[MAX_N];
	int n;
	void init(int _n) {
		n = _n;
		memset(a, 0, sizeof a);
	}
	void modify(int p, int x) {
		for (p++; p &lt;= n; p += p &amp; -p)
			a[p - 1] = max(a[p - 1], x);
	}
	int get(int p) {
		int ret = 0;
		for (p++; p; p -= p &amp; -p)
			ret = max(ret, a[p - 1]);
		return ret;
	}
} ta;

template&lt;class T&gt;
struct Index: public vector&lt;T&gt; {
	using vector&lt;T&gt;::erase;
	using vector&lt;T&gt;::begin;
	using vector&lt;T&gt;::end;
	void doit() {
		sort(begin(), end());
		erase(unique(begin(), end()), end());
	}
	int get(T x) {
		return lower_bound(begin(), end(), x) - begin();
	}
};

Index&lt;int&gt; idr;

void processInclude() {
	for (int i = 0; i &lt; nSegments; ++i) {
		idr.push_back(segments[i].r);
	}
	idr.doit();
	ta.init(idr.size());

	for (int i = 0; i &lt; nSegments; ++i) {
		int at = idr.size() - 1 - idr.get(segments[i].r);
		ans = max(ans, 1LL * segments[i].len() * ta.get(at));
		ta.modify(at, segments[i].len());
	}
}

struct Interval {
	int l, r, who;
};

int64 calc(int i, int j) {
	Segment&amp;a = segments[i], &amp;b = segments[j];
	return 1LL * (a.r - b.l) * (b.r - a.l);
}

bool better(int i, int j, int at) { //is i better than j?
	return calc(i, at) &gt;= calc(j, at);
}

int get(Interval a, int i) {
	int l = a.l, r = a.r + 1;
	while (l + 1 &lt; r) {
		int m = l + r &gt;&gt; 1;
		if (better(i, a.who, m))
			r = m;
		else
			l = m;
	}
	return r;
}

void solve() {

	int cur = 0;
	for (int i = 0; i &lt; nSegments; ++i) {
		if (!cur || segments[cur - 1].r &lt; segments[i].r)
			segments[cur++] = segments[i];
	}

	nSegments = cur;

	static Interval que[MAX_N];
	int qh = 0, qt = 0;
	que[qt++] = (Interval) {0,nSegments-1,0};
	for (int i = 1; i &lt; nSegments; ++i) {
		while (qh &lt; qt &amp;&amp; que[qh].r &lt; i) {
			++qh;
		}
		if (qh &lt; qt)
			ans = max(ans, calc(que[qh].who, i));
		//put i
		while (qh &lt; qt &amp;&amp; better(i, que[qt - 1].who, que[qt - 1].l))
			--qt;
		if (qh &lt; qt) {
			int sp = get(que[qt - 1], i);
			que[qt - 1].r = sp - 1;
			if (sp &lt;= nSegments - 1)
				que[qt++] = (Interval) {sp,nSegments-1,i};
		} else {
			que[qt++] = (Interval) {i+1,nSegments-1,i};
		}
	}
}

int main() {
	cin &gt;&gt; nSegments;
	for (int i = 0; i &lt; nSegments; ++i) {
		segments[i].read();
	}
	sort(segments, segments + nSegments);
	ans = 0;
	processInclude();
	solve();
	cout &lt;&lt; ans &lt;&lt; endl;

	return 0;
}
</pre><pre></pre><h2>Problem2691</h2><pre>/*
 * p1.cpp
 *
 *  Created on: 2012-4-14
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
typedef long long int64;
const int MAX_N = 50000 + 10;
int nSeq, nV, p, nE;
int a[MAX_N];
template&lt;class T&gt;
struct Index: public vector&lt;T&gt; {
    using vector&lt;T&gt;::erase;
    using vector&lt;T&gt;::begin;
    using vector&lt;T&gt;::end;
    void doit() {
        sort(begin(), end());
        erase(unique(begin(), end()), end());
    }
    int get(T x) {
        return lower_bound(begin(), end(), x) - begin();
    }
};
Index&lt;int&gt; ida;
int64 ans[MAX_N];
int sqrtNSeq;
struct Query {
    int l, r, id;
    bool operator&lt;(const Query&amp;o) const {
        if (l / sqrtNSeq != o.l / sqrtNSeq)
            return l / sqrtNSeq &lt; o.l / sqrtNSeq;
        return r &lt; o.r;
    }
};
Query qs[MAX_N];
int64 cube[MAX_N];
struct TA {
    int a[MAX_N];
    int n;
    void init(int _n) {
        n = _n;
        memset(a, 0, sizeof(int) * n);
    }
    void add(register int p, register int x) {
        for (p++; p &lt;= n; p += p &amp; -p)
            a[p - 1] += x;
    }
    int sum(register int p) {
        register int ret = 0;
        for (p++; p &gt; 0; p -= p &amp; -p)
            ret += a[p - 1];
        return ret;
    }
};
TA num, sum;
int cnt[MAX_N];
int64 result;
int nColor;
inline void add(int x) {
    int old = cnt[x];
    result += cube[old + 1] - cube[old];
    cnt[x]++;
    result += (nColor - num.sum(x)); // &gt;x
    if (old == 0) {
        nColor++;
        result += sum.sum(x - 1); // &lt;x
        num.add(x, 1);
    }
    sum.add(x, 1);
}
inline void del(int x) {
    int old = cnt[x];
    result += cube[old - 1] - cube[old];
    cnt[x]--;
    result -= (nColor - num.sum(x));
    if (old == 1) {
        nColor--;
        result -= sum.sum(x - 1);
        num.add(x, -1);
    }
    sum.add(x, -1);
}
bool contain(int l, int r, int m) {
    return m &gt;= l &amp;&amp; m &lt; r;
}
int64 powMod(int64 a, int64 e, int64 mod) {
    if (!e)
        return 1 % mod;
    return e % 2 == 0 ? powMod(a * a % mod, e &gt;&gt; 1, mod) : powMod(a, e - 1, mod) * a % mod;
}
int64 invMod(int64 a, int64 mod) {
    return powMod(a, mod - 2, mod);
}
namespace COMB {
//calc comb(n,m)%p
    const int MAX_DIVS = 100;
    int64 ps[MAX_DIVS], cs[MAX_DIVS], nPs;
    int64 p, pc;
    struct Result {
        int64 mod;
        int64 cnt;
        Result(int64 _mod, int64 _cnt) :
                mod(_mod), cnt(_cnt) {
        }
        Result(int64 a = 1) {
            cnt = 0;
            while (a % p == 0) {
                a /= p;
                cnt++;
            }
            mod = a;
        }
    };
    int64 phi;
    Result operator*(const Result&amp;a, const Result&amp;b) {
        return Result(a.mod * b.mod % pc, a.cnt + b.cnt);
    }
    Result operator/(const Result&amp;a, const Result&amp;b) {
        return Result(a.mod * powMod(b.mod, phi - 1, pc) % pc, a.cnt - b.cnt);
    }
    Result resultPow(const Result&amp;a, int64 e) {
        if (!e)
            return Result(1);
        return e % 2 == 0 ? resultPow(a * a, e &gt;&gt; 1) : resultPow(a, e - 1) * a;
    }
    const int MAX_PC = 100000 + 10;
    Result eval(int64 n, int64 p, int c) {
        //n!%(p^c)
        //[1,pc-1]
        COMB::p = p;
        pc = 1;
        for (int i = 0; i &lt; c; ++i) {
            pc *= p;
        }
        phi = pc / p * (p - 1);
        Result ret = Result(1);
        static Result mul[MAX_PC];
        mul[0] = Result(1);
        for (int i = 1; i &lt; pc; ++i) {
            if (i % p != 0)
                mul[i] = mul[i - 1] * Result(i);
            else
                mul[i] = mul[i - 1];
        }
        for (;;) {
            if (n &lt; p) {
                ret = ret * mul[n];
                break;
            }
            //n!%pc
            ret = ret * resultPow(mul[pc - 1], n / pc);
            ret = ret * mul[n % pc];
            ret = ret * Result(1, n / p);
            n /= p;
        }
        return ret;
    }
    Result eval(int64 n, int64 m, int64 p, int c) {
        //comb(n,m)%p p= p^c
        return eval(n, p, c) / eval(m, p, c) / eval(n - m, p, c);
    }
    void extGcd(int64 a, int64 b, int64&amp;x, int64&amp;y) {
        if (!b) {
            x = 1;
            y = 0;
            return;
        }
        extGcd(b, a % b, y, x);
        y -= a / b * x;
    }
    int64 calc(int64 n, int64 m, int64 mod) {
        //comb(n,m) %mod
        int64 x = mod;
        nPs = 0;
        for (int64 i = 2; i * i &lt;= x; i++) {
            if (x % i == 0) {
                int c = 0;
                while (x % i == 0)
                    x /= i, c++;
                ps[nPs] = i;
                cs[nPs++] = c;
            }
        }
        if (x &gt; 1)
            ps[nPs] = x, cs[nPs++] = 1;
        int64 ans = 0;
        for (int i = 0; i &lt; nPs; ++i) {
//          cout &lt;&lt; ps[i] &lt;&lt; " " &lt;&lt; cs[i] &lt;&lt; endl;
            Result ret = eval(n, m, ps[i], cs[i]);
            int64 rem = ret.mod * powMod(ps[i], ret.cnt, pc) % pc;
            int64 m = pc, M = mod / pc, x, y;
            extGcd(m, M, x, y);
            int64 me = M * y % mod;
            if (me &lt; 0)
                me += mod;
            ans += me * rem % mod;
            ans %= mod;
        }
        return ans;
    }
}
int main() {
//  cout &lt;&lt; COMB::calc(9874567, 1234567, 1 &lt;&lt; 15) &lt;&lt; endl;
    cin &gt;&gt; nSeq &gt;&gt; nV &gt;&gt; p &gt;&gt; nE;
    ida.clear();
    for (int i = 0; i &lt; nSeq; ++i) {
        scanf("%d", a + i);
        ida.push_back(a[i]);
    }
    ida.doit();
    for (int i = 0; i &lt; nSeq; ++i) {
        a[i] = ida.get(a[i]);
    }
    sqrtNSeq = 1;
    while (sqrtNSeq * sqrtNSeq &lt;= nSeq)
        ++sqrtNSeq;
    for (int i = 0; i &lt; nV; ++i) {
        scanf("%d%d", &amp;qs[i].l, &amp;qs[i].r);
        --qs[i].l;
        qs[i].id = i;
    }
    sort(qs, qs + nV);
    for (int i = 0; i &lt;= nSeq; ++i) {
        cube[i] = 1LL * i * i * i;
    }
    memset(cnt, 0, sizeof cnt);
    result = 0;
    nColor = 0;
    num.init(ida.size());
    sum.init(ida.size());
    int l = 0, r = 0; //[l,r)
    int64 ans = 1;
    for (int i = 0; i &lt; nV; ++i) {
        Query q = qs[i];
        int xs[4] = { l, r, qs[i].l, qs[i].r };
//      cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " -&gt; " &lt;&lt; qs[i].l &lt;&lt; " " &lt;&lt; qs[i].r &lt;&lt; endl;
        sort(xs, xs + 4);
        for (int j = 0; j &lt; 3; ++j) {
            int cl = xs[j], cr = xs[j + 1];
            int m = cl + cr &gt;&gt; 1;
            bool inP = contain(l, r, m), inC = contain(qs[i].l, qs[i].r, m);
            if (inP &amp;&amp; !inC) {
                for (int k = cl; k &lt; cr; ++k) {
                    del(a[k]);
                }
            }
            if (!inP &amp;&amp; inC) {
                for (int k = cl; k &lt; cr; ++k) {
                    add(a[k]);
                }
            }
        }
        l = qs[i].l;
        r = qs[i].r;
        ans *= powMod(nColor, result, p);
        ans %= p;
    }
//  cout &lt;&lt; COMB::calc(1LL * nV * (nV - 1) / 2, nE, p) &lt;&lt; endl;
    ans *= COMB::calc(1LL * nV * (nV - 1) / 2, nE, p);
    ans %= p;
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</pre><pre></pre><h2>Problem2693</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
using namespace std;

typedef long long int64;
const int MOD = int(1e8) + 9;

int bf(int n, int m) {
	int ret = 0;
	for (int i = 1; i &lt;= n; ++i) {
		for (int j = 1; j &lt;= m; ++j) {
			ret += 1LL * i / __gcd(i, j) * j % MOD;
			ret %= MOD;
		}
	}
	return ret;
}

const int MAX_N = int(1e7);
int minP[MAX_N + 1] = { }, minPow[MAX_N + 1], primes[MAX_N + 1], nPrimes = 0;
int f[MAX_N] = { };
int C[MAX_N + 1];

int main() {
	for (int i = 2; i &lt;= MAX_N; ++i) {
		if (minP[i] == 0) {
			minP[i] = minPow[i] = i;
			primes[nPrimes++] = i;
		}
		for (int j = 0; j &lt; nPrimes; ++j) {
			int p = primes[j];
			int ip = i * p;
			if (ip &gt; MAX_N)
				break;
			minP[ip] = p;
			if (minP[i] == p) {
				minPow[ip] = minPow[i] * p;
				break;
			} else {
				minPow[ip] = p;
			}
		}
	}

	f[1] = 1;
	for (int i = 2; i &lt;= MAX_N; ++i) {
		int p = minP[i], x = i / minPow[i];
		f[i] = 1LL * f[x] * (1 - p) % MOD;
		if (f[i] &lt; 0)
			f[i] += MOD;
	}

	for (int i = 2; i &lt;= MAX_N; ++i) {
		f[i] = 1LL * f[i] * i % MOD;
		f[i] += f[i - 1];
		if (f[i] &gt;= MOD)
			f[i] -= MOD;
	}

	C[0] = 0;
	for (int i = 1; i &lt;= MAX_N; ++i) {
		C[i] = C[i - 1] + i;
		if (C[i] &gt;= MOD)
			C[i] -= MOD;
	}

	int T;
	cin &gt;&gt; T;

	for (int i = 0; i &lt; T; ++i) {
		int n, m;
		scanf("%d%d", &amp;n, &amp;m);
		if (n &gt; m)
			swap(n, m); //n&lt;=m
		int ans = 0;
		for (int d = 1, r; d &lt;= n; d = r + 1) {
			r = min(n / (n / d), m / (m / d));
			//calc [d,r]
			ans += 1LL * C[n / d] * C[m / d] % MOD * (f[r] - f[d - 1]) % MOD;
			if (ans &gt;= MOD)
				ans -= MOD;
			if (ans &lt; 0)
				ans += MOD;
		}
		printf("%d\n", ans);
//		cout &lt;&lt; bf(n, m) &lt;&lt; endl;
	}
	return 0;
}
</pre><pre></pre><h2>Problem2694</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
using namespace std;

typedef long long int64;
const int MOD = 1 &lt;&lt; 30;

bool check(int a) {
	for (int i = 2; i * i &lt;= a; ++i) {
		if (a % (i * i) == 0)
			return false;
	}
	return true;
}

int bf(int n, int m) {
	int ret = 0;
	for (int i = 1; i &lt;= n; ++i) {
		for (int j = 1; j &lt;= m; ++j)
			if (check(__gcd(i, j))) {
				ret += 1LL * i / __gcd(i, j) * j % MOD;
				ret %= MOD;
			}
	}
	return ret;
}

const int MAX_N = int(4e6);
int minP[MAX_N + 1] = { }, minPow[MAX_N + 1], primes[MAX_N + 1], nPrimes = 0;
int f[MAX_N + 1] = { };
int C[MAX_N + 1];

int main() {
	for (int i = 2; i &lt;= MAX_N; ++i) {
		if (minP[i] == 0) {
			minP[i] = minPow[i] = i;
			primes[nPrimes++] = i;
		}
		for (int j = 0; j &lt; nPrimes; ++j) {
			int p = primes[j];
			int ip = i * p;
			if (ip &gt; MAX_N)
				break;
			minP[ip] = p;
			if (minP[i] == p) {
				minPow[ip] = minPow[i] * p;
				break;
			} else {
				minPow[ip] = p;
			}
		}
	}

	f[1] = 1;
	for (int i = 2; i &lt;= MAX_N; ++i) {
		int p = minP[i], x = i / minPow[i];
		if (minPow[i] &gt; 1LL * p * p) {
			f[i] = 0;
			continue;
		}
		if (minPow[i] == p) {
			f[i] = 1LL * f[x] * (1 - p) % MOD;
			if (f[i] &lt; 0)
				f[i] += MOD;
		} else {
			f[i] = -1LL * f[x] * p % MOD;
			if (f[i] &lt; 0)
				f[i] += MOD;
		}
	}

	for (int i = 2; i &lt;= MAX_N; ++i) {
		f[i] = 1LL * f[i] * i % MOD;
		f[i] += f[i - 1];
		if (f[i] &gt;= MOD)
			f[i] -= MOD;
	}

	C[0] = 0;
	for (int i = 1; i &lt;= MAX_N; ++i) {
		C[i] = C[i - 1] + i;
		if (C[i] &gt;= MOD)
			C[i] -= MOD;
	}

	int T;
	cin &gt;&gt; T;

	for (int i = 0; i &lt; T; ++i) {
		int n, m;
		scanf("%d%d", &amp;n, &amp;m);
		if (n &gt; m)
			swap(n, m); //n&lt;=m
		int ans = 0;
		for (int d = 1, r; d &lt;= n; d = r + 1) {
			r = min(n / (n / d), m / (m / d));
			//calc [d,r]
			ans += 1LL * C[n / d] * C[m / d] % MOD * (f[r] - f[d - 1]) % MOD;
			if (ans &gt;= MOD)
				ans -= MOD;
			if (ans &lt; 0)
				ans += MOD;
		}
		printf("%d\n", ans);
//		cout &lt;&lt; bf(n, m) &lt;&lt; endl;
	}
	return 0;
}
</pre><pre></pre><h2>Problem2694</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
using namespace std;

typedef long long int64;
const int MOD = 1 &lt;&lt; 30;

bool check(int a) {
	for (int i = 2; i * i &lt;= a; ++i) {
		if (a % (i * i) == 0)
			return false;
	}
	return true;
}

int bf(int n, int m) {
	int ret = 0;
	for (int i = 1; i &lt;= n; ++i) {
		for (int j = 1; j &lt;= m; ++j)
			if (check(__gcd(i, j))) {
				ret += 1LL * i / __gcd(i, j) * j % MOD;
				ret %= MOD;
			}
	}
	return ret;
}

const int MAX_N = int(4e6);
int minP[MAX_N + 1] = { }, minPow[MAX_N + 1], primes[MAX_N + 1], nPrimes = 0;
int f[MAX_N + 1] = { };
int C[MAX_N + 1];

int main() {
	for (int i = 2; i &lt;= MAX_N; ++i) {
		if (minP[i] == 0) {
			minP[i] = minPow[i] = i;
			primes[nPrimes++] = i;
		}
		for (int j = 0; j &lt; nPrimes; ++j) {
			int p = primes[j];
			int ip = i * p;
			if (ip &gt; MAX_N)
				break;
			minP[ip] = p;
			if (minP[i] == p) {
				minPow[ip] = minPow[i] * p;
				break;
			} else {
				minPow[ip] = p;
			}
		}
	}

	f[1] = 1;
	for (int i = 2; i &lt;= MAX_N; ++i) {
		int p = minP[i], x = i / minPow[i];
		if (minPow[i] &gt; 1LL * p * p) {
			f[i] = 0;
			continue;
		}
		if (minPow[i] == p) {
			f[i] = f[x] * (1 - p);
		} else {
			f[i] = -f[x] * p;
		}
	}

	for (int i = 2; i &lt;= MAX_N; ++i) {
		f[i] = f[i] * i;
		f[i] += f[i - 1];
	}

	C[0] = 0;
	for (int i = 1; i &lt;= MAX_N; ++i) {
		C[i] = C[i - 1] + i;
	}

	int T;
	cin &gt;&gt; T;

	for (int i = 0; i &lt; T; ++i) {
		int n, m;
		scanf("%d%d", &amp;n, &amp;m);
		if (n &gt; m)
			swap(n, m); //n&lt;=m
		int ans = 0;
		for (int d = 1, r; d &lt;= n; d = r + 1) {
			r = min(n / (n / d), m / (m / d));
			//calc [d,r]
			ans += C[n / d] * C[m / d] * (f[r] - f[d - 1]);
		}
		ans %= MOD;
		if (ans &lt; 0)
			ans += MOD;
		printf("%d\n", ans);
//		cout &lt;&lt; bf(n, m) &lt;&lt; endl;
	}
	return 0;
}
</pre><pre></pre><h2>Problem2696</h2><pre>/*
 * p2.cpp
 *
 *  Created on: 2012-4-15
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int INF = INT_MAX / 4;
template&lt;class Flow = int, class Cost = int&gt;
struct MinCostFlow {
    struct Edge {
        int t;
        Flow f;
        Cost c;
        Edge*next, *rev;
        Edge(int _t, Flow _f, Cost _c, Edge*_next) :
                t(_t), f(_f), c(_c), next(_next) {
        }
    };
    vector&lt;Edge*&gt; E;
    int addV() {
        E.push_back((Edge*) 0);
        return E.size() - 1;
    }
    Edge* makeEdge(int s, int t, Flow f, Cost c) {
        return E[s] = new Edge(t, f, c, E[s]);
    }
    void addEdge(int s, int t, Flow f, Cost c) {
        Edge*e1 = makeEdge(s, t, f, c), *e2 = makeEdge(t, s, 0, -c);
        e1-&gt;rev = e2, e2-&gt;rev = e1;
    }
    pair&lt;Flow, Cost&gt; minCostFlow(int vs, int vt) { //flow,cost
        int n = E.size();
        Flow flow = 0;
        Cost cost = 0;
        const Cost MAX_COST = INF;
        const Flow MAX_FLOW = INF;
        for (;;) {
            vector&lt;Cost&gt; dist(n, MAX_COST);
            vector&lt;Flow&gt; am(n, 0);
            vector&lt;Edge*&gt; prev(n);
            vector&lt;bool&gt; inQ(n, false);
            queue&lt;int&gt; que;
            dist[vs] = 0;
            am[vs] = MAX_FLOW;
            que.push(vs);
            inQ[vs] = true;
            while (!que.empty()) {
                int u = que.front();
                Cost c = dist[u];
                que.pop();
                inQ[u] = false;
                for (Edge*e = E[u]; e; e = e-&gt;next)
                    if (e-&gt;f &gt; 0) {
                        Cost nc = c + e-&gt;c;
                        if (nc &lt; dist[e-&gt;t]) {
                            dist[e-&gt;t] = nc;
                            prev[e-&gt;t] = e;
                            am[e-&gt;t] = min(am[u], e-&gt;f);
                            if (!inQ[e-&gt;t]) {
                                que.push(e-&gt;t);
                                inQ[e-&gt;t] = true;
                            }
                        }
                    }
            }
            if (dist[vt] &gt;= 0)
                break;
            if (dist[vt] == MAX_COST)
                break;
            Flow by = am[vt];
            int u = vt;
            flow += by;
            cost += by * dist[vt];
            while (u != vs) {
                Edge*e = prev[u];
                e-&gt;f -= by;
                e-&gt;rev-&gt;f += by;
                u = e-&gt;rev-&gt;t;
            }
        }
        return make_pair(flow, cost);
    }
};
const int MAX_N = 200 + 10;
int N, M, K, T;
int cst[MAX_N][MAX_N], dur[MAX_N][MAX_N];
struct State {
    int at, dur;
};
State src[MAX_N], dst[MAX_N];
int get[MAX_N];
int need(State a, State b) {
    int c = cst[a.at][b.at], t = dur[a.at][b.at];
    if (a.dur + t &gt; b.dur)
        return -1;
    else
        return c;
}
State start, target;
MinCostFlow&lt;int, int&gt; sol;
int in[MAX_N], out[MAX_N];
int main() {
    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K &gt;&gt; T;
    for (int i = 0; i &lt; N; ++i) {
        for (int j = 0; j &lt; N; ++j) {
            scanf("%d", dur[i] + j);
        }
    }
    for (int i = 0; i &lt; N; ++i) {
        for (int j = 0; j &lt; N; ++j) {
            scanf("%d", cst[i] + j);
        }
    }
    for (int i = 0; i &lt; M; ++i) {
        scanf("%d%d%d%d%d", &amp;src[i].at, &amp;dst[i].at, &amp;src[i].dur, &amp;dst[i].dur, get + i);
    }
    start = (State) {0,0};
    target = (State) {0,T};
    for (int i = 0; i &lt; M; ++i) {
        in[i] = sol.addV();
        out[i] = sol.addV();
    }
    int S = sol.addV(), T = sol.addV();
    for (int i = 0; i &lt; M; ++i) {
        int by = need(start, src[i]);
        if (by != -1)
            sol.addEdge(S, in[i], INF, by);
        sol.addEdge(in[i], out[i], 1, -get[i]);
        by = need(dst[i], target);
        if (by != -1)
            sol.addEdge(out[i], T, INF, by);
        for (int j = 0; j &lt; M; ++j)
            if (i != j) {
                by = need(dst[i], src[j]);
                if (by != -1) {
                    sol.addEdge(out[i], in[j], INF, by);
                }
            }
    }
    int vs = sol.addV();
    sol.addEdge(vs, S, K, 0);
    cout &lt;&lt; -sol.minCostFlow(vs, T).second &lt;&lt; endl;
    return 0;
}
</pre><pre></pre><h2>Problem2697</h2><pre>/*
 * p3.cpp
 *
 *  Created on: 2012-4-15
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N = 1000 + 10;
int C[MAX_N], n, k;
int main() {
    cin &gt;&gt; n &gt;&gt; k;
    for (int i = 0; i &lt; k; ++i) {
        cin &gt;&gt; C[i];
    }
    sort(C, C + k);
    reverse(C, C + k);
    int ans = 0;
    for (int l = 0, r = n - 1, i = 0; i &lt; k &amp;&amp; l &lt; r; ++i, ++l, --r) {
        ans += (r - l) * C[i];
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</pre><pre></pre><h2>Problem2698</h2><pre>#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
int n,m,s,t;
double calc(int n){
	int a=s,b=t;
	if(a&gt;n)return 0;
	if(b&gt;n)b=n;
	return 1.0*(n+1)*(b-a+1)-1.0*(a+b)*(b-a+1)/2;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;
	double ans=0,tot=calc(n);
	REP(i,n){
		int L=i,R=n-1-L;
		double p=(calc(L)+calc(R))/tot;
		ans+=1-pow(p,m);
	}
	printf("%0.3lf\n",ans);
}</pre><pre></pre><h2>Problem2699</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int N=150,K=300,MOD=1000000007;
int dp[N+2][N+2][K+2],f[N+2][N+2][K+2];
void upd(int&amp;x,int c){
	x+=c;if(x&gt;=MOD)x-=MOD;
}
int main(){
	for(int i=1;i&lt;=K;i++)dp[1][0][i]=1;
	for(int i=1;i&lt;=N;i++)
		for(int j=0;j&lt;N;j++){
			for(int k=1;k&lt;=K;k++){
				upd(dp[i][j][k],f[i][j][k]);
				upd(f[i][j][k+1],f[i][j][k]);
				int c=dp[i][j][k];
				if(!c) continue;
				upd(dp[i+1][j][k],1LL*k*c%MOD);
				upd(f[i+1][j+1][k+1],c);
			}
		}
	int T;cin&gt;&gt;T;
	REP(i,T){
		int n,k,p;cin&gt;&gt;n&gt;&gt;k&gt;&gt;p;
		int ans=0;
		for(int i=1;i&lt;=k;++i)
			upd(ans,dp[n][p][i]);
		printf("%d\n",ans);
	}
}
</pre><pre></pre><h2>Problem2700</h2><pre>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.StringTokenizer;

/**
 * Created by IntelliJ IDEA.
 * User: mac
 * Date: 11-12-30
 * Time: 下午5:57
 * To change this template use File | Settings | File Templates.
 */

public class Main {

    BufferedReader reader;
    StringTokenizer tokenizer;
    PrintWriter writer;

    void run() {
        try {
            reader = new BufferedReader(new InputStreamReader(System.in));
            tokenizer = null;
            writer = new PrintWriter(System.out);
            solve();
            reader.close();
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    String nextToken() throws IOException {
        while (tokenizer == null || !tokenizer.hasMoreTokens())
            tokenizer = new StringTokenizer(reader.readLine());
        return tokenizer.nextToken();
    }

    int nextInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    long nextLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    double nextDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    class Tea implements Comparable&lt;Tea&gt; {
        int cost, id;

        Tea(int cost, int id) {
            this.cost = cost;
            this.id = id;
        }

        public int compareTo(Tea o) {
            return cost - o.cost;
        }
    }

    void solve() throws IOException {
        int k = nextInt(), n = nextInt();
        if (n &lt; k) {
            writer.println("Impossible");
            return;
        }
        @SuppressWarnings({"unchecked"})
        List&lt;Tea&gt;[] teas = new List[2];
        for (int i = 0; i &lt; 2; i++) {
            teas[i] = new ArrayList&lt;Tea&gt;();
        }
        for (int i = 0; i &lt; n; i++) {
            Tea tea = new Tea(nextInt(), i + 1);
            teas[nextInt()].add(tea);
        }
        int[] cnt = {teas[0].size(), teas[1].size()};
        long[][][][] dp = new long[cnt[0] + 1][cnt[1] + 1][2][2];
        LongUtils.fill(dp, Long.MAX_VALUE);
        int[][][][] how = new int[cnt[0] + 1][cnt[1] + 1][2][2];
        for (List&lt;Tea&gt; tea : teas) {
            Collections.sort(tea);
        }
        dp[0][0][0][0] = 0;

        for (int a = 0; a &lt;= cnt[0]; a++) {
            for (int b = 0; b &lt;= cnt[1]; b++) {
                int cur = a + b;
                int rem = k - cur;
                if (rem &lt;= 0)
                    continue;

                for (int i = 0; i &lt; 2; i++) {
                    for (int j = 0; j &lt; 2; j++) {
                        long v = dp[a][b][i][j];
                        if (v == Long.MAX_VALUE)
                            continue;
                        if (a &lt; cnt[0]) {
                            if (cur &lt; 2 || i + j != 0) {
                                long nv = v + teas[0].get(a).cost * rem;
                                if (nv &lt; dp[a + 1][b][j][0]) {
                                    dp[a + 1][b][j][0] = nv;
                                    how[a + 1][b][j][0] = i;
                                }
                            }
                        }
                        if (b &lt; cnt[1]) {
                            if (cur &lt; 2 || i + j != 2) {
                                long nv = v + teas[1].get(b).cost * rem;
                                if (nv &lt; dp[a][b + 1][j][1]) {
                                    dp[a][b + 1][j][1] = nv;
                                    how[a][b + 1][j][1] = i;
                                }
                            }
                        }
                    }
                }
            }
        }

        long ret = Long.MAX_VALUE;
        int i = 0, j = 0, a = 0, b = 0;
        for (int aa = 0; aa &lt;= cnt[0]; aa++) {
            for (int bb = 0; bb &lt;= cnt[1]; bb++) {
                if (aa + bb == k) {
                    for (int ii = 0; ii &lt; 2; ii++) {
                        for (int jj = 0; jj &lt; 2; jj++) {
                            if (dp[aa][bb][ii][jj] &lt; ret) {
                                ret = dp[aa][bb][ii][jj];
                                a = aa;
                                b = bb;
                                i = ii;
                                j = jj;
                            }
                        }
                    }
                }
            }
        }

        writer.println(ret);
    }

    static public void main(String[] args) {
        new Main().run();
    }
}


class LongUtils {
    static int sign(long x) {
        return x &lt; 0 ? -1 : x &gt; 0 ? 1 : 0;
    }

    static int compare(long a, long b) {
        return a &lt; b ? -1 : a &gt; b ? 1 : 0;
    }

    static long gcd(long a, long b) {
        while (b != 0) {
            long t = a % b;
            a = b;
            b = t;
        }
        return a;
    }

    static long[][] generateBinomialCoefficients(int n) {
        long[][] c = new long[n + 1][n + 1];
        for (int i = 0; i &lt;= n; i++) {
            c[i][0] = 1;
            for (int j = 1; j &lt;= i; j++) {
                c[i][j] = c[i - 1][j] + c[i - 1][j - 1];
            }
        }
        return c;
    }

    static long[][] generateBinomialCoefficients(int n, long module) {
        long[][] c = new long[n + 1][n + 1];
        for (int i = 0; i &lt;= n; i++) {
            c[i][0] = 1 % module;
            for (int j = 1; j &lt;= i; j++) {
                c[i][j] = c[i - 1][j] + c[i - 1][j - 1];
                if (c[i][j] &gt;= module)
                    c[i][j] -= module;
            }
        }
        return c;
    }

    static boolean isPrime(long x) {
        if (x == 1)
            return false;
        for (long i = 2; i * i &lt;= x; i++)
            if (x % i == 0)
                return false;
        return true;
    }


    static long[] toLongArr(Long[] longs) {
        long[] arr = new long[longs.length];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = longs[i];
        }
        return arr;
    }

    static Long[] toLongArr(long[] a) {
        Long[] arr = new Long[a.length];
        for (int i = 0; i &lt; arr.length; i++) {
            arr[i] = a[i];
        }
        return arr;
    }

    static long factorial(int n) {
        long ret = 1;
        for (int i = 2; i &lt;= n; i++) {
            ret *= i;
        }
        return ret;
    }

    static long factorial(int n, long module) {
        long ret = 1;
        for (int i = 2; i &lt;= n; i++) {
            ret = ret * i % module;
        }
        return ret;
    }

    static long pow(long x, long e, long module) {
        if (e == 0)
            return 1 % module;
        return e % 2 == 0 ? pow(x * x % module, e &gt;&gt; 1, module) : pow(x, e - 1, module) * x % module;
    }

    static long inverse(long x, long module) {
        return pow(x, module - 2, module);
    }

    static long[] buildInverses(int n, long module) {//1..n
        long[] a = new long[n + 1];
        for (int i = 1; i &lt;= n; i++) {
            a[i] = inverse(i, module);
        }
        return a;
    }

    static long[] buildFactorials(int n, long module) {//1..n
        long[] a = new long[n + 1];
        a[0] = 1;

        for (int i = 1; i &lt;= n; i++) {
            a[i] = a[i - 1] * i % module;
        }

        return a;
    }

    static long[] buildInverses(long[] a, long module) {
        long[] ret = new long[a.length];
        for (int i = 0; i &lt; ret.length; i++) {
            ret[i] = inverse(a[i], module);
        }
        return ret;
    }

    static void swap(long[] arr, int a, int b) {
        long t = arr[a];
        arr[a] = arr[b];
        arr[b] = t;
    }

    static void reverse(long[] arr) {
        for (int l = 0, r = arr.length - 1; l &lt; r; l++, r--)
            swap(arr, l, r);
    }

    static long max(Object obj) {
        long ret = Long.MIN_VALUE;
        if (obj instanceof long[]) {
            long[] a = (long[]) obj;
            for (long i : a) {
                if (i &gt; ret)
                    ret = i;
            }
        } else if (obj instanceof Object[]) {
            Object[] a = (Object[]) obj;
            for (Object o : a) {
                ret = Math.max(ret, max(o));
            }
        } else throw new IllegalArgumentException();

        return ret;
    }

    static long min(Object obj) {
        long ret = Long.MAX_VALUE;
        if (obj instanceof long[]) {
            long[] a = (long[]) obj;
            for (long i : a) {
                if (i &lt; ret)
                    ret = i;
            }
        } else if (obj instanceof Object[]) {
            Object[] a = (Object[]) obj;
            for (Object o : a) {
                ret = Math.min(ret, min(o));
            }
        } else throw new IllegalArgumentException();
        return ret;
    }

    static void fill(Object obj, long x) {
        if (obj instanceof long[]) {
            long[] a = (long[]) obj;
            for (int i = 0; i &lt; a.length; i++) {
                a[i] = x;
            }
        } else if (obj instanceof Object[]) {
            Object[] a = (Object[]) obj;
            for (Object o : a) {
                fill(o, x);
            }
        } else throw new IllegalArgumentException();
    }

    static long sum(Object obj) {
        long ret = 0;
        if (obj instanceof long[]) {
            long[] a = (long[]) obj;
            for (long i : a) {
                ret += i;
            }
        } else if (obj instanceof Object[]) {
            Object[] a = (Object[]) obj;
            for (Object o : a) {
                ret += sum(o);
            }
        } else throw new IllegalArgumentException();
        return ret;
    }


    static long sum(Object obj, long module) {
        long ret = 0;
        if (obj instanceof long[]) {
            long[] a = (long[]) obj;
            for (long i : a) {
                ret += i;
                ret %= module;
                if (ret &lt; 0)
                    ret += module;
            }
        } else if (obj instanceof Object[]) {
            Object[] a = (Object[]) obj;
            for (Object o : a) {
                ret += sum(o, module);
                ret %= module;
                if (ret &lt; 0)
                    ret += module;
            }
        } else throw new IllegalArgumentException();
        return ret;
    }
}</pre><pre></pre><h2>Problem2705</h2><pre>n=int(raw_input())
def p(n):
	i,r=2,n
	while i*i &lt;= n:
		if n%i==0:
			r=r/i*(i-1)
			while n%i==0:
				n/=i
		i=i+1
	if n &gt; 1:
		r=r/n*(n-1)	
	return r

def gcd(a,b):
	if b == 0:
		return a
	else:
		return gcd(b,a%b)

def bf(n):
	r=0
	for i in range(1,n+1):
		r+=gcd(i,n)
	return r

i,r=1,0
while i*i&lt;=n:
	if n%i==0:
		r+=p(n/i)*i
		if i*i&lt;n:
			r+=p(i)*(n/i)
	i=i+1
print r</pre><pre></pre><h2>Problem2728</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;bitset&gt;
using namespace std;

typedef long long int64;

int n, k;
int64 L, R;
const int MAX_N = 1000 + 10;
const int MAX_K = 60 + 10;

int64 a[MAX_N];

int id[MAX_K];
string mask[MAX_K];
string all[MAX_K];
int tot;

int what[MAX_K];

int64 calc(int64 R) { //&lt;R
	memset(what, -1, sizeof what);

	int nFree = tot;
	if (R &gt;= (1LL &lt;&lt; k))
		return 1LL &lt;&lt; tot;

	int64 ans = 0;

	for (int i = k - 1; i &gt;= 0; --i) {
		int me = R &gt;&gt; i &amp; 1;
		int w = id[i];
		if (me == 0) {
			if (what[w] == -1)
				what[w] = 0, --nFree;
			if (what[w] != 0)
				break;
		} else {
			if (what[w] == 0)
				ans += 1LL &lt;&lt; nFree;
			if (what[w] == -1)
				ans += 1LL &lt;&lt; (nFree - 1);
			if (what[w] == -1)
				what[w] = 1, --nFree;
			if (what[w] != 1)
				break;
		}
	}

	return ans;
}

int main() {
	cin &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; R;
	R = min(R, (1LL &lt;&lt; k) - 1);
	if (L &gt; R) {
		cout &lt;&lt; 0 &lt;&lt; endl;
		return 0;
	}

	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; a[i];
	}

	for (int i = 0; i &lt; k; ++i) {
		string r = "";
		for (int j = 0; j &lt; n; ++j) {
			if (a[j] &gt;&gt; i &amp; 1)
				r += "1";
			else
				r += "0";
		}
		mask[i] = r;
		all[i] = r;
	}
	sort(all, all + k);
	tot = unique(all, all + k) - all;
	for (int i = 0; i &lt; k; ++i) {
		id[i] = lower_bound(all, all + tot, mask[i]) - all;
	}
	cout &lt;&lt; calc(R + 1) - calc(L) &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2729</h2><pre>n,m=map(int,raw_input().split())
def A(n,m):
	r=1
	for i in range(m):
		r*=n-i
	return r
print A(n,n)*(A(n+1,2)*A(n+3,m)+2*m*(n+1)*A(n+2,m-1))</pre><pre></pre><h2>Problem2735</h2><pre>/*
 * a.cpp
 *
 *  Created on: 2012-4-21
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
typedef long long int64;
const int MAX_N = int(1e5) + 10;
int n, nQ;
int64 a[MAX_N], b[MAX_N];
int64 val[MAX_N];
int64 ans[MAX_N];
int lt[MAX_N], rt[MAX_N];
template&lt;class T&gt;
struct Index: public vector&lt;T&gt; {
    using vector&lt;T&gt;::erase;
    using vector&lt;T&gt;::begin;
    using vector&lt;T&gt;::end;
    void doit() {
        sort(begin(), end());
        erase(unique(begin(), end()), end());
    }
    int get(T x) {
        return lower_bound(begin(), end(), x) - begin();
    }
};
Index&lt;int64&gt; idv;
struct Tree;
Tree*get();
struct Tree {
    int l, r, cnt;
    int64 sum;
    Tree*pl, *pr;
    Tree*set(int _l, int _r, Tree*_pl, Tree*_pr) {
        l = _l, r = _r, pl = _pl, pr = _pr;
        sum = pl-&gt;sum + pr-&gt;sum;
        cnt = pl-&gt;cnt + pr-&gt;cnt;
        return this;
    }
    Tree*set(int _l, int _r, int all) {
        l = _l, r = _r;
        if (l + 1 == r) {
            cnt = all;
            sum = 1LL * idv[l] * cnt;
            pl = pr = 0;
            return this;
        }
        int m = (l + r) &gt;&gt; 1;
        pl = get()-&gt;set(l, m, all);
        pr = get()-&gt;set(m, r, all);
        sum = pl-&gt;sum + pr-&gt;sum;
        cnt = pl-&gt;cnt + pr-&gt;cnt;
        return this;
    }
    Tree*modify(int at, int add) {
        if (l + 1 == r) {
            return get()-&gt;set(l, r, cnt + add);
        }
        int m = (l + r) &gt;&gt; 1;
        if (at &lt; m)
            return get()-&gt;set(l, r, pl-&gt;modify(at, add), pr);
        else
            return get()-&gt;set(l, r, pl, pr-&gt;modify(at, add));
    }
};
const int MAX_BUFFER = 10000;
Tree*buffer, *cur = 0;
Tree*get() {
    if (!cur || cur == buffer + MAX_BUFFER) {
        buffer = new Tree[MAX_BUFFER];
        cur = buffer;
    }
    return cur++;
}
Tree*by[MAX_N];
void doIt() {
    idv.clear();
    for (int i = 0; i &lt; n; ++i) {
        idv.push_back(val[i]);
    }
    idv.doit();
    for (int i = 0; i &lt; n; ++i) {
        val[i] = idv.get(val[i]);
    }
    by[0] = get()-&gt;set(0, idv.size(), 0);
    for (int i = 0; i &lt; n; ++i) {
        by[i + 1] = by[i]-&gt;modify(val[i], 1);
    }
    for (int i = 0; i &lt; nQ; ++i) {
        Tree*l = by[lt[i]], *r = by[rt[i]];
        int64 sum = r-&gt;sum - l-&gt;sum;
        int cnt = (rt[i] - lt[i]);
        int k = cnt / 2;
        int64 sumS = 0;
        int cntS = 0;
        int64 mid;
        for (;;) {
            if (l-&gt;l + 1 == l-&gt;r) {
                mid = idv[l-&gt;l];
                break;
            }
            int tmp = r-&gt;pl-&gt;cnt - l-&gt;pl-&gt;cnt;
            if (tmp &lt;= k) {
                k -= tmp;
                sumS += r-&gt;pl-&gt;sum - l-&gt;pl-&gt;sum;
                cntS += tmp;
                l = l-&gt;pr, r = r-&gt;pr;
            } else {
                l = l-&gt;pl;
                r = r-&gt;pl;
            }
        }
        int64 cntB = cnt - cntS, sumB = sum - sumS;
        int64 ret = (mid * cntS - sumS) + (sumB - cntB * mid);
        ans[i] += ret;
    }
}
int main() {
    cin &gt;&gt; n &gt;&gt; nQ;
    for (int i = 0; i &lt; n; ++i) {
        int x;
        scanf("%d", &amp;x), a[i] = x;
    }
    for (int i = 0; i &lt; n; ++i) {
        int x;
        scanf("%d", &amp;x), b[i] = x;
    }
    for (int i = 0; i &lt; nQ; ++i) {
        scanf("%d%d", lt + i, rt + i);
        --lt[i];
    }
    memset(ans, 0, sizeof ans);
    for (int i = 0; i &lt; n; ++i) {
        val[i] = a[i] + b[i];
    }
    doIt();
    for (int i = 0; i &lt; n; ++i) {
        val[i] = a[i] - b[i];
    }
    doIt();
    for (int i = 0; i &lt; nQ; ++i) {
        printf("%0.2lf\n", (double) ans[i] / 2);
    }
    return 0;
}</pre><pre></pre><h2>Problem2736</h2><pre>/*
 * p2.cpp
 *
 *  Created on: 2012-4-21
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N = 50 + 10;
const int MAX_K = 16;
typedef long long int64;
const int MOD = 1000000007;
int n, k;
int64 dp[MAX_N][1 &lt;&lt; MAX_K]; //i,[v[i]+1,v[i]+k]
int v[MAX_N];
bool have[300];
int64 a[1 &lt;&lt; MAX_K];
int64 dp1[1 &lt;&lt; MAX_K], dp2[1 &lt;&lt; MAX_K]; //ans,sum
int main() {
    cin &gt;&gt; n &gt;&gt; k;
    for (int i = 0; i &lt; n; ++i) {
        cin &gt;&gt; v[i];
    }
    sort(v, v + n);
    for (int i = 1; i &lt; n; ++i) {
        if (v[i] &gt; v[i - 1] + k) {
            cout &lt;&lt; 0 &lt;&lt; endl;
            return 0;
        }
    }
    memset(have, 0, sizeof have);
    for (int i = 0; i &lt; n; ++i) {
        have[v[i]] = true;
    }
    dp[n - 1][0] = 1;
    for (int i = n - 2; i &gt;= 0; --i) {
        //update from i+1 to i
        int l = v[i] + 1, r = v[i] + k;
        int nl = v[i + 1] + 1, nr = v[i + 1] + k;
        for (int mask = 0; mask &lt; 1 &lt;&lt; k; ++mask) {
            int nmask = 0;
            bool ok = true;
            for (int j = 0; j &lt; k; ++j) {
                if (have[l + j]) {
                    int nj = l + j - nl;
                    if (mask &gt;&gt; j &amp; 1) {
                        if (nj &gt;= 0)
                            nmask |= 1 &lt;&lt; nj;
                    } else {
                        if (nj &lt; 0) {
                            ok = false;
                            break;
                        }
                    }
                } else {
                    if (mask &gt;&gt; j &amp; 1) {
                        ok = false;
                        break;
                    }
                }
            }
            if (ok) {
                a[mask] = dp[i + 1][nmask];
            } else {
                a[mask] = 0;
            }
        }
        for (int mask = 0; mask &lt; 1 &lt;&lt; k; ++mask) {
            dp1[mask] = 0;
            dp2[mask] = a[mask];
        }
        for (int i = 0; i &lt; k; ++i) {
            for (int mask = 0; mask &lt; 1 &lt;&lt; k; ++mask) {
                if (~mask &gt;&gt; i &amp; 1) {
                    dp2[mask] += dp2[mask ^ (1 &lt;&lt; i)];
                    dp2[mask] %= MOD;
                    dp1[mask] += dp1[mask ^ (1 &lt;&lt; i)] + dp2[mask ^ (1 &lt;&lt; i)];
                    dp1[mask] %= MOD;
                }
            }
        }
        for (int mask = 0; mask &lt; 1 &lt;&lt; k; ++mask) {
            dp[i][mask] = (dp1[mask] + a[mask]) % MOD;
        }
    }
    int64 ans = dp[0][0];
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</pre><pre></pre><h2>Problem2738</h2><pre>/*
 * p1.cpp
 *
 *  Created on: 2012-4-22
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N = 500 + 10;
const int MAX_Q = 60000 + 10;
int val[MAX_N][MAX_N];
int n, nQ;
struct Query {
    int x1, y1, x2, y2, k;
    int id;
    void read() {
        scanf("%d%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;k);
        --x1, --y1, --x2, --y2, --k;
    }
};
Query qs[MAX_Q];
struct Value {
    int r, c, v;
    bool operator&lt;(const Value&amp;o) const {
        return v &lt; o.v;
    }
};
Value values[MAX_N * MAX_N];
int nValues;
int ta[MAX_N][MAX_N];
int ans[MAX_Q];
void add(int i, int j, int a) {
    for (register int x = i + 1; x &lt;= n; x += x &amp; -x)
        for (register int y = j + 1; y &lt;= n; y += y &amp; -y)
            ta[x - 1][y - 1] += a;
}
int get(int i, int j) {
    register int ret = 0;
    for (register int x = i + 1; x; x -= x &amp; -x)
        for (register int y = j + 1; y; y -= y &amp; -y)
            ret += ta[x - 1][y - 1];
    return ret;
}
int get(int x1, int y1, int x2, int y2) {
    return get(x2, y2) - get(x1 - 1, y2) - get(x2, y1 - 1) + get(x1 - 1, y1 - 1);
}
void rec(int l, int r, Query qs[], int nQs) {
    if (l + 1 == r) {
        for (int i = 0; i &lt; nQs; ++i) {
            ans[qs[i].id] = values[l].v;
        }
        return;
    }
    int m = (l + r) &gt;&gt; 1;
    for (int i = l; i &lt; m; ++i) {
        Value&amp;v = values[i];
        add(v.r, v.c, 1);
    }
    int cnt = 0;
    for (int i = 0; i &lt; nQs; ++i) {
        Query&amp;q = qs[i];
        int num = get(q.x1, q.y1, q.x2, q.y2);
        if (num &lt;= q.k) {
            q.k -= num;
        } else {
            swap(qs[i], qs[cnt++]);
        }
    }
    for (int i = l; i &lt; m; ++i) {
        Value&amp;v = values[i];
        add(v.r, v.c, -1);
    }
    rec(l, m, qs, cnt);
    rec(m, r, qs + cnt, nQs - cnt);
}
int main() {
    cin &gt;&gt; n &gt;&gt; nQ;
    for (int r = 0; r &lt; n; ++r) {
        for (int c = 0; c &lt; n; ++c) {
            scanf("%d", val[r] + c);
        }
    }
    for (int i = 0; i &lt; nQ; ++i) {
        qs[i].read();
        qs[i].id = i;
    }
    nValues = 0;
    for (int r = 0; r &lt; n; ++r) {
        for (int c = 0; c &lt; n; ++c) {
            values[nValues++] = (Value) {r,c,val[r][c]};
        }
    }
    sort(values, values + nValues);
    rec(0, nValues, qs, nQ);
    for (int i = 0; i &lt; nQ; ++i) {
        printf("%d\n", ans[i]);
    }
    return 0;
}</pre><pre></pre><h2>Problem2741</h2><pre>/*
 * 2741.cpp
 *
 *  Created on: 2012-4-26
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_N = 12000;

const int MAX_POOL = 10000000;

struct Trie;

Trie*get();

struct Trie {
	Trie*ch[2];
	Trie*clone() {
		Trie*t = get();
		memcpy(t-&gt;ch, ch, sizeof ch);
		return t;
	}
	Trie() {
		memset(ch, 0, sizeof ch);
	}
};

Trie pool[MAX_POOL], *cur = pool;
Trie*get() {
	memset(cur-&gt;ch, 0, sizeof cur-&gt;ch);
	return cur++;
}

Trie*go(Trie*t, int x, int at) {
	Trie*cp = t == 0 ? get() : t-&gt;clone();
	if (at &lt; 0)
		return cp;
	int me = x &gt;&gt; at &amp; 1;
	cp-&gt;ch[me] = go(cp-&gt;ch[me], x, at - 1);
	return cp;
}

int ask(Trie*a, int x, int at) {
	if (at &lt; 0)
		return 0;
	int me = x &gt;&gt; at &amp; 1;
	if (a-&gt;ch[!me])
		return (1 &lt;&lt; at) + ask(a-&gt;ch[!me], x, at - 1);
	else
		return ask(a-&gt;ch[me], x, at - 1);
}

const int MAX_SQRT = 120;

Trie*rt[MAX_SQRT][MAX_N];
int ans[MAX_SQRT][MAX_N];

int n, nQ;
int a[MAX_N];

int nSqrt;

bool is[MAX_N];

int calc(Trie*t, int l, int r) { //[l,r)
	int ret = 0;
	Trie*old = cur;
	for (int i = l; i &lt; r; ++i) {
		if (t)
			ret = max(ret, ask(t, a[i], 30));
		t = go(t, a[i], 30);
	}
	cur = old;
	return ret;
}

int main() {
	cin &gt;&gt; n &gt;&gt; nQ;
	for (int i = 1; i &lt;= n; ++i) {
		scanf("%d", a + i);
		a[i] ^= a[i - 1];
	}

	nSqrt = 1;
	while (nSqrt * nSqrt &lt;= n)
		nSqrt++;

	if (nSqrt &lt; 300)
		nSqrt = 300;

	memset(is, 0, sizeof is);
	for (int i = 0; i &lt;= n; i += nSqrt) {
		is[i] = true;
		int id = i / nSqrt;
		Trie*cur = 0;
		int ret = 0;
		for (int j = i; j &lt;= n; ++j) {
			if (cur)
				ret = max(ret, ask(cur, a[j], 30));
			cur = go(cur, a[j], 30);
			rt[id][j] = cur;
			ans[id][j] = ret;
		}
	}

	int last = 0;
	for (int i = 0; i &lt; nQ; ++i) {
		int x, y;
		scanf("%d%d", &amp;x, &amp;y);
		x %= n, y %= n;
		(x += last) %= n, (y += last) %= n;
		if (x &gt; y)
			swap(x, y);
		++y;

		int st = -1;
		for (int i = x; i &lt;= y; ++i) {
			if (is[i]) {
				st = i;
				break;
			}
		}

		if (st == -1) {
			int ans = calc(0, x, y + 1);
			printf("%d\n", ans);
			last = ans % n;
		} else {
			Trie*t = rt[st / nSqrt][y];
			int ans = max(::ans[st / nSqrt][y], calc(t, x, st));
			printf("%d\n", ans);
			last = ans % n;
		}
	}
}
</pre><pre></pre><h2>Problem2742</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
using namespace std;
int a[220], p[220], q[220], n, m, i, j, a0, an;
long long b[220], c[220];

int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}

bool ok(int x, int y, int mod) {
	int i;
	long long t = 0;
	for (b[0] = i = 1; i &lt;= n; i++)
		b[i] = b[i - 1] * x % mod;
	for (c[0] = i = 1; i &lt;= n; i++)
		c[i] = c[i - 1] * y % mod;
	for (i = 0; i &lt;= n; i++)
		t = (t + a[i] * b[i] * c[n - i]) % mod;
	if (t == 0)
		return 1;
	return 0;
}

void calc(int y, int x) {
	if (x &gt; 0 &amp;&amp; gcd(x, y) &gt; 1)
		return;
	if (ok(x, y, 9973) &amp;&amp; ok(x, y, 10007) &amp;&amp; ok(x, y, 32767))
		p[++m] = x, q[m] = y;
	if (x &gt; 0)
		calc(y, -x);
}

int main() {
	cin &gt;&gt; n;
	for (i = 0; i &lt;= n; i++)
		scanf("%d", &amp;a[i]);
	an = abs(a[n]);
	for (i = 0; i &lt;= n; i++)
		if (a[i]) {
			a0 = abs(a[i]);
			break;
		}
	if (!a[0])
		p[++m] = 0, q[m] = 1;
	for (i = 1; i * i &lt;= an; i++)
		if (an % i == 0)
			for (j = 1; j * j &lt;= a0; j++)
				if (a0 % j == 0) {
					calc(i, j);
					if (j * j != a0)
						calc(i, a0 / j);
					if (i * i != an)
						calc(an / i, j);
					if (i * i != an &amp;&amp; j * j != a0)
						calc(an / i, a0 / j);
				}
	for (i = 1; i &lt; m; i++)
		for (j = i + 1; j &lt;= m; j++)
			if (p[i] * q[j] &gt; p[j] * q[i])
				swap(p[i], p[j]), swap(q[i], q[j]);
	cout &lt;&lt; m &lt;&lt; endl;
	for (i = 1; i &lt;= m; i++)
		if (q[i] == 1)
			printf("%d\n", p[i]);
		else
			printf("%d/%d\n", p[i], q[i]);
	return 0;
}
</pre><pre></pre><h2>Problem2744</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
using namespace std;

const int MAX_N = 3000 + 10;
int a[MAX_N], b[MAX_N];
int A, B, M;
vector&lt;int&gt; f[MAX_N];
int cnt[MAX_N];

bool g[MAX_N][MAX_N];
int rs[MAX_N], ls[MAX_N], L, R;

int cntbit(int x) {
	int r = 0;
	for (; x; x -= x &amp; -x)
		++r;
	return r;
}

int mark[MAX_N], cur;
int pr[MAX_N];

bool dfs(int u) {
	if (mark[u] == cur)
		return false;
	mark[u] = cur;
	for (int v = 0; v &lt; R; ++v)
		if (g[u][v])
			if (pr[v] == -1 || dfs(pr[v]))
				return pr[v] = u, true;
	return false;
}

int main() {
	cin &gt;&gt; A &gt;&gt; B &gt;&gt; M;
	for (int i = 0; i &lt; A; ++i) {
		cin &gt;&gt; a[i];
	}
	for (int j = 0; j &lt; B; ++j) {
		cin &gt;&gt; b[j];
	}
	for (int i = 0; i &lt; M; ++i) {
		int x, y;
		cin &gt;&gt; x &gt;&gt; y;
		--x, --y;
		f[x].push_back(y);
	}

	int ans = 0;

	for (int i = A; i &gt;= 0; --i) {
		for (int j = A; j &gt;= 0; --j) {
			if (i &lt; A &amp;&amp; j &lt; A &amp;&amp; (a[i] ^ a[j]) % 2 != 1)
				continue;
			if (i &lt; A &amp;&amp; j &lt; A &amp;&amp; i == j)
				continue;

			memset(cnt, 0, sizeof(int) * B);

			int nCh = (i &lt; A) + (j &lt; A);
			if (i &lt; A)
				for (vector&lt;int&gt;::iterator e = f[i].begin(); e != f[i].end(); ++e) {
					++cnt[*e];
				}
			if (j &lt; A)
				for (vector&lt;int&gt;::iterator e = f[j].begin(); e != f[j].end(); ++e) {
					++cnt[*e];
				}

			L = 0, R = 0;

			for (int i = 0; i &lt; B; ++i) {
				if (cnt[i] == nCh) {
					if (b[i] % 2 == 0)
						ls[L++] = b[i];
					else
						rs[R++] = b[i];
				}
			}

			int ret = L + R + nCh;
			if (ret &lt;= ans)
				continue;

			for (int i = 0; i &lt; L; ++i) {
				for (int j = 0; j &lt; R; ++j) {
					g[i][j] = cntbit(ls[i] | rs[j]) % 2 == 0;
				}
			}

			memset(pr, -1, sizeof(int) * R);
			for (int i = 0; i &lt; L; ++i) {
				++cur;
				if (dfs(i))
					--ret;
				if (ret &lt;= ans)
					break;
			}
			ans = max(ans, ret);
		}
	}

	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2748</h2><pre>n,s,mx=map(int,raw_input().split())
c=map(int,raw_input().split())
can=[False]*(mx+1)
can[s]=True
for i in c:
	ncan=[False]*(mx+1)
	for j in range(mx+1):
		if can[j] and j-i&gt;=0:
			ncan[j-i]=True
		if can[j] and j+i&lt;=mx:
			ncan[j+i]=True
	can=ncan
for i in range(mx,-1,-1):
	if can[i]:
		print i
		break
else:
	print -1</pre><pre></pre><h2>Problem2751</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
using namespace std;
typedef long long int64;
const int MOD = 1000000007;

int64 n, m;
int k;

const int MAX_K = int(1e5) + 10;

map&lt;int, set&lt;int&gt; &gt; mp;

int64 myPow(int64 x, int64 e) {
	if (!e)
		return 1;
	return e % 2 == 0 ? myPow(x * x % MOD, e &gt;&gt; 1) : myPow(x, e - 1) * x % MOD;
}

int main() {
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
	int64 tot = n * (n + 1) / 2 % MOD;
	for (int i = 0; i &lt; k; ++i) {
		int x, y;
		scanf("%d%d", &amp;x, &amp;y);
		--x;
		mp[x].insert(y);
	}
	int64 ans = myPow(tot, m - mp.size());
	for (map&lt;int, set&lt;int&gt; &gt;::iterator it = mp.begin(); it != mp.end(); ++it) {
		int64 cur = tot - accumulate(it-&gt;second.begin(), it-&gt;second.end(), 0LL);
		cur = (cur % MOD + MOD) % MOD;
		ans = ans * cur % MOD;
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2753</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
using namespace std;

const int MAX_N = 100000 + 10;
const int MAX_M = 1000000 + 10;

int h[MAX_N];
int nV, nE;

struct Edge {
	int t, c;
};

vector&lt;Edge&gt; E[MAX_N];

typedef long long int64;

bool vis[MAX_N];

void dfs(int u) {
	if (vis[u])
		return;
	vis[u] = true;
	for (vector&lt;Edge&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (h[u] &gt;= h[e-&gt;t])
			dfs(e-&gt;t);
	}
}

bool cmp(int a, int b) {
	return h[a] &gt; h[b];
}

int p[MAX_N];

struct WE {
	int a, b, c;
	bool operator&lt;(const WE&amp;e) const {
		return c &lt; e.c;
	}
};

int f[MAX_N];
int fd(int x) {
	return f[x] == x ? x : f[x] = fd(f[x]);
}

WE es[MAX_M + MAX_N];
int nEs;

inline int nextInt() {
	int x = 0;
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
	return x;
}

int main() {
	nV = nextInt();
	nE = nextInt();
	for (int i = 0; i &lt; nV; ++i) {
		h[i] = nextInt();
		p[i] = i;
	}
	for (int i = 0; i &lt; nE; ++i) {
		int a = nextInt(), b = nextInt(), c = nextInt();
		--a, --b;
		E[a].push_back((Edge) {b,c});
		E[b].push_back((Edge) {a,c});
	}
	dfs(0);

	sort(p, p + nV, cmp);

	for (int i = 0; i &lt; nV; ++i) {
		f[i] = i;
	}

	int64 ans = 0;

	for (int i = 0, j; i &lt; nV; i = j) {
		for (j = i; j &lt; nV &amp;&amp; h[p[i]] == h[p[j]]; ++j)
			;
		if (h[p[i]] &gt; h[0])
			continue;
		//[i,j)
		f[nV] = nV;
		nEs = 0;

		for (int k = i; k &lt; j; ++k) {
			int x = p[k];
			int mi = INT_MAX;
			if (!vis[x])
				continue;
			for (vector&lt;Edge&gt;::iterator e = E[x].begin(); e != E[x].end(); ++e) {
				if (h[e-&gt;t] &gt; h[x] &amp;&amp; vis[e-&gt;t])
					mi = min(mi, e-&gt;c);
				else if (h[e-&gt;t] == h[x] &amp;&amp; x &lt; e-&gt;t)
					es[nEs++] = (WE) {x,e-&gt;t,e-&gt;c};
			}
			if (mi != INT_MAX)
				es[nEs++] = (WE) {x,nV,mi};
		}

		sort(es, es + nEs);
		for (int i = 0; i &lt; nEs; ++i) {
			int a = es[i].a, b = es[i].b;
			a = fd(a), b = fd(b);
			if (a != b)
				f[a] = b, ans += es[i].c;
		}
	}

	int tot = 0;
	for (int i = 0; i &lt; nV; ++i) {
		if (vis[i])
			++tot;
	}

	cout &lt;&lt; tot &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2754</h2><pre>/*
 * a.cpp
 *
 *  Created on: 2012-5-3
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_N = 20000 + 10;
const int MAX_M = 50000 + 10;
const int MAX_LEN = 100000 + 10;

vector&lt;int&gt; name[MAX_N][2];

int n, m;

void readVec(vector&lt;int&gt;&amp;a) {
	int k;
	scanf("%d", &amp;k);
	a.resize(k);
	for (int i = 0; i &lt; k; ++i) {
		scanf("%d", &amp;a[i]);
	}
}

const int MAX_LOG = 20;

int cur;

struct Trie {
	map&lt;int, Trie*&gt; ch;
	Trie*fail;
	vector&lt;Trie*&gt; failCh;

	int cnt;
	int ord;
	int dep;

	int sum;

	Trie() {
		sum = cnt = 0;
		fail = 0;
	}

	Trie*get(int w) {
		if (ch.count(w))
			return ch[w];
		return ch[w] = new Trie;
	}

	Trie*ask(int w) {
		return ch.count(w) ? ch[w] : 0;
	}

	Trie*anc[MAX_LOG];

	void dfs(int tot, int d) {
		tot += cnt;
		cnt = tot;
		dep = d;
		anc[0] = fail;
		ord = cur++;
		for (int i = 1; i &lt; MAX_LOG; ++i) {
			Trie*p = anc[i - 1];
			if (p == 0)
				anc[i] = 0;
			else
				anc[i] = p-&gt;anc[i - 1];
		}
		for (vector&lt;Trie*&gt;::iterator e = failCh.begin(); e != failCh.end(); ++e) {
			(*e)-&gt;dfs(tot, d + 1);
		}
	}

	Trie*up(int x) {
		Trie*u = this;
		for (int i = 0; i &lt; MAX_LOG; ++i) {
			if (x &gt;&gt; i &amp; 1)
				u = u-&gt;anc[i];
		}
		return u;
	}

	void dfs2() {
		for (vector&lt;Trie*&gt;::iterator e = failCh.begin(); e != failCh.end(); ++e) {
			(*e)-&gt;dfs2();
			sum += (*e)-&gt;sum;
		}
	}
}*root;

Trie*getLca(Trie*u, Trie*v) {
	int need = min(u-&gt;dep, v-&gt;dep);
	u = u-&gt;up(u-&gt;dep - need), v = v-&gt;up(v-&gt;dep - need);
	if (u == v)
		return u;
	for (int i = MAX_LOG - 1; i &gt;= 0; --i) {
		if (u-&gt;anc[i] != v-&gt;anc[i])
			u = u-&gt;anc[i], v = v-&gt;anc[i];
	}
	return u-&gt;anc[0];
}

Trie*que[MAX_LEN];

bool cmp(Trie*a, Trie*b) {
	return a-&gt;ord &lt; b-&gt;ord;
}

Trie*ts[MAX_LEN];
int nTs;

void process(vector&lt;int&gt;&amp;a) {
	Trie*t = root;
	for (vector&lt;int&gt;::iterator e = a.begin(); e != a.end(); ++e) {
		int x = *e;
		while (t &amp;&amp; t-&gt;ask(x) == 0)
			t = t-&gt;fail;
		if (t)
			t = t-&gt;ask(x);
		else
			t = root;
		ts[nTs++] = t;
	}
}

Trie*at[MAX_M];

int ans[MAX_N];

int main() {
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 0; i &lt; n; ++i) {
		for (int j = 0; j &lt; 2; ++j) {
			readVec(name[i][j]);
		}
	}

	root = new Trie;
	for (int i = 0; i &lt; m; ++i) {
		int k;
		scanf("%d", &amp;k);
		Trie*t = root;
		for (int j = 0; j &lt; k; ++j) {
			int x;
			scanf("%d", &amp;x);
			t = t-&gt;get(x);
		}
		t-&gt;cnt++;
		at[i] = t;
	}

	int qh = 0, qt = 0;
	que[qt++] = root;
	root-&gt;fail = 0;
	while (qh &lt; qt) {
		Trie*t = que[qh++];
		for (map&lt;int, Trie*&gt;::iterator it = t-&gt;ch.begin(); it != t-&gt;ch.end(); ++it) {
			Trie*v = it-&gt;second;
			int x = it-&gt;first;
			Trie*f = t-&gt;fail;
			while (f &amp;&amp; !f-&gt;ask(x))
				f = f-&gt;fail;
			if (f)
				v-&gt;fail = f-&gt;ask(x);
			else
				v-&gt;fail = root;
			v-&gt;fail-&gt;failCh.push_back(v);
			que[qt++] = v;
		}
	}

	cur = 0;
	root-&gt;dfs(0, 0);

	for (int i = 0; i &lt; n; ++i) {
		nTs = 0;
		for (int j = 0; j &lt; 2; ++j) {
			process(name[i][j]);
		}

		sort(ts, ts + nTs, cmp);
		int ret = 0;
		for (int j = 0; j &lt; nTs; ++j) {
			ret += ts[j]-&gt;cnt;
			ts[j]-&gt;sum++;
			if (j &gt; 0) {
				Trie*l = getLca(ts[j - 1], ts[j]);
				ret -= l-&gt;cnt;
				l-&gt;sum--;
			}
		}
		ans[i] = ret;
	}

	root-&gt;dfs2();

	for (int i = 0; i &lt; m; ++i) {
		printf("%d\n", at[i]-&gt;sum);
	}

	for (int i = 0; i &lt; n; ++i) {
		printf("%d", ans[i]);
		if (i + 1 &lt; n)
			printf(" ");
	}
	puts("");
	return 0;
}
</pre><pre></pre><h2>Problem2756</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
using namespace std;

typedef long long int64;

const int MAX_N = 40 + 10;
int v[MAX_N][MAX_N];
int n, m;

int64 INF = LONG_LONG_MAX / 4;

namespace SAP {
	const int MAX_V = MAX_N * MAX_N;
	const int MAX_E = MAX_V * 20;

	int nV;

	struct Edge {
		int t;
		int64 c;
		Edge*r, *n;
		Edge*set(int _t, int64 _c, Edge*_n) {
			t = _t, c = _c, n = _n;
			return this;
		}
	};

	Edge es[MAX_E], *ce;
	Edge*E[MAX_V];

	Edge*makeEdge(int s, int t, int64 c) {
		return E[s] = (ce++)-&gt;set(t, c, E[s]);
	}

	void addEdge(int s, int t, int64 c) {
		Edge*st = makeEdge(s, t, c), *ts = makeEdge(t, s, 0);
		st-&gt;r = ts, ts-&gt;r = st;
	}

	void init(int _nV) {
		nV = _nV;
		ce = es;
		for (int i = 0; i &lt; nV; ++i) {
			E[i] = 0;
		}
	}

	int64 am[MAX_V];
	int cnt[MAX_V], h[MAX_V];
	Edge*cur[MAX_V], *prev[MAX_V];

	int64 maxFlow(int vs, int vt) {
		memset(am, 0, sizeof am);
		memset(cnt, 0, sizeof cnt);
		memset(cur, 0, sizeof cur);
		memset(prev, 0, sizeof prev);
		memset(h, 0, sizeof h);
		am[vs] = INF;
		cnt[0] = nV;
		int u = vs;
		Edge*e = 0;
		int64 tot = 0;
		while (h[vs] &lt; nV) {
			for (e = cur[u]; e; e = e-&gt;n)
				if (e-&gt;c &amp;&amp; h[u] == h[e-&gt;t] + 1)
					break;
			if (e) {
				int v = e-&gt;t;
				cur[u] = prev[v] = e;
				am[v] = min(e-&gt;c, am[u]);
				if ((u = v) == vt) {
					int64 by = am[u];
					tot += by;
					while (u != vs) {
						Edge*p = prev[u];
						p-&gt;c -= by;
						p-&gt;r-&gt;c += by;
						u = p-&gt;r-&gt;t;
					}
					am[u] = INF;
				}
			} else {
				if (!--cnt[h[u]])
					break;
				h[u] = nV;
				for (e = E[u]; e; e = e-&gt;n)
					if (e-&gt;c &amp;&amp; h[e-&gt;t] + 1 &lt; h[u]) {
						cur[u] = e;
						h[u] = h[e-&gt;t] + 1;
					}
				++cnt[h[u]];
				if (u != vs)
					u = prev[u]-&gt;r-&gt;t;
			}
		}
		return tot;
	}
}

int64 need;

bool check(int64 same) {
	int vs = n * m, vt = n * m + 1;
	SAP::init(n * m + 2);
	need = 0;

	for (int r = 0; r &lt; n; ++r) {
		for (int c = 0; c &lt; m; ++c) {
			if ((r + c) &amp; 1) { //L
				SAP::addEdge(vs, r * m + c, same - v[r][c]);
				need += same - v[r][c];
				for (int dr = -1; dr &lt;= 1; ++dr) {
					for (int dc = -1; dc &lt;= 1; ++dc)
						if (dr == 0 ^ dc == 0) {
							int nr = r + dr, nc = c + dc;
							if (nr &gt;= 0 &amp;&amp; nr &lt; n &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; m) {
								SAP::addEdge(r * m + c, nr * m + nc, INF);
							}
						}
				}
			} else { //R
				SAP::addEdge(r * m + c, vt, same - v[r][c]);
			}
		}
	}

	return SAP::maxFlow(vs, vt) == need;
}

void work() {
	scanf("%d%d", &amp;n, &amp;m);
	int mx = 0;
	int cL = 0, cR = 0;
	int64 sL = 0, sR = 0;

	for (int r = 0; r &lt; n; ++r) {
		for (int c = 0; c &lt; m; ++c) {
			scanf("%d", v[r] + c);
			mx = max(mx, v[r][c]);
			if ((r + c) &amp; 1) { //L
				cL++;
				sL += v[r][c];
			} else {
				cR++;
				sR += v[r][c];
			}
		}
	}

	if (cL == cR) {
		if (sL != sR) {
			puts("-1");
			return;
		}
		int64 l = mx - 1, r = INF;
		if (!check(r)) {
			puts("-1");
			return;
		}
		while (l + 1 &lt; r) {
			int64 m = (l + r) &gt;&gt; 1;
			if (check(m))
				r = m;
			else
				l = m;
		}
		check(r);
		cout &lt;&lt; need &lt;&lt; endl;
	} else {
		// sL/cL == sR/cR
		// sL*cR == sR*cL
		//(sL+x)*cR == (sR+x)*cL
		//(x)*(cR-cL) == sR*cL-sL*cR
		int64 x = (sR * cL - sL * cR) / (cR - cL);
		int64 same = (sL + x) / cL;
		if (same &gt;= mx &amp;&amp; check(same))
			cout &lt;&lt; need &lt;&lt; endl;
		else
			puts("-1");
	}
}

int main() {
	int T;
	cin &gt;&gt; T;
	for (int i = 0; i &lt; T; ++i) {
		work();
	}
	return 0;
}
</pre><pre></pre><h2>Problem2757</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
using namespace std;

const int MAX_LEN = 20;
const int MOD = 20120427;

typedef long long int64;

const int PRIME[] = { 2, 3, 5, 7 };
int NUM[10][4];

int64 pw[MAX_LEN];

struct Result {
	int cnt, sum;
	Result() :
			cnt(0), sum(0) {
	}
};

namespace CALC1 { //k&gt;0
	const int MAX_SAVE = 17;

	bool saved[MAX_SAVE][MAX_SAVE * 3][MAX_SAVE * 2][MAX_SAVE][MAX_SAVE]; //rem,2,3,5,7
	Result memo[MAX_SAVE][MAX_SAVE * 3][MAX_SAVE * 2][MAX_SAVE][MAX_SAVE];

	Result eval(int rem, int c[]) {
		if (*min_element(c, c + 4) &lt; 0)
			return Result();
		if (rem == 0) {
			Result ret;
			if (count(c, c + 4, 0) == 4) {
				ret.cnt++;
			}
			return ret;
		}
		Result ret;
		if (rem &lt; MAX_SAVE) {
			if (c[0] &gt;= MAX_SAVE * 3 || c[1] &gt;= MAX_SAVE * 2 || c[2] &gt;= MAX_SAVE || c[3] &gt;= MAX_SAVE)
				return Result();
			bool&amp;sv = saved[rem][c[0]][c[1]][c[2]][c[3]];
			Result&amp; t = memo[rem][c[0]][c[1]][c[2]][c[3]];
			if (sv)
				return t;
			sv = true;
		}
		ret = Result();
		for (int i = 1; i &lt; 10; ++i) {
			for (int j = 0; j &lt; 4; ++j) {
				c[j] -= NUM[i][j];
			}
			Result ch = eval(rem - 1, c);
			ret.cnt += ch.cnt;
			ret.sum += ch.sum + pw[rem - 1] * ch.cnt * i % MOD;
			ret.cnt %= MOD;
			ret.sum %= MOD;
			for (int j = 0; j &lt; 4; ++j) {
				c[j] += NUM[i][j];
			}
		}
		if (rem &lt; MAX_SAVE) {
			Result&amp; t = memo[rem][c[0]][c[1]][c[2]][c[3]];
			t = ret;
		}
		return ret;
	}

	int ds[MAX_LEN], len;

	Result eval(int at, int rem, int c[4]) {
		if (rem == 0) {
			return Result();
		}
		Result ret;
		for (int i = 1; i &lt;= ds[at]; ++i) {
			for (int j = 0; j &lt; 4; ++j) {
				c[j] -= NUM[i][j];
			}
			Result ch = i &lt; ds[at] ? eval(rem - 1, c) : eval(at + 1, rem - 1, c);
			ret.cnt += ch.cnt;
			ret.sum += ch.sum + pw[rem - 1] * ch.cnt * i % MOD;
			ret.cnt %= MOD;
			ret.sum %= MOD;
			for (int j = 0; j &lt; 4; ++j) {
				c[j] += NUM[i][j];
			}
		}
		return ret;
	}

	int64 calc(int64 a, int64 k) { //&lt;a
		len = 0;
		while (a)
			ds[len++] = a % 10, a /= 10;
		reverse(ds, ds + len);

		int c[4] = { };
		for (int i = 0; i &lt; 4; ++i) {
			while (k % PRIME[i] == 0)
				k /= PRIME[i], c[i]++;
		}
		if (k &gt; 1)
			return 0;
		int64 ret = eval(0, len, c).sum;
		for (int i = 1; i &lt; len; ++i) {
			ret += eval(i, c).sum;
			ret %= MOD;
		}
		return ret;
	}
}

namespace CALC2 { //k=0
	bool saved[MAX_LEN][2][2];
	Result memo[MAX_LEN][2][2];

	Result eval(int rem, bool have, bool first = false) {
		if (rem == 0) {
			Result ret;
			if (have)
				ret.cnt++;
			return ret;
		}
		bool&amp;sv = saved[rem][have][first];
		Result&amp;ret = memo[rem][have][first];
		if (sv)
			return ret;
		sv = true;
		ret = Result();
		for (int i = first ? 1 : 0; i &lt; 10; ++i) {
			Result ch = eval(rem - 1, have || (i == 0));
			ret.cnt += ch.cnt;
			ret.sum += ch.cnt * pw[rem - 1] * i % MOD + ch.sum;
			ret.cnt %= MOD, ret.sum %= MOD;
		}
		return ret;
	}

	int ds[MAX_LEN], len;

	Result evalw(int at, int rem, bool have) {
		if (rem == 0)
			return Result();

		Result ret;
		for (int i = at ? 0 : 1; i &lt;= ds[at]; ++i) {
			Result ch = i &lt; ds[at] ? eval(rem - 1, have || (i == 0)) : evalw(at + 1, rem - 1, have || (i == 0));
			ret.cnt += ch.cnt;
			ret.sum += ch.cnt * pw[rem - 1] * i % MOD + ch.sum;
			ret.cnt %= MOD, ret.sum %= MOD;
		}
		return ret;
	}

	int64 calc(int64 a) { //&lt;a
		len = 0;
		while (a)
			ds[len++] = a % 10, a /= 10;
		reverse(ds, ds + len);

		int64 ret = evalw(0, len, 0).sum;
		for (int i = 1; i &lt; len; ++i) {
			ret += eval(i, 0, true).sum;
			ret %= MOD;
		}
		return ret;
	}

	int64 bfcalc(int64 a) {
		int64 ret = 0;
		for (int i = 1; i &lt; a; ++i) {
			bool ok = false;
			int x = i;
			while (x) {
				if (x % 10 == 0)
					ok = true;
				x /= 10;
			}
			if (ok)
				ret += i;
		}
		ret %= MOD;
		return ret;
	}
}

void prepare() {
	for (int i = 1; i &lt; 10; ++i) {
		for (int j = 0; j &lt; 4; ++j) {
			int x = i;
			while (x % PRIME[j] == 0)
				NUM[i][j]++, x /= PRIME[j];
		}
	}
	pw[0] = 1;
	for (int i = 1; i &lt; MAX_LEN; ++i) {
		pw[i] = pw[i - 1] * 10 % MOD;
	}
}

int main() {
	prepare();
	int nT;
	cin &gt;&gt; nT;
	for (int i = 0; i &lt; nT; ++i) {
		int64 a, b, k;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; k;
		int64 ret;
		if (k &gt; 0) {
			ret = CALC1::calc(b + 1, k) - CALC1::calc(a, k);
		} else {
			ret = CALC2::calc(b + 1) - CALC2::calc(a);
//			cout &lt;&lt; (CALC2::bfcalc(b + 1) - CALC2::bfcalc(a)) % MOD &lt;&lt; endl;
		}
		if (ret &lt; 0)
			ret += MOD;
		cout &lt;&lt; ret &lt;&lt; endl;
	}
	return 0;
}
</pre><pre></pre><h2>Problem2758</h2><pre>/*
 * 2758.cpp
 *
 *  Created on: 2012-5-5
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;cmath&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const double EPS = 1e-6;
inline int sign(double a) {
	return a &lt; -EPS ? -1 : a &gt; EPS;
}

struct Point {
	double x, y;
	Point() {
	}
	Point(double _x, double _y) :
			x(_x), y(_y) {
	}
	Point operator+(const Point&amp;p) const {
		return Point(x + p.x, y + p.y);
	}
	Point operator-(const Point&amp;p) const {
		return Point(x - p.x, y - p.y);
	}
	Point operator*(double d) const {
		return Point(x * d, y * d);
	}
	Point operator/(double d) const {
		return Point(x / d, y / d);
	}
	bool operator&lt;(const Point&amp;p) const {
		int c = sign(x - p.x);
		if (c)
			return c == -1;
		return sign(y - p.y) == -1;
	}
	double dot(const Point&amp;p) const {
		return x * p.x + y * p.y;
	}
	double det(const Point&amp;p) const {
		return x * p.y - y * p.x;
	}
	double alpha() const {
		return atan2(y, x);
	}
	double distTo(const Point&amp;p) const {
		double dx = x - p.x, dy = y - p.y;
		return hypot(dx, dy);
	}
	double alphaTo(const Point&amp;p) const {
		double dx = x - p.x, dy = y - p.y;
		return atan2(dy, dx);
	}
	void read() {
		scanf("%lf%lf", &amp;x, &amp;y);
	}
	double abs() {
		return hypot(x, y);
	}
	double abs2() {
		return x * x + y * y;
	}
	void write() {
		cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")" &lt;&lt; endl;
	}
};

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))

#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))

Point isSS(Point p1, Point p2, Point q1, Point q2) {
	double a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);
	return (p1 * a2 + p2 * a1) / (a1 + a2);
}

const int MAX_LOG = 20;

int cur;

struct Shape {
	Shape*par;
	int v;
	int id;

	int left, right;

	int dep;

	Shape(int _v) :
			v(_v), par(0) {
	}

	vector&lt;Shape*&gt; ch;

	void dfs(int d) {
		left = cur++;
		dep = d;
		for (vector&lt;Shape*&gt;::iterator e = ch.begin(); e != ch.end(); ++e) {
			(*e)-&gt;dfs(d + 1);
		}
		right = cur;
	}

	double lx, rx; //x's range
	virtual double isLower(double x)=0;
	virtual double isUpper(double x)=0;
};

struct Circle: public Shape {
	Point c;
	double r;

	Circle(Point _c, double _r, int _v) :
			c(_c), r(_r), Shape(_v) {
		lx = c.x - r;
		rx = c.x + r;
	}

	double isLower(double x) {
		double dx = x - c.x;
		double dy = sqrt(max(r * r - dx * dx, 0.0));
		return c.y - dy;
	}

	double isUpper(double x) {
		double dx = x - c.x;
		double dy = sqrt(max(r * r - dx * dx, 0.0));
		return c.y + dy;
	}
};

struct Polygon: public Shape {
	vector&lt;Point&gt; upper;
	vector&lt;Point&gt; lower;

	double isLower(double x) {
		return is(lower, x);
	}

	double isUpper(double x) {
		return is(upper, x);
	}

	Polygon(vector&lt;Point&gt; ps, int _v) :
			Shape(_v) {
		sort(ps.begin(), ps.end());

		lx = ps[0].x;
		rx = ps.back().x;
		static Point stk[1000];
		int top = 0;
		for (int i = 0; i &lt; ps.size(); ++i) {
			while (top &gt; 0 &amp;&amp; sign(stk[top - 1].x - ps[i].x) == 0)
				--top;
			while (top &gt; 1 &amp;&amp; crossOp(stk[top-2],stk[top-1],ps[i]) &gt;= 0)
				--top;
			stk[top++] = ps[i];
		}
		upper = vector&lt;Point&gt;(stk, stk + top);
		top = 0;
		for (int i = 0; i &lt; ps.size(); ++i) {
			if (top &gt; 0 &amp;&amp; sign(stk[top - 1].x - ps[i].x) == 0)
				continue;
			while (top &gt; 1 &amp;&amp; crossOp(stk[top-2],stk[top-1],ps[i]) &lt;= 0)
				--top;
			stk[top++] = ps[i];
		}
		lower = vector&lt;Point&gt;(stk, stk + top);

//		cout &lt;&lt; "LOWER:" &lt;&lt; endl;
//		for (int i = 0; i &lt; lower.size(); ++i) {
//			lower[i].write();
//		}
//		cout &lt;&lt; "UPPER:" &lt;&lt; endl;
//		for (int i = 0; i &lt; upper.size(); ++i) {
//			upper[i].write();
//		}
//		cout &lt;&lt; "END" &lt;&lt; endl;
	}

private:
	double is(vector&lt;Point&gt;&amp;ps, double x) {
		assert(x&gt;=lx-EPS&amp;&amp;x&lt;=rx+EPS);
		for (int i = 0; i &lt; ps.size(); ++i) {
			if (sign(x - ps[i].x) == 0)
				return ps[i].y;
			if (i + 1 &lt; ps.size() &amp;&amp; x &gt; ps[i].x &amp;&amp; x &lt; ps[i + 1].x) {
				Point it = isSS(Point(x, 0), Point(x, 1), ps[i], ps[i + 1]);
//				cout &lt;&lt; "HI:" &lt;&lt; it.y &lt;&lt; endl;
				return it.y;
			}
		}
		return 0;
	}
};

const int ADD = 0, DEL = 1, QUERY = 2;

struct Event {
	int type;
	double x;
	Shape*sp;
	Point p;
	Shape**qid;

	Event() {
	}

	Event(Point _p, Shape**_qid) :
			p(_p), qid(_qid) {
		x = p.x;
		type = QUERY;
	}

	Event(int _type, Shape*_sp) :
			type(_type), sp(_sp) {
		if (type == ADD)
			x = sp-&gt;lx;
		else
			x = sp-&gt;rx;
	}

	bool operator&lt;(const Event&amp;e) const {
		int cmp = sign(x - e.x);
		if (cmp != 0)
			return cmp == -1;
		return type &lt; e.type;
	}
};

double curX;

struct Node {
	Shape*sp;
	int type; //0:lower , 1:upper , 2:constant
	double y;
	double get() const {
		switch (type) {
			case 0:
				return sp-&gt;isLower(curX);
			case 1:
				return sp-&gt;isUpper(curX);
			case 2:
				return y;
		}
		return 0;
	}
	bool operator&lt;(const Node&amp;nd) const {
		int cmp = sign(get() - nd.get());
		if (cmp != 0)
			return cmp == -1;
		if (type != nd.type)
			return type &lt; nd.type;
		return sp &lt; nd.sp;
	}
	Node(double _y) :
			y(_y), type(2) {
	}
	Node(Shape*_sp, int _type) :
			sp(_sp), type(_type) {
	}
};

map&lt;Node, Shape*&gt; mp;

const int MAX_N = 100000 + 10;

int nShapes, nDays;

Shape*shapes[MAX_N];

Event events[MAX_N * 5];
int nEvents;

Shape*from[MAX_N], *to[MAX_N];
Shape*change[MAX_N];
int newv[MAX_N];

Shape*whole;

void readInput() {
	scanf("%d%d", &amp;nShapes, &amp;nDays);
	for (int i = 0; i &lt; nShapes; ++i) {
		char tp;
		int v;
		scanf(" ");
		scanf("%c", &amp;tp);
		if (tp == 'C') {
			Point c;
			c.read();
			double r;
			scanf("%lf%d", &amp;r, &amp;v);
			shapes[i] = new Circle(c, r, v);
		} else {
			int n;
			scanf("%d", &amp;n);
			vector&lt;Point&gt; ps(n);
			for (int j = 0; j &lt; n; ++j) {
				ps[j].read();
			}
			scanf("%d", &amp;v);
			shapes[i] = new Polygon(ps, v);
		}

		shapes[i]-&gt;id = i;
	}

	nEvents = 0;

	for (int i = 0; i &lt; nDays; ++i) {
		char tp;
		scanf(" ");
		scanf("%c", &amp;tp);
		if (tp == 'Q') {
			Point s, t;
			s.read(), t.read();
			events[nEvents++] = Event(s, &amp;from[i]);
			events[nEvents++] = Event(t, &amp;to[i]);
		} else {
			int id;
			scanf("%d%d", &amp;id, newv + i);
			change[i] = shapes[id - 1];
		}
	}

	for (int i = 0; i &lt; nShapes; ++i) {
//		shapes[i]-&gt;getPoint().write();
	}
}

Shape* get(Node nd) {
	map&lt;Node, Shape*&gt;::iterator it = mp.upper_bound(nd);
	--it;
	return it-&gt;second;
}

struct Tree {
	Tree*pl, *pr;
	int l, r;
	int v;
	Tree(int _l, int _r) :
			l(_l), r(_r) {
		int m = (l + r) &gt;&gt; 1;
		v = 0;
		if (l + 1 == r) {
			pl = pr = 0;
			return;
		}
		pl = new Tree(l, m);
		pr = new Tree(m, r);
	}

	void modify(int L, int R, int x) {
		if (L &gt;= r || l &gt;= R)
			return;
		if (L &lt;= l &amp;&amp; R &gt;= r) {
			v ^= x;
			return;
		}
		pl-&gt;modify(L, R, x);
		pr-&gt;modify(L, R, x);
	}

	int ask(int i) {
		if (l + 1 == r)
			return v;
		int m = l + r &gt;&gt; 1;
		if (i &lt; m)
			return pl-&gt;ask(i) ^ v;
		else
			return pr-&gt;ask(i) ^ v;
	}
};

void work() {
	for (int i = 0; i &lt; nShapes; ++i) {
		events[nEvents] = Event(ADD, shapes[i]);
		events[nEvents++].qid = &amp;shapes[i]-&gt;par;
		events[nEvents++] = Event(DEL, shapes[i]);
	}

	sort(events, events + nEvents);

	whole = new Circle(Point(0, 0), 0, 0);
	whole-&gt;id = -1;
	mp[Node(-1e100)] = whole;

	for (int i = 0; i &lt; nEvents; ++i) {
		Event&amp;e = events[i];
		curX = e.x;
		if (e.type == ADD) {
			Node low(e.sp, 0), up(e.sp, 1);
			Shape*old = get(low);
			*e.qid = old;
			mp[low] = e.sp;
			mp[up] = old;
		} else if (e.type == DEL) {
			Node low(e.sp, 0), up(e.sp, 1);
			mp.erase(low);
			mp.erase(up);
		} else {
//			e.p.write();
			*e.qid = get(Node(e.p.y));
		}
	}

	for (int i = 0; i &lt; nShapes; ++i) {
		shapes[i]-&gt;par-&gt;ch.push_back(shapes[i]);
	}

	cur = 0;
	whole-&gt;dfs(0);

	Tree*rt = new Tree(0, cur);

	for (int i = 0; i &lt; nShapes; ++i) {
		rt-&gt;modify(shapes[i]-&gt;left, shapes[i]-&gt;right, shapes[i]-&gt;v);
	}

	int ret = 0;

	for (int i = 0; i &lt; nDays; ++i) {
		if (from[i] != 0) {
			Shape*s = from[i], *t = to[i];
			ret ^= rt-&gt;ask(s-&gt;left) ^ rt-&gt;ask(t-&gt;left);
			printf("%d\n", ret);
		} else {
			Shape*t = change[i];
			rt-&gt;modify(t-&gt;left, t-&gt;right, t-&gt;v ^ newv[i]);
			t-&gt;v = newv[i];
		}
	}
}

int main() {
	readInput();
	work();
	return 0;
}
</pre><pre></pre><h2>Problem2761</h2><pre>/*
 * a.cpp
 *
 *  Created on: 2012-5-3
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

int main() {
	int T;
	cin &gt;&gt; T;
	for (int i = 0; i &lt; T; ++i) {
		set&lt;int&gt; have;
		int n;
		scanf("%d", &amp;n);
		for (int j = 0; j &lt; n; ++j) {
			int x;
			scanf("%d", &amp;x);
			if (have.insert(x).second)
				printf("%d ", x);
		}
		puts("");
	}
	return 0;
}
</pre><pre></pre><h2>Problem2780</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cassert&gt;
using namespace std;
const int TotalChar_Max=200000+100;
const int StringLength_Max=100000+100;
const int StringNum_Max=10000+10;
const int QueryNum_Max=500000+10;

namespace String_Data//For String and Suffix
{
    const int seed=133331;
    struct Power
    {
        int pow[StringLength_Max];
        void doit()
        {
            pow[0]=1;
            for(int cur=1;cur&lt;StringLength_Max;cur++)
                pow[cur]=pow[cur-1]*seed;
        }
        Power()
        {
            doit();
        }
        inline int operator()(int p)
        {
            return pow[p];
        }
    }power;

    template&lt;class T&gt;
    struct Memory
    {
        T Data[TotalChar_Max],*now;
        void clear(){now=Data;}
        Memory(){clear();}
        T*get(){return now;}
        void use(int size){now+=size;}
        void reuse(int size){now-=size;}
        int used(){return now-Data;}
    };

    Memory&lt;int&gt; Mem_Int;
    Memory&lt;char&gt; Mem_Char;
    struct String
    {
        char*str;
        int*hash;
        int len;

        void doit()
        {
            int ret=0;
            for(int cur=0;cur&lt;len;cur++)
            {
                ret*=seed;ret+=str[cur];
                hash[cur]=ret;
            }
        }

        void input_data()
        {
            str=Mem_Char.get();
            scanf("%s",str);
            len=strlen(str);
            Mem_Char.use(len);
            hash=Mem_Int.get();
            Mem_Int.use(len);
            doit();
        }

        int ask(int l,int r)
        {
            return hash[r]-(l?hash[l-1]:0)*power(r-l+1);
        }

        void inc_last()
        {
            str[len-1]++;
            doit();
        }

        void reuse()
        {
            Mem_Char.reuse(len);
            Mem_Int.reuse(len);
        }
    };

    String strs[StringNum_Max];

    struct Suffix
    {
        int own,start;
        Suffix(){}
        Suffix(int _own,int _start):
            own(_own),start(_start){}
        inline String&amp;ref()const{return strs[own];}
        int size()const{return ref().len-start;}
        int prefix(int size)const{return ref().ask(start,start+size-1);}
        char char_at(int at){return ref().str[start+at];}
        void output()
        {
            for(int cur=0;cur&lt;size();cur++)
                putchar(char_at(cur));
            printf("\n");
        }
    };

    int lcp(Suffix a,Suffix b)
    {
        int l=0,r=min(a.size(),b.size())+1;
        while(l+1&lt;r)
        {
            int m=l+r&gt;&gt;1;
            if(a.prefix(m)==b.prefix(m))
                l=m;
            else
                r=m;
        }
        return l;
    }

    bool operator&lt;(Suffix a,Suffix b)
    {
        int cnt=lcp(a,b);
        if(cnt==min(a.size(),b.size()))
            return a.size()&lt;b.size();
        return a.char_at(cnt)&lt;b.char_at(cnt);
    }
}
namespace Solve
{
    using String_Data::String;
    using String_Data::Suffix;
    using String_Data::strs;

    int nstrs,nqrys;
    Suffix sufs[StringLength_Max];
    int total;
    int ans[QueryNum_Max];

    void input_data()
    {
        scanf("%d%d",&amp;nstrs,&amp;nqrys);
        for(int cur=0;cur&lt;nstrs;cur++)
        {
            strs[cur].input_data();
        }
    }

    void prepare()
    {
        total=0;
        for(int cur=0;cur&lt;nstrs;cur++)
        {
            String&amp;str=strs[cur];
            for(int start=0;start&lt;str.len;start++)
            {
                Suffix suf(cur,start);
                sufs[total++]=suf;
            }
        }
        sort(sufs,sufs+total);
        /*
        for(int cur=0;cur&lt;total;cur++)
            sufs[cur].output();
        */
    }

    struct qry_type
    {
        int l,r,id;
        qry_type(){}
        qry_type(int _l,int _r,int _id):
            l(_l),r(_r),id(_id){}
    };
    qry_type qrys[QueryNum_Max];

    void read_querys()
    {
        int mem=StringNum_Max-1;
        String&amp;qry_str=strs[mem];
        for(int cur=0;cur&lt;nqrys;cur++)
        {
            qry_str.input_data();
            Suffix whole(mem,0);
            int l=lower_bound(sufs,sufs+total,whole)-sufs;
            qry_str.inc_last();
            int r=lower_bound(sufs,sufs+total,whole)-sufs-1;
            qry_str.reuse();
            if(l&lt;=r)
                qrys[cur]=qry_type(l,r,cur);
            else
                ans[cur]=0;
        }
    }

    namespace Distinct_Num_Range_Ask
    {
        int seq[StringLength_Max];

        struct Binary_Indexed_Tree
        {
            int T[StringLength_Max];
            int n;

            void init_size(int _n)
            {
                n=_n;
                memset(T,0,sizeof(int)*n);
            }

            void add(int p,int a)
            {
                for(p++;p&lt;=n;p+=p&amp;-p)
                    T[p-1]+=a;
            }

            void add(int l,int r,int a)
            {
                add(l,a);add(r+1,-a);
            }

            int sum(int p)
            {
                int res=0;
                for(p++;p;p-=p&amp;-p)
                    res+=T[p-1];
                return res;
            }
        };

        struct LinkedList
        {
            int head[StringLength_Max];
            int next[QueryNum_Max],id[QueryNum_Max],cnt;

            void clear_list(int n)
            {
                memset(head,-1,sizeof(int)*n);
                cnt=0;
            }

            void add_qry(int r,int _id)
            {
                next[cnt]=head[r];id[cnt]=_id;
                head[r]=cnt++;
            }
        };
        LinkedList lists;

        Binary_Indexed_Tree data;
        void work()
        {
            for(int cur=0;cur&lt;total;cur++)
            {
                seq[cur]=sufs[cur].own;
            }

            lists.clear_list(total);
            for(int cur=0;cur&lt;nqrys;cur++)
            {
                lists.add_qry(qrys[cur].r,qrys[cur].id);
            }

            int pre_app[StringNum_Max];
            memset(pre_app,-1,sizeof(int)*nstrs);

            data.init_size(total);
            for(int at=0;at&lt;total;at++)
            {
                int it=seq[at];
                data.add(pre_app[it]+1,at,1);
                pre_app[it]=at;
                for(int cur=lists.head[at];cur!=-1;cur=lists.next[cur])
                {
                    int id=lists.id[cur];
                    ans[id]=data.sum(qrys[id].l);
                }
            }
        }
    }

    void solve()
    {
        input_data();
        prepare();
        read_querys();
        Distinct_Num_Range_Ask::work();
        for(int cur=0;cur&lt;nqrys;cur++)
            printf("%d\n",ans[cur]);
    }
}
int main()
{
    Solve::solve();
}
</pre><pre></pre><h2>Problem2786</h2><pre>T=int(raw_input())
n=50
dp=[[0]*(n+1) for i in range(n+1)]
dp[0][0]=1
for i in range(1,n+1):
	for j in range(1,i+1):
		dp[i][j]=dp[i-1][j]*j+dp[i-1][j-1]*j
ans=[sum(dp[i]) for i in range(n+1)]
for i in range(T):
	print ans[int(raw_input())]</pre><pre></pre><h2>Problem2787</h2><pre>/*
 * COT4.cpp
 *
 *  Created on: 2012-5-25
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_N = 100000 + 10;
const int MAX_OPTS = 300000 + 10;
//const int MAX_LOG = 18;
const int CBRT = 50;

int step[MAX_N][3];

struct Str;

struct Trie {
	Trie*ch[26], *par, *par2k;
	int w;
	int rank, rank2;

	vector&lt;pair&lt;Str, int&gt; &gt; qs;

	Trie*anc[3][CBRT]; //(i,j) : j*CBRT^i

	Trie(int _w = -1, Trie*_par = 0) :
			w(_w), par(_par) {
		memset(ch, 0, sizeof ch);

		for (int pw = 0; pw &lt; 3; ++pw) {
			anc[pw][0] = this;
			if (pw == 0)
				anc[pw][1] = par;
			else {
				anc[pw][1] = anc[pw - 1][CBRT - 1] ? anc[pw - 1][CBRT - 1]-&gt;anc[pw - 1][1] : 0;
			}
			for (int j = 1; j + 1 &lt; CBRT; ++j) {
				anc[pw][j + 1] = anc[pw][j] ? anc[pw][j]-&gt;anc[pw][1] : 0;
			}
		}
	}

	Trie*get(int w) {
		if (ch[w] == 0)
			ch[w] = new Trie(w, this);
		return ch[w];
	}

	Trie*up(int w) {
		Trie*r = this;
		for (int i = 0; i &lt; 3; ++i) {
			r = r-&gt;anc[i][step[w][i]];
			if (r == 0)
				return r;
		}
		return r;
	}

	int charAt(int w) {
		Trie*t = up(w);
		return t ? t-&gt;w : -1;
	}

	void show() {
		Trie*r = this;
		while (r != 0) {
			if (r-&gt;w != -1)
				cerr &lt;&lt; char(r-&gt;w + 'a');
			else
				cerr &lt;&lt; r-&gt;w;
			r = r-&gt;par;
		}
	}
}*root;

Trie*at[MAX_N];
int nQ, n;

int type[MAX_OPTS], args[MAX_OPTS][3];

namespace SuffixArray {
	Trie*sa[MAX_N];

	void doSort(Trie*x[], int m) {
		static int cnt[MAX_N];
		static Trie*ret[MAX_N];

		for (int w = 0; w &lt; 2; ++w) {
			memset(cnt, 0, sizeof(int) * m);
			for (int i = 0; i &lt; n; ++i) {
				cnt[w ? x[i]-&gt;rank : x[i]-&gt;rank2]++;
			}
			for (int i = 1; i &lt; m; ++i) {
				cnt[i] += cnt[i - 1];
			}
			for (int i = n - 1; i &gt;= 0; --i) {
				ret[--cnt[w ? x[i]-&gt;rank : x[i]-&gt;rank2]] = x[i];
			}
			memcpy(x, ret, sizeof(Trie*) * n);
		}
	}

	int tmp[MAX_N];

	void build() {
		//init the case k=1
		for (int i = 0; i &lt; n; ++i) {
			sa[i] = at[i];
			sa[i]-&gt;rank = sa[i]-&gt;w + 1;
			sa[i]-&gt;rank2 = 0;
			sa[i]-&gt;par2k = sa[i]-&gt;par;
		}
		int m = 27;
		doSort(sa, m);
		for (int k = 1; k &lt; n; k &lt;&lt;= 1) {
			//k -&gt; 2k
			for (int i = 0; i &lt; n; ++i) {
				sa[i]-&gt;rank2 = sa[i]-&gt;par2k ? sa[i]-&gt;par2k-&gt;rank + 1 : 0;
			}
//			cout &lt;&lt; "HI" &lt;&lt; endl;
			doSort(sa, m + 1);
//			cout &lt;&lt; "HI" &lt;&lt; endl;
			for (int i = n - 1; i &gt;= 0; --i) {
				at[i]-&gt;par2k = at[i]-&gt;par2k ? at[i]-&gt;par2k-&gt;par2k : 0;
			}
			m = 0;
			for (int i = 0; i &lt; n; ++i) {
				if (!i || (sa[i - 1]-&gt;rank != sa[i]-&gt;rank || sa[i - 1]-&gt;rank2 != sa[i]-&gt;rank2))
					tmp[i] = m++;
				else
					tmp[i] = m - 1;
			}

			for (int i = 0; i &lt; n; ++i) {
				sa[i]-&gt;rank = tmp[i];
			}
			if (m == n)
				break;
		}

//		for (int i = 0; i &lt; n - 1; ++i) {
//			assert(cmp(sa[i],sa[i+1]));
//		}
	}
}

using SuffixArray::sa;

struct Str {
	int l, r; //[l,r) in sa
	int len;

//	crope s;

	bool bad() {
		return l &gt;= r || len &gt; n;
	}

	//suppose the string is s
	//l is first who &gt;= s
	//r is first who &gt; s* ,* is a maximum char
};

Str T[MAX_OPTS];
int nT;

Str addFirst(Str s, int c) {
	//s -&gt; sc
	if (s.bad())
		return s;

	Str ret;
	int len = s.len;
	ret.len = len + 1;
	//find L
	{
		int l = s.l - 1, r = s.r;
		while (l + 1 &lt; r) {
			int m = l + r &gt;&gt; 1;
			//if sa[m] &gt;= sc
			if (sa[m]-&gt;charAt(len) &gt;= c)
				r = m;
			else
				l = m;
		}
		ret.l = r;
	}
	//find R
	{
		int l = s.l - 1, r = s.r;
		while (l + 1 &lt; r) {
			int m = l + r &gt;&gt; 1;
			//if sa[m] &gt; sc*
			if (sa[m]-&gt;charAt(len) &gt; c)
				r = m;
			else
				l = m;
		}
		ret.r = r;
	}
//	ret.s = s.s + crope(char(c + 'a'));
//	if (ret.s == crope("blcap")) {
//		cout &lt;&lt; s.l &lt;&lt; " " &lt;&lt; s.r &lt;&lt; endl;
//		cerr &lt;&lt; s.s &lt;&lt; " + " &lt;&lt; char(c + 'a') &lt;&lt; endl;
//		cerr &lt;&lt; "HERE!" &lt;&lt; endl;
//		cerr &lt;&lt; ret.l &lt;&lt; " " &lt;&lt; ret.r &lt;&lt; endl;
//	}
	return ret;
}

Str addLast(Str s, int c) {
	if (s.bad())
		return s;
	//s -&gt; cs
	Str ret;
	int len = s.len;
	ret.len = len + 1;

	//find L
	{
		int l = -1, r = n;
		while (l + 1 &lt; r) {
			int m = l + r &gt;&gt; 1;
			//if sa[m] &gt;= cs
			Trie*t = sa[m];
			if (t-&gt;w &gt; c || (t-&gt;w == c &amp;&amp; t-&gt;par &amp;&amp; t-&gt;par-&gt;rank &gt;= s.l))
				r = m;
			else
				l = m;
		}
		ret.l = r;
	}
	//find R
	{
		int l = -1, r = n;
		while (l + 1 &lt; r) {
			int m = l + r &gt;&gt; 1;
			//if sa[m] &gt; cs*
			Trie*t = sa[m];
			bool ok = false;
			if (t-&gt;w &gt; c)
				ok = true;
			else if (t-&gt;w == c) {
				Trie*p = t-&gt;par;
				//check p&gt;s*
				if (p) {
					if (p-&gt;rank &gt;= s.r)
						ok = true;
				}
			}
			if (ok)
				r = m;
			else
				l = m;
		}
		ret.r = r;
	}
//	ret.s = crope(char(c + 'a')) + s.s;
	return ret;
}

Str merge(Str a, Str b) {
	swap(a, b); //ab
	if (a.bad())
		return a;
	if (b.bad())
		return b;
	Str ret;
	ret.len = a.len + b.len;
	//find L
	{
		int l = -1, r = n;
		while (l + 1 &lt; r) {
			int m = l + r &gt;&gt; 1;
			//check sa[m] &gt;= ab
			Trie*t = sa[m];
			bool ok = false;
			if (t-&gt;rank &gt;= a.l &amp;&amp; t-&gt;rank &lt; a.r) {
				//t start with a
				t = t-&gt;up(a.len);
				if (t &amp;&amp; t-&gt;rank &gt;= b.l)
					ok = true;
			} else {
				ok = t-&gt;rank &gt;= a.l;
			}
			if (ok)
				r = m;
			else
				l = m;
		}
		ret.l = r;
	}
	//find R
	{
		int l = -1, r = n;
		while (l + 1 &lt; r) {
			int m = l + r &gt;&gt; 1;
			//check sa[m] &gt; ab*
			Trie*t = sa[m];
			bool ok = false;
			if (t-&gt;rank &gt;= a.l &amp;&amp; t-&gt;rank &lt; a.r) {
				//t start with a
				t = t-&gt;up(a.len);
				if (t &amp;&amp; t-&gt;rank &gt;= b.r)
					ok = true;
			} else {
				ok = (t-&gt;rank &gt;= a.r);
			}
			if (ok)
				r = m;
			else
				l = m;
		}
		ret.r = r;
	}
//	ret.s = a.s + b.s;
	return ret;
}

struct TA {
	int a[MAX_N], n;
	void init(int _n) {
		n = _n;
		memset(a, 0, sizeof(int) * n);
	}
	void add(int p, int x) {
//		assert(p+1&gt;=0);
		for (p++; p &lt;= n; p += p &amp; -p)
			a[p - 1] += x;
	}
	int get(int p) {
//		assert(p+1&gt;=0);
		int r = 0;
		for (p++; p &gt; 0; p -= p &amp; -p)
			r += a[p - 1];
		return r;
	}
} ta;

void prepare() {
	for (int i = 0; i &lt;= n; ++i) {
		int x = i;
		for (int j = 0; j &lt; 3; ++j) {
			step[i][j] = x % CBRT;
			x /= CBRT;
		}
	}
}

int ans[MAX_N];

void doDFS() {
	static pair&lt;Trie*, int&gt; stack[MAX_N];
	int top = 0;
	stack[top++] = make_pair(root, -1);

	while (top &gt; 0) {
		pair&lt;Trie*, int&gt;&amp;c = stack[top - 1];
		Trie*t = c.first;
		int&amp;ch = c.second;
		if (ch == -1) {
			ta.add(t-&gt;rank, 1);
			for (vector&lt;pair&lt;Str, int&gt; &gt;::iterator e = t-&gt;qs.begin(); e != t-&gt;qs.end(); ++e) {
				Str s = e-&gt;first;
				if (!s.bad()) {
					ans[e-&gt;second] = ta.get(s.r - 1) - ta.get(s.l - 1);
				}
			}
			ch = 0;
		}
		for (; ch &lt; 26 &amp;&amp; !t-&gt;ch[ch]; ++ch)
			;

		if (ch &lt; 26) {
			stack[top++] = make_pair(t-&gt;ch[ch], -1);
			++ch;
			continue;
		}

		ta.add(t-&gt;rank, -1);
		--top;
	}
}

inline int nextInt() {
	int x = 0;
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
	return x;
}

int main() {
//	freopen("in", "r", stdin);
	root = new Trie;
	at[0] = root;
	n = 1;

	scanf("%d", &amp;nQ);

	for (int i = 0; i &lt; nQ; ++i) {
//		scanf("%d", type + i);
		type[i] = nextInt();
		char ch;
		if (type[i] == 1) {
			int par;
//			scanf("%d", &amp;par);
			par = nextInt();
			scanf(" ");
//			scanf("%c", &amp;ch);
			ch = getchar();
			at[n++] = at[par - 1]-&gt;get(ch - 'a');
		} else {
			int*a = args[i];
//			scanf("%d%d", a, a + 1);
			a[0] = nextInt(), a[1] = nextInt();

			if (type[i] == 2) {
				scanf(" ");
//				scanf("%c", &amp;ch);
				ch = getchar();
				a[2] = ch - 'a';
			}
		}
	}

//	cout &lt;&lt; "HI" &lt;&lt; endl;
//	return 0;
	SuffixArray::build();
//	for (int i = 0; i &lt; n; ++i) {
//		sa[i]-&gt;show();
//		cout &lt;&lt; endl;
//	}
	prepare();

	nT = 0;
	T[nT++] = (Str) {0,n,0};

	int nAns = 0;

	for (int i = 0; i &lt; nQ; ++i) {
		int*a = args[i];
//		cout &lt;&lt; type[i] &lt;&lt; endl;
		switch (type[i]) {
			case 2:
				if (a[0] == 0)
					T[nT++] = addFirst(T[a[1] - 1], a[2]);
				else
					T[nT++] = addLast(T[a[1] - 1], a[2]);
				break;
			case 3:
				T[nT++] = merge(T[a[0] - 1], T[a[1] - 1]);
				break;
			case 4:
				int t = a[0] - 1, s = a[1] - 1;
//				at[s]-&gt;show();
//				assert(t &lt; nT);
				if (T[t].len &gt; 0 &amp;&amp; s &gt;= 1)
					at[s]-&gt;qs.push_back(make_pair(T[t], nAns++));
				else
					ans[nAns++] = 0;
				break;
		}
	}

//	sa[6578]-&gt;show();

//	for (int i = 0; i &lt; nT; ++i) {
//		cout &lt;&lt; T[i].l &lt;&lt; " " &lt;&lt; T[i].r &lt;&lt; " " &lt;&lt; T[i].s &lt;&lt; endl;
//	}

	ta.init(n);
	doDFS();

	for (int i = 0; i &lt; nAns; ++i) {
		printf("%d\n", ans[i]);
	}
//	cout &lt;&lt; "HI" &lt;&lt; endl;
//	cerr &lt;&lt; "HI" &lt;&lt; endl;

	return 0;
}
</pre><pre></pre><h2>Problem2788</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
#define CLR(x,c) memset(x,c,sizeof x)
#define FORE(e,x) for(vector&lt;Edge&gt;::iterator e=x.begin();e!=x.end();++e)
using namespace std;

//join all vertices linked with 1-edge

struct Edge{
	int t,c;
	Edge(int _t,int _c):t(_t),c(_c){}
};

const int MAX_N=600+10,MAX_M=100000+10;

vector&lt;Edge&gt; E[MAX_N];//1-edge

int a[MAX_M],b[MAX_M];

int n,m1,m2;

int id[MAX_N],val[MAX_N];
int mx[MAX_N];
int nId;

vector&lt;int&gt; all;

void dfs(int u,int v){
	if(id[u]==-1){
		id[u]=nId;
		val[u]=v;
		all.push_back(u);
	} else if(val[u]!=v){
		puts("NIE");
		exit(0);
		return;
	} else {
		return;
	}

	FORE(e,E[u])
		dfs(e-&gt;t,v+e-&gt;c);
}

vector&lt;Edge&gt; e[MAX_N];//dist-edge

bool reach[MAX_N][MAX_N];

void dfs(int u,bool r[]){
	if(r[u])return;r[u]=1;
	FORE(it,e[u])dfs(it-&gt;t,r);
}

int dist[MAX_N];
bool inq[MAX_N];
const int INF=~0U&gt;&gt;2;

bool cur[MAX_N],done[MAX_N];

int doit(int u){
	all.clear();

	CLR(cur,0);
	
	REP(k,nId)
		if(reach[u][k]&amp;&amp;reach[k][u])
			all.push_back(k),cur[k]=true,done[k]=true;


	int ret=0;

	//enumerate who's last
	REP(i,all.size()){

		REP(j,all.size())
			dist[all[j]]=-INF;
		int last=all[i];

		dist[last]=0;inq[last]=1;
		queue&lt;int&gt; que;que.push(last);

		int rem=all.size()*m2+10;
		while(!que.empty()){
			--rem;
			if(rem&lt;=0){
				puts("NIE");
				exit(0);
				return -1;
			}
			int u=que.front();que.pop();inq[u]=0;
			int d=dist[u];
			FORE(it,e[u])
				if(cur[it-&gt;t]&amp;&amp;d+it-&gt;c &gt; dist[it-&gt;t]){
					dist[it-&gt;t] = d+it-&gt;c;
					if(!inq[it-&gt;t]){
						inq[it-&gt;t]=1;
						que.push(it-&gt;t);
					}
				}
		}

		int mi=0;
		REP(j,all.size())
			mi=min(mi,dist[all[j]]);
		ret=max(ret,0-mi+mx[last]+1);
	}
	return ret;
}

int main(){
	cin&gt;&gt;n&gt;&gt;m1&gt;&gt;m2;
	REP(i,m1){
		int a,b;
		scanf("%d%d",&amp;a,&amp;b);
		--a,--b;
		//D[a] = D[b] -1
		E[a].push_back(Edge(b,1));
		E[b].push_back(Edge(a,-1));
	}

	REP(i,m2){
		scanf("%d%d",a+i,b+i);
		--a[i],--b[i];
	}

	CLR(id,-1);

	nId=0;
	REP(i,n)if(id[i]==-1){
		all.clear();
		dfs(i,0);
		int mi=0;
		REP(j,all.size())mi=min(mi,val[all[j]]);
		REP(j,all.size())val[all[j]]-=mi;

		mx[nId]=0;
		REP(j,all.size())mx[nId]=max(mx[nId],val[all[j]]);
		nId++;
	}
	
	//cout&lt;&lt;"HI"&lt;&lt;endl;

	//build graph
	REP(i,m2){
		int u=a[i],v=b[i];
		//D[u] &lt;= D[v]
		if(id[u]==id[v]){
			if(val[u]&gt;val[v]){
				puts("NIE");
				return 0;
			}
		} else {
			int a=id[u],b=id[v];
			//D[a] + val[u] &lt;= D[b] + val[v]
			//D[a] &lt;= D[b] + val[v] - val[u]
			//D[b] &gt;= D[a] - val[v] + val[u];
			//e[b].push_back(Edge(a,val[v]-val[u]));
			e[a].push_back(Edge(b,val[u]-val[v]));
			//cout&lt;&lt;a&lt;&lt;" -&gt; "&lt;&lt;b&lt;&lt;" : "&lt;&lt;val[u]-val[v]&lt;&lt;endl;
		}
	}

	CLR(reach,0);
	REP(i,nId)
		dfs(i,reach[i]);


	int ans=0;
	CLR(done,0);
	
	REP(i,nId)if(!done[i])
		ans+=doit(i);

	cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem2789</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
int n;
string a,b;

inline int ABS(int x){return x&lt;0?-x:x;}

vector&lt;int&gt; pa[26],pb[26];
const int MAX_N=1000000+10;

int at[MAX_N];

int c[MAX_N];
int get(int p){int r=0;for(p++;p;p-=p&amp;-p)r+=c[p-1];return r;}
void add(int p,int x){for(p++;p&lt;=n;p+=p&amp;-p)c[p-1]+=x;}

int main(){
	cin&gt;&gt;n;
	cin&gt;&gt;a&gt;&gt;b;
	REP(i,n)pa[a[i]-'A'].push_back(i),pb[b[i]-'A'].push_back(i);

	REP(c,26)REP(i,pa[c].size())
		at[pb[c][i]]=pa[c][i];

	long long ans=0;
	REP(i,n){
		ans+=i-get(at[i]);
		add(at[i],1);
	}
	cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem2790</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
using namespace std;
const int MAX_N=100000+10;
const int MAX_VAL=1000000+10;
const int MAX_E=7000000;

int n;
int a[MAX_N];

bool isprime[MAX_VAL];

int next[MAX_E],dest[MAX_E];
int first[MAX_VAL];
int ce;

void addEdge(int a,int b){
	int e=ce++;
	next[e]=first[a];dest[e]=b;
	first[a]=e;
}

int mxv;

void prepare(){
	fill(isprime,isprime+mxv,true);
	ce=0;
	fill(first,first+mxv,-1);
	
	for(int i=2;i&lt;mxv;i++)
		if(isprime[i])
			for(int j=i;j&lt;mxv;j+=i){
				isprime[j]=false;
				addEdge(j,j/i);
				addEdge(j/i,j);
			}

//	REP(i,10)
//		FORE(e,edge[i])
//			if(*e &lt; 10)
//				cout&lt;&lt;i&lt;&lt;" &lt;-&gt; "&lt;&lt;*e&lt;&lt;endl;	
}

int dist[MAX_VAL],from[MAX_VAL];
int que[MAX_VAL],qh,qt;

const int INF=~0U&gt;&gt;2;

typedef pair&lt;int,int&gt; ipair;
ipair ret[MAX_N];

int ord[MAX_N];

bool cmp(int x,int y){
	return a[x]!=a[y]?a[x]&lt;a[y]:x&lt;y;
}

template&lt;class T&gt; void cmin(T&amp;a,T c){if(c&lt;a)a=c;}

void work(){
	REP(i,n)ret[i]=make_pair(INF,INF);
	REP(i,n)ord[i]=i;
	sort(ord,ord+n,cmp);

	for(int i=0,j;i&lt;n;i=j){
		for(j=i;j&lt;n&amp;&amp;a[ord[i]]==a[ord[j]];j++);
		if(j-i&gt;1){
			ret[ord[i]]=make_pair(0,ord[i+1]);
			for(int k=i+1;k&lt;j;++k)
				ret[ord[k]]=make_pair(0,ord[i]);
		}
	}

	REP(i,mxv)dist[i]=INF,from[i]=0;

	qh=qt=0;
	REP(u,n){
		int me=a[u];
		if(dist[me]==INF){
			dist[me]=0;
			from[me]=u;
			que[qt++]=me;		
		}
	}

	while(qh&lt;qt){
		int u=que[qh++];
		for(int e=first[u];e!=-1;e=next[e]){
			int v=dest[e];
			if(dist[v]==INF){
				dist[v]=dist[u]+1;
				from[v]=from[u];
				que[qt++]=v;
			} else if(from[u]!=from[v]){
				int d=dist[u]+dist[v]+1;
				int a=from[u],b=from[v];
				cmin(ret[a],make_pair(d,b));
				cmin(ret[b],make_pair(d,a));
			}
		}
	}
}

int main(){
	cin&gt;&gt;n;
	mxv=0;
	REP(i,n)cin&gt;&gt;a[i],mxv=max(mxv,a[i]);
	++mxv;
	prepare();
	work();
	REP(i,n)printf("%d\n",ret[i].second+1);
}</pre><pre></pre><h2>Problem2792</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
#define CLR(x,c) memset(x,c,sizeof x)
using namespace std;


const int MAX_N=int(1e6)+10;
typedef long long int64;

int n;
int a[MAX_N];

int64 m;

int at;

int calc(int h[],int rt[],int k){
	//rt[i] put h[i] -&gt; 0 , the effect length
	int cur=n-1;
	
	rt[n-1]=cur;
	
	for(int i=n-2;i&gt;=0;--i){
		while(cur&gt;i &amp;&amp; 1LL*(cur-i)*k&gt;=h[cur])
			--cur;
		rt[i]=cur;
	}
}

int64 get(int n){//sum 1..n
	return 1LL*n*(n+1)/2;
}

bool check(int k){
	//initial case
	static int h[MAX_N];
	
	REP(i,n)h[i]=a[i];

	for(int i=1;i&lt;n;i++){
		if(h[i-1]+k&lt;h[i]){
			h[i]=h[i-1]+k;
		}
	}

	for(int i=n-2;i&gt;=0;--i){
		if(h[i+1]+k&lt;h[i]){
			h[i]=h[i+1]+k;
		}
	}

	int64 done=0;
	REP(i,n)done+=a[i]-h[i];

 	static int lt[MAX_N],rt[MAX_N];
	calc(h,rt,k);
	reverse(h,h+n);
	calc(h,lt,k);
	reverse(h,h+n);reverse(lt,lt+n);REP(i,n)lt[i]=n-1-lt[i];

	static int64 sum[MAX_N];
	sum[0]=0;
	REP(i,n)sum[i+1]=sum[i]+h[i];

	//REP(i,n)cout&lt;&lt;lt[i]&lt;&lt;" - "&lt;&lt;rt[i]&lt;&lt;endl;

	REP(i,n){
		int l=lt[i],r=rt[i];
		int64 need=done+h[i];
		//[l,i)
		need += -get(i-l)*k + (sum[i]-sum[l]);
		//[i+1,r]
		need += -get(r-i)*k +(sum[r+1]-sum[i+1]);
		if(need &lt;= ::m){
			at=i;
			return true;
		}
	}

	return false;
}

int main(){
	cin&gt;&gt;n&gt;&gt;m;
	REP(i,n)scanf("%d",a+i);

	int l=-1,r=*max_element(a,a+n)+1;

	while(l+1&lt;r){
		int m=l+r&gt;&gt;1;
		if(check(m))
			r=m;
		else
			l=m;
	}

	cout&lt;&lt;at+1&lt;&lt;" "&lt;&lt;r&lt;&lt;endl;
}</pre><pre></pre><h2>Problem2793</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
#include&lt;list&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
#define CLR(x,c) memset(x,c,sizeof x)
using namespace std;
const int MAX_N=1000000+10;

int nV,n;

bool has[MAX_N];

int next[MAX_N];
bool used[MAX_N];

int main(){
	cin&gt;&gt;nV;
	REP(i,nV){
		int x;scanf("%d",&amp;x);
		has[x]=1;
	}

	REP(i,MAX_N)next[i]=i;
	
	cin&gt;&gt;n;
	long long who=1;

	static long long ans[MAX_N];
	int cnt=0;

	REP(iter,n){
		int x;scanf("%d",&amp;x);
		int cur=next[x];
		REP(it2,x){
			while(cur&lt;MAX_N&amp;&amp;used[cur])
				cur+=x;
			if(cur&gt;=MAX_N){
				break;
			}
			used[cur]=1;
			if(has[cur])ans[cnt++]=who+it2;
				
			cur+=x;
		}
		who+=x;
		next[x]=cur;
	}

	printf("%d\n",cnt);
	REP(i,cnt)printf("%lld\n",ans[i]);
}</pre><pre></pre><h2>Problem2794</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;bitset&gt;
using namespace std;

const int MAX_N = 1000, MAX_VAL = 100000 + 10;

typedef bitset&lt;MAX_VAL&gt; BIT;

int n;
int a[MAX_N], b[MAX_N], c[MAX_N];

template&lt;class T&gt;
struct Index: public vector&lt;T&gt; {
	using vector&lt;T&gt;::erase;
	using vector&lt;T&gt;::begin;
	using vector&lt;T&gt;::end;
	void doit() {
		sort(begin(), end());
		erase(unique(begin(), end()), end());
	}
	int get(T x) {
		return lower_bound(begin(), end(), x) - begin();
	}
};

Index&lt;int&gt; ida;

const int MAX_Q = 1000000 + 10;

struct Query {
	int w, id;
	Query(int _w, int _id) :
			w(_w), id(_id) {
	}
};

vector&lt;Query&gt; at[MAX_N][MAX_N];

bool ans[MAX_Q];

const int BLOCK_SIZE = 5;
const int MAX_N_BLOCKS = MAX_N / BLOCK_SIZE + 1;

void doit(int a[], int v[], int n) {
	static pair&lt;int, int&gt; ps[MAX_N];
	for (int i = 0; i &lt; n; ++i) {
		ps[i] = make_pair(a[i], i);
	}
	sort(ps, ps + n);
	for (int i = 0; i &lt; n; ++i) {
		v[i] = ps[i].first;
		a[ps[i].second] = i;
	}
}

int idb[MAX_N];

int vs[MAX_N_BLOCKS][BLOCK_SIZE];

BIT bits[MAX_N_BLOCKS];

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d%d%d", c + i, a + i, b + i);
		ida.push_back(a[i]);
	}

	ida.doit();
	doit(b, idb, n);

	for (int i = 0; i &lt; n; ++i) {
		a[i] = ida.get(a[i]);
	}

	int na = ida.size();

	int nQ;
	cin &gt;&gt; nQ;

	for (int i = 0; i &lt; nQ; ++i) {
		int l, r, k;
		scanf("%d%d%d", &amp;l, &amp;k, &amp;r);
		r += l + 1;
		l = upper_bound(ida.begin(), ida.end(), l) - ida.begin() - 1;
		r = lower_bound(idb, idb + n, r) - idb;

		if (l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; ida[l] &lt;= idb[r]) {
			at[l][r].push_back(Query(k, i));
		} else {
			ans[i] = false;
		}
	}

	for (int i = 0; i &lt; MAX_N_BLOCKS; ++i) {
		bits[i][0] = 1;
	}

	memset(vs, -1, sizeof vs);

	for (int start = 0; start &lt; na; ++start) {
		//put
		for (int k = 0; k &lt; n; ++k) {
			if (a[k] == start) {
				int r = b[k], w = c[k];
				int at = r / BLOCK_SIZE;
				vs[at][r % BLOCK_SIZE] = w;
				for (int i = at; i &gt;= 0; --i) {
					bits[i] |= bits[i] &lt;&lt; w;
					if (idb[i * BLOCK_SIZE] &lt; ida[start])
						break;
				}
			}
		}

		//query
		for (int r = 0; r &lt; n; ++r) {
			for (vector&lt;Query&gt;::iterator e = at[start][r].begin(); e != at[start][r].end(); ++e) {
				int at = r / BLOCK_SIZE;
				int v[5], cnt = 0;
				for (int k = r % BLOCK_SIZE; k &lt; BLOCK_SIZE; ++k) {
					if (vs[at][k] != -1)
						v[cnt++] = vs[at][k];
				}

//				cout &lt;&lt; "{";
//				for (int i = 0; i &lt; cnt; ++i) {
//					cout &lt;&lt; v[i] &lt;&lt; ",";
//				}
//				cout &lt;&lt; "}" &lt;&lt; endl;

				for (int i = 0; i &lt; (1 &lt;&lt; cnt); ++i) {
					int s = e-&gt;w;
					for (int j = 0; j &lt; cnt; ++j) {
						if (i &gt;&gt; j &amp; 1)
							s -= v[j];
					}
					if (s &lt; MAX_VAL &amp;&amp; s &gt;= 0 &amp;&amp; bits[at + 1][s]) {
						ans[e-&gt;id] = true;
						goto end;
					}
				}

				end: {
				}
			}
		}
	}

	for (int i = 0; i &lt; nQ; ++i) {
		puts(ans[i] ? "TAK" : "NIE");
	}
	return 0;
}</pre><pre></pre><h2>Problem2794</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;bitset&gt;
using namespace std;

const int MAX_N = 1000, MAX_VAL = 100000 + 10;

typedef bitset&lt;MAX_VAL&gt; BIT;

int n;
int a[MAX_N], b[MAX_N], c[MAX_N];

template&lt;class T&gt;
struct Index: public vector&lt;T&gt; {
	using vector&lt;T&gt;::erase;
	using vector&lt;T&gt;::begin;
	using vector&lt;T&gt;::end;
	void doit() {
		sort(begin(), end());
		erase(unique(begin(), end()), end());
	}
	int get(T x) {
		return lower_bound(begin(), end(), x) - begin();
	}
};

Index&lt;int&gt; ida;

const int MAX_Q = 1000000 + 10;

struct Query {
	int w, id;
	Query(int _w, int _id) :
			w(_w), id(_id) {
	}
};

vector&lt;Query&gt; at[MAX_N][MAX_N];

bool ans[MAX_Q];

const int BLOCK_SIZE = 6;
const int MAX_N_BLOCKS = MAX_N / BLOCK_SIZE + 10;

void doit(int a[], int v[], int n) {
	static pair&lt;int, int&gt; ps[MAX_N];
	for (int i = 0; i &lt; n; ++i) {
		ps[i] = make_pair(a[i], i);
	}
	sort(ps, ps + n);
	for (int i = 0; i &lt; n; ++i) {
		v[i] = ps[i].first;
		a[ps[i].second] = i;
	}
}

int idb[MAX_N];

int vs[MAX_N_BLOCKS][BLOCK_SIZE];

BIT bits[MAX_N_BLOCKS];

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d%d%d", c + i, a + i, b + i);
		ida.push_back(a[i]);
	}

	ida.doit();
	doit(b, idb, n);

	for (int i = 0; i &lt; n; ++i) {
		a[i] = ida.get(a[i]);
	}

	int na = ida.size();

	int nQ;
	cin &gt;&gt; nQ;

	for (int i = 0; i &lt; nQ; ++i) {
		int l, r, k;
		scanf("%d%d%d", &amp;l, &amp;k, &amp;r);
		r += l + 1;
		l = upper_bound(ida.begin(), ida.end(), l) - ida.begin() - 1;
		r = lower_bound(idb, idb + n, r) - idb;

		if (l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; ida[l] &lt;= idb[r]) {
			at[l][r].push_back(Query(k, i));
		} else {
			ans[i] = false;
		}
	}

	for (int i = 0; i &lt; MAX_N_BLOCKS; ++i) {
		bits[i][0] = 1;
	}

	memset(vs, -1, sizeof vs);

	for (int start = 0; start &lt; na; ++start) {
		//put
		for (int k = 0; k &lt; n; ++k) {
			if (a[k] == start) {
				int r = b[k], w = c[k];
				int at = r / BLOCK_SIZE;
				vs[at][r % BLOCK_SIZE] = w;
				for (int i = at; i &gt;= 0; --i) {
					bits[i] |= bits[i] &lt;&lt; w;
					if (idb[i * BLOCK_SIZE] &lt; ida[start])
						break;
				}
			}
		}

		//query
		for (int r = 0; r &lt; n; ++r) {
			for (vector&lt;Query&gt;::iterator e = at[start][r].begin(); e != at[start][r].end(); ++e) {
				int at = r / BLOCK_SIZE;
				static int v[BLOCK_SIZE];
				int cnt = 0;

				for (int k = r % BLOCK_SIZE; k &lt; BLOCK_SIZE; ++k) {
					if (vs[at][k] != -1)
						v[cnt++] = vs[at][k];
				}

//				cout &lt;&lt; "{";
//				for (int i = 0; i &lt; cnt; ++i) {
//					cout &lt;&lt; v[i] &lt;&lt; ",";
//				}
//				cout &lt;&lt; "}" &lt;&lt; endl;

				static int all[1 &lt;&lt; BLOCK_SIZE];
				int cur = 0;
				all[cur++] = 0;

				for (int i = 0; i &lt; cnt; ++i) {
					int old = cur;
					for (int j = 0; j &lt; old; ++j) {
						all[cur++] = all[j] + v[i];
					}
				}

				for (int i = 0; i &lt; cur; ++i) {
					int s = e-&gt;w - all[i];
					if (s &gt;= 0 &amp;&amp; s &lt; MAX_VAL &amp;&amp; bits[at + 1][s]) {
						ans[e-&gt;id] = true;
						break;
					}
				}
			}
		}
	}

	for (int i = 0; i &lt; nQ; ++i) {
		puts(ans[i] ? "TAK" : "NIE");
	}
	return 0;
}
</pre><pre></pre><h2>Problem2794</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;bitset&gt;
using namespace std;

const int MAX_N = 1000, MAX_VAL = 100000 + 10;

typedef bitset&lt;MAX_VAL&gt; BIT;

int n;
int a[MAX_N], b[MAX_N], c[MAX_N];

template&lt;class T&gt;
struct Index: public vector&lt;T&gt; {
	using vector&lt;T&gt;::erase;
	using vector&lt;T&gt;::begin;
	using vector&lt;T&gt;::end;
	void doit() {
		sort(begin(), end());
		erase(unique(begin(), end()), end());
	}
	int get(T x) {
		return lower_bound(begin(), end(), x) - begin();
	}
};

Index&lt;int&gt; ida;

const int MAX_Q = 1000000 + 10;

struct Query {
	int w, id;
	Query(int _w, int _id) :
			w(_w), id(_id) {
	}
};

vector&lt;Query&gt; at[MAX_N][MAX_N];

bool ans[MAX_Q];

const int BLOCK_SIZE = 5;
const int MAX_N_BLOCKS = MAX_N / BLOCK_SIZE + 10;

void doit(int a[], int v[], int n) {
	static pair&lt;int, int&gt; ps[MAX_N];
	for (int i = 0; i &lt; n; ++i) {
		ps[i] = make_pair(a[i], i);
	}
	sort(ps, ps + n);
	for (int i = 0; i &lt; n; ++i) {
		v[i] = ps[i].first;
		a[ps[i].second] = i;
	}
}

int idb[MAX_N];

int vs[MAX_N_BLOCKS][BLOCK_SIZE];

BIT bits[MAX_N_BLOCKS];

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d%d%d", c + i, a + i, b + i);
		ida.push_back(a[i]);
	}

	ida.doit();
	doit(b, idb, n);

	for (int i = 0; i &lt; n; ++i) {
		a[i] = ida.get(a[i]);
	}

	int na = ida.size();

	int nQ;
	cin &gt;&gt; nQ;

	for (int i = 0; i &lt; nQ; ++i) {
		int l, r, k;
		scanf("%d%d%d", &amp;l, &amp;k, &amp;r);
		r += l + 1;
		l = upper_bound(ida.begin(), ida.end(), l) - ida.begin() - 1;
		r = lower_bound(idb, idb + n, r) - idb;

		if (l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; ida[l] &lt;= idb[r]) {
			at[l][r].push_back(Query(k, i));
		} else {
			ans[i] = false;
		}
	}

	for (int i = 0; i &lt; MAX_N_BLOCKS; ++i) {
		bits[i][0] = 1;
	}

	memset(vs, -1, sizeof vs);

	for (int start = 0; start &lt; na; ++start) {
		//put
		for (int k = 0; k &lt; n; ++k) {
			if (a[k] == start) {
				int r = b[k], w = c[k];
				int at = r / BLOCK_SIZE;
				vs[at][r % BLOCK_SIZE] = w;
				for (int i = at; i &gt;= 0; --i) {
					bits[i] |= bits[i] &lt;&lt; w;
					if (idb[i * BLOCK_SIZE] &lt; ida[start])
						break;
				}
			}
		}

		//query
		for (int r = 0; r &lt; n; ++r) {
			for (vector&lt;Query&gt;::iterator e = at[start][r].begin(); e != at[start][r].end(); ++e) {
				int at = r / BLOCK_SIZE;
				static int v[BLOCK_SIZE];
				int cnt = 0;

				for (int k = r % BLOCK_SIZE; k &lt; BLOCK_SIZE; ++k) {
					if (vs[at][k] != -1)
						v[cnt++] = vs[at][k];
				}

//				cout &lt;&lt; "{";
//				for (int i = 0; i &lt; cnt; ++i) {
//					cout &lt;&lt; v[i] &lt;&lt; ",";
//				}
//				cout &lt;&lt; "}" &lt;&lt; endl;

				static int all[1 &lt;&lt; BLOCK_SIZE];
				int cur = 0;
				all[cur++] = 0;

				BIT&amp;r = bits[at + 1];
				if (e-&gt;w &lt; MAX_VAL &amp;&amp; r[e-&gt;w]) {
					ans[e-&gt;id] = true;
					goto end;
				}

				for (int i = 0; i &lt; cnt; ++i) {
					int old = cur;
					for (int j = 0; j &lt; old; ++j) {
						all[cur] = all[j] + v[i];
						int s = e-&gt;w - all[cur++];
						if (s &gt;= 0 &amp;&amp; s &lt; MAX_VAL &amp;&amp; r[s]) {
							ans[e-&gt;id] = true;
							goto end;
						}
					}
				}

				end: {
				}
			}
		}
	}

	for (int i = 0; i &lt; nQ; ++i) {
		puts(ans[i] ? "TAK" : "NIE");
	}
	return 0;
}
</pre><pre></pre><h2>Problem2794</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;bitset&gt;
using namespace std;

const int MAX_N = 1000, MAX_VAL = 100000 + 10;

int n;
int a[MAX_N], b[MAX_N], c[MAX_N];

template&lt;class T&gt;
struct Index: public vector&lt;T&gt; {
	using vector&lt;T&gt;::erase;
	using vector&lt;T&gt;::begin;
	using vector&lt;T&gt;::end;
	void doit() {
		sort(begin(), end());
		erase(unique(begin(), end()), end());
	}
	int get(T x) {
		return lower_bound(begin(), end(), x) - begin();
	}
};

typedef unsigned int uint;

struct BIT {
	uint g[MAX_VAL / 32 + 1];
	int n;
	BIT() {
		memset(g, 0, sizeof g);
		n = 0;
		g[0] = 1;
	}
	void add(int w) {
		int d = w &gt;&gt; 5;
		int x = w &amp; 31;
		int y = 32 - x;
		for (int k = min(n + d + 1, MAX_VAL / 32); k &gt;= d + 1; k--) {
			if (g[k] == ~0U || (g[k - d] == 0 &amp;&amp; g[k - d - 1] == 0))
				continue;
			g[k] |= g[k - d] &lt;&lt; x;
			if (y &lt; 32)
				g[k] |= g[k - d - 1] &gt;&gt; y;
			if (g[k] &amp;&amp; k &gt; n)
				n = k;
		}
		g[d] |= g[0] &lt;&lt; x;
		if (g[d] &gt; 0 &amp;&amp; d &gt; n)
			n = d;
	}
	inline bool operator[](int x) {
		return g[x &gt;&gt; 5] &gt;&gt; (x &amp; 31) &amp; 1;
	}
};

Index&lt;int&gt; ida;

const int MAX_Q = 1000000 + 10;

struct Query {
	int w, id;
	Query(int _w, int _id) :
			w(_w), id(_id) {
	}
};

vector&lt;Query&gt; at[MAX_N][MAX_N];

bool ans[MAX_Q];

const int BLOCK_SIZE = 5;
const int MAX_N_BLOCKS = MAX_N / BLOCK_SIZE + 10;

void doit(int a[], int v[], int n) {
	static pair&lt;int, int&gt; ps[MAX_N];
	for (int i = 0; i &lt; n; ++i) {
		ps[i] = make_pair(a[i], i);
	}
	sort(ps, ps + n);
	for (int i = 0; i &lt; n; ++i) {
		v[i] = ps[i].first;
		a[ps[i].second] = i;
	}
}

int idb[MAX_N];

int vs[MAX_N_BLOCKS][BLOCK_SIZE];

BIT bits[MAX_N_BLOCKS];

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d%d%d", c + i, a + i, b + i);
		ida.push_back(a[i]);
	}

	ida.doit();
	doit(b, idb, n);

	for (int i = 0; i &lt; n; ++i) {
		a[i] = ida.get(a[i]);
	}

	int na = ida.size();

	int nQ;
	cin &gt;&gt; nQ;

	for (int i = 0; i &lt; nQ; ++i) {
		int l, r, k;
		scanf("%d%d%d", &amp;l, &amp;k, &amp;r);
		r += l + 1;
		l = upper_bound(ida.begin(), ida.end(), l) - ida.begin() - 1;
		r = lower_bound(idb, idb + n, r) - idb;

		if (l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; ida[l] &lt;= idb[r]) {
			at[l][r].push_back(Query(k, i));
		} else {
			ans[i] = false;
		}
	}

	memset(vs, -1, sizeof vs);

	for (int start = 0; start &lt; na; ++start) {
		//put
		for (int k = 0; k &lt; n; ++k) {
			if (a[k] == start) {
				int r = b[k], w = c[k];
				int at = r / BLOCK_SIZE;
				vs[at][r % BLOCK_SIZE] = w;
				for (int i = at; i &gt;= 0; --i) {
					bits[i].add(w);
					if (idb[i * BLOCK_SIZE] &lt; ida[start])
						break;
				}
			}
		}

		//query
		for (int r = 0; r &lt; n; ++r) {
			for (vector&lt;Query&gt;::iterator e = at[start][r].begin(); e != at[start][r].end(); ++e) {
				int at = r / BLOCK_SIZE;
				static int v[BLOCK_SIZE];
				int cnt = 0;

				for (int k = r % BLOCK_SIZE; k &lt; BLOCK_SIZE; ++k) {
					if (vs[at][k] != -1)
						v[cnt++] = vs[at][k];
				}

//				cout &lt;&lt; "{";
//				for (int i = 0; i &lt; cnt; ++i) {
//					cout &lt;&lt; v[i] &lt;&lt; ",";
//				}
//				cout &lt;&lt; "}" &lt;&lt; endl;

				static int all[1 &lt;&lt; BLOCK_SIZE];
				int cur = 0;
				all[cur++] = 0;

				BIT &amp; r = bits[at + 1];
				if (e-&gt;w &lt; MAX_VAL &amp;&amp; r[e-&gt;w]) {
					ans[e-&gt;id] = true;
					goto end;
				}

				for (int i = 0; i &lt; cnt; ++i) {
					int old = cur;
					for (int j = 0; j &lt; old; ++j) {
						all[cur] = all[j] + v[i];
						int s = e-&gt;w - all[cur++];
						if (s &gt;= 0 &amp;&amp; s &lt; MAX_VAL &amp;&amp; r[s]) {
							ans[e-&gt;id] = true;
							goto end;
						}
					}
				}

				end: {
				}
			}
		}
	}

	for (int i = 0; i &lt; nQ; ++i) {
		puts(ans[i] ? "TAK" : "NIE");
	}
	return 0;
}
</pre><pre></pre><h2>Problem2794</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;bitset&gt;
using namespace std;

const int MAX_N = 1000, MAX_VAL = 100000 + 10;

int n;
int a[MAX_N], b[MAX_N], c[MAX_N];

template&lt;class T&gt;
struct Index: public vector&lt;T&gt; {
	using vector&lt;T&gt;::erase;
	using vector&lt;T&gt;::begin;
	using vector&lt;T&gt;::end;
	void doit() {
		sort(begin(), end());
		erase(unique(begin(), end()), end());
	}
	int get(T x) {
		return lower_bound(begin(), end(), x) - begin();
	}
};

typedef unsigned int uint;

struct BIT {
	uint g[MAX_VAL / 32 + 1];
	int n;
	BIT() {
		memset(g, 0, sizeof g);
		n = 0;
		g[0] = 1;
	}
	void add(int w) {
		int d = w &gt;&gt; 5;
		int x = w &amp; 31;
		int y = 32 - x;
		for (int k = min(n + d + 1, MAX_VAL / 32); k &gt;= d + 1; k--) {
			if (g[k] == ~0U || (g[k - d] == 0 &amp;&amp; g[k - d - 1] == 0))
				continue;
			g[k] |= g[k - d] &lt;&lt; x;
			if (y &lt; 32)
				g[k] |= g[k - d - 1] &gt;&gt; y;
			if (g[k] &amp;&amp; k &gt; n)
				n = k;
		}
		g[d] |= g[0] &lt;&lt; x;
		if (g[d] &gt; 0 &amp;&amp; d &gt; n)
			n = d;
	}
	inline bool operator[](int x) {
		return g[x &gt;&gt; 5] &gt;&gt; (x &amp; 31) &amp; 1;
	}
};

Index&lt;int&gt; ida;

const int MAX_Q = 1000000 + 10;

struct Query {
	int w, id;
	Query(int _w, int _id) :
			w(_w), id(_id) {
	}
};

vector&lt;Query&gt; at[MAX_N][MAX_N];

bool ans[MAX_Q];

const int BLOCK_SIZE = 4;
const int MAX_N_BLOCKS = MAX_N / BLOCK_SIZE + 10;

void doit(int a[], int v[], int n) {
	static pair&lt;int, int&gt; ps[MAX_N];
	for (int i = 0; i &lt; n; ++i) {
		ps[i] = make_pair(a[i], i);
	}
	sort(ps, ps + n);
	for (int i = 0; i &lt; n; ++i) {
		v[i] = ps[i].first;
		a[ps[i].second] = i;
	}
}

int idb[MAX_N];

int vs[MAX_N_BLOCKS][BLOCK_SIZE];

BIT bits[MAX_N_BLOCKS];

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d%d%d", c + i, a + i, b + i);
		ida.push_back(a[i]);
	}

	ida.doit();
	doit(b, idb, n);

	for (int i = 0; i &lt; n; ++i) {
		a[i] = ida.get(a[i]);
	}

	int na = ida.size();

	int nQ;
	cin &gt;&gt; nQ;

	for (int i = 0; i &lt; nQ; ++i) {
		int l, r, k;
		scanf("%d%d%d", &amp;l, &amp;k, &amp;r);
		r += l + 1;
		l = upper_bound(ida.begin(), ida.end(), l) - ida.begin() - 1;
		r = lower_bound(idb, idb + n, r) - idb;

		if (l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; ida[l] &lt;= idb[r]) {
			at[l][r].push_back(Query(k, i));
		} else {
			ans[i] = false;
		}
	}

	memset(vs, -1, sizeof vs);

	for (int start = 0; start &lt; na; ++start) {
		//put
		for (int k = 0; k &lt; n; ++k) {
			if (a[k] == start) {
				int r = b[k], w = c[k];
				int at = r / BLOCK_SIZE;
				vs[at][r % BLOCK_SIZE] = w;
				for (int i = at; i &gt;= 0; --i) {
					bits[i].add(w);
					if (idb[i * BLOCK_SIZE] &lt; ida[start])
						break;
				}
			}
		}

		//query
		for (int r = 0; r &lt; n; ++r) {
			for (vector&lt;Query&gt;::iterator e = at[start][r].begin(); e != at[start][r].end(); ++e) {
				int at = r / BLOCK_SIZE;
				static int v[BLOCK_SIZE];
				int cnt = 0;

				for (int k = r % BLOCK_SIZE; k &lt; BLOCK_SIZE; ++k) {
					if (vs[at][k] != -1)
						v[cnt++] = vs[at][k];
				}

//				cout &lt;&lt; "{";
//				for (int i = 0; i &lt; cnt; ++i) {
//					cout &lt;&lt; v[i] &lt;&lt; ",";
//				}
//				cout &lt;&lt; "}" &lt;&lt; endl;

				static int all[1 &lt;&lt; BLOCK_SIZE];
				int cur = 0;
				all[cur++] = 0;

				BIT &amp; r = bits[at + 1];
				if (e-&gt;w &lt; MAX_VAL &amp;&amp; r[e-&gt;w]) {
					ans[e-&gt;id] = true;
					goto end;
				}

				for (int i = 0; i &lt; cnt; ++i) {
					int old = cur;
					for (int j = 0; j &lt; old; ++j) {
						all[cur] = all[j] + v[i];
						int s = e-&gt;w - all[cur++];
						if (s &gt;= 0 &amp;&amp; s &lt; MAX_VAL &amp;&amp; r[s]) {
							ans[e-&gt;id] = true;
							goto end;
						}
					}
				}

				end: {
				}
			}
		}
	}

	for (int i = 0; i &lt; nQ; ++i) {
		puts(ans[i] ? "TAK" : "NIE");
	}
	return 0;
}
</pre><pre></pre><h2>Problem2794</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;bitset&gt;
using namespace std;

const int MAX_N = 1000, MAX_VAL = 100000 + 10;

int n;
int a[MAX_N], b[MAX_N], c[MAX_N];

template&lt;class T&gt;
struct Index: public vector&lt;T&gt; {
	using vector&lt;T&gt;::erase;
	using vector&lt;T&gt;::begin;
	using vector&lt;T&gt;::end;
	void doit() {
		sort(begin(), end());
		erase(unique(begin(), end()), end());
	}
	int get(T x) {
		return lower_bound(begin(), end(), x) - begin();
	}
};

typedef unsigned int uint;

struct BIT {
	uint g[MAX_VAL / 32 + 1];
	int n;
	BIT() {
		memset(g, 0, sizeof g);
		n = 0;
		g[0] = 1;
	}
	void add(int w) {
		int d = w &gt;&gt; 5;
		int x = w &amp; 31;
		int y = 32 - x;
		for (int k = min(n + d + 1, MAX_VAL / 32); k &gt;= d + 1; k--) {
			if (g[k] == ~0U || (g[k - d] == 0 &amp;&amp; g[k - d - 1] == 0))
				continue;
			g[k] |= g[k - d] &lt;&lt; x;
			if (y &lt; 32)
				g[k] |= g[k - d - 1] &gt;&gt; y;
			if (g[k] &amp;&amp; k &gt; n)
				n = k;
		}
		g[d] |= g[0] &lt;&lt; x;
		if (g[d] &gt; 0 &amp;&amp; d &gt; n)
			n = d;
	}
	inline bool operator[](int x) {
		return g[x &gt;&gt; 5] &gt;&gt; (x &amp; 31) &amp; 1;
	}
};

Index&lt;int&gt; ida;

const int MAX_Q = 1000000 + 10;

struct Query {
	int w, id;
	Query(int _w, int _id) :
			w(_w), id(_id) {
	}
};

vector&lt;Query&gt; at[MAX_N][MAX_N];

bool ans[MAX_Q];

const int BLOCK_SIZE = 6;
const int MAX_N_BLOCKS = MAX_N / BLOCK_SIZE + 10;

void doit(int a[], int v[], int n) {
	static pair&lt;int, int&gt; ps[MAX_N];
	for (int i = 0; i &lt; n; ++i) {
		ps[i] = make_pair(a[i], i);
	}
	sort(ps, ps + n);
	for (int i = 0; i &lt; n; ++i) {
		v[i] = ps[i].first;
		a[ps[i].second] = i;
	}
}

int idb[MAX_N];

int vs[MAX_N_BLOCKS][BLOCK_SIZE];

BIT bits[MAX_N_BLOCKS];

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d%d%d", c + i, a + i, b + i);
		ida.push_back(a[i]);
	}

	ida.doit();
	doit(b, idb, n);

	for (int i = 0; i &lt; n; ++i) {
		a[i] = ida.get(a[i]);
	}

	int na = ida.size();

	int nQ;
	cin &gt;&gt; nQ;

	for (int i = 0; i &lt; nQ; ++i) {
		int l, r, k;
		scanf("%d%d%d", &amp;l, &amp;k, &amp;r);
		r += l + 1;
		l = upper_bound(ida.begin(), ida.end(), l) - ida.begin() - 1;
		r = lower_bound(idb, idb + n, r) - idb;

		if (l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; ida[l] &lt;= idb[r]) {
			at[l][r].push_back(Query(k, i));
		} else {
			ans[i] = false;
		}
	}

	memset(vs, -1, sizeof vs);

	for (int start = 0; start &lt; na; ++start) {
		//put
		for (int k = 0; k &lt; n; ++k) {
			if (a[k] == start) {
				int r = b[k], w = c[k];
				int at = r / BLOCK_SIZE;
				vs[at][r % BLOCK_SIZE] = w;
				for (int i = at; i &gt;= 0; --i) {
					bits[i].add(w);
					if (idb[i * BLOCK_SIZE] &lt; ida[start])
						break;
				}
			}
		}

		//query
		for (int r = 0; r &lt; n; ++r) {
			for (vector&lt;Query&gt;::iterator e = at[start][r].begin(); e != at[start][r].end(); ++e) {
				int at = r / BLOCK_SIZE;
				static int v[BLOCK_SIZE];
				int cnt = 0;

				for (int k = r % BLOCK_SIZE; k &lt; BLOCK_SIZE; ++k) {
					if (vs[at][k] != -1)
						v[cnt++] = vs[at][k];
				}

//				cout &lt;&lt; "{";
//				for (int i = 0; i &lt; cnt; ++i) {
//					cout &lt;&lt; v[i] &lt;&lt; ",";
//				}
//				cout &lt;&lt; "}" &lt;&lt; endl;

				static int all[1 &lt;&lt; BLOCK_SIZE];
				int cur = 0;
				all[cur++] = 0;

				BIT &amp; r = bits[at + 1];
				if (e-&gt;w &lt; MAX_VAL &amp;&amp; r[e-&gt;w]) {
					ans[e-&gt;id] = true;
					goto end;
				}

				for (int i = 0; i &lt; cnt; ++i) {
					int old = cur;
					for (int j = 0; j &lt; old; ++j) {
						all[cur] = all[j] + v[i];
						int s = e-&gt;w - all[cur++];
						if (s &gt;= 0 &amp;&amp; s &lt; MAX_VAL &amp;&amp; r[s]) {
							ans[e-&gt;id] = true;
							goto end;
						}
					}
				}

				end: {
				}
			}
		}
	}

	for (int i = 0; i &lt; nQ; ++i) {
		puts(ans[i] ? "TAK" : "NIE");
	}
	return 0;
}
</pre><pre></pre><h2>Problem2796</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;cassert&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
#define CLR(x,c) memset(x,c,sizeof x)
using namespace std;
typedef long long int64;
const int MAX_LEN=90;
int64 fib[MAX_LEN];
int cnt[MAX_LEN];

int64 p;

int dp[MAX_LEN][7][7];//at,c_{at+1},c_{at}
const int INF=~0U&gt;&gt;2;

void cmin(int&amp;x,int c){if(c&lt;x)x=c;}

void work(){
	cin&gt;&gt;p;
	CLR(cnt,0);
	for(int i=MAX_LEN-1;i&gt;=0;--i){
		if(p&gt;=fib[i])
			cnt[i]++,p-=fib[i];		
	}
	
	assert(p==0);
	REP(i,MAX_LEN)REP(j,7)REP(k,7)dp[i][j][k]=INF;

	dp[MAX_LEN-1][3][3+cnt[MAX_LEN-1]]=0;

	for(int i=MAX_LEN-1;i&gt;0;--i)
		for(int j=-3;j&lt;=3;++j)
			for(int k=-3;k&lt;=3;++k){
				int c=dp[i][j+3][k+3];
				if(c==INF)continue;
				for(int nk=-3;nk&lt;=3;++nk){
					int nc=c+abs(k-nk);
					int nxtJ=nk+j,nxtK=j+cnt[i-1];
					if(nxtJ&gt;=-3&amp;&amp;nxtJ&lt;=3&amp;&amp;nxtK&gt;=-3&amp;&amp;nxtK&lt;=3)
						cmin(dp[i-1][nxtJ+3][nxtK+3],nc);
				}
			}

	int ans=INF;
	for(int j=-3;j&lt;=3;++j)
		for(int k=-3;k&lt;=3;++k)
			cmin(ans,dp[0][j+3][k+3]+abs(j));

	cout&lt;&lt;ans&lt;&lt;endl;
}

int main(){
	fib[0]=0;fib[1]=1;
	for(int i=2;i&lt;MAX_LEN;i++)fib[i]=fib[i-1]+fib[i-2];
	int nT;cin&gt;&gt;nT;
	REP(i,nT)work();
}</pre><pre></pre><h2>Problem2802</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;queue&gt;
#define REP(i,n) for(int i=0;i&lt;n;i++)
#define CLR(x,c) memset(x,c,sizeof x)
using namespace std;
const int MAX_N=250000+10;
typedef long long int64;
int a[MAX_N],b[MAX_N],n;
int main(){
	cin&gt;&gt;n;
	REP(i,n)scanf("%d",a+i);
	REP(i,n)scanf("%d",b+i);

	int64 rem=0;
	priority_queue&lt;pair&lt;int,int&gt; &gt; que;

	static bool used[MAX_N];
	int cnt=0;

	REP(i,n){
		rem+=a[i];
		if(rem&gt;=b[i]){
			que.push(make_pair(b[i],i));
			rem-=b[i];
			used[i]=true;
			++cnt;
		} else {
			if(!que.empty()&amp;&amp;que.top().first &gt;= b[i]){
				rem+=que.top().first-b[i];
				used[que.top().second]=false;
				used[i]=true;
				que.pop();
				que.push(make_pair(b[i],i));
			}
		}
	}

	printf("%d\n",cnt);

	REP(i,n)if(used[i])
		printf("%d ",i+1);
	puts("");
}</pre><pre></pre><h2>Problem2804</h2><pre>/*
 * cd.cpp
 *
 *  Created on: 2012-6-25
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;string&gt;
#include &lt;cassert&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

//2,3,...,A

struct Card {
	int p, r;
	Card() {
	}
	Card(int p, int r) {
		this-&gt;p = p;
		this-&gt;r = r;
	}
	bool operator&lt;(const Card&amp;o) const {
		return p != o.p ? p &lt; o.p : r &lt; o.r;
	}

	int id() {
		return (p - 2) * 4 + r;
	}

	void read() {
		cin &gt;&gt; p &gt;&gt; r;
		if (p == 1)
			p = 14;
		r = 4 - r;
	}
};

void show(int who) {
	for (int i = 0; i &lt; 5; ++i) {
		cout &lt;&lt; who % 52 &lt;&lt; " ";
		who /= 52;
	}
	cout &lt;&lt; endl;
}

struct Hand {
	int type, dot, col, who;
	Hand() {
	}
	Hand(int type, int dot, int col, int who) {
		this-&gt;type = type;
		this-&gt;dot = dot;
		this-&gt;col = col;
		this-&gt;who = who;
	}

	bool operator&lt;(const Hand&amp;o) const {
		if (type != o.type)
			return type &gt; o.type;
		if (dot != o.dot)
			return dot &lt; o.dot;
		if (col != o.col)
			return col &lt; o.col;
		return false;
	}
};

Card cards[5];

bool isStright(int&amp;dot, int&amp;col) {
	bool ok = true;
	for (int i = 1; i &lt; 5; ++i) {
		if (cards[i].p != cards[0].p + i)
			ok = false;
	}
	if (ok) {
		dot = cards[0].p, col = 0;
		for (int i = 5 - 1; i &gt;= 0; --i) {
			col = col * 4 + cards[i].r;
		}
		return true;
	}

	//check A2345
	if (cards[4].p == 14) {
		ok = true;
		for (int i = 0; i &lt; 4; ++i) {
			if (cards[i].p != i + 2)
				ok = false;
		}
		if (ok) { //good! A2345
			dot = 1, col = 0;
			for (int i = 4 - 1; i &gt;= 0; --i) {
				col = col * 4 + cards[i].r;
			}
			col = col * 4 + cards[4].r;
			return true;
		}
	}

	return false;
}

bool isFlush() {
	for (int i = 1; i &lt; 5; ++i) {
		if (cards[i].r != cards[0].r)
			return false;
	}
	return true;
}

string makeIt(int&amp;dot, int&amp;col) {
	pair&lt;int, Card&gt; ps[5];
	string cnt = "";
	for (int i = 0, j; i &lt; 5; i = j) {
		for (j = i; j &lt; 5 &amp;&amp; cards[j].p == cards[i].p; ++j)
			;
		cnt += char('0' + j - i);
		for (int k = i; k &lt; j; ++k) {
			ps[k] = make_pair(j - i, cards[k]);
		}
	}
	sort(ps, ps + 5);

	dot = col = 0;

	for (int i = 5 - 1; i &gt;= 0; --i) {
		dot = dot * 13 + ps[i].second.p - 2;
		col = col * 4 + ps[i].second.r;
	}

	sort(cnt.rbegin(), cnt.rend());
	return cnt;
}

void makeItSorted(int&amp;dot, int&amp;col) {
	dot = 0, col = 0;
	for (int i = 5 - 1; i &gt;= 0; --i) {
		dot = dot * 13 + cards[i].p - 2;
		col = col * 4 + cards[i].r;
	}
}

Hand process() {
	sort(cards, cards + 5);
	int dot, col, who = 0;

	for (int i = 0; i &lt; 5; ++i) {
		who = who * 52 + cards[i].id();
	}

	bool isS = isStright(dot, col);
	bool isF = isFlush();
	int type;

	int dotG, colG;
	string cnt = makeIt(dotG, colG);

	if (isS &amp;&amp; isF) {
		type = 1;
		return Hand(type, dot, col, who);
	}

	if (cnt == "41") {
		type = 2;
		return Hand(type, dotG, colG, who);
	}

	if (cnt == "32") {
		type = 3;
		return Hand(type, dotG, colG, who);
	}

	int dotS, colS;
	makeItSorted(dotS, colS);

	if (isF) {
		type = 4;
		return Hand(type, dotS, colS, who);
	}

	if (isS) {
		type = 5;
		return Hand(type, dot, col, who);
	}

	if (cnt == "311") {
		type = 6;
		return Hand(type, dotG, colG, who);
	}

	if (cnt == "221") {
		type = 7;
		return Hand(type, dotG, colG, who);
	}

	if (cnt == "2111") {
		type = 8;
		return Hand(type, dotG, colG, who);
	}

	type = 9;
	return Hand(type, dotS, colS, who);
}

typedef long long int64;

bool myCard[52] = { }, youCard[52] = { };
int n;

void readCardSet(int n, bool cardSet[]) {
	Card c;
	for (int i = 0; i &lt; n; ++i) {
		c.read();
		cardSet[c.id()] = true;
	}
}

Card allCard[52];

Card cur[5];

const int MAX_HANDS = 3000000 + 10;

Hand hands[MAX_HANDS];
int nHands = 0;

bool check(int who, bool cardSet[], int n) {
	int cnt = 0;
	for (int i = 0; i &lt; 5; ++i) {
		int x = who % 52;
		who /= 52;
		if (cardSet[x])
			++cnt;
	}
	return cnt == n;
}

void dfs(int u, int who, int cnt) { //search all cardSet combination
	if (u == 52) {
		if (cnt == 5 &amp;&amp; (check(who, myCard, n) || check(who, youCard, n - 1))) {
			memcpy(cards, cur, sizeof cur);
			hands[nHands++] = process();
		}
		return;
	}
	dfs(u + 1, who, cnt);
	if (cnt &lt; 5) {
		cur[cnt] = allCard[u];
		dfs(u + 1, who * 52 + u, cnt + 1);
	}
}

bool check(const Hand&amp;h, bool cardSet[], int n) {
	return check(h.who, cardSet, n);
}

typedef long long int64;

int64 comb(int n, int m) {
	int64 ret = 1;
	for (int i = 0; i &lt; m; ++i) {
		ret *= n - i;
		ret /= i + 1;
	}
	return ret;
}

int id[5];

int64 A, B;

int dp[6][60]; //rem,max

void prepare() {
	memset(dp, 0, sizeof dp);
	fill(dp[0], dp[0] + 60, 1);
	for (int rem = 1; rem &lt;= 5; ++rem) {
		for (int mx = 1; mx &lt;= 52; ++mx) {
			dp[rem][mx] += dp[rem][mx - 1] + dp[rem - 1][mx - 1];
		}
	}
}

int curv[5];
int mp[4000000];

int eval(int v[], int n) {
	int code = 0;
	for (int i = 0; i &lt; n; ++i) {
		code += dp[i][52];
	}
	for (int i = 0; i &lt; n; ++i)
		code += dp[n - i][v[i]];
	return code;
}

void dfs1(int u, int cnt) {
	if (u == 5) {
		int cd = eval(curv, cnt);
		A += (cnt % 2 == 0 ? 1 : -1) * mp[cd];
		return;
	}
	dfs1(u + 1, cnt);
	curv[cnt] = id[u];
	dfs1(u + 1, cnt + 1);
}

void dfs2(int u, int cnt) {
	if (u == 5) {
		int cd = eval(curv, cnt);
		mp[cd]++;
		return;
	}
	dfs2(u + 1, cnt);
	curv[cnt] = id[u];
	dfs2(u + 1, cnt + 1);
}

int main() {
	cin &gt;&gt; n;
	readCardSet(n, myCard);
	readCardSet(n - 1, youCard);

	for (int i = 2; i &lt;= 14; ++i) {
		for (int j = 0; j &lt; 4; ++j) {
			Card c(i, j);
			allCard[c.id()] = c;
		}
	}

	dfs(0, 0, 0);

	sort(hands, hands + nHands);

	int rem = 52 - n - (n - 1);
	A = 0, B = 1;
	B *= comb(rem, 5 - n);
	rem -= 5 - n;
	B *= comb(rem, 5 - (n - 1));

	prepare();

	for (int i = 0; i &lt; nHands; ++i) {
		Hand&amp;h = hands[i];
		if (check(h, myCard, n)) {
			int who = h.who;
			for (int j = 0; j &lt; 5; ++j) {
				id[j] = who % 52;
				who /= 52;
			}

			sort(id, id + 5);
			reverse(id, id + 5);
			dfs1(0, 0);
		}

		if (check(h, youCard, n - 1)) {
			int who = h.who;
			for (int j = 0; j &lt; 5; ++j) {
				id[j] = who % 52;
				who /= 52;
			}
			sort(id, id + 5);
			reverse(id, id + 5);
			dfs2(0, 0);
		}
	}

	int64 G = __gcd(A, B);
	A /= G, B /= G;
	cout &lt;&lt; A &lt;&lt; "/" &lt;&lt; B &lt;&lt; endl;

	return 0;
}
</pre><pre></pre><h2>Problem2806</h2><pre>/*
 * cheat.cpp
 *
 *  Created on: 2012-5-25
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_LEN = 1100000 + 10;

struct State {
	State*suf, *go[3];
	int val;
	State() :
			suf(0), val(0) {
		memset(go, 0, sizeof go);
	}
}*root, *last;
State statePool[MAX_LEN * 2], *cur = statePool;

void init() {
	root = last = cur++;
}

void extend(int w) {
	State*p = last, *np = cur++;
	np-&gt;val = p-&gt;val + 1;
	while (p &amp;&amp; !p-&gt;go[w])
		p-&gt;go[w] = np, p = p-&gt;suf;
	if (!p)
		np-&gt;suf = root;
	else {
		State*q = p-&gt;go[w];
		if (p-&gt;val + 1 == q-&gt;val)
			np-&gt;suf = q;
		else {
			State*nq = cur++;
			memcpy(nq-&gt;go, q-&gt;go, sizeof q-&gt;go);
			nq-&gt;val = p-&gt;val + 1;
			nq-&gt;suf = q-&gt;suf;
			q-&gt;suf = nq;
			np-&gt;suf = nq;
			while (p &amp;&amp; p-&gt;go[w] == q)
				p-&gt;go[w] = nq, p = p-&gt;suf;
		}
	}
	last = np;
}

char buf[MAX_LEN];
int n, m;

void calc() {
	scanf("%s", buf);
	int n = strlen(buf);
	static int ext[MAX_LEN];
	State*cur = root;
	int l = 0;
	for (int i = 0; i &lt; n; ++i) {
		while (i + l &lt; n &amp;&amp; cur-&gt;go[buf[i + l] - '0'])
			cur = cur-&gt;go[buf[i + l] - '0'], l++;
		ext[i] = l;
		if (l &gt; 0) {
			--l;
			if (l &lt;= cur-&gt;suf-&gt;val)
				cur = cur-&gt;suf;
		}
	}

	int r = n + 1;
	l = 0;
	while (l + 1 &lt; r) {
		static int dp[MAX_LEN], v[MAX_LEN], que[MAX_LEN];
		int qh = 0, qt = 0;
		int m = l + r &gt;&gt; 1;
		dp[n] = 0, v[n] = dp[n] + n;
		for (int i = n - 1; i &gt;= 0; --i) {
			dp[i] = dp[i + 1];
			if (i + m &lt;= n) {
				while (qh &lt; qt &amp;&amp; v[que[qt - 1]] &lt;= v[i + m])
					--qt;
				que[qt++] = i + m;
			}
			while (qh &lt; qt &amp;&amp; i + ext[i] &lt; que[qh])
				++qh;
			if (qh &lt; qt)
				dp[i] = max(dp[i], v[que[qh]] - i);
			v[i] = dp[i] + i;
		}
		if (dp[0] * 10 &gt;= n * 9)
			l = m;
		else
			r = m;
	}
	printf("%d\n", l);
}

int main() {
	init();
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 0; i &lt; m; ++i) {
		scanf("%s", buf);
		for (int j = 0, l = strlen(buf); j &lt; l; j++)
			extend(buf[j] - '0');
		extend(2);
	}
	for (int i = 0; i &lt; n; ++i) {
		calc();
	}
	return 0;
}
</pre><pre></pre><h2>Problem2808</h2><pre>#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
using namespace std;

char lit[] = "RGBY";
#define Q 1000000007

#define VAR(a,b) typeof(b) a=(b)
#define FOR(i,a,b) for(VAR(i,a);i&lt;=b;++i)
#define FORD(i,a,b) for(VAR(i,a);i&gt;=b;--i)
#define REP(i,a) for(int i=0;i&lt;(a);++i)
#define FORE(a,b) for(typeof((b).begin()) a=(b).begin();a!=(b).end();++a)

int t[107][4][107], w[107][11000];

class ColorfulTiles {
public:
	int rozw(string s, int K) {
		REP(i,4)
			t[0][i][1] = 1, t[0][i][0] = 0;
		REP(i,4)
			if (lit[i] == s[0]) {
				t[0][i][1] = 0;
				t[0][i][0] = 1;
			}
		FOR(i,1,s.size()-1)
			REP(j,4)
				REP(k,K+1)
					if (k &gt;= (lit[j] != s[i])) {
						t[i][j][k] = 0;
						REP(u,4)
							if (u != j)
								t[i][j][k] = (t[i][j][k] + t[i - 1][u][k - (lit[j] != s[i])]) % Q;
					} else
						t[i][j][k] = 0;
		long long ret = 0;
		REP(j,4)
			REP(k,K+1)
				ret += t[s.size() - 1][j][k];
		return ret % Q;
	}
	int theCount(vector&lt;string&gt; s, int K) {
		int n = s.size(), m = s[0].size();
		if (m == 1 || n == 1) {
			string t;
			FORE(i,s)
				t += *i;
			return rozw(t, K);
		}
		int ret = 0;
		char p[7] = "BGRY";
		do {
			int blad = 0;
			REP(i,K+1)
				w[0][i] = 1;
			REP(i,n) {
				char a[2];
				a[0] = p[0], a[1] = p[1];
				if (i % 2)
					a[0] = p[2], a[1] = p[3];
				int b1 = 0;
				REP(j,m)
					if (s[i][j] != a[j % 2])
						b1++;
				blad += b1;
				swap(a[0], a[1]);
				int b2 = 0;
				REP(j,m)
					if (s[i][j] != a[j % 2])
						b2++;
				REP(x,K+1)
					w[i + 1][x] = 0;
				REP(x,K+1) {
					if (x + b1 &lt;= K)
						w[i + 1][x + b1] = (w[i + 1][x + b1] + w[i][x]) % Q;
					if (x + b2 &lt;= K &amp;&amp; i &gt; 1)
						w[i + 1][x + b2] = (w[i + 1][x + b2] + w[i][x]) % Q;
				}
			}
			if (blad &lt;= K)
				ret--;
			ret += w[n][K];
			ret %= Q;

			REP(i,K+1)
				w[0][i] = 1;
			REP(j,m) {
				char a[2];
				a[0] = p[0], a[1] = p[1];
				if (j % 2)
					a[0] = p[2], a[1] = p[3];
				int b1 = 0;
				REP(i,n)
					if (s[i][j] != a[i % 2])
						b1++;
				blad += b1;
				swap(a[0], a[1]);
				int b2 = 0;
				REP(i,n)
					if (s[i][j] != a[i % 2])
						b2++;
				REP(x,K+1)
					w[j + 1][x] = 0;
				REP(x,K+1) {
					if (x + b1 &lt;= K)
						w[j + 1][x + b1] = (w[j + 1][x + b1] + w[j][x]) % Q;
					if (x + b2 &lt;= K &amp;&amp; j &gt; 1)
						w[j + 1][x + b2] = (w[j + 1][x + b2] + w[j][x]) % Q;
				}
			}
			ret += w[m][K];
			ret %= Q;
		} while (next_permutation(p, p + 4));
		ret += Q;
		return ret % Q;
	}
};

int main() {
	int n, m, k;
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
	vector&lt;string&gt; a;
	for (int i = 0; i &lt; n; ++i) {
		string t;
		cin &gt;&gt; t;
		a.push_back(t);
	}
	cout &lt;&lt; ColorfulTiles().theCount(a, k) &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem2809</h2><pre>/*
 * dispatching.cpp
 *
 *  Created on: 2012-5-31
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_N = 100000 + 10;

struct Node {
	int v;
	Node*l, *r;
	Node(int _v) :
			v(_v) {
		l = r = 0;
	}
};

Node*merge(Node*a, Node*b) {
	if (!a || !b)
		return a ? a : b;
	if (a-&gt;v &lt; b-&gt;v)
		swap(a, b);
	a-&gt;r = merge(a-&gt;r, b);
	swap(a-&gt;l, a-&gt;r);
	return a;
}

int n, m;

typedef long long int64;

int b[MAX_N], c[MAX_N], l[MAX_N];

Node*heap[MAX_N];

int64 tot[MAX_N];
int cnt[MAX_N];

int main() {
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d%d%d", b + i, c + i, l + i);
		--b[i];
	}

	int64 ans = 0;
	for (int i = n - 1; i &gt;= 0; --i) {
		heap[i] = merge(heap[i], new Node(c[i]));
		tot[i] += c[i];
		++cnt[i];

		while (tot[i] &gt; m) {
			tot[i] -= heap[i]-&gt;v;
			--cnt[i];
			heap[i] = merge(heap[i]-&gt;l, heap[i]-&gt;r);
		}

		ans = max(ans, 1LL * cnt[i] * l[i]);

		if (b[i] &gt;= 0) {
			heap[b[i]] = merge(heap[b[i]], heap[i]);
			cnt[b[i]] += cnt[i];
			tot[b[i]] += tot[i];
		}
	}

	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2813</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
using namespace std;
const int MOD = int(1e9) + 7;
const int MAX_N = int(1e7) + 10;

int Q, A, B, C;
int cnt[MAX_N], ret[MAX_N]; //cnt div,sum div^2

int primes[MAX_N], nPrimes = 0;
int minP[MAX_N] = { }, minPow[MAX_N];

typedef long long int64;

int main() {
	int64 cur;
	cin &gt;&gt; Q &gt;&gt; cur &gt;&gt; A &gt;&gt; B &gt;&gt; C;

	for (int i = 2; i &lt;= C; ++i) {
		if (minP[i] == 0) {
			minP[i] = i;
			minPow[i] = i;
			primes[nPrimes++] = i;
		}
		for (int j = 0; j &lt; nPrimes; ++j) {
			int p = primes[j];
			int ip = i * p;
			if (ip &gt; C)
				break;
			minP[ip] = p;
			if (minP[i] == p) {
				minPow[ip] = minPow[i] * p;
				break;
			} else {
				minPow[ip] = p;
			}
		}
	}

	cnt[1] = ret[1] = 1;
	for (int i = 2; i &lt;= C; ++i) {
		if (minPow[i] == i) {
			int x = i / minP[i];
			cnt[i] = cnt[x] + 1;
			ret[i] = (ret[x] + 1LL * i * i) % MOD;
		} else {
			int mp = minPow[i], x = i / mp;
			cnt[i] = cnt[mp] * cnt[x];
			ret[i] = 1LL * ret[mp] * ret[x] % MOD;
		}
	}

	for (int i = 1; i &lt;= C; ++i) {
		if (i % 2 != 0) {
			cnt[i]++;
			(ret[i] += 4) %= MOD;
		}
	}

	int64 SA = 0, SB = 0;
	SA += cnt[cur], SB += ret[cur];
	for (int i = 1; i &lt; Q; ++i) {
		cur = (cur * A + B) % C + 1;
//		cout &lt;&lt; cur &lt;&lt; endl;
		SA += cnt[cur], SB += ret[cur];
	}
	SA %= MOD, SB %= MOD;
	cout &lt;&lt; SA &lt;&lt; endl &lt;&lt; SB &lt;&lt; endl;

	return 0;
}
</pre><pre></pre><h2>Problem2815</h2><pre>/*
 * catas.cpp
 *
 *  Created on: 2012-5-31
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

int n;
const int MAX_N = 70000;
const int MAX_LOG = 18;

vector&lt;int&gt; E[MAX_N], RE[MAX_N];

int ord[MAX_N], in[MAX_N], que[MAX_N];

int anc[MAX_N][MAX_LOG], dep[MAX_N];

vector&lt;int&gt; child[MAX_N];

int getLca(int u, int v) {
	if (dep[u] &lt; dep[v])
		swap(u, v);
	int up = dep[u] - dep[v];
	for (int i = 0; i &lt; MAX_LOG; ++i) {
		if (up &gt;&gt; i &amp; 1)
			u = anc[u][i];
	}
	if (u == v)
		return u;
	for (int i = MAX_LOG - 1; i &gt;= 0; --i) {
		if (anc[u][i] != anc[v][i])
			u = anc[u][i], v = anc[v][i];
	}
	return anc[u][0];
}

int size[MAX_N];

void dfs(int u) {
	size[u] = 1;
	for (vector&lt;int&gt;::iterator e = child[u].begin(); e != child[u].end(); ++e) {
		dfs(*e);
		size[u] += size[*e];
	}
}

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		int x;
		for (;;) {
			scanf("%d", &amp;x);
			if (!x)
				break;
			--x;
			E[x].push_back(i);
			RE[i].push_back(x);
		}
		in[i] = RE[i].size();
	}

	int qh = 0, qt = 0;

	for (int i = 0; i &lt; n; ++i) {
		if (in[i] == 0)
			E[n].push_back(i), RE[i].push_back(n), ++in[i];
	}

	que[qt++] = n;
	while (qh &lt; qt) {
		int u = que[qh++];
		for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
			--in[*e];
			if (!in[*e]) {
				que[qt++] = *e;
			}
		}
	}

	memset(anc[n], -1, sizeof anc[n]);
	dep[n] = 0;

	for (int i = 1; i &lt;= n; ++i) {
		int u = que[i];
		int fa = RE[u][0];
		for (vector&lt;int&gt;::iterator e = RE[u].begin(); e != RE[u].end(); ++e) {
			fa = getLca(fa, *e);
		}
		anc[u][0] = fa;
		dep[u] = dep[fa] + 1;
		for (int i = 0; i &lt; MAX_LOG - 1; ++i) {
			int go = anc[u][i];
			anc[u][i + 1] = go == -1 ? -1 : anc[go][i];
		}
		child[fa].push_back(u);
	}

	dfs(n);
	for (int i = 0; i &lt; n; ++i) {
		printf("%d\n", size[i] - 1);
	}
	return 0;
}
</pre><pre></pre><h2>Problem2816</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N=10000+10,MAX_C=10,MAX_M=MAX_N*MAX_C,INF=~0U&gt;&gt;1;

int n,m,c,k;

struct Node{
	Node*ch[2],*p;
	int mx,val;
	bool rev;
	bool d(){return this==p-&gt;ch[1];}
	void sc(Node*c,int d){ch[d]=c;c-&gt;p=this;}
	Node(){mx=val=-INF;}
	void upd(){mx=max(val,max(ch[0]-&gt;mx,ch[1]-&gt;mx));}
	void revIt(){rev^=1;swap(ch[0],ch[1]);}
	void relax(){
		if(rev){
			REP(i,2)ch[i]-&gt;revIt();
			rev=0;
		}
	}
}Tnull,*null=&amp;Tnull;

Node mem[MAX_N*MAX_C],*C=mem;
Node*make(int v){
	C-&gt;ch[0]=C-&gt;ch[1]=null;
	C-&gt;mx=C-&gt;val=v;
	C-&gt;p=null;C-&gt;rev=0;
	return C++;
}

void rot(Node*t){
	Node*p=t-&gt;p;p-&gt;relax();t-&gt;relax();
	int d=t-&gt;d();
	p-&gt;p-&gt;sc(t,p-&gt;d());
	p-&gt;sc(t-&gt;ch[!d],d);
	t-&gt;sc(p,!d);
	p-&gt;upd();
}

void pushdown(Node*t){
	static Node*stk[MAX_N];
	int top=0;
	while(t!=null)
		stk[top++]=t,t=t-&gt;p;
	for(int i=top-1;i&gt;=0;--i)
		stk[i]-&gt;relax();
}

void splay(Node*t,Node*f=null){
	pushdown(t);
	while(t-&gt;p!=f){
		if(t-&gt;p-&gt;p==f)rot(t);
		else t-&gt;d()==t-&gt;p-&gt;d()?(rot(t-&gt;p),rot(t))
:(rot(t),rot(t));
	}
	t-&gt;upd();
}

int v[MAX_N];

struct Data{
	Node*p[MAX_N];
	int deg[MAX_N];
	void makeE(Node*u,int d){
		splay(u);
		if(u-&gt;ch[d]!=null)
			u-&gt;revIt();
	}
	void init(int n){
		REP(i,n) {p[i]=make(v[i]);deg[i]=0;}
	}
	void addE(int i,int j){
		Node*u=p[i],*v=p[j];
		makeE(u,1);makeE(v,0);
		u-&gt;relax();
		u-&gt;sc(v,1);
		splay(v);
		deg[i]++;deg[j]++;
	}
	void delE(int i,int j){
		Node*u=p[i],*v=p[j];
		splay(u);
		splay(v,u);
		u-&gt;sc(null,v-&gt;d());
		v-&gt;p=null;
		deg[i]--;deg[j]--;
	}
	void changeV(int i,int v){
		Node*u=p[i];
		splay(u);
		u-&gt;val=v;
		u-&gt;upd();
	}
	int query(int i,int j){
		Node*u=p[i],*v=p[j];
		if(u==v)	 return u-&gt;val;
		splay(u);
		Node*x=v;
		while(x-&gt;p!=null)x=x-&gt;p;
		if(x!=u)
			return -1;
		splay(v,u);
		return max(v-&gt;ch[!v-&gt;d()]-&gt;mx,max(u-&gt;val,v-&gt;val));
	}
	int wantAdd(int i,int j){
		if(deg[i]==2||deg[j]==2)
			return -1;
		Node*u=p[i],*v=p[j];
		splay(u);
		while(v-&gt;p!=null)v=v-&gt;p;
		if(u==v) return -2;
		return 1;
	}
};

Data ds[MAX_C];

typedef pair&lt;int,int&gt; ipair;

ipair st[MAX_M],ps[MAX_M];
int cols[MAX_M],cws[MAX_M];

int&amp;get(int u,int v,bool&amp;ok){
	if(u&gt;v)swap(u,v);
	pair&lt;int,int&gt; key=make_pair(u,v);
	int i=lower_bound(st,st+m,key)-st;
	ok=key==st[i];
	return cols[i];
}

int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;c&gt;&gt;k;
	REP(i,n)scanf("%d",v+i);
	REP(i,c)ds[i].init(n);
	REP(i,m){
		int u,v,w;
		scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		--u,--v;
		if(u&gt;v)swap(u,v);ps[i]=make_pair(u,v);st[i]=ps[i];
		cws[i]=w;
		ds[w].addE(u,v);
	}
	sort(st,st+m);
	bool ok;
	REP(i,m){
		get(ps[i].first,ps[i].second,ok)=cws[i];
	}
	REP(it,k){
		int t;scanf("%d",&amp;t);
		if(t==0){
			int x,y;scanf("%d%d",&amp;x,&amp;y);--x;
			REP(i,c)ds[i].changeV(x,y);
		} else if(t==1){
			int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
			--u,--v;
			int old=get(u,v,ok);
			if(!ok){
				puts("No such edge.");
				continue;
			}
			if(old==w){
				puts("Success.");
				continue;
			}
			int a=ds[w].wantAdd(u,v);
			if(a==-1){
				puts("Error 1.");
			} else if(a==-2){
				puts("Error 2.");
			} else {
				ds[old].delE(u,v);
				ds[w].addE(u,v);
				puts("Success.");
				get(u,v,ok)=w;
			}
		} else {
			int c,u,v;
			scanf("%d%d%d",&amp;c,&amp;u,&amp;v);--u,--v;
			printf("%d\n",ds[c].query(u,v));
		}
	}
}</pre><pre></pre><h2>Problem2818</h2><pre>/*
 * Gcd.cpp
 *
 *  Created on: 2012-5-31
 *      Author: mac
 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

const int MAX_N = int(1e7) + 10;
typedef long long int64;
bool isPrime[MAX_N];
int n;
int64 dp[MAX_N];

int main() {
	cin &gt;&gt; n;
	fill(isPrime + 2, isPrime + n + 1, true);
	for (int i = 2; i * i &lt;= n; ++i) {
		if (isPrime[i])
			for (int j = i * i; j &lt;= n; j += i)
				isPrime[j] = false;
	}
	int64 ans = 0;
	for (int i = n; i &gt;= 1; --i) {
		dp[i] = 1LL * (n / i) * (n / i);
		for (int j = i + i; j &lt;= n; j += i)
			dp[i] -= dp[j];
		if (isPrime[i])
			ans += dp[i];
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2820</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
using namespace std;

typedef long long int64;

const int MAX_N = int(1e7);
int minP[MAX_N + 1] = { }, minPow[MAX_N + 1], primes[MAX_N + 1], nPrimes = 0;
int64 f[MAX_N + 1] = { }, g[MAX_N + 1] = { };

int main() {
	for (int i = 2; i &lt;= MAX_N; ++i) {
		if (minP[i] == 0) {
			minP[i] = minPow[i] = i;
			primes[nPrimes++] = i;
		}
		for (int j = 0; j &lt; nPrimes; ++j) {
			int p = primes[j];
			int ip = i * p;
			if (ip &gt; MAX_N)
				break;
			minP[ip] = p;
			if (minP[i] == p) {
				minPow[ip] = minPow[i] * p;
				break;
			} else {
				minPow[ip] = p;
			}
		}
	}

	f[1] = 0, g[1] = 1;
	for (int i = 2; i &lt;= MAX_N; ++i) {
		int p = minP[i], x = i / minPow[i];
		if (minPow[i] &gt; 1LL * p * p) {
			continue;
		}
		if (minPow[i] == p) {
			f[i] = -f[x] + g[x];
			g[i] = -g[x];
		} else {
			g[i] = 0;
			f[i] = -g[x];
		}
	}

	for (int i = 1; i &lt;= MAX_N; ++i) {
		f[i] += f[i - 1];
	}

	int T;
	cin &gt;&gt; T;

	for (int i = 0; i &lt; T; ++i) {
		int n, m;
		scanf("%d%d", &amp;n, &amp;m);
		if (n &gt; m)
			swap(n, m); //n&lt;=m
		int64 ans = 0;
		for (int d = 1, r; d &lt;= n; d = r + 1) {
			r = min(n / (n / d), m / (m / d));
			//calc [d,r]
			ans += 1LL * (n / d) * (m / d) * (f[r] - f[d - 1]);
		}
		printf("%lld\n", ans);
//		cout &lt;&lt; bf(n, m) &lt;&lt; endl;
	}
	return 0;
}
</pre><pre></pre><h2>Problem2831</h2><pre>def bf(R,A,B,C):
	r=0
	for x in range(R+1):
		r+=x* ((A*x+B)/C)
	return r
	
def bf0(R,A,B,C):
	r=0
	for x in range(R+1):
		r+= (A*x+B)/C
	return r
	
c1=lambda x:x*(x+1)/2 # sum [0,x]
c2=lambda x:x*(x+1)*(2*x+1)/6 # sum[0^2..x^2]

def calc0(R,A,B,C):
	# x&lt;-[0,R] (Ax+B)/C
	if C==1:
		return (R+1)*B+c1(R)*A
	if A&gt;=C or B&gt;=C:
		return calc0(R,A%C,B%C,C)+(B/C)*(R+1)+c1(R)*(A/C)
	Y=(A*R+B)/C
	return Y*R-calc0(Y-1,C,C-B-1,A)
	
def calc1(R,A,B,C):
	# sum x&lt;-[0,R] x* ((Ax+B)/C)
	if C==1:
		return B*c1(R)+A*c2(R) # Ax^2+xB
	if A&gt;=C or B&gt;=C:
		return calc1(R,A%C,B%C,C)+c2(R)*(A/C)+c1(R)*(B/C)
	#A&lt;C,B&lt;C
	Y=(A*R+B)/C
	return Y*c1(R)-( calc2(Y-1,C,C-B-1,A) + calc0(Y-1,C,C-B-1,A) )/2

def calc(R,A,B,C):
	if R&lt;0:
		return [0]*3
	# sum x&lt;-[0,R] x* ((Ax+B)/C)
	# sum x&lt;-[0,R] ((Ax+B)/C)^2
	# sum x&lt;-[0.R] ((Ax+B)/C)
	if C==1: #A^2x^2+2ABx+B^2
		return [B*c1(R)+A*c2(R),A*A*c2(R)+2*A*B*c1(R)+B*B*(R+1),B*(R+1)+A*c1(R)]
	if A&gt;=C:
		p1,p2,p3=calc(R,A%C,B,C)
		a=A/C
		ret=[0]*3
		ret[0]=p1+a*c2(R)
		ret[1]=p2+c2(R)*a*a+2*a*p1
		ret[2]=p3+a*c1(R)
		return ret
	if B&gt;=C:
		p1,p2,p3=calc(R,A,B%C,C)
		b=B/C
		ret=[0]*3
		ret[0]=p1+b*c1(R)
		ret[1]=p2+b*b*(R+1)+2*b*p3
		ret[2]=p3+b*(R+1)
		return ret
	#A&lt;C,B&lt;C
	Y=(A*R+B)/C
	p1,p2,p3=calc(Y-1,C,C-B-1,A)
	ret=[0]*3
	ret[0]=Y*c1(R)-(p2+p3)/2
	ret[1]=Y*Y*R-p3-2*p1
	ret[2]=Y*R-p3
	return ret

A,C,B,L,R=map(int,raw_input().split(' '))
#print bf(R,A,B,C)-bf(L-1,A,B,C)
print calc(R,A,B,C)[0]-calc(L-1,A,B,C)[0]</pre><pre></pre><h2>Problem2831</h2><pre>c1=lambda x:x*(x+1)/2 # sum [0,x]
c2=lambda x:x*(x+1)*(2*x+1)/6 # sum[0^2..x^2]
def calc(R,A,B,C):
	if R&lt;0:
		return [0]*3
	# sum x&lt;-[0,R] x* ((Ax+B)/C)
	# sum x&lt;-[0,R] ((Ax+B)/C)^2
	# sum x&lt;-[0.R] ((Ax+B)/C)
	if C==1: #A^2x^2+2ABx+B^2
		return [B*c1(R)+A*c2(R),A*A*c2(R)+2*A*B*c1(R)+B*B*(R+1),B*(R+1)+A*c1(R)]
	if A&gt;=C:
		p1,p2,p3=calc(R,A%C,B,C)
		a=A/C
		ret=[0]*3
		ret[0]=p1+a*c2(R)
		ret[1]=p2+c2(R)*a*a+2*a*p1
		ret[2]=p3+a*c1(R)
		return ret
	if B&gt;=C:
		p1,p2,p3=calc(R,A,B%C,C)
		b=B/C
		ret=[0]*3
		ret[0]=p1+b*c1(R)
		ret[1]=p2+b*b*(R+1)+2*b*p3
		ret[2]=p3+b*(R+1)
		return ret
	#A&lt;C,B&lt;C
	Y=(A*R+B)/C
	p1,p2,p3=calc(Y-1,C,C-B-1,A)
	ret=[0]*3
	ret[0]=Y*c1(R)-(p2+p3)/2
	ret[1]=Y*Y*R-p3-2*p1
	ret[2]=Y*R-p3
	return ret

A,C,B,L,R=map(int,raw_input().split(' '))
print calc(R,A,B,C)[0]-calc(L-1,A,B,C)[0]</pre><pre></pre><h2>Problem2833</h2><pre>div=[[] for i in range(1001)]
for i in range(1,1001):
	for j in range(i*2,1001,i):
		div[j].append(i)
def f(n,m,tab=[[-1]*1001 for i in range(0,1001)]):
	if n==1 or m==1:
		return 1
	if tab[n][m]!=-1:
		return tab[n][m]
	global div	
	r=0
	for a in div[n]:
		r+=g(a,m)
	tab[n][m]=r
	return r
	
def g(n,m,tab=[[-1]*1001 for i in range(0,1001)]):
	if n==1 or m==1:
		return 1
	if tab[n][m]!=-1:
		return tab[n][m]
	global div	
	r=0
	for a in div[m]:
		r+=f(n,a)
	tab[n][m]=r
	return r

n=int(raw_input())
for i in range(n):
	x=int(raw_input())
	print f(x,x)
	</pre><pre></pre><h2>Problem2844</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;cstdlib&gt;
using namespace std;

const int MAX_N = 100000 + 10;
const int MOD = 10086;

int n, a[MAX_N], Q;
int bit[32];
bool used[MAX_N] = { };

int ans = 0;

void search(int at, bool ok, int rem, int mask) {
	if (ok) {
		ans += 1 &lt;&lt; rem;
		ans %= MOD;
		return;
	}
	if (at == -1)
		return;
	int me = Q &gt;&gt; at &amp; 1;
	for (int digit = 0; digit &lt; 2; ++digit) {
		if (!ok &amp;&amp; digit &gt; me)
			continue;
		int w = mask &gt;&gt; at &amp; 1;
		if (bit[at] == -1) {
			if (w == digit)
				search(at - 1, ok || (digit != me), rem, mask);
		} else {
			int v = a[bit[at]];
			int nmask = mask;
			if (w != digit)
				nmask ^= v;
			search(at - 1, ok || (digit != me), rem - 1, nmask);
		}
	}
}

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", a + i);
	}

	cin &gt;&gt; Q;
//	n = 20;
//	for (int i = 0; i &lt; n; ++i) {
//		a[i] = rand() % 177;
//	}
//	Q = rand() % 177;
//
//	int t = 0;
//	for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) {
//		int x = 0;
//		for (int j = 0; j &lt; n; ++j) {
//			if (i &gt;&gt; j &amp; 1)
//				x ^= a[j];
//		}
//		if (x &lt; Q)
//			++t;
//	}
//	cout &lt;&lt; (++t) % MOD &lt;&lt; endl;

	for (int i = 30; i &gt;= 0; --i) {
		bit[i] = -1;
		for (int j = 0; j &lt; n; ++j) {
			if ((a[j] &gt;&gt; i &amp; 1) &amp;&amp; !used[j]) {
				used[j] = true;
				bit[i] = j;
				for (int k = 0; k &lt; n; ++k)
					if (k != j &amp;&amp; (a[k] &gt;&gt; i &amp; 1)) {
						a[k] ^= a[j];
					}
				break;
			}
		}
	}

	int free = n;
	for (int i = 0; i &lt; 31; ++i) {
		if (bit[i] != -1)
			--free;
	}

	search(30, false, n - free, 0);
	ans %= MOD;
	for (int i = 0; i &lt; free; ++i) {
		ans = (ans + ans) % MOD;
	}
	ans = (ans + 1) % MOD;
	cout &lt;&lt; ans &lt;&lt; endl;

	return 0;
}
</pre><pre></pre><h2>Problem2856</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
using namespace std;

typedef long long int64;

inline int nextInt() {
	int x = 0;
	char ch;
	while (ch = getchar(), ch &lt; '0' || ch &gt; '9')
		;
	x = ch - '0';
	while (ch = getchar(), ch &gt;= '0' &amp;&amp; ch &lt;= '9')
		x = x * 10 + ch - '0';
	return x;
}

struct Point {
	int x, y;
	Point() {
	}
	void read() {
		x = nextInt();
		y = nextInt();
	}
	Point(int x, int y) {
		this-&gt;x = x;
		this-&gt;y = y;
	}
	int64 operator^(const Point&amp;o) const {
		return (int64) x * o.y - (int64) y * o.x;
	}
	Point operator-(const Point&amp;o) const {
		return Point(x - o.x, y - o.y);
	}
	bool operator&lt;(const Point&amp;o) const {
		return ((*this) ^ o) &gt; 0;
	}
	bool operator&gt;(const Point&amp;o) const {
		return ((*this) ^ o) &lt; 0;
	}
	bool operator==(const Point&amp;o) const {
		return ((*this) ^ o) == 0;
	}
	void write() const {
		cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")";
	}
};

const int MAX_N = int(1e5) + 10;

int n;
Point ps[MAX_N];

struct Segment {
	Point p1, p2;
	void write() const {
		p1.write();
		cout &lt;&lt; " - ";
		p2.write();
	}
};

#define cross(p1,p2,p3) (int64(p2.x-p1.x)*(p3.y-p1.y)-int64(p3.x-p1.x)*(p2.y-p1.y))

//double isSS(Point p1, Point p2, Point q1, Point q2) {
//	double a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);
//	return (p1.x * a2 + p2.x * a1) / (a1 + a2);
//	//return (p1 * a2 + p2 * a1) / (a1 + a2);
//}

Point st[MAX_N];
int nSt;

Point O(0, 0);
Point CUR;

double isSS(Point p1, Point p2) {
	double a1 = CUR ^ p1, a2 = p2 ^ CUR;
	return (p1.x * a2 + p2.x * a1) / (a1 + a2);
}

bool operator&lt;(const Segment&amp;a, const Segment&amp;b) {
	double x = isSS(a.p1, a.p2), y = isSS(b.p1, b.p2);
	return x &lt; y - 1e-6;
}

int rank[MAX_N];

Segment segs[MAX_N];

int minX[MAX_N];

bool bad[MAX_N];

struct Heap {
	int n;
	int a[MAX_N];
	int idx[MAX_N];

	Heap() {
		n = 0;
	}

	bool cmp(int a, int b) {
		return segs[a] &lt; segs[b];
	}

	void exch(int i, int j) {
		swap(a[i], a[j]);
		swap(idx[a[i]], idx[a[j]]);
	}

	void fixUp(int i) {
		if (i == 1)
			return;
		if (cmp(a[i], a[i / 2]))
			exch(i, i / 2), fixUp(i / 2);
	}

	void fixDown(int i) {
		if (2 * i &gt; n)
			return;
		int j = 2 * i;
		if (j + 1 &lt;= n)
			if (cmp(a[j + 1], a[j]))
				++j;
		if (cmp(a[j], a[i]))
			exch(i, j), fixDown(j);
	}

	int top() {
		return a[1];
	}

	void add(int x) {
		a[++n] = x;
		idx[x] = n;
		fixUp(n);
	}

	void del(int x) {
		int i = idx[x];
		exch(i, n);
		--n;
		if (i &lt;= n)
			fixUp(i), fixDown(i);
	}
} heap;

struct List {
	int next[MAX_N];
	int first[MAX_N];
	List() {
		memset(first, -1, sizeof first);
	}
	void add(int a, int i) {
		next[i] = first[a];
		first[a] = i;
	}
};

List byL, byR, byP;

#define FOREACH(e,lst,x) for(int e=lst.first[x];e!=-1;e=lst.next[e])

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		ps[i].read();
		st[i] = ps[i];
	}
	sort(st, st + n);
	nSt = unique(st, st + n) - st;
	fill(minX, minX + nSt, INT_MAX);

	for (int i = 0; i &lt; n; ++i) {
		int id = lower_bound(st, st + nSt, ps[i]) - st;
		byP.add(id, i);
		minX[id] = min(minX[id], ps[i].x);
		rank[i] = id;
	}

	for (int i = 0; i &lt; n; ++i) {
		Point p1 = ps[i], p2 = ps[(i + 1) % n];
		int L = rank[i], R = rank[(i + 1) % n];
		if (p2 &lt; p1)
			swap(p1, p2), swap(L, R);
		segs[i].p1 = p1;
		segs[i].p2 = p2;
		++L;
		//[L,R)
		if (L &lt; R) {
			byL.add(L, i);
			byR.add(R, i);
		}
	}

	for (int i = 0; i &lt; nSt; ++i) {
//		cout &lt;&lt; "HI" &lt;&lt; endl;
		CUR = st[i];
		//del R
		FOREACH(e,byR,i) {
//			cout &lt;&lt; "ERASE" &lt;&lt; endl;
//			cur.erase(segs[*e]);
			heap.del(e);
		}
		//add L
		FOREACH(e,byL,i) {
//			cout &lt;&lt; "INSERT" &lt;&lt; endl;
//			cout &lt;&lt; cur.insert(segs[*e]).second &lt;&lt; endl;
//			if (!cur.insert(segs[*e]).second) {
//				cur.find(segs[*e])-&gt;write();
//				cout &lt;&lt; endl;
//				segs[*e].write();
//				cout &lt;&lt; endl;
//			}
			heap.add(e);
		}
		//query p
		FOREACH(e,byP,i) {
			if (heap.n &gt; 0) {
				const Segment&amp;s = segs[heap.top()];
				if (cross(s.p1, s.p2, ps[e]) &lt; 0)
					bad[e] = true;
			}
		}
	}

	for (int i = 0; i &lt; n; ++i) {
		if (minX[rank[i]] != ps[i].x)
			bad[i] = true;
	}

	static int ans[MAX_N];
	int cnt = 0;

	for (int i = 0; i &lt; n; ++i) {
		if (!bad[i])
			ans[cnt++] = i + 1;
	}

	cout &lt;&lt; cnt &lt;&lt; endl;

	for (int i = 0; i &lt; cnt; ++i) {
		printf("%d ", ans[i]);
	}
	puts("");
}</pre><pre></pre><h2>Problem2863</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
using namespace std;

const int MAX_N = 3000 + 10;
const int MOD = int(1e9) + 7;

typedef long long int64;
int comb[MAX_N][MAX_N];
int n;

int pow2[MAX_N * MAX_N];

int64 F[MAX_N];

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt;= n; ++i) {
		for (int j = 0; j &lt;= i; ++j) {
			comb[i][j] = (i == 0 || j == 0) ? 1 : (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD;
		}
	}
	pow2[0] = 1;
	for (int i = 1; i &lt;= n * n; ++i) {
		pow2[i] = pow2[i - 1] * 2 % MOD;
	}
	F[0] = F[1] = 1;

	for (int i = 2; i &lt;= n; ++i) {
		for (int L = 1; L &lt;= i; ++L) {
			F[i] += (L % 2 ? 1 : -1) * comb[i][L] * F[i - L] % MOD * pow2[L * (i - L)];
			F[i] %= MOD;
		}
		if (F[i] &lt; 0)
			F[i] += MOD;
	}
	cout &lt;&lt; F[n] &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem2865</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;

//suffix array

const int MAX_N=500000+10;
int rank[MAX_N],sa[MAX_N],tmp[MAX_N],m;

void dosort(int x[],int y[],int n){
	static int cnt[MAX_N];
	memset(cnt,0,sizeof(int)*(m));
	REP(i,n)cnt[x[i]]++;
	REP(i,m-1)cnt[i+1]+=cnt[i];
	for(int i=n-1;i&gt;=0;--i)sa[--cnt[x[y[i]]]]=y[i];
}

char str[MAX_N];

bool cmp(int a,int b,int k){
	return rank[a]==rank[b]&amp;&amp;rank[a+k]==rank[b+k];
}

void DA(int n){
	m=300;
	REP(i,n)rank[i]=str[i],tmp[i]=i;
	dosort(rank,tmp,n);
	for(int k=1;k&lt;=n;k&lt;&lt;=1){
		//k-&gt;2k
		int c=0;
		for(int i=n-k;i&lt;n;i++)tmp[c++]=i;
		for(int i=0;i&lt;n;i++)if(sa[i]&gt;=k)tmp[c++]=sa[i]-k;
		dosort(rank,tmp,n);
		m=0;
		REP(i,n)if(!i||!cmp(sa[i],sa[i-1],k))tmp[sa[i]]=m++;else tmp[sa[i]]=m-1;
		REP(i,n)rank[i]=tmp[i];
		if(m==n)	 break;
	}
}

int n;
const int SEED=10007;
int h[MAX_N],pw[MAX_N];
int get(int l,int r){return h[r]-h[l]*pw[r-l];}//SEED
int lcp(int a,int b){
	int l=0,r=min(n-a,n-b)+1;
	while(l+1&lt;r){
		int m=l+r&gt;&gt;1;
		if(get(a,a+m)==get(b,b+m)) l=m; else r=m;
	}
	return l;
}

int mxsame[MAX_N];
const int INF=~0U&gt;&gt;2;

int f[MAX_N];
int fd(int x){return f[x]==x?x:f[x]=fd(f[x]);}

struct Updater{
	int a[MAX_N];
	
	struct Update{
		Update*nxt;
		int l,r;
	};
	
	Update mem[MAX_N],*cur,*first[MAX_N];
	
	void init(int n){
		REP(i,n)a[i]=INF;
		REP(i,n+1)first[i]=0;
		cur=mem;
	}
	
	void add(int l,int r,int v){
		cur-&gt;l=l,cur-&gt;r=r,cur-&gt;nxt=first[v];
		first[v]=cur++;	
	}
	
	void doit(){
		REP(i,n+1)f[i]=i;
		REP(i,n+1){
			for(Update*u=first[i];u;u=u-&gt;nxt)
				for(int x=fd(u-&gt;l);x&lt;=u-&gt;r;x=fd(x))
					a[x]=i,f[x]=x+1;
		}
	}
}UA,UB;

int main(){
	scanf("%s",str);
	n=strlen(str);
	str[n]=0;
	DA(n+1);
	pw[0]=1;REP(i,n)pw[i+1]=pw[i]*SEED,h[i+1]=h[i]*SEED+str[i];
	
	REP(i,n){
		int a=sa[i],b=sa[i+1];
		if(a==n||b==n) continue;
		int com=lcp(a,b);
		mxsame[a]=max(mxsame[a],com);
		mxsame[b]=max(mxsame[b],com);
	}
	
	UA.init(n),UB.init(n);
	
	//REP(i,n)cout&lt;&lt;mxsame[i]&lt;&lt;" ";cout&lt;&lt;endl;
	
	REP(i,n){
		int same=mxsame[i];
		int r=i+same;
		//update [i,r] for r-i+1
		//update (r,n) for i
		if(r&lt;n){
			UA.add(i,r,r-i+1);
			if(r+1&lt;=n-1)
				UB.add(r+1,n-1,n-i);
		}
	}
	
	UA.doit();UB.doit();
	
	REP(i,n)
		printf("%d\n",min(UA.a[i],UB.a[i]+i-n+1));
		
	return 0;
}</pre><pre></pre><h2>Problem2956</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
typedef long long int64;
const int MOD=19940417;
int64 bf(int n,int m){
    int64 ans=0;
    REP(i,n)REP(j,m)
        if(i!=j){
            ans+=(n%(i+1))*(m%(j+1));
            ans%=MOD;
        }
    return ans;
}
int64 calc(int64 l,int64 r){
    return (r+l)*(r-l+1)/2%MOD;
}
int64 eval(int n){
    // sum of n%1 + n%2 + ... n%n
    // n^2 - sum n/i*i
    int64 ans=1LL*n*n%MOD;
    for(int i=1;i&lt;=n;++i){
        int d=n/i,r=n/d;
//        cout&lt;&lt;i&lt;&lt;","&lt;&lt;r&lt;&lt;endl;
//        cout&lt;&lt;d*calc(i,r)&lt;&lt;endl;
        ans-=1LL*d*calc(i,r)%MOD;
        ans%=MOD;
        i=r;
    }
    if(ans&lt;0)ans+=MOD;
    return ans;
}
int64 get2(int64 n){
    ++n;
    //n(2*n*n+1-3*n)
    int a=2,b=3;
    int64 L=n,R=2*n*n+1-3*n;
    if(L%a==0)L/=a,a=1;
    if(R%a==0)R/=a,a=1;
    if(L%b==0)L/=b,b=1;
    if(R%b==0)R/=b,b=1;
    L%=MOD,R%=MOD;
    return L*R%MOD;
}
int64 calc2(int64 l,int64 r){
    //sum of l^2 + ... + r^2
    return get2(r)-get2(l-1);
}
int64 eval2(int n,int m){
    //sum of (n%i)*(m%i)
    //sum of (n-n/i*i)*(m-m/i*i)
    //sum of n*m-n*(m/i)*i-m*(n/i)*i+i^2*(n/i)*(m/i)
    if(n&gt;m)swap(n,m);
    //n&lt;=m
    int64 ans=1LL*n*m%MOD*n%MOD;
    for(int i=1;i&lt;=n;++i){
        int64 r=min(n/(n/i),m/(m/i));
        int64 d1=n/i,d2=m/i;
        int64 c1=calc(i,r),c2=calc2(i,r);
        ans+=-1LL*n*d2%MOD*c1%MOD-1LL*m*d1%MOD*c1%MOD+c2*d1%MOD*d2%MOD;
        ans%=MOD;
        i=r;
    }
    if(ans&lt;0)
        ans+=MOD;
    return ans;
}
int64 solve(int n,int m){
    if(n&gt;m)swap(n,m);
    int64 ans=eval(n)*eval(m)%MOD;
    ans-=eval2(n,m);
    ans%=MOD;
    if(ans&lt;0)
        ans+=MOD;
    return ans;
}
int main(){
    int n,m;
    cin&gt;&gt;n&gt;&gt;m;
//    cout&lt;&lt;bf(n,m)&lt;&lt;endl;
    cout&lt;&lt;solve(n,m)&lt;&lt;endl;
//    while(1);
    return 0;
}
</pre><pre></pre><h2>Problem2957</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
using namespace std;
const int MAX_N = int(1e5) + 10;
int n, nQ;
int y[MAX_N];
bool cmp(int a, int b) { //a&lt;b
	if (a == 0)
		return y[b] &gt; 0;
	return 1LL * y[a] * b &lt; 1LL * y[b] * a;
}

struct Tree {
	Tree*pl, *pr;
	int l, r;
	int len, mx;

	void update() {
		len = pl-&gt;len + pr-&gt;calc(pl-&gt;mx);
		mx = cmp(pl-&gt;mx, pr-&gt;mx) ? pr-&gt;mx : pl-&gt;mx;
	}

	Tree(int l, int r) :
			l(l), r(r) {
		if (l + 1 == r) {
			len = 1;
			mx = l;
			return;
		}
		pl = new Tree(l, l + r &gt;&gt; 1);
		pr = new Tree(l + r &gt;&gt; 1, r);
		update();
	}

	int calc(int st) {
		if (l + 1 == r) {
			return cmp(st, l);
		}
		if (cmp(st, pl-&gt;mx))
			return pl-&gt;calc(st) + len - pl-&gt;len;
		else
			return pr-&gt;calc(st);
	}

	void change(int i) {
		if (i &lt; l || i &gt;= r)
			return;
		if (l + 1 == r) {
			return;
		}
		pl-&gt;change(i);
		pr-&gt;change(i);
		update();
	}
}*root;

int main() {
	cin &gt;&gt; n &gt;&gt; nQ;
	root = new Tree(0, n + 1);
	for (int i = 0; i &lt; nQ; ++i) {
		int x, y;
		scanf("%d%d", &amp;x, &amp;y);
		::y[x] = y;
		root-&gt;change(x);
		printf("%d\n", root-&gt;len - 1);
	}
	return 0;
}
</pre><pre></pre><h2>Problem2958</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N=int(1e6)+10;
const int MOD=int(1e9)+7;
//dpi means i..i-K+1 is all B and never happened before :)
int n,K;
char s[MAX_N];
int dp1[MAX_N],dp2[MAX_N];
int addIt(int a,int b){
    a+=b;
    if(a&gt;=MOD)
        a-=MOD;
    return a;
}
int mark[MAX_N]={},cmark=0;
int at[MAX_N];
int&amp;get(int x){
    if(mark[x]!=cmark){
        mark[x]=cmark;
        at[x]=0;
    }
    return at[x];
}
void solve(char seq[],int n,char c,int dp[]){
    //i..i-K+1 is the same and j&lt;i,j..j-K+1 is not the same :)
    //at[i] means lastNot at i-1
    ++cmark;
    get(0)=1;
    int sum=1;
    for(int i=1;i&lt;=n;++i){
        char ch=seq[i-1];
        if(ch==c){
            //move forward :)
        } else if(ch!='X'){
            ++cmark;
            get(i)=sum;
        } else {
            get(i)=sum;
            sum=addIt(sum,sum);
        }
        if(i-K&gt;=0){
            sum=addIt(sum,MOD-get(i-K));
            dp[i-1]=get(i-K);
            get(i-K)=0;
        } else {
            dp[i-1]=0;
        }
    }
}
int work(){
    solve(s,n,'B',dp1);
    reverse(s,s+n);
    solve(s,n,'W',dp2);
    reverse(s,s+n);
    reverse(dp2,dp2+n);
    
    for(int i=1;i&lt;n;++i){
        int t=dp1[i-1];
        if(s[i]=='X')t=addIt(t,t);
        dp1[i]=addIt(dp1[i],t);
    }
    int ans=0;
    for(int i=1;i&lt;n;++i)
        ans=addIt(ans,1LL*dp1[i-1]*dp2[i]%MOD);
    return ans;
}
int main(){
    cin&gt;&gt;n&gt;&gt;K;
    scanf("%s",s);
    cout&lt;&lt;work()&lt;&lt;endl;
//    while(1);
    return 0;
}</pre><pre></pre><h2>Problem2959</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N=150000+10,MAX_M=MAX_N*5;
int nextInt(){
    int a=0;
    char ch;
    while(ch=getchar(),ch&lt;'0'||ch&gt;'9');
    a=ch-'0';
    while(ch=getchar(),ch&gt;='0'&amp;&amp;ch&lt;='9')
        a=a*10+ch-'0';
    return a;
}
//build the MST
struct Edge{
    int t,id;
    Edge(int t,int id):t(t),id(id){}
};
vector&lt;Edge&gt; E[MAX_N];
int n,m;
int have[MAX_N];
struct Oper{
    int p,a,b;
    void read(){
//        scanf("%d%d%d",&amp;p,&amp;a,&amp;b);
        p=nextInt(),a=nextInt(),b=nextInt();
        --a;
        if(p!=2)
            --b;
    }
};
Oper ops[MAX_M];
int FA[MAX_N],tot[MAX_N];
int fd(int x){
    if(FA[x]==x)
        return x;
    return FA[x]=fd(FA[x]);
}
void addEdge(int u,int v,int id){
    E[u].push_back(Edge(v,id));
    E[v].push_back(Edge(u,id)); 
}
int which[MAX_M];
int dep[MAX_N],father[MAX_N];
void dfs(int u,int par,int d){
    dep[u]=d;
    father[u]=par;
    for(vector&lt;Edge&gt;::iterator e=E[u].begin();e!=E[u].end();++e){
        if(e-&gt;t==par)
            continue;
        if(e-&gt;id!=-1)
            which[e-&gt;id]=e-&gt;t;
        dfs(e-&gt;t,u,d+1);
    }
}
int L[MAX_N],R[MAX_N],pt;
const int MAX_LOG=20;
int anc[MAX_N][MAX_LOG];
void dfs(){
    static int stack[MAX_N];
    int top=0;
    stack[top++]=0;
    
    father[0]=-1;dep[0]=0;
    pt=0;
    
    memset(L,-1,sizeof L);
    
    while(top&gt;0){
        int u=stack[top-1];
        if(L[u]==-1){
            L[u]=pt++;
        } else {
            R[u]=pt-1;
            --top;
            continue;
        }
        anc[u][0]=father[u];
        for(int i=1;i&lt;MAX_LOG;++i){
            int p=anc[u][i-1];
            if(p==-1)
                anc[u][i]=-1;
            else
                anc[u][i]=anc[p][i-1];
        }
        for(vector&lt;Edge&gt;::iterator e=E[u].begin();e!=E[u].end();++e){
            if(e-&gt;t==father[u])
                continue;
            if(e-&gt;id!=-1)
                which[e-&gt;id]=e-&gt;t;
            stack[top++]=e-&gt;t;
            father[e-&gt;t]=u;
            dep[e-&gt;t]=dep[u]+1;
        }
    }
}
struct TA{
    int a[MAX_N],n;
    
    void init(int n){
        this-&gt;n=n;
        memset(a,0,sizeof a); 
    }
    
    void add(int p,int x){
        for(p++;p&lt;=n;p+=p&amp;-p)
            a[p-1]+=x;
    }
    
    void add(int l,int r,int x){
        add(l,x);
        add(r+1,-x);
    }
    
    int get(int p){
        int r=0;
        for(p++;p;p-=p&amp;-p)
            r+=a[p-1];
        return r;
    }
}ta,tcant;
bool can[MAX_N];
bool treeE[MAX_M]={};
int getLca(int u,int v){
    if(dep[u]&lt;dep[v])
        swap(u,v);
    int go=dep[u]-dep[v];
    REP(i,MAX_LOG)if(go&gt;&gt;i&amp;1)
        u=anc[u][i];
    if(u==v)
        return u;
    for(int i=MAX_LOG-1;i&gt;=0;--i){
        int nu=anc[u][i],nv=anc[v][i];
        if(nu!=nv){
            u=nu,v=nv;
        }
    }
    return father[u];
}
namespace Small {
    const int MAX_N=150000+10,MAX_M=MAX_N*5;
    //build the MST
    struct Edge{
        int t,id;
        Edge(int t,int id):t(t),id(id){}
    };
    vector&lt;Edge&gt; E[MAX_N];
    int n,m;
    int have[MAX_N];
    
    struct Oper{
        int p,a,b;
        void read(){
            scanf("%d%d%d",&amp;p,&amp;a,&amp;b);
            --a;
            if(p!=2)
                --b;
        }
    };
    
    Oper ops[MAX_M];
    int FA[MAX_N],tot[MAX_N];
    int fd(int x){
        if(FA[x]==x)
            return x;
        return FA[x]=fd(FA[x]);
    }
    
    void addEdge(int u,int v,int id){
        E[u].push_back(Edge(v,id));
        E[v].push_back(Edge(u,id)); 
    }
    
    int which[MAX_M];
    int dep[MAX_N],father[MAX_N];
    void dfs(int u,int par,int d){
        dep[u]=d;
        father[u]=par;
        for(vector&lt;Edge&gt;::iterator e=E[u].begin();e!=E[u].end();++e){
            if(e-&gt;t==par)
                continue;
            if(e-&gt;id!=-1)
                which[e-&gt;id]=e-&gt;t;
            dfs(e-&gt;t,u,d+1);
        }
    }
    
    bool can[MAX_N];
    bool treeE[MAX_M]={};
    int work(int _n,int _m){
    //    freopen("in.cpp","r",stdin);
//        cin&gt;&gt;n&gt;&gt;m;
        n=_n,m=_m;
        REP(i,n)scanf("%d",have+i);
        REP(i,m)
            ops[i].read();
        REP(i,n)FA[i]=i;
        //build MST
        REP(i,m)if(ops[i].p==1){
            int a=ops[i].a,b=ops[i].b;
            int fa=fd(a),fb=fd(b);
            if(fa!=fb){
                addEdge(a,b,i);
                treeE[i]=true;
                FA[fa]=fb;
            }
        }
        //add some other tree-edge if needed :)
        for(int i=1;i&lt;n;++i){
            if(fd(i)!=fd(0)){
                addEdge(i,0,-1);
                FA[fd(i)]=fd(0);
            }
        }
        
        dfs(0,-1,0);
        
        //start :)
        REP(i,n)FA[i]=i,tot[i]=have[i],can[i]=false;
        
        REP(i,m){
            if(ops[i].p==1){
                if(treeE[i]){
                    int w=which[i];
                    can[w]=true;
                } else {
                    int a=ops[i].a,b=ops[i].b;
                    //merge them :)
                    for(;;){
                        a=fd(a);b=fd(b);
                        if(a==b)
                            break;
                        if(dep[a]&lt;dep[b])
                            swap(a,b);
                        //a is deeper :)
                        int f=fd(father[a]);
                        FA[a]=f;
                        tot[f]+=tot[a];
                    }
                }
            } else if(ops[i].p==2){
                int a=ops[i].a,b=ops[i].b;
                int det=b-have[a];
    //            cout&lt;&lt;"HI:"&lt;&lt;det&lt;&lt;endl;
                have[a]=b;
                a=fd(a);
                tot[a]+=det;
            } else {
                int a=ops[i].a,b=ops[i].b;
                int ans=0;
                for(;;){
                    a=fd(a);b=fd(b);
                    if(a==b){
                        ans+=tot[a];
                        break;
                    }
                    if(dep[a]&lt;dep[b])
                        swap(a,b);
                    //a is deeper :)
                    if(!can[a]){
                        ans=-1;
                        break;
                    }
                    ans+=tot[a];
                    a=father[a];
                }
                printf("%d\n",ans);
            }
        }
    //    while(1);
    }
}
int main(){
//    freopen("in.cpp","r",stdin);
//    freopen("large","w",stdout);
    cin&gt;&gt;n&gt;&gt;m;
//    int st=clock();
    if(n&lt;=1000){
        Small::work(n,m);
        return 0;
    }
    REP(i,n)have[i]=nextInt();
    REP(i,m)
        ops[i].read();
    REP(i,n)FA[i]=i;
    //build MST
    REP(i,m)if(ops[i].p==1){
        int a=ops[i].a,b=ops[i].b;
        int fa=fd(a),fb=fd(b);
        if(fa!=fb){
            addEdge(a,b,i);
            treeE[i]=true;
            FA[fa]=fb;
        }
    }
    //add some other tree-edge if needed :)
    for(int i=1;i&lt;n;++i){
        if(fd(i)!=fd(0)){
            addEdge(i,0,-1);
            FA[fd(i)]=fd(0);
        }
    }
    
    dfs();
    ta.init(n);
    tcant.init(n);
    
    REP(i,n){
        FA[i]=i;
        tot[i]=have[i];
        ta.add(L[i],R[i],have[i]);
        tcant.add(L[i],R[i],1);
    }
    
    REP(i,m){
        Oper&amp;op=ops[i];
        if(op.p==1){//add
            if(treeE[i]){
                int a=which[i];
                tcant.add(L[a],R[a],-1);
            } else {
                //merge
                int a=op.a,b=op.b;
                for(;;){
                    a=fd(a);b=fd(b);
                    if(a==b)
                        break;
                    if(dep[a]&lt;dep[b])
                        swap(a,b);
                    //a is deeper
                    //merge a with his father
                    int fa=fd(father[a]);
                    ta.add(L[fa],R[fa],tot[a]);
                    ta.add(L[a],R[a],-tot[a]);
                    FA[a]=fa;
                    tot[fa]+=tot[a];
                }
            }
        } else if(op.p==2){
            int a=op.a,b=op.b;
            int det=b-have[a];
            have[a]=b;
            
            a=fd(a);
            tot[a]+=det;
            ta.add(L[a],R[a],det);
        } else {
            int a=op.a,b=op.b;
            int lca=getLca(a,b);
            //check can
            int ncant=tcant.get(L[a])+tcant.get(L[b])-2*tcant.get(L[lca]);
            if(ncant&gt;0){
                puts("-1");
                continue;
            }
            a=fd(a);b=fd(b);
            lca=fd(lca);
            int ans=ta.get(L[a])+ta.get(L[b])-2*ta.get(L[lca])+tot[lca];
            printf("%d\n",ans);
        }
    }
//    cerr&lt;&lt;clock()-st&lt;&lt;endl;
    return 0;
}</pre><pre></pre><h2>Problem2962</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N=50000+10,MOD=19940417,MAX_C=20+1;
typedef long long int64;
int n,nQ;
int a[MAX_N];
int comb[MAX_N][MAX_C];
void rex(int&amp;x){
    if(x&gt;=MOD)
        x-=MOD;
}
void prepare(){
    REP(i,n+1)REP(j,MAX_C)
        if(!i||!j)
            comb[i][j]=(i&gt;=j?1:0);
        else {
            rex(comb[i][j]=comb[i-1][j]+comb[i-1][j-1]);
        }
}
struct Info{
    int c[MAX_C],n;
    Info() {
        memset(c,0,sizeof c);
        n=0;
    }
    Info(int x,int n):n(n){
        memset(c,0,sizeof c);
        c[0]=1;
        c[1]=x;
    }
    void applyRev(){
        for(int i=1;i&lt;MAX_C;i+=2){
            c[i]=MOD-c[i];
            if(c[i]&gt;=MOD)
                c[i]-=MOD;
        }
    }
    void applyAdd(int x){
        static int pwx[MAX_C];
        pwx[0]=1;
        for(int i=1;i&lt;MAX_C;++i)
            pwx[i]=1LL*pwx[i-1]*x%MOD;
            
        for(int i=MAX_C-1;i&gt;=0;--i){
            int64 t=0;
            for(int j=i;j&gt;=0;--j)
                t+=1LL*c[j]*comb[n-j][i-j]%MOD*pwx[i-j];
            c[i]=t%MOD;
        }
    }
};
const Info EMPTY;
Info operator+(const Info&amp;a,const Info&amp;b){
    if(a.n==0)
        return b;
    if(b.n==0)
        return a;
    Info ret;
    ret.n=a.n+b.n;
    for(int i=0;i&lt;MAX_C;++i){
        int64 t=0;
        for(int j=0;j&lt;=i;++j)
            t+=1LL*a.c[j]*b.c[i-j];
        ret.c[i]=t%MOD;
    }
    return ret;
}
struct Tree{
    int l,r;
    Tree*pl,*pr;
    bool rev;
    int add;
    Info i;
    
    void update(){
        i=pl-&gt;i+pr-&gt;i;
    }
    
    Tree(int l,int r):l(l),r(r) {
        rev=false;add=0;
        if(l+1==r){
            pl=pr=0;
            i=Info(a[l],1);
            return;
        }
        pl=new Tree(l,(l+r)/2);
        pr=new Tree((l+r)/2,r);
        update();
    } 
    
    //rev -&gt; add
    
    void applyRev(){
        rev^=1;
        i.applyRev();
        add=MOD-add;
        rex(add);
    }
    
    void applyAdd(int x){
        add+=x;
        rex(add);
        i.applyAdd(x);
    }
    
    void relax(){
        if(rev){
            rev = 0;
            pl-&gt;applyRev();
            pr-&gt;applyRev();
        }
        if(add!=0){
            pl-&gt;applyAdd(add);
            pr-&gt;applyAdd(add);
            add=0;
        }
    }
    
    void applyRev(int L,int R){
        if(L&gt;=r||l&gt;=R)
            return;
        if(L&lt;=l&amp;&amp;R&gt;=r){
            applyRev();
            return;
        }
        relax();
        pl-&gt;applyRev(L,R);
        pr-&gt;applyRev(L,R);
        update();
    }
    
    void applyAdd(int L,int R,int x){
        if(L&gt;=r||l&gt;=R)
            return;
        if(L&lt;=l&amp;&amp;R&gt;=r){
            applyAdd(x);
            return;
        }
        relax();
        pl-&gt;applyAdd(L,R,x);
        pr-&gt;applyAdd(L,R,x);
        update();
    }
    
    Info get(int L,int R){
        if(L&gt;=r||l&gt;=R)
            return EMPTY;
        if(L&lt;=l&amp;&amp;R&gt;=r){
            return i;
        }
        relax();
        return pl-&gt;get(L,R)+pr-&gt;get(L,R);
    }
}*root;
int main(){
//    freopen("in.cpp","r",stdin);
//    freopen("large","w",stdout);
    cin&gt;&gt;n&gt;&gt;nQ;
    prepare();
    
    REP(i,n) scanf("%d",a+i),a[i]%=MOD;
    
    root=new Tree(0,n);
    
    REP(i,nQ) {
        char cmd;
        scanf(" ");
        scanf("%c",&amp;cmd);
        if(cmd == 'I'){
            int l,r,x;
            scanf("%d%d%d",&amp;l,&amp;r,&amp;x);
            x%=MOD;
            --l;
            root-&gt;applyAdd(l,r,x);
        } else if(cmd == 'R'){
            int l,r;
            scanf("%d%d",&amp;l,&amp;r);
            --l;
            root-&gt;applyRev(l,r);
        } else {
            int l,r,c;
            scanf("%d%d%d",&amp;l,&amp;r,&amp;c);
            --l;
            Info ans=root-&gt;get(l,r);
            printf("%d\n",ans.c[c]);
        }
    }
    
//    while(1);
    
    return 0;
}</pre><pre></pre><h2>Problem2963</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;cassert&gt;
using namespace std;
typedef long long int64;
int64 comb[200][200];

const int MAX[] = { 9, 9, 9, 7 };
int cnt[4][10], n;

int*cur, L, orig[10];

typedef pair&lt;int, int&gt; ipair;

map&lt;int64, vector&lt;ipair&gt; &gt; mp;
map&lt;int64, vector&lt;int&gt; &gt; how;
int64 pw5[10];

bool forbid;

int iter;
void rec(int st, int i, int nP, int nT, int64 code, bool hap = false) {
	if (nP &gt; 1 &amp;&amp; nT &gt; 1)
		return;
	if (nP * 2 + nT * 3 &gt; 14)
		return;
	//end here
	if (hap) {
		iter++;
		mp[code].push_back(make_pair(nP, nT));
		if (!how.count(code)) {
			how[code] = vector&lt;int&gt;(cur, cur + L);
		}
	}
	if (st == 0) {
		rec(1, 0, nP, nT, code);
		if (i == L)
			return;
		//take a pair
		if (cur[i] &gt;= 2) {
			cur[i] -= 2;
			rec(st, i + 1, nP + 1, nT, code + 2 * pw5[i], true);
			cur[i] += 2;
		}
		//next
		rec(st, i + 1, nP, nT, code);
		return;
	}
	if (st == 1) {
		rec(2, 0, nP, nT, code);
		//take three
//		return;
		if (i == L)
			return;
		if (cur[i] &gt;= 3) {
			cur[i] -= 3;
			rec(st, i, nP, nT + 1, code + 3 * pw5[i], true);
			cur[i] += 3;
		}
		rec(st, i + 1, nP, nT, code);
		return;
	}
	if (forbid)
		return;
	if (st == 2) {
		if (i + 2 &gt;= L)
			return;
		//take three consecutive
		bool ok = true;
		for (int j = i; j &lt; i + 3; ++j)
			if (cur[j] == 0) {
				ok = false;
			}
		if (ok) {
			cur[i] -= 1, cur[i + 1] -= 1, cur[i + 2] -= 1;
			rec(st, i, nP, nT + 1, code + pw5[i] + pw5[i + 1] + pw5[i + 2], true);
			cur[i] += 1, cur[i + 1] += 1, cur[i + 2] += 1;
		}
		rec(st, i + 1, nP, nT, code);
	}
}

map&lt;vector&lt;ipair&gt;, int64&gt; am;

bool impossible(ipair a) {
	if (a.first * 2 + a.second * 3 &gt; 14)
		return true;
	if (a.first &gt; 1 &amp;&amp; a.second &gt; 0)
		return true;
	return false;
}

void clean(vector&lt;ipair&gt;&amp;v) {
	int cur = 0;
	for (int i = 0; i &lt; v.size(); ++i) {
		if (impossible(v[i]))
			continue;
		v[cur++] = v[i];
	}
	v.resize(cur);
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(), v.end()), v.end());
}

vector&lt;ipair&gt; merge(vector&lt;ipair&gt; a, vector&lt;ipair&gt; b) {
	vector&lt;ipair&gt; v;
	for (vector&lt;ipair&gt;::iterator it1 = a.begin(); it1 != a.end(); ++it1) {
		for (vector&lt;ipair&gt;::iterator it2 = b.begin(); it2 != b.end(); ++it2) {
			v.push_back(make_pair(it1-&gt;first + it2-&gt;first, it1-&gt;second + it2-&gt;second));
		}
	}
	clean(v);
	return v;
}

bool check(vector&lt;ipair&gt; a) {
	for (vector&lt;ipair&gt;::iterator it = a.begin(); it != a.end(); ++it) {
		if (it-&gt;first == 7 || (it-&gt;first == 1 &amp;&amp; it-&gt;second == 4)) {
//			cout &lt;&lt; it-&gt;first &lt;&lt; " " &lt;&lt; it-&gt;second &lt;&lt; endl;
			return true;
		}
	}
	return false;
}

int64 GSWS() {
	const string cs[] = { "1m", "9m", "1s", "9s", "1p", "9p", "1c", "2c", "3c", "4c", "5c", "6c", "7c" };
	int64 ans = 0;
	for (int i = 0; i &lt; 13; ++i) {
		int64 tmp = 1;
		for (int j = 0; j &lt; 13; ++j) {
			string s = cs[j];
			int t = string("mspc").find(s[1]), k = s[0] - '1';
			if (j == i)
				tmp *= comb[cnt[t][k]][2];
			else
				tmp *= cnt[t][k];
		}
		ans += tmp;
	}
	return ans;
}

map&lt;vector&lt;ipair&gt;, int&gt; id;
vector&lt;vector&lt;ipair&gt; &gt; states;
vector&lt;int&gt; ids[2];
vector&lt;vector&lt;int&gt; &gt; hows[2];
int nId;

int get(vector&lt;ipair&gt; a) {
	if (id.count(a))
		return id[a];
	states.push_back(a);
	int me = id.size();
	return id[a] = me;
}

int nxt[30][30];

void prepare() {
	for (int f = 0; f &lt; 2; ++f) {
		L = f ? 7 : 9;
		forbid = f;
		int t[10];
		fill(t, t + L, 4);
		cur = t;
		mp.clear(), how.clear();
		rec(0, 0, 0, 0, 0, true);
		for (map&lt;int64, vector&lt;ipair&gt; &gt;::iterator it = mp.begin(); it != mp.end(); ++it) {
			clean(it-&gt;second);
			int x = get(it-&gt;second);
			ids[f].push_back(x);
		}

		for (map&lt;int64, vector&lt;int&gt; &gt;::iterator it = how.begin(); it != how.end(); ++it) {
			hows[f].push_back(it-&gt;second);
		}
	}

	for (int i = 0; i &lt; states.size(); ++i) {
		for (int j = 0; j &lt; states.size(); ++j) {
			nxt[i][j] = get(merge(states[i], states[j]));
		}
	}
}

void work() {
	cin &gt;&gt; n;
	memset(cnt, 0, sizeof cnt);
	for (int i = 0; i &lt; n; ++i) {
		string s;
		cin &gt;&gt; s;
		int t = string("mspc").find(s[1]), k = s[0] - '1';
//		cout &lt;&lt; t &lt;&lt; " " &lt;&lt; k &lt;&lt; endl;
		cnt[t][k]++;
	}

	vector&lt;ipair&gt; st;
	st.push_back(make_pair(0, 0));
	int64 am[30] = { };
	am[get(st)] = 1;

	for (int i = 0; i &lt; 4; ++i) {
		forbid = i == 3;
		cur = cnt[i];
		L = MAX[i];

		iter = 0;
		int64 cnt[30] = { };

		for (int i = 0; i &lt; ids[forbid].size(); ++i) {
			int64 t = 1;
			vector&lt;int&gt;&amp;h = hows[forbid][i];
			for (int j = 0; j &lt; L; ++j) {
				t *= comb[cur[j]][4 - h[j]];
				if (!t)
					break;
			}
			cnt[ids[forbid][i]] += t;
		}

		int64 nam[30] = { };

		for (int i = 0; i &lt; states.size(); ++i) {
			for (int j = 0; j &lt; states.size(); ++j) {
				nam[nxt[i][j]] += am[i] * cnt[j];
			}
		}

		memcpy(am, nam, sizeof am);
	}

	int64 ans = 0;
	for (int i = 0; i &lt; states.size(); ++i) {
		if (check(states[i]))
			ans += am[i];
	}

	ans += GSWS();
	int64 tot = comb[n][14];
//	cout &lt;&lt; tot &lt;&lt; endl;
	int64 g = __gcd(ans, tot);
	ans /= g, tot /= g;
	cout &lt;&lt; ans &lt;&lt; "/" &lt;&lt; tot &lt;&lt; endl;
}

int main() {
//	freopen("in", "r", stdin);
	for (int i = 0; i &lt; 200; ++i) {
		for (int j = 0; j &lt;= i; ++j) {
			comb[i][j] = (!i || !j) ? 1 : comb[i - 1][j] + comb[i - 1][j - 1];
		}
	}
	pw5[0] = 1;
	for (int i = 1; i &lt; 10; ++i) {
		pw5[i] = pw5[i - 1] * 5;
	}
	prepare();
	int T;
	cin &gt;&gt; T;
	for (int i = 0; i &lt; T; ++i) {
		work();
	}
	return 0;
}
</pre><pre></pre><h2>Problem2963</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;climits&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;cassert&gt;
using namespace std;
typedef long long int64;
int64 comb[200][200];

const int MAX[] = { 9, 9, 9, 7 };
int cnt[4][10], n;

int*cur, L, orig[10];

typedef pair&lt;int, int&gt; ipair;

//map&lt;int64, vector&lt;ipair&gt; &gt; mp;
pair&lt;int64, ipair&gt; all[1000000];
int nAll = 0;
int64 pw5[10];

bool forbid;

int iter;
void rec(int st, int i, int nP, int nT, int64 code, bool hap = false) {
	if (nP &gt; 1 &amp;&amp; nT &gt; 1)
		return;
	if (nP * 2 + nT * 3 &gt; 14)
		return;
	//end here
	if (hap) {
//		cout &lt;&lt; nAll &lt;&lt; endl;
		all[nAll++] = make_pair(code, make_pair(nP, nT));
	}
	if (st == 0) {
		rec(1, 0, nP, nT, code);
		if (i == L)
			return;
		//take a pair
		if (cur[i] &gt;= 2) {
			cur[i] -= 2;
			rec(st, i + 1, nP + 1, nT, code + 2 * pw5[i], true);
			cur[i] += 2;
		}
		//next
		rec(st, i + 1, nP, nT, code);
		return;
	}
	if (st == 1) {
		rec(2, 0, nP, nT, code);
		//take three
//		return;
		if (i == L)
			return;
		if (cur[i] &gt;= 3) {
			cur[i] -= 3;
			rec(st, i, nP, nT + 1, code + 3 * pw5[i], true);
			cur[i] += 3;
		}
		rec(st, i + 1, nP, nT, code);
		return;
	}
	if (forbid)
		return;
	if (st == 2) {
		if (i + 2 &gt;= L)
			return;
		//take three consecutive
		bool ok = true;
		for (int j = i; j &lt; i + 3; ++j)
			if (cur[j] == 0) {
				ok = false;
			}
		if (ok) {
			cur[i] -= 1, cur[i + 1] -= 1, cur[i + 2] -= 1;
			rec(st, i, nP, nT + 1, code + pw5[i] + pw5[i + 1] + pw5[i + 2], true);
			cur[i] += 1, cur[i + 1] += 1, cur[i + 2] += 1;
		}
		rec(st, i + 1, nP, nT, code);
	}
}

map&lt;vector&lt;ipair&gt;, int64&gt; am;

bool impossible(ipair a) {
	if (a.first * 2 + a.second * 3 &gt; 14)
		return true;
	if (a.first &gt; 1 &amp;&amp; a.second &gt; 0)
		return true;
	return false;
}

void clean(vector&lt;ipair&gt;&amp;v) {
	int cur = 0;
	for (int i = 0; i &lt; v.size(); ++i) {
		if (impossible(v[i]))
			continue;
		v[cur++] = v[i];
	}
	v.resize(cur);
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(), v.end()), v.end());
}

vector&lt;ipair&gt; merge(vector&lt;ipair&gt; a, vector&lt;ipair&gt; b) {
	vector&lt;ipair&gt; v;
	for (vector&lt;ipair&gt;::iterator it1 = a.begin(); it1 != a.end(); ++it1) {
		for (vector&lt;ipair&gt;::iterator it2 = b.begin(); it2 != b.end(); ++it2) {
			v.push_back(make_pair(it1-&gt;first + it2-&gt;first, it1-&gt;second + it2-&gt;second));
		}
	}
	clean(v);
	return v;
}

bool check(vector&lt;ipair&gt; a) {
	for (vector&lt;ipair&gt;::iterator it = a.begin(); it != a.end(); ++it) {
		if (it-&gt;first == 7 || (it-&gt;first == 1 &amp;&amp; it-&gt;second == 4)) {
//			cout &lt;&lt; it-&gt;first &lt;&lt; " " &lt;&lt; it-&gt;second &lt;&lt; endl;
			return true;
		}
	}
	return false;
}

int64 GSWS() {
	const string cs[] = { "1m", "9m", "1s", "9s", "1p", "9p", "1c", "2c", "3c", "4c", "5c", "6c", "7c" };
	int64 ans = 0;
	for (int i = 0; i &lt; 13; ++i) {
		int64 tmp = 1;
		for (int j = 0; j &lt; 13; ++j) {
			string s = cs[j];
			int t = string("mspc").find(s[1]), k = s[0] - '1';
			if (j == i)
				tmp *= comb[cnt[t][k]][2];
			else
				tmp *= cnt[t][k];
		}
		ans += tmp;
	}
	return ans;
}

map&lt;vector&lt;ipair&gt;, int&gt; id;
vector&lt;vector&lt;ipair&gt; &gt; states;
vector&lt;int&gt; ids[2];
vector&lt;vector&lt;int&gt; &gt; hows[2];
int nId;

int get(vector&lt;ipair&gt; a) {
	if (id.count(a))
		return id[a];
	states.push_back(a);
	int me = id.size();
	return id[a] = me;
}

int nxt[30][30];

void prepare() {
	for (int f = 0; f &lt; 2; ++f) {
		L = f ? 7 : 9;
		forbid = f;
		int t[10];
		fill(t, t + L, 4);
		cur = t;
		nAll = 0;
		rec(0, 0, 0, 0, 0, true);
		sort(all, all + nAll);
		for (int i = 0, j; i &lt; nAll;) {
			for (j = i; j &lt; nAll &amp;&amp; all[j].first == all[i].first; ++j)
				;
			vector&lt;ipair&gt; v;
			for (int k = i; k &lt; j; ++k) {
				v.push_back(all[k].second);
			}
			clean(v);
			int x = get(v);
			ids[f].push_back(x);
			int cur[10];
			int64 c = all[i].first;
			for (int k = 0; k &lt; L; ++k) {
				cur[k] = c % 5;
				c /= 5;
			}
			hows[f].push_back(vector&lt;int&gt;(cur, cur + L));
			i = j;
		}
//		cout &lt;&lt; ids[f].size() &lt;&lt; endl;
	}

	for (int i = 0; i &lt; states.size(); ++i) {
		for (int j = 0; j &lt; states.size(); ++j) {
			nxt[i][j] = get(merge(states[i], states[j]));
		}
	}
}

void work() {
	cin &gt;&gt; n;
	memset(cnt, 0, sizeof cnt);
	for (int i = 0; i &lt; n; ++i) {
		string s;
		cin &gt;&gt; s;
		int t = string("mspc").find(s[1]), k = s[0] - '1';
//		cout &lt;&lt; t &lt;&lt; " " &lt;&lt; k &lt;&lt; endl;
		cnt[t][k]++;
	}

	vector&lt;ipair&gt; st;
	st.push_back(make_pair(0, 0));
	int64 am[30] = { };
	am[get(st)] = 1;

	for (int i = 0; i &lt; 4; ++i) {
		forbid = i == 3;
		cur = cnt[i];
		L = MAX[i];

		iter = 0;
		int64 cnt[30] = { };

		for (int i = 0; i &lt; ids[forbid].size(); ++i) {
			int64 t = 1;
			vector&lt;int&gt;&amp;h = hows[forbid][i];
			for (int j = 0; j &lt; L; ++j) {
				t *= comb[cur[j]][h[j]];
				if (!t)
					break;
			}
//			cout &lt;&lt; t &lt;&lt; endl;
			cnt[ids[forbid][i]] += t;
		}

		int64 nam[30] = { };

		for (int i = 0; i &lt; states.size(); ++i) {
			for (int j = 0; j &lt; states.size(); ++j) {
				nam[nxt[i][j]] += am[i] * cnt[j];
			}
		}

		memcpy(am, nam, sizeof am);
	}

	int64 ans = 0;
	for (int i = 0; i &lt; states.size(); ++i) {
		if (check(states[i]))
			ans += am[i];
	}

	ans += GSWS();
	int64 tot = comb[n][14];
//	cout &lt;&lt; tot &lt;&lt; endl;
	int64 g = __gcd(ans, tot);
	ans /= g, tot /= g;
	cout &lt;&lt; ans &lt;&lt; "/" &lt;&lt; tot &lt;&lt; endl;
}

int main() {
//	freopen("in", "r", stdin);
	for (int i = 0; i &lt; 200; ++i) {
		for (int j = 0; j &lt;= i; ++j) {
			comb[i][j] = (!i || !j) ? 1 : comb[i - 1][j] + comb[i - 1][j - 1];
		}
	}
	pw5[0] = 1;
	for (int i = 1; i &lt; 10; ++i) {
		pw5[i] = pw5[i - 1] * 5;
	}
	prepare();
	int T;
	cin &gt;&gt; T;
	for (int i = 0; i &lt; T; ++i) {
		work();
	}
	return 0;
}
</pre><pre></pre><h2>Problem2964</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N=1000+10;
int n,M,HP,MP,SP,DHP,DMP,DSP,X;
int a[MAX_N];
int N1,B[MAX_N],Y[MAX_N];//magic
int N2,C[MAX_N],Z[MAX_N];//angry 
int dp[MAX_N][MAX_N];//day,hp,max of free day :) -1 means dead :(
//orz ChaoGe GFS WNM
void cmax(int&amp;x,int c){
    if(c&gt;x)x=c;
} 
int dp2[MAX_N][MAX_N];//day,mp
int dp3[MAX_N][MAX_N];//day,sp
int mx2[MAX_N],mx3[MAX_N],mx[MAX_N];
void work(){
    cin&gt;&gt;n&gt;&gt;M&gt;&gt;HP&gt;&gt;MP&gt;&gt;SP&gt;&gt;DHP&gt;&gt;DMP&gt;&gt;DSP&gt;&gt;X;
    REP(i,n) cin&gt;&gt;a[i];
    cin&gt;&gt;N1;REP(i,N1) cin&gt;&gt;B[i]&gt;&gt;Y[i];
    cin&gt;&gt;N2;REP(i,N2) cin&gt;&gt;C[i]&gt;&gt;Z[i];
    
    memset(dp,-1,sizeof dp);
    dp[0][HP]=0;
    REP(i,n)
        REP(hp,HP+1){
            int c=dp[i][hp];
            if(c==-1)
                continue;
//            cout&lt;&lt;i&lt;&lt;" "&lt;&lt;hp&lt;&lt;" "&lt;&lt;c&lt;&lt;endl;
            //at start of i round
            //before get attack by a[i-1]
            int nhp=hp;
            if(i&gt;0)
                nhp-=a[i-1];
            if(nhp&lt;=0)//dead
                continue;
            //heal
            cmax(dp[i+1][min(nhp+DHP,HP)],c);
            //papapa
            cmax(dp[i+1][nhp],c+1);
        }
    
    memset(dp2,-1,sizeof dp2);
    dp2[0][MP]=0;
    REP(i,n)
        REP(j,MP+1){
            int c=dp2[i][j];
            if(c==-1)
                continue;
            //attack
            REP(k,N1)if(j&gt;=B[k])
                cmax(dp2[i+1][j-B[k]],c+Y[k]);
            //papapa
            cmax(dp2[i+1][min(j+DMP,MP)],c);
        } 
    
    memset(dp3,-1,sizeof dp3);
    dp3[0][SP]=0;
    
    REP(i,n)
        REP(j,SP+1){
            int c=dp3[i][j];
            if(c==-1)
                continue;
            //attack
            REP(k,N2)if(j&gt;=C[k])
                cmax(dp3[i+1][j-C[k]],c+Z[k]);
            //papapa
            cmax(dp3[i+1][min(j+DSP,SP)],c+X);
        } 
    
    memset(mx2,-1,sizeof mx2);
    memset(mx3,-1,sizeof mx3);
    
    REP(i,n+1)REP(j,MP+1) cmax(mx2[i],dp2[i][j]);
    REP(i,n+1)REP(j,SP+1) cmax(mx3[i],dp3[i][j]);
    
    memset(mx,-1,sizeof mx);
    
    REP(i,n+1)REP(j,i+1)cmax(mx[i],mx2[j]+mx3[i-j]);
    
    REP(it,n+1){
        //beat it at start of round it
        int mxF=-1;
        REP(j,HP+1){
            cmax(mxF,dp[it][j]);
        }
        
        if(mxF==-1)
            continue;
        
//        cout&lt;&lt;it&lt;&lt;" "&lt;&lt;mxF&lt;&lt;endl;
        
        if(mx[mxF]&gt;=M){
            cout&lt;&lt;"Yes "&lt;&lt;it&lt;&lt;endl;
            return;
        }
    }
    
    bool survive=false;
    
    REP(i,HP+1)if(dp[n][i]!=-1&amp;&amp;i&gt;=a[n-1])
        survive=true;
    
    if(survive)
        puts("Tie");
    else
        puts("No");
}
int main(){
//    freopen("in.cpp","r",stdin);
    int T;
    cin&gt;&gt;T;
    REP(i,T)
        work();
//    while(1);
}</pre><pre></pre><h2>Problem2965</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
using namespace std;
const int MAX_N=100+10,MAX_P=10,INF=~0U&gt;&gt;2;
typedef long long int64;
struct P{
    int64 x,y;
    P(int64 x,int64 y):x(x),y(y){}
    P(){}
    P operator+(P o){return P(x+o.x,y+o.y);}
    P operator-(P o){return P(x-o.x,y-o.y);}
    int64 operator^(P o){return x*o.y-y*o.x;}
};
inline int64 cross(P p1,P p2,P p3){
    return (p2-p1)^(p3-p1);
}
int p,n,m;
P ps[MAX_N],vs[MAX_N];
struct Edge{
    int t,c,mask;
    Edge*nxt;
    Edge(int t,int c,Edge*nxt):t(t),c(c),nxt(nxt){}
};
Edge*es[MAX_N];
void addEdge(int u,int v,int w){
    es[u]=new Edge(v,w,es[u]);
    es[v]=new Edge(u,w,es[v]);
}
void readInput(){
    cin&gt;&gt;p&gt;&gt;n&gt;&gt;m;
    REP(i,p)cin&gt;&gt;ps[i].x&gt;&gt;ps[i].y;
    REP(i,n)cin&gt;&gt;vs[i].x&gt;&gt;vs[i].y;
    REP(i,n)es[i]=0;
    REP(i,m){
        int u,v,w;
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        --u,--v;
        addEdge(u,v,w);
    }
}
int dp[1&lt;&lt;MAX_P];
bool check(P p1,P p2,P q){
    if(p1.x&gt;p2.x)swap(p1,p2);
    //[l,r)
    if(q.x&lt;p1.x||q.x&gt;=p2.x)
        return false;
    return cross(p1,p2,q)&gt;0;
}
int dist[MAX_N][1&lt;&lt;MAX_P];
bool used[MAX_N][1&lt;&lt;MAX_P];
inline void cmin(int&amp;x,int c){
    if(c&lt;x)x=c;
}
//we assume u is the smallest-indexed vertex in the cycle :)
void dijkstra(int u){
    int SMALL=u;
    
    fill(dist[0],dist[n],INF);
    memset(used,0,sizeof used);
    
    dist[u][0]=0;
    
    priority_queue&lt;pair&lt;int,int&gt; &gt; que;
    que.push(make_pair(-dist[u][0],(u&lt;&lt;p)+0));
    
    while(!que.empty()) {
        int key=que.top().second;
        que.pop();
        int u=(key&gt;&gt;p),msk=key&amp;((1&lt;&lt;p)-1);
        if(used[u][msk])
            continue;
        int c=dist[u][msk];
        used[u][msk]=true;
        for(Edge*e=es[u];e;e=e-&gt;nxt){
            int v=e-&gt;t,nmsk=msk^e-&gt;mask;
            if(v&gt;=SMALL){
                int nc=c+e-&gt;c;
                if(nc &lt; dist[v][nmsk]){
                    dist[v][nmsk] = nc;
                    que.push(make_pair(-nc,(v&lt;&lt;p)+nmsk));
                }
            }
        }
    }
    
    REP(i,(1&lt;&lt;p))
        cmin(dp[i],dist[u][i]);
}
void work(){
    //build graph
    REP(i,n){
        for(Edge*e=es[i];e;e=e-&gt;nxt){
            int j=e-&gt;t;
            int mask=0;
            REP(k,p) {
                if(check(vs[i],vs[j],ps[k]))
                    mask|=1&lt;&lt;k;
            }
            e-&gt;mask=mask;
        }
    }
    
    fill(dp,dp+(1&lt;&lt;p),INF);
    dp[0]=0;
    REP(i,n) dijkstra(i);
    
    REP(i,(1&lt;&lt;p))
        for(int j=i;j&gt;0;(--j)&amp;=i)
            cmin(dp[i],dp[j]+dp[i^j]);
    
    int ans[20];
    REP(i,p+1)ans[i]=INF;
    REP(i,(1&lt;&lt;p)){
        int c=0;
        REP(j,p)if(i&gt;&gt;j&amp;1)++c;
        cmin(ans[c],dp[i]);
    }        
    
    for(int i=p;i&gt;0;--i)
        cmin(ans[i-1],ans[i]);
    
    REP(i,p) printf("%d\n",ans[i+1]);
}
void solve(){
    readInput();
    work();
}
int main(){
//    int start=clock();
//    freopen("in.cpp","r",stdin);
    solve();
//    cout&lt;&lt;clock()-start&lt;&lt;endl;
//    while(1);
    return 0;
}
</pre><pre></pre><h2>Problem3051</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#define REP(i,n) for(int i=0;i&lt;n;++i)
#define CLR(x,c) memset(x,c,sizeof x)
#define SHOW_MEMORY(x) cout&lt;&lt;sizeof(x)/(1024*1024.0)&lt;&lt;"MB"

//todo : brute force check
using namespace std;

void setIO(string a){
	string in=a+".in",out=a+".out";
	freopen(in.c_str(),"r",stdin);
	freopen(out.c_str(),"w",stdout);
}

const int MAX_N=int(1e5)+10;

const int MAX_F=MAX_N*3;

typedef long long int64;

struct P{
	int x,y;
	P(int x=0,int y=0):x(x),y(y){}
	P operator+(P o){return P(x+o.x,y+o.y);}
	P operator-(P o){return P(x-o.x,y-o.y);}
	int64 operator*(P o){return 1LL*x*o.x+1LL*y*o.y;}
	int64 operator^(P o){return 1LL*x*o.y-1LL*y*o.x;}
	double al(){return atan2(y,x);}
	double abs(){return hypot(x,y);}
	void read(){scanf("%d%d",&amp;x,&amp;y);x*=2,y*=2;} //*2
	bool operator==(const P&amp;o)const{
		return x==o.x&amp;&amp;y==o.y;
	}
};

//replace alpha with det if posssible :)

int sign(int64 x){
	return x&lt;0?-1:x&gt;0;
}

int64 cross(P p1,P p2,P p3){return (p2-p1)^(p3-p1);}

int crossOp(P p1,P p2,P p3){return sign(cross(p1,p2,p3));}

int n,m,nQ;
P ps[MAX_N];

struct Edge;

vector&lt;Edge*&gt; allE;

struct Edge{
	Edge*rev,*nxt,*pre;
	double alpha;
	int sta,tar;
	int cst;
	
	int id;
	
	Edge(int sta,int tar,int cst):sta(sta),tar(tar),cst(cst),id(-1){
		alpha=(ps[tar]-ps[sta]).al();
		allE.push_back(this);
	}
};

vector&lt;Edge*&gt; es[MAX_N];

Edge* makeEdge(int u,int v,int c){
	Edge*e=new Edge(u,v,c);
	es[u].push_back(e);
	return e;
}

void addEdge(int u,int v,int c){
	Edge*uv=makeEdge(u,v,c);
	Edge*vu=makeEdge(v,u,c);
	uv-&gt;rev=vu,vu-&gt;rev=uv;
}

void readInput(){
	cin&gt;&gt;n&gt;&gt;m;
	REP(i,n){
		ps[i].read();
	}
	REP(i,m){
		int u,v,c;
		scanf("%d%d%d",&amp;u,&amp;v,&amp;c);
		--u,--v;
		addEdge(u,v,c);
	}
}

bool cmp(Edge*a,Edge*b){
	return a-&gt;alpha&lt;b-&gt;alpha;
}

int nId;

int forbid;

void buildGraph(){
	//sort 
	REP(i,n){
		vector&lt;Edge*&gt;&amp;arr=es[i];
		if(arr.empty())
			continue;
		sort(arr.begin(),arr.end(),cmp);
		REP(j,arr.size()){
			Edge*nxt;
			if(j+1&lt;arr.size())
				nxt=arr[j+1];
			else
				nxt=arr[0];
			arr[j]-&gt;nxt=nxt;
			nxt-&gt;pre=arr[j];
		}
	}
	
	//build
	
	nId=0;
	REP(it,allE.size()){
		Edge*e=allE[it];
		if(e-&gt;id!=-1)
			continue;
			
		int64 area=0;	
			
		while(e-&gt;id==-1){
			area+=ps[e-&gt;sta]^ps[e-&gt;tar];
			e-&gt;id=nId;
			e=e-&gt;rev-&gt;pre;
		}
		
		if(area&lt;0){
			forbid=nId;
		}
		
		nId++;		
	}
	
	//build MST
}

struct WEdge{
	int u,v,c;
	WEdge(int u,int v,int c):u(u),v(v),c(c){}
	bool operator&lt;(const WEdge&amp;o)const{
		return c&lt;o.c;
	}
};

vector&lt;WEdge&gt; wes;

struct UF{
	int fa[MAX_F];
	void init(int n){
		REP(i,n)
			fa[i]=i;
	}
	
	int find(int i){
		return fa[i]==i?i:fa[i]=find(fa[i]);
	}
	
	bool unite(int a,int b){
		a=find(a),b=find(b);
		fa[a]=b;
		return a!=b;
	}
}uf;

struct Tree{
	static const int MAX_N=MAX_F,MAX_LOG=20;
	
	struct Edge{
		int t,c;
		Edge(int t,int c):t(t),c(c){}
	};
	
	vector&lt;Edge&gt; E[MAX_N];

	void addEdge(int u,int v,int c){
		E[u].push_back(Edge(v,c));
		E[v].push_back(Edge(u,c));			
	}
	
	int anc[MAX_N][MAX_LOG];
	
	int mx[MAX_N][MAX_LOG];
	
	int dep[MAX_N];
	
	int n;
	
	void init(int n){
		this-&gt;n=n;
	}
	
	void preprocess(int rt){
		queue&lt;int&gt; que;
		
		que.push(rt);
		CLR(anc[rt],-1);
		CLR(mx[rt],-1);
		dep[rt]=0;
		
		while(!que.empty()){
			int u=que.front();que.pop();
			for(vector&lt;Edge&gt;::iterator e=E[u].begin();e!=E[u].end();++e){
				if(e-&gt;t==anc[u][0])
					continue;
				int v=e-&gt;t;
				
				dep[v]=dep[u]+1;
				anc[v][0]=u;
				mx[v][0]=e-&gt;c;
				
				for(int i=0;i+1&lt;MAX_LOG;++i){
					int go=anc[v][i];
					if(go==-1)
						anc[v][i+1]=-1,mx[v][i+1]=-1;
					else {
						anc[v][i+1]=anc[go][i];
						mx[v][i+1]=max(mx[v][i],mx[go][i]);
					}
				}
				que.push(v);
			}
		}
		
		
	}
	
	int query(int u,int v){
		int ans=-1;
		
		//make dep[u]&gt;dep[v]
		if(dep[u]&lt;dep[v])
			swap(u,v);
		
		int need=dep[u]-dep[v];
		REP(i,MAX_LOG)
			if(need&gt;&gt;i&amp;1)
				ans=max(ans,mx[u][i]),u=anc[u][i];
		
		if(u==v)
			return ans;
		
		for(int i=MAX_LOG-1;i&gt;=0;--i){
			if(anc[u][i]!=anc[v][i]){
				ans=max(ans,mx[u][i]);
				u=anc[u][i];
				
				ans=max(ans,mx[v][i]);
				v=anc[v][i];
			}
		}
		
		ans=max(ans,mx[u][0]);
		ans=max(ans,mx[v][0]);
		
		return ans;
	}
};

Tree tree;

void buildMST(){
	REP(it,allE.size()){
		Edge*e=allE[it];
		int u=e-&gt;id,v=e-&gt;rev-&gt;id;
		if(u==forbid||v==forbid)
			continue;
		wes.push_back(WEdge(u,v,e-&gt;cst));
	}
	
	sort(wes.begin(),wes.end());
	
	uf.init(nId);
	
	tree.init(nId);
	
	REP(it,wes.size()){
		WEdge&amp;e=wes[it];
		if(uf.unite(e.u,e.v)){
			//cerr&lt;&lt;e.u&lt;&lt;" "&lt;&lt;e.v&lt;&lt;" "&lt;&lt;e.c&lt;&lt;endl;
			tree.addEdge(e.u,e.v,e.c);
		}
	}
	
	int rt=0;
	if(forbid==0)
		rt=1;
	
	tree.preprocess(rt);
}

const int ADD=0,QRY=1,DEL=2;

struct Event{
	int type;
	int x;
	Edge*e;//for add/del edge
	int y;//for query
	int*ptr;
	
	//query
	Event(int x,int y,int*ptr):x(x),y(y),type(QRY),ptr(ptr){}
	//add/del
	Event(int x,Edge*e,int type):x(x),e(e),type(type){}
};

bool operator&lt;(const Event&amp;a,const Event&amp;b){
	if(a.x!=b.x)
		return a.x&lt;b.x;
	//add-&gt;query-&gt;delete
	return a.type&lt;b.type;
}

vector&lt;Event&gt; events;

const int PT=0,EG=1;

struct Stuff{
	int type;
	P p1,p2;
	int id;
	
	Stuff(P p):p1(p),type(PT){}
	
	Stuff(P p1,P p2):p1(p1),p2(p2),type(EG){}
};

//whether a is upper than b

bool checkIt(P p1,P p2,P q){
	return q.x&gt;=p1.x&amp;&amp;q.x&lt;=p2.x;
}

bool check(P p1,P p2,P q1,P q2){
	if(p2==q1){
		return true;
	}
	if(q2==p1){
		return false;
	}
	
	if(checkIt(p1,p2,q1)){
		int op=crossOp(p1,p2,q1);
		if(op!=0)
			return op&lt;0;
	}
	
	if(checkIt(p1,p2,q2)){
		int op=crossOp(p1,p2,q2);
		if(op!=0)
			return op&lt;0;
	}
	
	if(checkIt(q1,q2,p1)){
		int op=crossOp(q1,q2,p1);
		if(op!=0)
			return op&gt;0;
	}
	
	if(checkIt(q1,q2,p2)){
		int op=crossOp(q1,q2,p2);
		if(op!=0)
			return op&gt;0;
	}
	
	return false;
}

bool operator&lt;(const Stuff&amp;a,const Stuff&amp;b){
	if(a.type==PT&amp;&amp;b.type==EG)
		return crossOp(b.p1,b.p2,a.p1)&gt;0;
		
	if(a.type==EG&amp;&amp;b.type==PT)
		return !(b&lt;a);
		
	if(a.type==EG&amp;&amp;b.type==EG){
		//if they only share a point , the righter one is smaller
		return check(a.p1,a.p2,b.p1,b.p2);
	}
}

struct Query{
	P p1,p2;
	int u,v;
	
	void rd(P&amp;p){
		double x,y;
		scanf("%lf%lf",&amp;x,&amp;y);
		p.x=x*2+0.1;p.y=y*2+0.1;
	}
	
	void read(){
		rd(p1),rd(p2);
	}
};

Query qs[MAX_N];

void lineSweep(){
	//find every point's location
	
	//read queries
	
	cin&gt;&gt;nQ;
	
	REP(i,nQ){
		qs[i].read();
	}
	
	//make Events
	REP(it,allE.size()){
		Edge*e=allE[it];
		P p1=ps[e-&gt;sta],p2=ps[e-&gt;tar];
		
		if(p1.x&lt;p2.x){
			//add Edge
			events.push_back(Event(p1.x,e,ADD));
			events.push_back(Event(p2.x,e,DEL));
		}
	}
	
	REP(i,nQ){
		Query&amp;q=qs[i];
		events.push_back(Event(q.p1.x,q.p1.y,&amp;q.u));
		events.push_back(Event(q.p2.x,q.p2.y,&amp;q.v));
	}
	
	sort(events.begin(),events.end());
	
	set&lt;Stuff&gt; stf;
	
	REP(it,events.size()){
		Event&amp;e=events[it];
		//cerr&lt;&lt;e.x&lt;&lt;endl;
		if(e.type==ADD){
			Edge*ep=e.e;
			Stuff st(ps[ep-&gt;sta],ps[ep-&gt;tar]);
			
			st.id=ep-&gt;id;
			stf.insert(st);
		} else if(e.type==DEL){
			Edge*ep=e.e;
			Stuff st(ps[ep-&gt;sta],ps[ep-&gt;tar]);
			
			st.id=ep-&gt;id;
			//cerr&lt;&lt;stf.size()&lt;&lt;"-&gt;";
			stf.erase(st);
			//cerr&lt;&lt;stf.size()&lt;&lt;endl;
		} else {
			//find the first one who &gt; this :)
			Stuff st(P(e.x,e.y));
			set&lt;Stuff&gt;::iterator it=stf.lower_bound(st);
			if(it==stf.end()){
				*e.ptr=forbid;
			} else {
				*e.ptr=it-&gt;id;
			}
		}
	}
}

void answerQueries(){
	REP(i,nQ){
		Query&amp;q=qs[i];
		//cout&lt;&lt;q.u&lt;&lt;" "&lt;&lt;q.v&lt;&lt;endl;
		if(q.u==forbid||q.v==forbid){
			puts("-1");
			continue;
		}
		if(q.u==q.v){
			puts("0");
			continue;
		}
		printf("%d\n",tree.query(q.u,q.v));
	}
}

void work(){
	buildGraph();
	buildMST();
	lineSweep();
	answerQueries();
}

int main(){	
	//setIO("graph");
	readInput();
	work();
	return 0;
}
</pre><pre></pre><h2>Problem3052</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;
int n, m, nQ;
const int MAX_N = int(1e5) + 10;
const int MAX_CBRT = 50;
typedef long long int64;
int V[MAX_N], W[MAX_N], C[MAX_N];
vector&lt;int&gt; E[MAX_N];

int blockSize;

int fa[MAX_N];
int idx[MAX_N], pt = 0;

void dfs() {
	//random shuffle the edge list

	for (int i = 0; i &lt; n; ++i) {
		random_shuffle(E[i].begin(), E[i].end());
	}

	static int stack[MAX_N];
	int top = 0;
	fa[0] = -1;
	stack[top++] = 0;

	while (top &gt; 0) {
		int u = stack[--top];
		idx[u] = pt++;

		for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
			if (*e != fa[u])
				stack[top++] = *e, fa[*e] = u;
		}
	}
}

struct Query {
	int when, u, v;
	int id;

	Query(int when, int u, int v, int id) :
			when(when), u(u), v(v), id(id) {
	}

	void set(int a[]) const {
		int x[] = { when / blockSize, idx[u] / blockSize, idx[v], id };
		memcpy(a, x, sizeof x);
	}

	bool operator&lt;(const Query&amp;o) const {
		int a[4], b[4];
		set(a), o.set(b);
		return lexicographical_compare(a, a + 4, b, b + 4);
	}

};

int curT;

int at[MAX_N], newC[MAX_N], oldC[MAX_N];

vector&lt;Query&gt; queries;

struct LCT {
	int fa[MAX_N];

	void init() {
		memcpy(fa, ::fa, sizeof fa);
	}

	void make(int u) {
		if (fa[u] == -1)
			return;
		int f = fa[u];
		make(f);
		fa[f] = u;
	}

	void makeRoot(int u) {
		make(u);
		fa[u] = -1;
	}
} LU, LV;

int64 ans;
int cnt[MAX_N];

inline void addC(int c) {
	int x = cnt[c]++;
	ans += 1LL * W[x] * V[c];
}

inline void delC(int c) {
	int x = --cnt[c];
	ans -= 1LL * W[x] * V[c];
}

int t, u, v;
bool mark[MAX_N];

inline void addV(int u) {
	mark[u] = true;
	addC(C[u]);
}

inline void delV(int u) {
	mark[u] = false;
	delC(C[u]);
}

inline void change(int u, int c, int nc) {
	if (!mark[u]) {
		C[u] = nc;
	} else {
		delC(c);
		C[u] = nc;
		addC(nc);
	}
}

inline void apply(int t) {
	change(at[t], oldC[t], newC[t]);
}

inline void revoke(int t) {
	change(at[t], newC[t], oldC[t]);
}

vector&lt;int64&gt; results;

void moveTo(int u, int v, int nu, LCT&amp;LV) { //(u,v) -&gt; (nu,v)
	LV.makeRoot(v);
	while (!mark[nu]) {
		addV(nu);
		nu = LV.fa[nu];
	}
	while (u != nu) {
		delV(u);
		u = LV.fa[u];
	}
}

int main() {
//	freopen("in", "r", stdin);
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; nQ;
	for (int i = 0; i &lt; m; ++i) {
		scanf("%d", V + i);
	}
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", W + i);
	}
	for (int i = 0; i &lt; n - 1; ++i) {
		int a, b;
		scanf("%d%d", &amp;a, &amp;b);
		--a, --b;
		E[a].push_back(b), E[b].push_back(a);
	}
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", C + i);
		--C[i];
	}

	blockSize = n / cbrt(1.0 * n) + 1;

	curT = 0;

	static int cpyC[MAX_N];
	memcpy(cpyC, C, sizeof C);

	for (int i = 0; i &lt; nQ; ++i) {
		int t, x, y;
		scanf("%d%d%d", &amp;t, &amp;x, &amp;y);
		--x, --y;
		if (t == 0) {
			at[curT] = x;
			newC[curT] = y;
			oldC[curT] = C[x];
			C[x] = y;
			++curT;
		} else {
			queries.push_back(Query(curT, x, y, results.size()));
			results.push_back(0);
		}
	}

	memcpy(C, cpyC, sizeof C);

	dfs();

	sort(queries.begin(), queries.end());

	LU.init(), LV.init();
	t = 0, u = 0, v = 0;
	LU.makeRoot(u), LV.makeRoot(v);

	addV(0);

	for (vector&lt;Query&gt;::iterator e = queries.begin(); e != queries.end(); ++e) {
		Query q = *e;
		int nt = q.when, nu = q.u, nv = q.v;
		//(u,v) -&gt; (nu,v)
		moveTo(u, v, nu, LV);
		u = nu;
		//(v,u) -&gt; (nv,u)
		moveTo(v, u, nv, LU);
		v = nv;
		//t -&gt; nt
		for (int i = t; i &lt; nt; ++i) {
			apply(i);
		}
		for (int i = t; i &gt; nt; --i) {
			revoke(i - 1);
		}
		t = nt;
		results[q.id] = ans;
	}

	for (vector&lt;int64&gt;::iterator e = results.begin(); e != results.end(); ++e) {
		printf("%lld\n", *e);
	}
}
</pre><pre></pre><h2>Problem3060</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
using namespace std;
int n, m, k;
const int MAX_N = int(1e6) + 10, MAX_M = int(2e6) + 10;
int fa[MAX_N], a[MAX_M], b[MAX_M];
int fd(int x) {
	return x == fa[x] ? x : fa[x] = fd(fa[x]);
}

int main() {
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
	for (int i = 0; i &lt; n; ++i) {
		fa[i] = i;
	}
	for (int i = 0; i &lt; m; ++i) {
		scanf("%d%d", a + i, b + i);
		--a[i], --b[i];
	}
	for (int i = 0; i &lt; m; ++i) {
		if (a[i] &gt;= k &amp;&amp; b[i] &gt;= k)
			fa[fd(a[i])] = fd(b[i]);
	}
	int ans = 0;
	for (int i = 0; i &lt; m; ++i) {
		if (a[i] &lt; k || b[i] &lt; k) {
			int x = fd(a[i]), y = fd(b[i]);
			if (x == y)
				++ans;
			fa[x] = y;
		}
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}
</pre><pre></pre><h2>Problem3067</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
using namespace std;
const int MAX_N = int(3e5) + 10;
typedef long long int64;
int64 a[MAX_N];
int id[256], n;
char s[MAX_N];
int64 val[MAX_N];
int cnt[MAX_N];
int tot;

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; 26; ++i) {
		id['a' + i] = i;
	}
	for (int i = 0; i &lt; 26; ++i) {
		id['A' + i] = i + 26;
	}
	scanf("%s", s);
	a[0] = 0;
	for (int i = 1; i &lt;= n; ++i) {
		a[i] = a[i - 1] ^ (1LL &lt;&lt; id[s[i - 1]]);
	}
	sort(a, a + n + 1);

	for (int i = 0, j; i &lt;= n; i = j) {
		for (j = i; j &lt;= n &amp;&amp; a[i] == a[j]; ++j)
			;
		val[tot] = a[i];
		cnt[tot++] = j - i;
	}

//	for (int i = 0; i &lt; tot; ++i) {
//		cout &lt;&lt; val[i] &lt;&lt; " " &lt;&lt; cnt[i] &lt;&lt; endl;
//	}

	int64 ans = 0;
	for (int i = 0; i &lt; tot; ++i) {
		ans += 1LL * cnt[i] * (cnt[i] - 1) / 2;
	}
	for (int k = 0; k &lt; 52; ++k) {
		int64 pw = 1LL &lt;&lt; k;
		int j = 0;
		for (int i = 0; i &lt; tot; ++i) {
			if (~val[i] &gt;&gt; k &amp; 1) {
				int64 exp = val[i] ^ pw;
				while (j &lt; tot &amp;&amp; val[j] &lt; exp)
					++j;
				if (j &lt; tot &amp;&amp; val[j] == exp)
					ans += 1LL * cnt[i] * cnt[j];
			}
		}
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem3083</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
using namespace std;

const int INF = ~0U &gt;&gt; 1, MAX_N = 100000 + 10;

struct Node;

struct Node {
	Node*ch[4], *p;
	int chainMark, treeMark;
	int chain, tree, all;

	bool inner, rev;
	int val;

	Node() :
			p(0), inner(true), rev(false), val(0) { //inner
		memset(ch, 0, sizeof ch);
		chainMark = treeMark = -1;
		chain = tree = all = INF;
	}

	Node(int v) :
			p(0), inner(false), rev(false), val(v) {
		memset(ch, 0, sizeof ch);
		update();
	}

	void applyRev() {
		rev ^= 1;
	}

	void applyChain(int a) {
		chainMark = a, chain = a, val = a;
		all = min(chain, tree);
	}

	void applyTree(int a, bool kd = true) {
		treeMark = a, tree = a, all = a;
		if (kd)
			applyChain(a);
	}

	void relax() {
		if (rev) {
			swap(ch[0], ch[1]);
			for (int i = 0; i &lt; 2; ++i) {
				if (ch[i])
					ch[i]-&gt;applyRev();
			}
			rev = 0;
		}

		if (treeMark &gt; 0) {
			for (int i = 0; i &lt; 4; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyTree(treeMark, i &gt;= 2);
				}
			treeMark = -1;
		}

		if (chainMark &gt; 0) {
			for (int i = 0; i &lt; 2; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyChain(chainMark);
				}
			chainMark = -1;
		}
	}

	void update() {
		chain = tree = all = INF;
		if (!inner)
			chain = all = val;

		for (int i = 0; i &lt; 4; ++i) {
			if (ch[i])
				all = min(all, ch[i]-&gt;all);
		}

		for (int i = 0; i &lt; 2; ++i) {
			if (ch[i]) {
				chain = min(chain, ch[i]-&gt;chain);
				tree = min(tree, ch[i]-&gt;tree);
			}
		}

		for (int i = 2; i &lt; 4; ++i) {
			if (ch[i]) {
				tree = min(tree, ch[i]-&gt;all);
			}
		}
	}
	Node*get(int d) {
		if (ch[d]) {
			ch[d]-&gt;relax();
		}
		return ch[d];
	}
	bool dir(int t) {
		return p-&gt;ch[t + 1] == this;
	}
	int pos() {
		for (int i = 0; i &lt; 4; ++i) {
			if (p-&gt;ch[i] == this)
				return i;
		}
		return -1;
	}
	void setc(Node*c, int d) {
		ch[d] = c;
		if (c)
			c-&gt;p = this;
	}
	bool isRoot(int t) {
		if (t == 0) {
			return !p || (p-&gt;ch[0] != this &amp;&amp; p-&gt;ch[1] != this);
		} else {
			return !p || !p-&gt;inner || !inner;
		}
	}
};

void rot(Node*u, int t) {
	Node*p = u-&gt;p;
	int d = u-&gt;dir(t);
	if (p-&gt;p)
		p-&gt;p-&gt;setc(u, p-&gt;pos());
	else
		u-&gt;p = 0;
	p-&gt;setc(u-&gt;ch[!d + t], d + t);
	u-&gt;setc(p, !d + t);
	p-&gt;update();
}

void splay(Node*u, int t = 0) {
	while (!u-&gt;isRoot(t)) {
		if (u-&gt;p-&gt;isRoot(t))
			rot(u, t);
		else if (u-&gt;p-&gt;dir(t) == u-&gt;dir(t))
			rot(u-&gt;p, t), rot(u, t);
		else
			rot(u, t), rot(u, t);
	}
	u-&gt;update();
}

void add(Node*u, Node*v) { //put u into v
	v-&gt;relax();
	for (int i = 2; i &lt; 4; ++i) {
		if (!v-&gt;ch[i]) {
			v-&gt;setc(u, i);
			return;
		}
	}
	Node*t = v, *x = new Node;
	for (; t-&gt;ch[2]-&gt;inner; t = t-&gt;get(2))
		;
	x-&gt;setc(t-&gt;ch[2], 2), x-&gt;setc(u, 3);
	t-&gt;setc(x, 2);
	splay(x, 2);
}

void del(Node*u) {
	if (u-&gt;p-&gt;inner) {
		u-&gt;p-&gt;p-&gt;setc(u-&gt;p-&gt;ch[5 - u-&gt;pos()], u-&gt;p-&gt;pos());
		Node*t = u-&gt;p;
		splay(u-&gt;p-&gt;p, 2);
		delete t;
	} else {
		u-&gt;p-&gt;setc(0, u-&gt;pos());
	}
	u-&gt;p = 0;
}

void pushTo(Node*u) {
	static Node*stack[MAX_N * 2];
	int top = 0;
	for (; u; u = u-&gt;p)
		stack[top++] = u;
	while (top)
		stack[--top]-&gt;relax();
}

void expose(Node*u) {
	Node*v = u, *t;
	pushTo(u);
	splay(u);
	if (u-&gt;ch[1]) {
		t = u-&gt;ch[1], u-&gt;ch[1] = 0, add(t, u), u-&gt;update();
	}
	while (u-&gt;p) {
		for (t = u-&gt;p; t-&gt;inner; t = t-&gt;p)
			;
		splay(t);
		if (t-&gt;ch[1])
			u-&gt;p-&gt;setc(t-&gt;ch[1], u-&gt;pos()), splay(u-&gt;p, 2), t-&gt;setc(u, 1);
		else
			del(u), t-&gt;setc(u, 1);
		u = t;
		u-&gt;update();
	}
	splay(v);
}

void makeRoot(Node* u) {
	expose(u);
	u-&gt;applyRev();
}

Node*getPar(Node*u) {
	expose(u);
	u = u-&gt;get(0);
	while (u &amp;&amp; u-&gt;ch[1])
		u = u-&gt;get(1);
	return u;
}

Node*getRoot(Node*u) {
	while (u-&gt;p)
		u = u-&gt;p;
	return u;
}

Node*cut(Node*u) {
	Node*v = getPar(u);
	if (v)
		expose(v), del(u), v-&gt;update();
	return v;
}

int n, nQ;
Node*v[MAX_N];
int a[MAX_N], b[MAX_N], val[MAX_N];

#define BUFSIZE 10000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
int sign;
#define read() \
    do{ \
        if (pt &gt;= pend) \
        { \
            pt = buf; \
            fread(buf, 1, BUFSIZE, stdin); \
        } \
    } while(0)

#define scan(t) \
{ \
    t = 0;sign=1; \
    read(); \
    while ((*pt&lt;'0'||*pt&gt;'9')&amp;&amp;*pt!='-') {pt ++; read();} \
    if(*pt=='-')sign=-1,pt++;\
    while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
    t*=sign;\
}
#define scan_str(s) \
{ \
    int p = 0; \
    read(); \
    while ((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\r') {pt ++; read();}\
    while (!((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\n')) {s[p ++] = (*(pt ++)); read();} \
    s[p] = 0; \
}

int A[20], k;
char p[10000000];
char*opt = p;
inline void printInt(int x) {
	if (x &lt; 0)
		*opt++ = '-', x = -x;
	if (!x)
		*opt++ = '0';
	k = 0;
	while (x)
		A[k++] = x % 10, x /= 10;
	for (int i = k - 1; i &gt;= 0; i--)
		*opt++ = '0' + A[i];
	*opt++ = '\n';
}

vector&lt;int&gt; E[MAX_N];

void dfs(int u, int par) {
	for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (*e != par) {
			dfs(*e, u);
			add(v[*e], v[u]), v[u]-&gt;update();
		}
	}
}

int main() {
//	freopen("in", "r", stdin);
//	cin &gt;&gt; n &gt;&gt; nQ;
	scan(n);
	scan(nQ);
	for (int i = 0; i &lt; n - 1; ++i) {
		int a, b;
		scan(a);
		scan(b);
		--a, --b;
		E[a].push_back(b), E[b].push_back(a);
	}
	for (int i = 0; i &lt; n; ++i) {
		scan(val[i]);
		v[i] = new Node(val[i]);
	}
	int rt;
	scan(rt);
	--rt;
	dfs(rt, -1);
	makeRoot(v[rt]);
	while (nQ--) {
		int k, x;
		scan(k);
		scan(x);
		--x;
		Node*u = v[x];
//		cout &lt;&lt; k &lt;&lt; ":" &lt;&lt; endl;
		if (k == 1) { //change root
			makeRoot(u);
			rt = x;
		} else if (k == 3) {
			//subtree operation
			expose(u);
			if (k == 3) {
				//query
				int ans = u-&gt;val;
				for (int i = 2; i &lt; 4; ++i)
					if (u-&gt;ch[i]) {
						ans = min(ans, u-&gt;ch[i]-&gt;all);
					}
				printInt(ans);
			}
		} else {
			//chain operation
			int y;
			scan(y);
			--y;
			makeRoot(u), expose(v[y]), splay(u);
			int z;
			scan(z);
			u-&gt;applyChain(z);
			makeRoot(v[rt]);
		}
	}
	*opt++ = '\0';
	puts(p);
}
</pre><pre></pre><h2>Problem3123</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include &lt;vector&gt;
using namespace std;

const int MAX_N = int(8e4) + 10, MAX_LOG = 18;

struct Index: public vector&lt;int&gt; {
	void doit() {
		sort(begin(), end());
		erase(unique(begin(), end()), end());
	}
	int get(int x) {
		return lower_bound(begin(), end(), x) - begin();
	}
};

int v[MAX_N];

int n, m, nQ;

Index idv;

struct Tree;
Tree*get();

struct Tree {
	int cnt;
	Tree*pl, *pr;

	Tree() {
		pl = pr = 0;
		cnt = 0;
	}
};

int calc(int l, int r, Tree* arr[], int det[], int n, int k, int w = -1) {
	while (l + 1 &lt; r) {
		int m = (l + r) &gt;&gt; 1;

		int cnt = 0;
		for (int i = 0; i &lt; n; ++i) {
			if (arr[i] &amp;&amp; arr[i]-&gt;pl) {
				cnt += arr[i]-&gt;pl-&gt;cnt * det[i];
			}
		}

		if (w &gt;= l &amp;&amp; w &lt; m) {
			++cnt;
		}

		if (k &lt;= cnt) {
			for (int i = 0; i &lt; n; ++i) {
				if (arr[i])
					arr[i] = arr[i]-&gt;pl;
			}
			r = m;
		} else {
			k -= cnt;
			for (int i = 0; i &lt; n; ++i) {
				if (arr[i])
					arr[i] = arr[i]-&gt;pr;
			}
			l = m;
		}
	}
	return l;
}

Tree*add(Tree*p, int l, int r, int x) {
//	cerr &lt;&lt; "HI" &lt;&lt; endl;
	Tree*t = get();
	t-&gt;cnt = (p ? p-&gt;cnt : 0) + 1;
	if (l + 1 == r) {
		return t;
	}
	int m = (l + r) &gt;&gt; 1;
	if (x &lt; m) {
		t-&gt;pl = add(p ? p-&gt;pl : 0, l, m, x);
		if (p)
			t-&gt;pr = p-&gt;pr;
	} else {
		if (p)
			t-&gt;pl = p-&gt;pl;
		t-&gt;pr = add(p ? p-&gt;pr : 0, m, r, x);
	}
	return t;
}

const int BUFFER_SIZE = 10000;
Tree*buffer = 0, *cur;

Tree*get() {
	if (buffer == 0 || cur == buffer + BUFFER_SIZE) {
		buffer = new Tree[BUFFER_SIZE];
		cur = buffer;
	}
	return cur++;
}

int anc[MAX_N][MAX_LOG];

vector&lt;int&gt; E[MAX_N];

Tree*my[MAX_N];

int mark[MAX_N] = { }, cmark = 0;

int dep[MAX_N];

int nComp;

int compId[MAX_N];
int size[MAX_N];

void dfs(int u, int par, int d, int comp) {
	dep[u] = d;
	compId[u] = comp;
	size[comp]++;

	Tree*p = par == -1 ? 0 : my[par];

	my[u] = add(p, 0, idv.size(), v[u]);

	anc[u][0] = par;
	for (int i = 1; i &lt; MAX_LOG; ++i) {
		int go = anc[u][i - 1];
		if (go == -1)
			anc[u][i] = -1;
		else
			anc[u][i] = anc[go][i - 1];
	}

	for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (*e != par)
			dfs(*e, u, d + 1, comp);
	}
}

void bfs(int rt, int par, int d, int comp) {
	static int que[MAX_N];
	int qh = 0, qt = 0;
	que[qt++] = rt;

	dep[rt] = d, anc[rt][0] = par;

	while (qh &lt; qt) {
		int u = que[qh++];
		mark[u] = cmark;
		compId[u] = comp;
		++size[comp];

		for (int i = 1; i &lt; MAX_LOG; ++i) {
			int go = anc[u][i - 1];
			if (go == -1)
				anc[u][i] = -1;
			else
				anc[u][i] = anc[go][i - 1];
		}

		int par = anc[u][0];

		Tree*p = par == -1 ? 0 : my[par];

		my[u] = add(p, 0, idv.size(), v[u]);

		for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
			if (*e != par) {
				dep[*e] = dep[u] + 1;
				anc[*e][0] = u;
				que[qt++] = *e;
			}
		}
	}
}

int getLca(int u, int v) {
	if (dep[u] &lt; dep[v])
		swap(u, v);

	int up = dep[u] - dep[v];
	for (int i = 0; i &lt; MAX_LOG; ++i) {
		if (up &gt;&gt; i &amp; 1)
			u = anc[u][i];
	}

	if (u == v)
		return u;

	for (int i = MAX_LOG - 1; i &gt;= 0; --i) {
		int nu = anc[u][i], nv = anc[v][i];
		if (nu != nv) {
			u = nu, v = nv;
		}
	}

	return anc[u][0];
}

int query(int x, int y, int k) {
	int lca = getLca(x, y);

//	cerr &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; lca &lt;&lt; endl;

	Tree*arr[3];
	int det[3];

//	cerr &lt;&lt; my[x]-&gt;pl &lt;&lt; " " &lt;&lt; my[y]-&gt;pl &lt;&lt; " " &lt;&lt; my[lca]-&gt;pl &lt;&lt; endl;

	arr[0] = my[x], arr[1] = my[y], arr[2] = my[lca];
	det[0] = 1, det[1] = 1, det[2] = -2;
	return calc(0, idv.size(), arr, det, 3, k, v[lca]);
}

void addEdge(int u, int v) {
	if (size[compId[u]] &lt; size[compId[v]]) {
		swap(u, v);
	}

	E[u].push_back(v), E[v].push_back(u);
	bfs(v, u, dep[u] + 1, compId[u]);
}

int main() {
	int _;
	cin &gt;&gt; _;

	cin &gt;&gt; n &gt;&gt; m &gt;&gt; nQ;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", v + i);
		idv.push_back(v[i]);
	}

	idv.doit();

	for (int i = 0; i &lt; n; ++i) {
		v[i] = idv.get(v[i]);
	}

	for (int i = 0; i &lt; m; ++i) {
		int x, y;
		scanf("%d%d", &amp;x, &amp;y);
		--x, --y;

		E[x].push_back(y), E[y].push_back(x);
	}

	nComp = 0;
	++cmark;
	for (int i = 0; i &lt; n; ++i) {
		if (mark[i] != cmark) {
			size[nComp] = 0;
			bfs(i, -1, 0, nComp++);
		}
	}

	int last = 0;

	for (int i = 0; i &lt; nQ; ++i) {
		char cmd;
		scanf(" ");
		scanf("%c", &amp;cmd);
//		cerr &lt;&lt; cmd &lt;&lt; endl;

		if (cmd == 'Q') {
			int x, y, k;
			scanf("%d%d%d", &amp;x, &amp;y, &amp;k);
			x ^= last, y ^= last, k ^= last;
			--x, --y;
			printf("%d\n", last = idv[query(x, y, k)]);
		} else {
			int x, y;
			scanf("%d%d", &amp;x, &amp;y);
			x ^= last, y ^= last;
			--x, --y;
			addEdge(x, y);
		}
	}
}
</pre><pre></pre><h2>Problem3123</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include &lt;vector&gt;
using namespace std;

const int MAX_N = int(8e4) + 10, MAX_LOG = 18;

struct Index: public vector&lt;int&gt; {
	void doit() {
		sort(begin(), end());
		erase(unique(begin(), end()), end());
	}
	int get(int x) {
		return lower_bound(begin(), end(), x) - begin();
	}
};

int v[MAX_N];

int n, m, nQ;

Index idv;

struct Tree;
Tree*get();

struct Tree {
	int cnt;
	Tree*pl, *pr;

	Tree() {
		pl = pr = 0;
		cnt = 0;
	}
} TNull, *null = &amp;TNull;

int calc(int l, int r, Tree* arr[], int det[], int n, int k, int w = -1) {
	while (l + 1 &lt; r) {
		int m = (l + r) &gt;&gt; 1;

//		int newN = 0;
//		for (int i = 0; i &lt; n; ++i) {
//			if (arr[i] == null) {
//				arr[newN] = arr[i];
//				det[newN] = det[i];
//				newN++;
//			}
//		}
//		n = newN;

		int cnt = 0;
		for (int i = 0; i &lt; n; ++i) {
			cnt += arr[i]-&gt;pl-&gt;cnt * det[i];
		}

		if (w &gt;= l &amp;&amp; w &lt; m) {
			++cnt;
		}

		if (k &lt;= cnt) {
			for (int i = 0; i &lt; n; ++i) {
				arr[i] = arr[i]-&gt;pl;
			}
			r = m;
		} else {
			k -= cnt;
			for (int i = 0; i &lt; n; ++i) {
				arr[i] = arr[i]-&gt;pr;
			}
			l = m;
		}
	}
	return l;
}

Tree*add(Tree*p, int l, int r, int x) {
//	cerr &lt;&lt; "HI" &lt;&lt; endl;
	Tree*t = get();
	t-&gt;cnt = p-&gt;cnt + 1;
	if (l + 1 == r) {
		return t;
	}
	int m = (l + r) &gt;&gt; 1;
	if (x &lt; m) {
		t-&gt;pl = add(p-&gt;pl, l, m, x);
		t-&gt;pr = p-&gt;pr;
	} else {
		t-&gt;pr = add(p-&gt;pr, m, r, x);
		t-&gt;pl = p-&gt;pl;
	}
	return t;
}

const int BUFFER_SIZE = 10000;
Tree*buffer = 0, *cur;

Tree*get() {
	if (buffer == 0 || cur == buffer + BUFFER_SIZE) {
		buffer = new Tree[BUFFER_SIZE];
		cur = buffer;
	}
	cur-&gt;cnt = 0;
	cur-&gt;pl = cur-&gt;pr = null;
	return cur++;
}

int anc[MAX_N][MAX_LOG];

vector&lt;int&gt; E[MAX_N];

Tree*my[MAX_N];

int mark[MAX_N] = { }, cmark = 0;

int dep[MAX_N];

int nComp;

int compId[MAX_N];
int size[MAX_N];

void dfs(int u, int par, int d, int comp) {
	dep[u] = d;
	compId[u] = comp;
	size[comp]++;

	Tree*p = par == -1 ? null : my[par];

	my[u] = add(p, 0, idv.size(), v[u]);

	anc[u][0] = par;
	for (int i = 1; i &lt; MAX_LOG; ++i) {
		int go = anc[u][i - 1];
		if (go == -1)
			anc[u][i] = -1;
		else
			anc[u][i] = anc[go][i - 1];
	}

	for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (*e != par)
			dfs(*e, u, d + 1, comp);
	}
}

void bfs(int rt, int par, int d, int comp) {
	static int que[MAX_N];
	int qh = 0, qt = 0;
	que[qt++] = rt;

	dep[rt] = d, anc[rt][0] = par;

	while (qh &lt; qt) {
		int u = que[qh++];
		mark[u] = cmark;
		compId[u] = comp;
		++size[comp];

		for (int i = 1; i &lt; MAX_LOG; ++i) {
			int go = anc[u][i - 1];
			if (go == -1)
				anc[u][i] = -1;
			else
				anc[u][i] = anc[go][i - 1];
		}

		int par = anc[u][0];

		Tree*p = par == -1 ? null : my[par];

		my[u] = add(p, 0, idv.size(), v[u]);

		for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
			if (*e != par) {
				dep[*e] = dep[u] + 1;
				anc[*e][0] = u;
				que[qt++] = *e;
			}
		}
	}
}

int getLca(int u, int v) {
	if (dep[u] &lt; dep[v])
		swap(u, v);

	int up = dep[u] - dep[v];
	for (int i = 0; i &lt; MAX_LOG; ++i) {
		if (up &gt;&gt; i &amp; 1)
			u = anc[u][i];
	}

	if (u == v)
		return u;

	for (int i = MAX_LOG - 1; i &gt;= 0; --i) {
		int nu = anc[u][i], nv = anc[v][i];
		if (nu != nv) {
			u = nu, v = nv;
		}
	}

	return anc[u][0];
}

int query(int x, int y, int k) {
	int lca = getLca(x, y);

//	cerr &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; lca &lt;&lt; endl;

	Tree*arr[3];
	int det[3];

//	cerr &lt;&lt; my[x]-&gt;pl &lt;&lt; " " &lt;&lt; my[y]-&gt;pl &lt;&lt; " " &lt;&lt; my[lca]-&gt;pl &lt;&lt; endl;

	arr[0] = my[x], arr[1] = my[y], arr[2] = my[lca];
	det[0] = 1, det[1] = 1, det[2] = -2;
	return calc(0, idv.size(), arr, det, 3, k, v[lca]);
}

void addEdge(int u, int v) {
	if (size[compId[u]] &lt; size[compId[v]]) {
		swap(u, v);
	}

	E[u].push_back(v), E[v].push_back(u);
	bfs(v, u, dep[u] + 1, compId[u]);
}

int main() {
	null-&gt;pl = null-&gt;pr = null;

	int _;
	cin &gt;&gt; _;

	cin &gt;&gt; n &gt;&gt; m &gt;&gt; nQ;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", v + i);
		idv.push_back(v[i]);
	}

	idv.doit();

	for (int i = 0; i &lt; n; ++i) {
		v[i] = idv.get(v[i]);
	}

	for (int i = 0; i &lt; m; ++i) {
		int x, y;
		scanf("%d%d", &amp;x, &amp;y);
		--x, --y;

		E[x].push_back(y), E[y].push_back(x);
	}

	nComp = 0;
	++cmark;
	for (int i = 0; i &lt; n; ++i) {
		if (mark[i] != cmark) {
			size[nComp] = 0;
			bfs(i, -1, 0, nComp++);
		}
	}

	int last = 0;

	for (int i = 0; i &lt; nQ; ++i) {
		char cmd;
		scanf(" ");
		scanf("%c", &amp;cmd);
//		cerr &lt;&lt; cmd &lt;&lt; endl;

		if (cmd == 'Q') {
			int x, y, k;
			scanf("%d%d%d", &amp;x, &amp;y, &amp;k);
			x ^= last, y ^= last, k ^= last;
			--x, --y;
			printf("%d\n", last = idv[query(x, y, k)]);
		} else {
			int x, y;
			scanf("%d%d", &amp;x, &amp;y);
			x ^= last, y ^= last;
			--x, --y;
			addEdge(x, y);
		}
	}
}
</pre><pre></pre><h2>Problem3139</h2><pre>/*
 * [CQOI2009]match循环赛.cpp
 *
 *  Created on: 2011-3-11
 *      Author: user
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;
//#define DEBUG
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N_TEAMS = 10;
const int MOD = int(1e9) + 7;
int score[MAX_N_TEAMS];
int nTeams;

void inputData() {
	scanf("%d", &amp;nTeams);
	for (int i = 0; i &lt; nTeams; ++i) {
		scanf("%d", score + i);
	}
}

int ansCnt = 0;

int bitCnt[1 &lt;&lt; MAX_N_TEAMS];

bool possible(int restMatch, int vals) {
	if (vals &lt; 0)
		return false;
	int cnt = vals / 3 + vals % 3;
	if (restMatch &lt; cnt)
		return false;
	return true;
}

bool possible2(int usedSet) {
	return true;
	int sum = 0;
	int cnt = 0;
	for (int who = 0; who &lt; nTeams; ++who) {
		if (~usedSet &gt;&gt; who &amp; 1) {
			sum += score[who];
			++cnt;
		}
	}
	if (sum &gt; (cnt * (cnt - 1) / 2) * 3)
		return false;
	return true;
}

typedef long long int64;
const int MAX_SCORE = MAX_N_TEAMS * 3 + 1;
int64 compress(int usedSet) {
	static int nScore[MAX_N_TEAMS];
	int64 ret = 0;
	int cnt = 0;
	for (int who = 0; who &lt; nTeams; ++who) {
		if (~usedSet &gt;&gt; who &amp; 1) {
			nScore[cnt++] = score[who];
		}
	}
	sort(nScore, nScore + cnt);
	ret = cnt;
	for (int who = 0; who &lt; nTeams; ++who) {
		ret = ret * MAX_SCORE + nScore[who];
	}
	return ret;
}

map&lt;int64, int&gt; memo;

int dfs(int usedSet) {
	if (usedSet == (1 &lt;&lt; nTeams) - 1) {
		return 1;
	}
	int64 code = compress(usedSet);
	if (memo.count(code))
		return memo[code];
	int&amp;ret = memo[code];
	ret = 0;
	int minScoreId = -1;
	for (int nextTeam = 0; nextTeam &lt; nTeams; ++nextTeam) {
		if (usedSet &gt;&gt; nextTeam &amp; 1)
			continue;
		if (minScoreId == -1 || score[nextTeam] &lt; score[minScoreId])
			minScoreId = nextTeam;
	}

	int otherSet = ((1 &lt;&lt; nTeams) - 1 - usedSet) ^ (1 &lt;&lt; minScoreId);
	int nOthers = bitCnt[otherSet];
	for (int drawSet = otherSet;; (--drawSet) &amp;= otherSet) {
		int drawCnt = bitCnt[drawSet];
		int rest = otherSet ^ drawSet;
		int nScore;
		int needWins;
		bool ok;
		if (score[minScoreId] &lt; drawCnt)
			goto endIterDrawSet;
		nScore = score[minScoreId] - drawCnt;
		if (nScore % 3 != 0)
			goto endIterDrawSet;
		needWins = nScore / 3;
		if (needWins &gt; nOthers)
			goto endIterDrawSet;
		ok = true;
		for (int who = 0; who &lt; nTeams; ++who) {
			if (drawSet &gt;&gt; who &amp; 1) {
				if (!possible(nOthers - 1, score[who] - 1)) {
					ok = false;
					break;
				}
			}
		}
		if (!ok)
			goto endIterDrawSet;
		for (int who = 0; who &lt; nTeams; ++who) {
			if (drawSet &gt;&gt; who &amp; 1) {
				score[who] -= 1;
			}
		}
		for (int winSet = rest;; --(winSet) &amp;= rest) {
			if (bitCnt[winSet] != needWins)
				goto endIterWinSet;
			ok = true;
			for (int who = 0; who &lt; nTeams; ++who) {
				if (rest &gt;&gt; who &amp; 1) {
					if (winSet &gt;&gt; who &amp; 1) {
						if (!possible(nOthers - 1, score[who]))
							ok = false;
						break;
					} else {
						if (!possible(nOthers - 1, score[who] - 3))
							ok = false;
						break;
					}
				}
			}
			if (ok) {
				for (int who = 0; who &lt; nTeams; ++who) {
					if (rest &gt;&gt; who &amp; 1) {
						if (winSet &gt;&gt; who &amp; 1)
							;
						else
							score[who] -= 3;
					}
				}
				int nUsedSet = usedSet ^ (1 &lt;&lt; minScoreId);
				if (possible2(nUsedSet)) {
					ret += dfs(nUsedSet);
					if (ret &gt;= MOD)
						ret -= MOD;
				}
				for (int who = 0; who &lt; nTeams; ++who) {
					if (rest &gt;&gt; who &amp; 1) {
						if (winSet &gt;&gt; who &amp; 1)
							;
						else
							score[who] += 3;
					}
				}
			}

			endIterWinSet: {
			}
			if (!winSet)
				break;
		}

		for (int who = 0; who &lt; nTeams; ++who) {
			if (drawSet &gt;&gt; who &amp; 1) {
				score[who] += 1;
			}
		}

		endIterDrawSet: {
		}
		if (!drawSet)
			break;
	}

	return ret;
}

void prepareBitCnt() {
	memset(bitCnt, 0, sizeof bitCnt);
	for (int mask = 1; mask &lt; (1 &lt;&lt; nTeams); ++mask) {
		bitCnt[mask] = bitCnt[mask &gt;&gt; 1] + (mask &amp; 1);
	}
}

void work() {
	ansCnt = 0;
	prepareBitCnt();
	cout &lt;&lt; dfs(0) &lt;&lt; endl;
}

void runLargest() {
	nTeams = 8;
	for (int i = 0; i &lt; nTeams; ++i) {
		score[i] = 10;
	}
	work();
}

void solve() {
	inputData();
	work();
}

int main() {
#ifndef DEBUG
	solve();
#endif
#ifdef DEBUG
	runLargest();
#endif
}
</pre><pre></pre><h2>Problem3142</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
using namespace std;

typedef long long int64;
int MOD;

struct Int {
	int x;
	Int() :
			x(0) {
	}
	Int(int _x) :
			x(_x) {
		x %= MOD;
		if (x &lt; 0)
			x += MOD;
	}
	Int(int64 _x) {
		x = _x % MOD;
		if (x &lt; 0)
			x += MOD;
	}
	static Int get(int x) {
		Int a;
		a.x = x;
		return a;
	}

	Int operator+(const Int&amp;o) const {
		int t = x + o.x;
		if (t &gt;= MOD)
			t -= MOD;
		return get(t);
	}
	Int operator*(const Int&amp;o) const {
		return get(1LL * x * o.x % MOD);
	}
	Int operator-(const Int&amp;o) const {
		int t = x - o.x;
		if (t &lt; 0)
			t += MOD;
		return get(t);
	}
	Int operator/(const Int&amp;o) const {
		return (*this) * o.inv();
	}
	Int&amp;operator+=(const Int&amp;o) {
		return (*this) = *this + o;
	}
	Int&amp;operator-=(const Int&amp;o) {
		return (*this) = *this - o;
	}
	Int&amp;operator*=(const Int&amp;o) {
		return (*this) = *this * o;
	}
	Int&amp;operator/=(const Int&amp;o) {
		return (*this) = *this / o;
	}

	Int power(int64 n) const {
		if (!n)
			return get(1);
		const Int&amp;a = *this;
		if (n &amp; 1)
			return power(n - 1) * a;
		else
			return (a * a).power(n &gt;&gt; 1);
	}

	Int inv() const {
		return power(MOD - 2);
	}
};
int64 N, K, M, P;

int main() {
	cin &gt;&gt; N &gt;&gt; K &gt;&gt; M &gt;&gt; P;
	//sum (N - sum a)
	MOD = P;
	if (K == 1)
		cout &lt;&lt; N % P &lt;&lt; endl;
	else {
		Int ans = Int(M).power(K - 1) * N;
		int64 tot = M * (M + 1) / 2;
		ans -= Int(M).power(K - 2) * (K - 1) * tot;
		cout &lt;&lt; ans.x &lt;&lt; endl;
	}
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include &lt;cassert&gt;
using namespace std;

const int INF = ~0U &gt;&gt; 1, MAX_N = 100000 + 10;

struct Info {
	int size, minv, maxv, sum;
	Info(int size, int minv, int maxv, int sum) :
			size(size), minv(minv), maxv(maxv), sum(sum) {
	}
	Info() :
			size(0), minv(INF), maxv(-INF), sum(0) {
	}
};

const Info EMPTY;

struct Mark {
	int mul, plus;
	Mark(int mul, int plus) :
			mul(mul), plus(plus) {
	}
	Mark() :
			mul(1), plus(0) {
	}
	bool ok() {
		return mul != 1 || plus != 0;
	}
};

inline int apply(int x, const Mark&amp;b) {
	return b.mul * x + b.plus;
}

int operator+(int x, const Mark&amp;b) {
	return x * b.mul + b.plus;
}
Mark operator+(const Mark&amp;a, const Mark&amp;b) {
	return Mark(a.mul * b.mul, a.plus * b.mul + b.plus);
}

Info operator+(const Info&amp;a, const Mark&amp;b) {
	if (!a.size)
		return a;
	return Info(a.size, a.minv + b, a.maxv + b, a.sum * b.mul + a.size * b.plus);
}

Info operator+(const Info&amp;a, const Info&amp;b) {
	return Info(a.size + b.size, min(a.minv, b.minv), max(a.maxv, b.maxv),
			a.sum + b.sum);
}

#define MAKE_IT(T1,T2) \
	T1&amp; operator+=(T1&amp;a,const T2&amp;b){\
		a=a+b;\
		return a;\
	}

MAKE_IT(Info, Info);
MAKE_IT(Info, Mark);
MAKE_IT(Mark, Mark);
MAKE_IT(int, Mark);

struct Node;

struct Node {
	Node*ch[4], *p;
	Mark chainMark, treeMark;
	Info chain, tree, all;

	bool inner, rev;
	int val;

	Node() :
			p(0), inner(true), rev(false), val(0) { //inner
		memset(ch, 0, sizeof ch);
	}

	Node(int v) :
			p(0), inner(false), rev(false), val(v) {
		memset(ch, 0, sizeof ch);
		update();
	}

	void applyRev() {
		rev ^= 1;
	}

	void applyChain(const Mark&amp;a) {
		chainMark += a, chain += a, val += a;
		all = chain + tree;
	}

	void applyTree(const Mark&amp;a, bool kd = true) {
		treeMark += a, tree += a, all += a;
		if (kd)
			applyChain(a);
	}

	void relax() {
		if (rev) {
			swap(ch[0], ch[1]);
			for (int i = 0; i &lt; 2; ++i) {
				if (ch[i])
					ch[i]-&gt;applyRev();
			}
			rev = 0;
		}

		if (treeMark.ok()) {
			for (int i = 0; i &lt; 4; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyTree(treeMark, i &gt;= 2);
				}
			treeMark = Mark();
		}

		if (chainMark.ok()) {
			for (int i = 0; i &lt; 2; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyChain(chainMark);
				}
			chainMark = Mark();
		}
	}

	void update() {
		chain = tree = all = EMPTY;
		if (!inner)
			chain = all = Info(1, val, val, val);

		for (int i = 0; i &lt; 4; ++i) {
			if (ch[i])
				all += ch[i]-&gt;all;
		}

		for (int i = 0; i &lt; 2; ++i) {
			if (ch[i]) {
				chain += ch[i]-&gt;chain;
				tree += ch[i]-&gt;tree;
			}
		}

		for (int i = 2; i &lt; 4; ++i) {
			if (ch[i]) {
				tree += ch[i]-&gt;all;
			}
		}
	}
	Node*get(int d) {
		if (ch[d]) {
			ch[d]-&gt;relax();
		}
		return ch[d];
	}
	bool dir(int t) {
		return p-&gt;ch[t + 1] == this;
	}
	int pos() {
		for (int i = 0; i &lt; 4; ++i) {
			if (p-&gt;ch[i] == this)
				return i;
		}
		return -1;
	}
	void setc(Node*c, int d) {
		ch[d] = c;
		if (c)
			c-&gt;p = this;
	}
	bool isRoot(int t) {
		if (t == 0) {
			return !p || (p-&gt;ch[0] != this &amp;&amp; p-&gt;ch[1] != this);
		} else {
			return !p || !p-&gt;inner || !inner;
		}
	}
};

void rot(Node*u, int t) {
	Node*p = u-&gt;p;
	int d = u-&gt;dir(t);
	if (p-&gt;p)
		p-&gt;p-&gt;setc(u, p-&gt;pos());
	else
		u-&gt;p = 0;
	p-&gt;setc(u-&gt;ch[!d + t], d + t);
	u-&gt;setc(p, !d + t);
	p-&gt;update();
}

void splay(Node*u, int t = 0) {
	while (!u-&gt;isRoot(t)) {
		if (u-&gt;p-&gt;isRoot(t))
			rot(u, t);
		else if (u-&gt;p-&gt;dir(t) == u-&gt;dir(t))
			rot(u-&gt;p, t), rot(u, t);
		else
			rot(u, t), rot(u, t);
	}
	u-&gt;update();
}

void add(Node*u, Node*v) { //put u into v
	v-&gt;relax();
	for (int i = 2; i &lt; 4; ++i) {
		if (!v-&gt;ch[i]) {
			v-&gt;setc(u, i);
			return;
		}
	}
	Node*t = v, *x = new Node;
	for (; t-&gt;ch[2]-&gt;inner; t = t-&gt;get(2))
		;
	x-&gt;setc(t-&gt;ch[2], 2), x-&gt;setc(u, 3);
	t-&gt;setc(x, 2);
	splay(x, 2);
}

void del(Node*u) {
	if (u-&gt;p-&gt;inner) {
		u-&gt;p-&gt;p-&gt;setc(u-&gt;p-&gt;ch[5 - u-&gt;pos()], u-&gt;p-&gt;pos());
		Node*t = u-&gt;p;
		splay(u-&gt;p-&gt;p, 2);
		delete t;
	} else {
		u-&gt;p-&gt;setc(0, u-&gt;pos());
	}
	u-&gt;p = 0;
}

void pushTo(Node*u) {
	static Node*stack[MAX_N * 2];
	int top = 0;
	for (; u; u = u-&gt;p)
		stack[top++] = u;
	while (top)
		stack[--top]-&gt;relax();
}

void expose(Node*u) {
	Node*v = u, *t;
	pushTo(u);
	splay(u);
	if (u-&gt;ch[1]) {
		t = u-&gt;ch[1], u-&gt;ch[1] = 0, add(t, u), u-&gt;update();
	}
	while (u-&gt;p) {
		for (t = u-&gt;p; t-&gt;inner; t = t-&gt;p)
			;
		splay(t);
		if (t-&gt;ch[1])
			u-&gt;p-&gt;setc(t-&gt;ch[1], u-&gt;pos()), splay(u-&gt;p, 2), t-&gt;setc(u, 1);
		else
			del(u), t-&gt;setc(u, 1);
		u = t;
		u-&gt;update();
	}
	splay(v);
}

void makeRoot(Node* u) {
	expose(u);
	u-&gt;applyRev();
}

Node*getPar(Node*u) {
	expose(u);
	u = u-&gt;get(0);
	while (u &amp;&amp; u-&gt;ch[1])
		u = u-&gt;get(1);
	return u;
}

Node*getRoot(Node*u) {
	while (u-&gt;p)
		u = u-&gt;p;
	return u;
}

Node*cut(Node*u) {
	Node*v = getPar(u);
	if (v)
		expose(v), del(u), v-&gt;update();
	return v;
}

void link(Node*u, Node*v) {
	Node*p = cut(u);
	if (getRoot(u) != getRoot(v))
		p = v;
	if (p)
		expose(p), add(u, p), p-&gt;update();
}

int n, nQ;
Node*v[MAX_N];
int a[MAX_N], b[MAX_N], val[MAX_N];

int main() {
	cin &gt;&gt; n &gt;&gt; nQ;
	for (int i = 0; i &lt; n - 1; ++i) {
		scanf("%d%d", a + i, b + i);
		--a[i], --b[i];
	}
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", val + i);
		v[i] = new Node(val[i]);
	}
	int rt;
	for (int i = 0; i &lt; n - 1; ++i) {
		makeRoot(v[a[i]]);
		link(v[a[i]], v[b[i]]);
	}
	cin &gt;&gt; rt;
	--rt;
	makeRoot(v[rt]);
	while (nQ--) {
		int k, x;
		scanf("%d%d", &amp;k, &amp;x), --x;
		Node*u = v[x];
//		cout &lt;&lt; k &lt;&lt; ":" &lt;&lt; endl;
		if (k == 1) { //change root
			makeRoot(u);
			rt = x;
		} else if (k == 9) { //change x's father to y
			int y;
			scanf("%d", &amp;y), --y;
			link(u, v[y]);
		} else if (k == 0 || k == 3 || k == 11 || k == 5 || k == 4) {
			//subtree operation
			expose(u);
			if (k == 3 || k == 4 || k == 11) {
				//query
				int ans = u-&gt;val;
				for (int i = 2; i &lt; 4; ++i)
					if (u-&gt;ch[i]) {
						Info&amp;r = u-&gt;ch[i]-&gt;all;
						if (k == 3)
							ans = min(ans, r.minv);
						else if (k == 4)
							ans = max(ans, r.maxv);
						else if (k == 11)
							ans += r.sum;
					}
				printf("%d\n", ans);
			} else { //change
				int y;
				scanf("%d", &amp;y);
				Mark m(k == 5, y);
				u-&gt;val += m;
				for (int i = 2; i &lt; 4; ++i) {
					if (u-&gt;ch[i])
						u-&gt;ch[i]-&gt;applyTree(m);
				}
				u-&gt;update();
			}
		} else {
			//chain operation
			int y;
			scanf("%d", &amp;y), --y;
			makeRoot(u), expose(v[y]), splay(u);
			if (k == 7 || k == 8 || k == 10) {
				Info&amp;ans = u-&gt;chain;
				if (k == 7)
					printf("%d\n", ans.minv);
				else if (k == 8)
					printf("%d\n", ans.maxv);
				else if (k == 10)
					printf("%d\n", ans.sum);
			} else {
				int z;
				scanf("%d", &amp;z);
				u-&gt;applyChain(Mark(k == 6, z));
			}
			makeRoot(v[rt]);
		}
	}
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
using namespace std;

const int INF = ~0U &gt;&gt; 1, MAX_N = 100000 + 10;

struct Info {
	int size, minv, maxv, sum;
	Info(int size, int minv, int maxv, int sum) :
			size(size), minv(minv), maxv(maxv), sum(sum) {
	}
	Info() :
			size(0), minv(INF), maxv(-INF), sum(0) {
	}
};

const Info EMPTY;

struct Mark {
	int mul, plus;
	Mark(int mul, int plus) :
			mul(mul), plus(plus) {
	}
	Mark() :
			mul(1), plus(0) {
	}
	bool ok() {
		return mul != 1 || plus != 0;
	}
};

inline int apply(int x, const Mark&amp;b) {
	return b.mul * x + b.plus;
}

int operator+(int x, const Mark&amp;b) {
	return x * b.mul + b.plus;
}
Mark operator+(const Mark&amp;a, const Mark&amp;b) {
	return Mark(a.mul * b.mul, a.plus * b.mul + b.plus);
}

Info operator+(const Info&amp;a, const Mark&amp;b) {
	if (!a.size)
		return a;
	return Info(a.size, a.minv + b, a.maxv + b, a.sum * b.mul + a.size * b.plus);
}

Info operator+(const Info&amp;a, const Info&amp;b) {
	return Info(a.size + b.size, min(a.minv, b.minv), max(a.maxv, b.maxv),
			a.sum + b.sum);
}

#define MAKE_IT(T1,T2) \
	T1&amp; operator+=(T1&amp;a,const T2&amp;b){\
		a=a+b;\
		return a;\
	}

MAKE_IT(Info, Info);
MAKE_IT(Info, Mark);
MAKE_IT(Mark, Mark);
MAKE_IT(int, Mark);

struct Node;

struct Node {
	Node*ch[4], *p;
	Mark chainMark, treeMark;
	Info chain, tree, all;

	bool inner, rev;
	int val;

	Node() :
			p(0), inner(true), rev(false), val(0) { //inner
		memset(ch, 0, sizeof ch);
	}

	Node(int v) :
			p(0), inner(false), rev(false), val(v) {
		memset(ch, 0, sizeof ch);
		update();
	}

	void applyRev() {
		rev ^= 1;
	}

	void applyChain(const Mark&amp;a) {
		chainMark += a, chain += a, val += a;
		all = chain + tree;
	}

	void applyTree(const Mark&amp;a, bool kd = true) {
		treeMark += a, tree += a, all += a;
		if (kd)
			applyChain(a);
	}

	void relax() {
		if (rev) {
			swap(ch[0], ch[1]);
			for (int i = 0; i &lt; 2; ++i) {
				if (ch[i])
					ch[i]-&gt;applyRev();
			}
			rev = 0;
		}

		if (treeMark.ok()) {
			for (int i = 0; i &lt; 4; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyTree(treeMark, i &gt;= 2);
				}
			treeMark = Mark();
		}

		if (chainMark.ok()) {
			for (int i = 0; i &lt; 2; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyChain(chainMark);
				}
			chainMark = Mark();
		}
	}

	void update() {
		chain = tree = all = EMPTY;
		if (!inner)
			chain = all = Info(1, val, val, val);

		for (int i = 0; i &lt; 4; ++i) {
			if (ch[i])
				all += ch[i]-&gt;all;
		}

		for (int i = 0; i &lt; 2; ++i) {
			if (ch[i]) {
				chain += ch[i]-&gt;chain;
				tree += ch[i]-&gt;tree;
			}
		}

		for (int i = 2; i &lt; 4; ++i) {
			if (ch[i]) {
				tree += ch[i]-&gt;all;
			}
		}
	}
	Node*get(int d) {
		if (ch[d]) {
			ch[d]-&gt;relax();
		}
		return ch[d];
	}
	bool dir(int t) {
		return p-&gt;ch[t + 1] == this;
	}
	int pos() {
		for (int i = 0; i &lt; 4; ++i) {
			if (p-&gt;ch[i] == this)
				return i;
		}
		return -1;
	}
	void setc(Node*c, int d) {
		ch[d] = c;
		if (c)
			c-&gt;p = this;
	}
	bool isRoot(int t) {
		if (t == 0) {
			return !p || (p-&gt;ch[0] != this &amp;&amp; p-&gt;ch[1] != this);
		} else {
			return !p || !p-&gt;inner || !inner;
		}
	}
};

void rot(Node*u, int t) {
	Node*p = u-&gt;p;
	int d = u-&gt;dir(t);
	if (p-&gt;p)
		p-&gt;p-&gt;setc(u, p-&gt;pos());
	else
		u-&gt;p = 0;
	p-&gt;setc(u-&gt;ch[!d + t], d + t);
	u-&gt;setc(p, !d + t);
	p-&gt;update();
}

void splay(Node*u, int t = 0) {
	while (!u-&gt;isRoot(t)) {
		if (u-&gt;p-&gt;isRoot(t))
			rot(u, t);
		else if (u-&gt;p-&gt;dir(t) == u-&gt;dir(t))
			rot(u-&gt;p, t), rot(u, t);
		else
			rot(u, t), rot(u, t);
	}
	u-&gt;update();
}

void add(Node*u, Node*v) { //put u into v
	v-&gt;relax();
	for (int i = 2; i &lt; 4; ++i) {
		if (!v-&gt;ch[i]) {
			v-&gt;setc(u, i);
			return;
		}
	}
	Node*t = v, *x = new Node;
	for (; t-&gt;ch[2]-&gt;inner; t = t-&gt;get(2))
		;
	x-&gt;setc(t-&gt;ch[2], 2), x-&gt;setc(u, 3);
	t-&gt;setc(x, 2);
	splay(x, 2);
}

void del(Node*u) {
	if (u-&gt;p-&gt;inner) {
		u-&gt;p-&gt;p-&gt;setc(u-&gt;p-&gt;ch[5 - u-&gt;pos()], u-&gt;p-&gt;pos());
		Node*t = u-&gt;p;
		splay(u-&gt;p-&gt;p, 2);
		delete t;
	} else {
		u-&gt;p-&gt;setc(0, u-&gt;pos());
	}
	u-&gt;p = 0;
}

void pushTo(Node*u) {
	static Node*stack[MAX_N * 2];
	int top = 0;
	for (; u; u = u-&gt;p)
		stack[top++] = u;
	while (top)
		stack[--top]-&gt;relax();
}

void expose(Node*u) {
	Node*v = u, *t;
	pushTo(u);
	splay(u);
	if (u-&gt;ch[1]) {
		t = u-&gt;ch[1], u-&gt;ch[1] = 0, add(t, u), u-&gt;update();
	}
	while (u-&gt;p) {
		for (t = u-&gt;p; t-&gt;inner; t = t-&gt;p)
			;
		splay(t);
		if (t-&gt;ch[1])
			u-&gt;p-&gt;setc(t-&gt;ch[1], u-&gt;pos()), splay(u-&gt;p, 2), t-&gt;setc(u, 1);
		else
			del(u), t-&gt;setc(u, 1);
		u = t;
		u-&gt;update();
	}
	splay(v);
}

void makeRoot(Node* u) {
	expose(u);
	u-&gt;applyRev();
}

Node*getPar(Node*u) {
	expose(u);
	u = u-&gt;get(0);
	while (u &amp;&amp; u-&gt;ch[1])
		u = u-&gt;get(1);
	return u;
}

Node*getRoot(Node*u) {
	while (u-&gt;p)
		u = u-&gt;p;
	return u;
}

Node*cut(Node*u) {
	Node*v = getPar(u);
	if (v)
		expose(v), del(u), v-&gt;update();
	return v;
}

void link(Node*u, Node*v) {
	Node*p = cut(u);
	if (getRoot(u) != getRoot(v))
		p = v;
	if (p)
		expose(p), add(u, p), p-&gt;update();
}

int n, nQ;
Node*v[MAX_N];
vector&lt;int&gt; E[MAX_N];

#define BUFSIZE 10000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
int sign;
#define read() \
    do{ \
        if (pt &gt;= pend) \
        { \
            pt = buf; \
            fread(buf, 1, BUFSIZE, stdin); \
        } \
    } while(0)

#define scan(t) \
{ \
    t = 0;sign=1; \
    read(); \
    while ((*pt&lt;'0'||*pt&gt;'9')&amp;&amp;*pt!='-') {pt ++; read();} \
    if(*pt=='-')sign=-1,pt++;\
    while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
    t*=sign;\
}
#define scan_str(s) \
{ \
    int p = 0; \
    read(); \
    while ((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\r') {pt ++; read();}\
    while (!((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\n')) {s[p ++] = (*(pt ++)); read();} \
    s[p] = 0; \
}

int A[20], k;
char p[10000000];
char*opt = p;
inline void printInt(int x) {
	if (x &lt; 0)
		*opt++ = '-', x = -x;
	if (!x)
		*opt++ = '0';
	k = 0;
	while (x)
		A[k++] = x % 10, x /= 10;
	for (int i = k - 1; i &gt;= 0; i--)
		*opt++ = '0' + A[i];
	*opt++ = '\n';
}

void dfs(int u, int par) {
	for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (*e != par) {
			dfs(*e, u);
			add(v[*e], v[u]), v[u]-&gt;update();
		}
	}
}

int main() {
//	freopen("in", "r", stdin);
//	cin &gt;&gt; n &gt;&gt; nQ;
	scan(n);
	scan(nQ);
	for (int i = 0; i &lt; n - 1; ++i) {
		int a, b;
		scan(a);
		scan(b);
		--a, --b;
		E[a].push_back(b), E[b].push_back(a);
	}
	for (int i = 0; i &lt; n; ++i) {
//		scanf("%d", val + i);
		int val;
		scan(val);
		v[i] = new Node(val);
	}
	int rt;
//	cin &gt;&gt; rt;
	scan(rt);
	--rt;
	dfs(rt, -1);
	makeRoot(v[rt]);
	while (nQ--) {
		int k, x;
//		scanf("%d%d", &amp;k, &amp;x), --x;
		scan(k);
		scan(x);
		--x;
		Node*u = v[x];
//		cout &lt;&lt; k &lt;&lt; ":" &lt;&lt; endl;
		if (k == 1) { //change root
			makeRoot(u);
			rt = x;
		} else if (k == 9) { //change x's father to y
			int y;
			scan(y);
			--y;
//			scanf("%d", &amp;y), --y;
			link(u, v[y]);
		} else if (k == 0 || k == 3 || k == 11 || k == 5 || k == 4) {
			//subtree operation
			expose(u);
			if (k == 3 || k == 4 || k == 11) {
				//query
				int ans = u-&gt;val;
				for (int i = 2; i &lt; 4; ++i)
					if (u-&gt;ch[i]) {
						Info&amp;r = u-&gt;ch[i]-&gt;all;
						if (k == 3)
							ans = min(ans, r.minv);
						else if (k == 4)
							ans = max(ans, r.maxv);
						else if (k == 11)
							ans += r.sum;
					}
//				printf("%d\n", ans);
				printInt(ans);
			} else { //change
				int y;
//				scanf("%d", &amp;y);
				scan(y);
				Mark m(k == 5, y);
				u-&gt;val += m;
				for (int i = 2; i &lt; 4; ++i) {
					if (u-&gt;ch[i])
						u-&gt;ch[i]-&gt;applyTree(m);
				}
				u-&gt;update();
			}
		} else {
			//chain operation
			int y;
//			scanf("%d", &amp;y), --y;
			scan(y);
			--y;
			makeRoot(u), expose(v[y]), splay(u);
			if (k == 7 || k == 8 || k == 10) {
				Info&amp;ans = u-&gt;chain;
				if (k == 7)
					printInt(ans.minv);
				else if (k == 8)
					printInt(ans.maxv);
				else if (k == 10)
					printInt(ans.sum);
			} else {
				int z;
//				scanf("%d", &amp;z);
				scan(z);
				u-&gt;applyChain(Mark(k == 6, z));
			}
			makeRoot(v[rt]);
		}
	}
	*opt++ = '\0';
	puts(p);
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
using namespace std;

const int INF = ~0U &gt;&gt; 1, MAX_N = 100000 + 10;

struct Info {
	int size, minv, maxv, sum;
	Info(int size, int minv, int maxv, int sum) :
			size(size), minv(minv), maxv(maxv), sum(sum) {
	}
	Info() :
			size(0), minv(INF), maxv(-INF), sum(0) {
	}
};

const Info EMPTY;

struct Mark {
	int mul, plus;
	Mark(int mul, int plus) :
			mul(mul), plus(plus) {
	}
	Mark() :
			mul(1), plus(0) {
	}
	bool ok() {
		return mul != 1 || plus != 0;
	}
};

inline int apply(int x, const Mark&amp;b) {
	return b.mul * x + b.plus;
}

inline void operator+=(int&amp;x, const Mark&amp;b) {
	x = x * b.mul + b.plus;
}
inline void operator+=(Mark&amp;a, const Mark&amp;b) {
	a.mul *= b.mul;
	a.plus = a.plus * b.mul + b.plus;
//	return Mark(a.mul * b.mul, a.plus * b.mul + b.plus);
}

inline void operator+=(Info&amp;a, const Mark&amp;b) {
	if (a.size == 0)
		return;
	a.minv += b, a.maxv += b;
	a.sum = a.sum * b.mul + a.size * b.plus;
//	return Info(a.size, a.minv + b, a.maxv + b, a.sum * b.mul + a.size * b.plus);
}

inline void operator+=(Info&amp;a, const Info&amp;b) {
	a.size += b.size, a.minv = min(a.minv, b.minv), a.maxv = max(a.maxv,
			b.maxv), a.sum += b.sum;
//	return Info(a.size + b.size, min(a.minv, b.minv), max(a.maxv, b.maxv),
//			a.sum + b.sum);
}

struct Node;

struct Node {
	Node*ch[4], *p;
	Mark chainMark, treeMark;
	Info chain, tree, all;

	bool inner, rev;
	int val;

	Node() :
			p(0), inner(true), rev(false), val(0) { //inner
		memset(ch, 0, sizeof ch);
	}

	Node(int v) :
			p(0), inner(false), rev(false), val(v) {
		memset(ch, 0, sizeof ch);
		update();
	}

	void applyRev() {
		rev ^= 1;
	}

	void applyChain(const Mark&amp;a) {
		chainMark += a, chain += a, val += a;
		all = chain;
		all += tree;
	}

	void applyTree(const Mark&amp;a, bool kd = true) {
		treeMark += a, tree += a, all += a;
		if (kd)
			applyChain(a);
	}

	void relax() {
		if (rev) {
			swap(ch[0], ch[1]);
			for (int i = 0; i &lt; 2; ++i) {
				if (ch[i])
					ch[i]-&gt;applyRev();
			}
			rev = 0;
		}

		if (treeMark.ok()) {
			for (int i = 0; i &lt; 4; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyTree(treeMark, i &gt;= 2);
				}
			treeMark = Mark();
		}

		if (chainMark.ok()) {
			for (int i = 0; i &lt; 2; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyChain(chainMark);
				}
			chainMark = Mark();
		}
	}

	void update() {
		chain = tree = all = EMPTY;
		if (!inner)
			chain = all = Info(1, val, val, val);

		for (int i = 0; i &lt; 4; ++i) {
			if (ch[i])
				all += ch[i]-&gt;all;
		}

		for (int i = 0; i &lt; 2; ++i) {
			if (ch[i]) {
				chain += ch[i]-&gt;chain;
				tree += ch[i]-&gt;tree;
			}
		}

		for (int i = 2; i &lt; 4; ++i) {
			if (ch[i]) {
				tree += ch[i]-&gt;all;
			}
		}
	}
	Node*get(int d) {
		if (ch[d]) {
			ch[d]-&gt;relax();
		}
		return ch[d];
	}
	bool dir(int t) {
		return p-&gt;ch[t + 1] == this;
	}
	int pos() {
		for (int i = 0; i &lt; 4; ++i) {
			if (p-&gt;ch[i] == this)
				return i;
		}
		return -1;
	}
	void setc(Node*c, int d) {
		ch[d] = c;
		if (c)
			c-&gt;p = this;
	}
	bool isRoot(int t) {
		if (t == 0) {
			return !p || (p-&gt;ch[0] != this &amp;&amp; p-&gt;ch[1] != this);
		} else {
			return !p || !p-&gt;inner || !inner;
		}
	}
};

void rot(Node*u, int t) {
	Node*p = u-&gt;p;
	int d = u-&gt;dir(t);
	if (p-&gt;p)
		p-&gt;p-&gt;setc(u, p-&gt;pos());
	else
		u-&gt;p = 0;
	p-&gt;setc(u-&gt;ch[!d + t], d + t);
	u-&gt;setc(p, !d + t);
	p-&gt;update();
}

void splay(Node*u, int t = 0) {
	while (!u-&gt;isRoot(t)) {
		if (u-&gt;p-&gt;isRoot(t))
			rot(u, t);
		else if (u-&gt;p-&gt;dir(t) == u-&gt;dir(t))
			rot(u-&gt;p, t), rot(u, t);
		else
			rot(u, t), rot(u, t);
	}
	u-&gt;update();
}

void add(Node*u, Node*v) { //put u into v
	v-&gt;relax();
	for (int i = 2; i &lt; 4; ++i) {
		if (!v-&gt;ch[i]) {
			v-&gt;setc(u, i);
			return;
		}
	}
	Node*t = v, *x = new Node;
	for (; t-&gt;ch[2]-&gt;inner; t = t-&gt;get(2))
		;
	x-&gt;setc(t-&gt;ch[2], 2), x-&gt;setc(u, 3);
	t-&gt;setc(x, 2);
	splay(x, 2);
}

void del(Node*u) {
	if (u-&gt;p-&gt;inner) {
		u-&gt;p-&gt;p-&gt;setc(u-&gt;p-&gt;ch[5 - u-&gt;pos()], u-&gt;p-&gt;pos());
		Node*t = u-&gt;p;
		splay(u-&gt;p-&gt;p, 2);
		delete t;
	} else {
		u-&gt;p-&gt;setc(0, u-&gt;pos());
	}
	u-&gt;p = 0;
}

void pushTo(Node*u) {
	static Node*stack[MAX_N * 2];
	int top = 0;
	for (; u; u = u-&gt;p)
		stack[top++] = u;
	while (top)
		stack[--top]-&gt;relax();
}

void expose(Node*u) {
	Node*v = u, *t;
	pushTo(u);
	splay(u);
	if (u-&gt;ch[1]) {
		t = u-&gt;ch[1], u-&gt;ch[1] = 0, add(t, u), u-&gt;update();
	}
	while (u-&gt;p) {
		for (t = u-&gt;p; t-&gt;inner; t = t-&gt;p)
			;
		splay(t);
		if (t-&gt;ch[1])
			u-&gt;p-&gt;setc(t-&gt;ch[1], u-&gt;pos()), splay(u-&gt;p, 2), t-&gt;setc(u, 1);
		else
			del(u), t-&gt;setc(u, 1);
		u = t;
		u-&gt;update();
	}
	splay(v);
}

void makeRoot(Node* u) {
	expose(u);
	u-&gt;applyRev();
}

Node*getPar(Node*u) {
	expose(u);
	u = u-&gt;get(0);
	while (u &amp;&amp; u-&gt;ch[1])
		u = u-&gt;get(1);
	return u;
}

Node*getRoot(Node*u) {
	while (u-&gt;p)
		u = u-&gt;p;
	return u;
}

Node*cut(Node*u) {
	Node*v = getPar(u);
	if (v)
		expose(v), del(u), v-&gt;update();
	return v;
}

void link(Node*u, Node*v) {
	Node*p = cut(u);
	if (getRoot(u) != getRoot(v))
		p = v;
	if (p)
		expose(p), add(u, p), p-&gt;update();
}

int n, nQ;
Node*v[MAX_N];
vector&lt;int&gt; E[MAX_N];

#define BUFSIZE 10000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
int sign;
#define read() \
    do{ \
        if (pt &gt;= pend) \
        { \
            pt = buf; \
            fread(buf, 1, BUFSIZE, stdin); \
        } \
    } while(0)

#define scan(t) \
{ \
    t = 0;sign=1; \
    read(); \
    while ((*pt&lt;'0'||*pt&gt;'9')&amp;&amp;*pt!='-') {pt ++; read();} \
    if(*pt=='-')sign=-1,pt++;\
    while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
    t*=sign;\
}
#define scan_str(s) \
{ \
    int p = 0; \
    read(); \
    while ((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\r') {pt ++; read();}\
    while (!((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\n')) {s[p ++] = (*(pt ++)); read();} \
    s[p] = 0; \
}

int A[20], k;
char p[10000000];
char*opt = p;
inline void printInt(int x) {
	if (x &lt; 0)
		*opt++ = '-', x = -x;
	if (!x)
		*opt++ = '0';
	k = 0;
	while (x)
		A[k++] = x % 10, x /= 10;
	for (int i = k - 1; i &gt;= 0; i--)
		*opt++ = '0' + A[i];
	*opt++ = '\n';
}

void dfs(int u, int par) {
	for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (*e != par) {
			dfs(*e, u);
			add(v[*e], v[u]), v[u]-&gt;update();
		}
	}
}

int main() {
//	freopen("in", "r", stdin);
//	cin &gt;&gt; n &gt;&gt; nQ;
	scan(n);
	scan(nQ);
	for (int i = 0; i &lt; n - 1; ++i) {
		int a, b;
		scan(a);
		scan(b);
		--a, --b;
		E[a].push_back(b), E[b].push_back(a);
	}
	for (int i = 0; i &lt; n; ++i) {
//		scanf("%d", val + i);
		int val;
		scan(val);
		v[i] = new Node(val);
	}
	int rt;
//	cin &gt;&gt; rt;
	scan(rt);
	--rt;
	dfs(rt, -1);
	makeRoot(v[rt]);
	while (nQ--) {
		int k, x;
//		scanf("%d%d", &amp;k, &amp;x), --x;
		scan(k);
		scan(x);
		--x;
		Node*u = v[x];
//		cout &lt;&lt; k &lt;&lt; ":" &lt;&lt; endl;
		if (k == 1) { //change root
			makeRoot(u);
			rt = x;
		} else if (k == 9) { //change x's father to y
			int y;
			scan(y);
			--y;
//			scanf("%d", &amp;y), --y;
			link(u, v[y]);
		} else if (k == 0 || k == 3 || k == 11 || k == 5 || k == 4) {
			//subtree operation
			expose(u);
			if (k == 3 || k == 4 || k == 11) {
				//query
				int ans = u-&gt;val;
				for (int i = 2; i &lt; 4; ++i)
					if (u-&gt;ch[i]) {
						Info&amp;r = u-&gt;ch[i]-&gt;all;
						if (k == 3)
							ans = min(ans, r.minv);
						else if (k == 4)
							ans = max(ans, r.maxv);
						else if (k == 11)
							ans += r.sum;
					}
//				printf("%d\n", ans);
				printInt(ans);
			} else { //change
				int y;
//				scanf("%d", &amp;y);
				scan(y);
				Mark m(k == 5, y);
				u-&gt;val += m;
				for (int i = 2; i &lt; 4; ++i) {
					if (u-&gt;ch[i])
						u-&gt;ch[i]-&gt;applyTree(m);
				}
				u-&gt;update();
			}
		} else {
			//chain operation
			int y;
//			scanf("%d", &amp;y), --y;
			scan(y);
			--y;
			makeRoot(u), expose(v[y]), splay(u);
			if (k == 7 || k == 8 || k == 10) {
				Info&amp;ans = u-&gt;chain;
				if (k == 7)
					printInt(ans.minv);
				else if (k == 8)
					printInt(ans.maxv);
				else if (k == 10)
					printInt(ans.sum);
			} else {
				int z;
//				scanf("%d", &amp;z);
				scan(z);
				u-&gt;applyChain(Mark(k == 6, z));
			}
			makeRoot(v[rt]);
		}
	}
	*opt++ = '\0';
	puts(p);
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
using namespace std;

const int INF = ~0U &gt;&gt; 1, MAX_N = 100000 + 10;

struct Info {
	int size, minv, maxv, sum;
	Info(int size, int minv, int maxv, int sum) :
			size(size), minv(minv), maxv(maxv), sum(sum) {
	}
	Info() :
			size(0), minv(INF), maxv(-INF), sum(0) {
	}
};

const Info EMPTY;

struct Mark {
	int mul, plus;
	Mark(int mul, int plus) :
			mul(mul), plus(plus) {
	}
	Mark() :
			mul(1), plus(0) {
	}
	bool ok() {
		return mul != 1 || plus != 0;
	}
};

inline int apply(int x, const Mark&amp;b) {
	return b.mul * x + b.plus;
}

inline void operator+=(int&amp;x, const Mark&amp;b) {
	x = x * b.mul + b.plus;
}
inline void operator+=(Mark&amp;a, const Mark&amp;b) {
	a.mul *= b.mul;
	a.plus = a.plus * b.mul + b.plus;
//	return Mark(a.mul * b.mul, a.plus * b.mul + b.plus);
}

inline void operator+=(Info&amp;a, const Mark&amp;b) {
	if (a.size == 0)
		return;
	a.minv += b, a.maxv += b;
	a.sum = a.sum * b.mul + a.size * b.plus;
//	return Info(a.size, a.minv + b, a.maxv + b, a.sum * b.mul + a.size * b.plus);
}

inline void operator+=(Info&amp;a, const Info&amp;b) {
	a.size += b.size, a.minv = min(a.minv, b.minv), a.maxv = max(a.maxv,
			b.maxv), a.sum += b.sum;
//	return Info(a.size + b.size, min(a.minv, b.minv), max(a.maxv, b.maxv),
//			a.sum + b.sum);
}

struct Node;

struct Node {
	Node*ch[4], *p;
	Mark chainMark, treeMark;
	Info chain, tree, all;

	bool inner, rev;
	int val;

	Node() :
			p(0), inner(true), rev(false), val(0) { //inner
		memset(ch, 0, sizeof ch);
	}

	Node(int v) :
			p(0), inner(false), rev(false), val(v) {
		memset(ch, 0, sizeof ch);
		update();
	}

	void applyRev() {
		rev ^= 1;
	}

	void applyChain(const Mark&amp;a) {
		chainMark += a, chain += a, val += a;
		all = chain;
		all += tree;
	}

	void applyTree(const Mark&amp;a, bool kd = true) {
		treeMark += a, tree += a, all += a;
		if (kd)
			applyChain(a);
	}

	void relax() {
		if (rev) {
			swap(ch[0], ch[1]);
			for (int i = 0; i &lt; 2; ++i) {
				if (ch[i])
					ch[i]-&gt;applyRev();
			}
			rev = 0;
		}

		if (treeMark.ok()) {
			for (int i = 0; i &lt; 4; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyTree(treeMark, i &gt;= 2);
				}
			treeMark = Mark();
		}

		if (chainMark.ok()) {
			for (int i = 0; i &lt; 2; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyChain(chainMark);
				}
			chainMark = Mark();
		}
	}

	void update() {
		chain = tree = all = EMPTY;
		if (!inner)
			chain = all = Info(1, val, val, val);

		for (int i = 0; i &lt; 4; ++i) {
			if (ch[i])
				all += ch[i]-&gt;all;
		}

		for (int i = 0; i &lt; 2; ++i) {
			if (ch[i]) {
				chain += ch[i]-&gt;chain;
				tree += ch[i]-&gt;tree;
			}
		}

		for (int i = 2; i &lt; 4; ++i) {
			if (ch[i]) {
				tree += ch[i]-&gt;all;
			}
		}
	}
	Node*get(int d) {
		if (ch[d]) {
			ch[d]-&gt;relax();
		}
		return ch[d];
	}
	bool dir(int t) {
		return p-&gt;ch[t + 1] == this;
	}
	int pos() {
		for (int i = 0; i &lt; 4; ++i) {
			if (p-&gt;ch[i] == this)
				return i;
		}
		return -1;
	}
	void setc(Node*c, int d) {
		ch[d] = c;
		if (c)
			c-&gt;p = this;
	}
	bool isRoot(int t) {
		if (t == 0) {
			return !p || (p-&gt;ch[0] != this &amp;&amp; p-&gt;ch[1] != this);
		} else {
			return !p || !p-&gt;inner || !inner;
		}
	}
};

void rot(Node*u, int t) {
	Node*p = u-&gt;p;
	int d = u-&gt;dir(t);
	if (p-&gt;p)
		p-&gt;p-&gt;setc(u, p-&gt;pos());
	else
		u-&gt;p = 0;
	p-&gt;setc(u-&gt;ch[!d + t], d + t);
	u-&gt;setc(p, !d + t);
	p-&gt;update();
}

void splay(Node*u, int t = 0) {
	while (!u-&gt;isRoot(t)) {
		if (u-&gt;p-&gt;isRoot(t))
			rot(u, t);
		else if (u-&gt;p-&gt;dir(t) == u-&gt;dir(t))
			rot(u-&gt;p, t), rot(u, t);
		else
			rot(u, t), rot(u, t);
	}
	u-&gt;update();
}

void add(Node*u, Node*v) { //put u into v
	v-&gt;relax();
	for (int i = 2; i &lt; 4; ++i) {
		if (!v-&gt;ch[i]) {
			v-&gt;setc(u, i);
			return;
		}
	}
	Node*t = v, *x = new Node;
	for (; t-&gt;ch[2]-&gt;inner; t = t-&gt;get(2))
		;
	x-&gt;setc(t-&gt;ch[2], 2), x-&gt;setc(u, 3);
	t-&gt;setc(x, 2);
	splay(x, 2);
}

void del(Node*u) {
	if (u-&gt;p-&gt;inner) {
		u-&gt;p-&gt;p-&gt;setc(u-&gt;p-&gt;ch[5 - u-&gt;pos()], u-&gt;p-&gt;pos());
		Node*t = u-&gt;p;
		splay(u-&gt;p-&gt;p, 2);
		delete t;
	} else {
		u-&gt;p-&gt;setc(0, u-&gt;pos());
	}
	u-&gt;p = 0;
}

void pushTo(Node*u) {
	static Node*stack[MAX_N * 2];
	int top = 0;
	for (; u; u = u-&gt;p)
		stack[top++] = u;
	while (top)
		stack[--top]-&gt;relax();
}

void expose(Node*u) {
	Node*v = u, *t;
	pushTo(u);
	splay(u);
	if (u-&gt;ch[1]) {
		t = u-&gt;ch[1], u-&gt;ch[1] = 0, add(t, u), u-&gt;update();
	}
	while (u-&gt;p) {
		for (t = u-&gt;p; t-&gt;inner; t = t-&gt;p)
			;
		splay(t);
		if (t-&gt;ch[1])
			u-&gt;p-&gt;setc(t-&gt;ch[1], u-&gt;pos()), splay(u-&gt;p, 2), t-&gt;setc(u, 1);
		else
			del(u), t-&gt;setc(u, 1);
		u = t;
		u-&gt;update();
	}
	splay(v);
}

void makeRoot(Node* u) {
	expose(u);
	u-&gt;applyRev();
}

Node*getPar(Node*u) {
	expose(u);
	u = u-&gt;get(0);
	while (u &amp;&amp; u-&gt;ch[1])
		u = u-&gt;get(1);
	return u;
}

Node*getRoot(Node*u) {
	while (u-&gt;p)
		u = u-&gt;p;
	return u;
}

Node*cut(Node*u) {
	Node*v = getPar(u);
	if (v)
		expose(v), del(u), v-&gt;update();
	return v;
}

Node*getChainRoot(Node*u) {
	while (!u-&gt;isRoot(0))
		u = u-&gt;p;
	return u;
}

void link(Node*u, Node*v) {
//	Node*p = cut(u);
//	if (getRoot(u) != getRoot(v))
//		p = v;
//	if (p)
//		expose(p), add(u, p), p-&gt;update();
	expose(v);
	if (getChainRoot(u) == v)
		return;
	cut(u);
	expose(v), add(u, v), v-&gt;update();
}

int n, nQ;
Node*v[MAX_N];
vector&lt;int&gt; E[MAX_N];

#define BUFSIZE 10000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
int sign;
#define read() \
    do{ \
        if (pt &gt;= pend) \
        { \
            pt = buf; \
            fread(buf, 1, BUFSIZE, stdin); \
        } \
    } while(0)

#define scan(t) \
{ \
    t = 0;sign=1; \
    read(); \
    while ((*pt&lt;'0'||*pt&gt;'9')&amp;&amp;*pt!='-') {pt ++; read();} \
    if(*pt=='-')sign=-1,pt++;\
    while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
    t*=sign;\
}
#define scan_str(s) \
{ \
    int p = 0; \
    read(); \
    while ((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\r') {pt ++; read();}\
    while (!((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\n')) {s[p ++] = (*(pt ++)); read();} \
    s[p] = 0; \
}

int A[20], k;
char p[10000000];
char*opt = p;
inline void printInt(int x) {
	if (x &lt; 0)
		*opt++ = '-', x = -x;
	if (!x)
		*opt++ = '0';
	k = 0;
	while (x)
		A[k++] = x % 10, x /= 10;
	for (int i = k - 1; i &gt;= 0; i--)
		*opt++ = '0' + A[i];
	*opt++ = '\n';
}

void dfs(int u, int par) {
	for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (*e != par) {
			dfs(*e, u);
			add(v[*e], v[u]), v[u]-&gt;update();
		}
	}
}

int main() {
//	freopen("in", "r", stdin);
//	cin &gt;&gt; n &gt;&gt; nQ;
	scan(n);
	scan(nQ);
	for (int i = 0; i &lt; n - 1; ++i) {
		int a, b;
		scan(a);
		scan(b);
		--a, --b;
		E[a].push_back(b), E[b].push_back(a);
	}
	for (int i = 0; i &lt; n; ++i) {
//		scanf("%d", val + i);
		int val;
		scan(val);
		v[i] = new Node(val);
	}
	int rt;
//	cin &gt;&gt; rt;
	scan(rt);
	--rt;
	dfs(rt, -1);
	makeRoot(v[rt]);
	while (nQ--) {
		int k, x;
//		scanf("%d%d", &amp;k, &amp;x), --x;
		scan(k);
		scan(x);
		--x;
		Node*u = v[x];
//		cout &lt;&lt; k &lt;&lt; ":" &lt;&lt; endl;
		if (k == 1) { //change root
			makeRoot(u);
			rt = x;
		} else if (k == 9) { //change x's father to y
			int y;
			scan(y);
			--y;
//			scanf("%d", &amp;y), --y;
			link(u, v[y]);
		} else if (k == 0 || k == 3 || k == 11 || k == 5 || k == 4) {
			//subtree operation
			expose(u);
			if (k == 3 || k == 4 || k == 11) {
				//query
				int ans = u-&gt;val;
				for (int i = 2; i &lt; 4; ++i)
					if (u-&gt;ch[i]) {
						Info&amp;r = u-&gt;ch[i]-&gt;all;
						if (k == 3)
							ans = min(ans, r.minv);
						else if (k == 4)
							ans = max(ans, r.maxv);
						else if (k == 11)
							ans += r.sum;
					}
//				printf("%d\n", ans);
				printInt(ans);
			} else { //change
				int y;
//				scanf("%d", &amp;y);
				scan(y);
				Mark m(k == 5, y);
				u-&gt;val += m;
				for (int i = 2; i &lt; 4; ++i) {
					if (u-&gt;ch[i])
						u-&gt;ch[i]-&gt;applyTree(m);
				}
				u-&gt;update();
			}
		} else {
			//chain operation
			int y;
//			scanf("%d", &amp;y), --y;
			scan(y);
			--y;
			makeRoot(u), expose(v[y]), splay(u);
			if (k == 7 || k == 8 || k == 10) {
				Info&amp;ans = u-&gt;chain;
				if (k == 7)
					printInt(ans.minv);
				else if (k == 8)
					printInt(ans.maxv);
				else if (k == 10)
					printInt(ans.sum);
			} else {
				int z;
//				scanf("%d", &amp;z);
				scan(z);
				u-&gt;applyChain(Mark(k == 6, z));
			}
			makeRoot(v[rt]);
		}
	}
	*opt++ = '\0';
	puts(p);
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
using namespace std;

const int INF = ~0U &gt;&gt; 1, MAX_N = 100000 + 10;

struct Info {
	int size, minv, maxv, sum;
	Info(int size, int minv, int maxv, int sum) :
			size(size), minv(minv), maxv(maxv), sum(sum) {
	}
	Info() :
			size(0), minv(INF), maxv(-INF), sum(0) {
	}
};

const Info EMPTY;

struct Mark {
	int mul, plus;
	Mark(int mul, int plus) :
			mul(mul), plus(plus) {
	}
	Mark() :
			mul(1), plus(0) {
	}
	bool ok() {
		return mul != 1 || plus != 0;
	}
};

inline int apply(int x, const Mark&amp;b) {
	return b.mul * x + b.plus;
}

inline void operator+=(int&amp;x, const Mark&amp;b) {
	x = x * b.mul + b.plus;
}
inline void operator+=(Mark&amp;a, const Mark&amp;b) {
	a.mul *= b.mul;
	a.plus = a.plus * b.mul + b.plus;
//	return Mark(a.mul * b.mul, a.plus * b.mul + b.plus);
}

inline void operator+=(Info&amp;a, const Mark&amp;b) {
	if (a.size == 0)
		return;
	a.minv += b, a.maxv += b;
	a.sum = a.sum * b.mul + a.size * b.plus;
//	return Info(a.size, a.minv + b, a.maxv + b, a.sum * b.mul + a.size * b.plus);
}

inline void operator+=(Info&amp;a, const Info&amp;b) {
	a.size += b.size, a.minv = min(a.minv, b.minv), a.maxv = max(a.maxv,
			b.maxv), a.sum += b.sum;
//	return Info(a.size + b.size, min(a.minv, b.minv), max(a.maxv, b.maxv),
//			a.sum + b.sum);
}

struct Node;

struct Node {
	Node*ch[4], *p;
	Mark chainMark, treeMark;
	Info chain, tree, all;

	bool inner, rev;
	int val;

	Node() :
			p(0), inner(true), rev(false), val(0) { //inner
		memset(ch, 0, sizeof ch);
	}

	Node(int v) :
			p(0), inner(false), rev(false), val(v) {
		memset(ch, 0, sizeof ch);
		update();
	}

	void applyRev() {
		rev ^= 1;
	}

	void applyChain(const Mark&amp;a) {
		chainMark += a, chain += a, val += a;
		all = chain;
		all += tree;
	}

	void applyTree(const Mark&amp;a, bool kd = true) {
		treeMark += a, tree += a, all += a;
		if (kd)
			applyChain(a);
	}

	void relax() {
		if (rev) {
			swap(ch[0], ch[1]);
			for (int i = 0; i &lt; 2; ++i) {
				if (ch[i])
					ch[i]-&gt;applyRev();
			}
			rev = 0;
		}

		if (treeMark.ok()) {
			for (int i = 0; i &lt; 4; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyTree(treeMark, i &gt;= 2);
				}
			treeMark = Mark();
		}

		if (chainMark.ok()) {
			for (int i = 0; i &lt; 2; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyChain(chainMark);
				}
			chainMark = Mark();
		}
	}

	void update() {
		chain = tree = all = EMPTY;
		if (!inner)
			chain = all = Info(1, val, val, val);

		for (int i = 0; i &lt; 2; ++i) {
			if (ch[i]) {
				chain += ch[i]-&gt;chain;
				tree += ch[i]-&gt;tree;
			}
		}

		for (int i = 2; i &lt; 4; ++i) {
			if (ch[i]) {
				tree += ch[i]-&gt;all;
			}
		}

		all = chain, all += tree;
	}
	Node*get(int d) {
		if (ch[d]) {
			ch[d]-&gt;relax();
		}
		return ch[d];
	}
	bool dir(int t) {
		return p-&gt;ch[t + 1] == this;
	}
	int pos() {
		for (int i = 0; i &lt; 4; ++i) {
			if (p-&gt;ch[i] == this)
				return i;
		}
		return -1;
	}
	void setc(Node*c, int d) {
		ch[d] = c;
		if (c)
			c-&gt;p = this;
	}
	bool isRoot(int t) {
		if (t == 0) {
			return !p || (p-&gt;ch[0] != this &amp;&amp; p-&gt;ch[1] != this);
		} else {
			return !p || !p-&gt;inner || !inner;
		}
	}
};

void rot(Node*u, int t) {
	Node*p = u-&gt;p;
	int d = u-&gt;dir(t);
	if (p-&gt;p)
		p-&gt;p-&gt;setc(u, p-&gt;pos());
	else
		u-&gt;p = 0;
	p-&gt;setc(u-&gt;ch[!d + t], d + t);
	u-&gt;setc(p, !d + t);
	p-&gt;update();
}

void splay(Node*u, int t = 0) {
	while (!u-&gt;isRoot(t)) {
		if (u-&gt;p-&gt;isRoot(t))
			rot(u, t);
		else if (u-&gt;p-&gt;dir(t) == u-&gt;dir(t))
			rot(u-&gt;p, t), rot(u, t);
		else
			rot(u, t), rot(u, t);
	}
	u-&gt;update();
}

void add(Node*u, Node*v) { //put u into v
	v-&gt;relax();
	for (int i = 2; i &lt; 4; ++i) {
		if (!v-&gt;ch[i]) {
			v-&gt;setc(u, i);
			return;
		}
	}
	Node*t = v, *x = new Node;
	for (; t-&gt;ch[2]-&gt;inner; t = t-&gt;get(2))
		;
	x-&gt;setc(t-&gt;ch[2], 2), x-&gt;setc(u, 3);
	t-&gt;setc(x, 2);
	splay(x, 2);
}

void del(Node*u) {
	if (u-&gt;p-&gt;inner) {
		u-&gt;p-&gt;p-&gt;setc(u-&gt;p-&gt;ch[5 - u-&gt;pos()], u-&gt;p-&gt;pos());
		Node*t = u-&gt;p;
		splay(u-&gt;p-&gt;p, 2);
		delete t;
	} else {
		u-&gt;p-&gt;setc(0, u-&gt;pos());
	}
	u-&gt;p = 0;
}

void pushTo(Node*u) {
	static Node*stack[MAX_N * 2];
	int top = 0;
	for (; u; u = u-&gt;p)
		stack[top++] = u;
	while (top)
		stack[--top]-&gt;relax();
}

void expose(Node*u) {
	Node*v = u, *t;
	pushTo(u);
	splay(u);
	if (u-&gt;ch[1]) {
		t = u-&gt;ch[1], u-&gt;ch[1] = 0, add(t, u), u-&gt;update();
	}
	while (u-&gt;p) {
		for (t = u-&gt;p; t-&gt;inner; t = t-&gt;p)
			;
		splay(t);
		if (t-&gt;ch[1])
			u-&gt;p-&gt;setc(t-&gt;ch[1], u-&gt;pos()), splay(u-&gt;p, 2), t-&gt;setc(u, 1);
		else
			del(u), t-&gt;setc(u, 1);
		u = t;
		u-&gt;update();
	}
	splay(v);
}

void makeRoot(Node* u) {
	expose(u);
	u-&gt;applyRev();
}

Node*getPar(Node*u) {
	expose(u);
	u = u-&gt;get(0);
	while (u &amp;&amp; u-&gt;ch[1])
		u = u-&gt;get(1);
	return u;
}

Node*getRoot(Node*u) {
	while (u-&gt;p)
		u = u-&gt;p;
	return u;
}

Node*cut(Node*u) {
	Node*v = getPar(u);
	if (v)
		expose(v), del(u), v-&gt;update();
	return v;
}

void link(Node*u, Node*v) {
	Node*p = cut(u);
	if (getRoot(u) != getRoot(v))
		p = v;
	if (p)
		expose(p), add(u, p), p-&gt;update();
}

int n, nQ;
Node*v[MAX_N];
vector&lt;int&gt; E[MAX_N];

#define BUFSIZE 10000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
int sign;
#define read() \
    do{ \
        if (pt &gt;= pend) \
        { \
            pt = buf; \
            fread(buf, 1, BUFSIZE, stdin); \
        } \
    } while(0)

#define scan(t) \
{ \
    t = 0;sign=1; \
    read(); \
    while ((*pt&lt;'0'||*pt&gt;'9')&amp;&amp;*pt!='-') {pt ++; read();} \
    if(*pt=='-')sign=-1,pt++;\
    while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
    t*=sign;\
}
#define scan_str(s) \
{ \
    int p = 0; \
    read(); \
    while ((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\r') {pt ++; read();}\
    while (!((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\n')) {s[p ++] = (*(pt ++)); read();} \
    s[p] = 0; \
}

int A[20], k;
char p[10000000];
char*opt = p;
inline void printInt(int x) {
	if (x &lt; 0)
		*opt++ = '-', x = -x;
	if (!x)
		*opt++ = '0';
	k = 0;
	while (x)
		A[k++] = x % 10, x /= 10;
	for (int i = k - 1; i &gt;= 0; i--)
		*opt++ = '0' + A[i];
	*opt++ = '\n';
}

void dfs(int u, int par) {
	for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (*e != par) {
			dfs(*e, u);
			add(v[*e], v[u]), v[u]-&gt;update();
		}
	}
}

int main() {
//	freopen("in", "r", stdin);
//	cin &gt;&gt; n &gt;&gt; nQ;
	scan(n);
	scan(nQ);
	for (int i = 0; i &lt; n - 1; ++i) {
		int a, b;
		scan(a);
		scan(b);
		--a, --b;
		E[a].push_back(b), E[b].push_back(a);
	}
	for (int i = 0; i &lt; n; ++i) {
//		scanf("%d", val + i);
		int val;
		scan(val);
		v[i] = new Node(val);
	}
	int rt;
//	cin &gt;&gt; rt;
	scan(rt);
	--rt;
	dfs(rt, -1);
	makeRoot(v[rt]);
	while (nQ--) {
		int k, x;
//		scanf("%d%d", &amp;k, &amp;x), --x;
		scan(k);
		scan(x);
		--x;
		Node*u = v[x];
//		cout &lt;&lt; k &lt;&lt; ":" &lt;&lt; endl;
		if (k == 1) { //change root
			makeRoot(u);
			rt = x;
		} else if (k == 9) { //change x's father to y
			int y;
			scan(y);
			--y;
//			scanf("%d", &amp;y), --y;
			link(u, v[y]);
		} else if (k == 0 || k == 3 || k == 11 || k == 5 || k == 4) {
			//subtree operation
			expose(u);
			if (k == 3 || k == 4 || k == 11) {
				//query
				int ans = u-&gt;val;
				for (int i = 2; i &lt; 4; ++i)
					if (u-&gt;ch[i]) {
						Info&amp;r = u-&gt;ch[i]-&gt;all;
						if (k == 3)
							ans = min(ans, r.minv);
						else if (k == 4)
							ans = max(ans, r.maxv);
						else if (k == 11)
							ans += r.sum;
					}
//				printf("%d\n", ans);
				printInt(ans);
			} else { //change
				int y;
//				scanf("%d", &amp;y);
				scan(y);
				Mark m(k == 5, y);
				u-&gt;val += m;
				for (int i = 2; i &lt; 4; ++i) {
					if (u-&gt;ch[i])
						u-&gt;ch[i]-&gt;applyTree(m);
				}
				u-&gt;update();
			}
		} else {
			//chain operation
			int y;
//			scanf("%d", &amp;y), --y;
			scan(y);
			--y;
			makeRoot(u), expose(v[y]), splay(u);
			if (k == 7 || k == 8 || k == 10) {
				Info&amp;ans = u-&gt;chain;
				if (k == 7)
					printInt(ans.minv);
				else if (k == 8)
					printInt(ans.maxv);
				else if (k == 10)
					printInt(ans.sum);
			} else {
				int z;
//				scanf("%d", &amp;z);
				scan(z);
				u-&gt;applyChain(Mark(k == 6, z));
			}
			makeRoot(v[rt]);
		}
	}
	*opt++ = '\0';
	puts(p);
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
using namespace std;

const int INF = ~0U &gt;&gt; 1, MAX_N = 100000 + 10;

struct Info {
	int size, minv, maxv, sum;
	Info(int size, int minv, int maxv, int sum) :
			size(size), minv(minv), maxv(maxv), sum(sum) {
	}
	Info() :
			size(0), minv(INF), maxv(-INF), sum(0) {
	}
};

const Info EMPTY;

struct Mark {
	int mul, plus;
	Mark(int mul, int plus) :
			mul(mul), plus(plus) {
	}
	Mark() :
			mul(1), plus(0) {
	}
	bool ok() {
		return mul != 1 || plus != 0;
	}
};

inline int apply(int x, const Mark&amp;b) {
	return b.mul * x + b.plus;
}

inline void operator+=(int&amp;x, const Mark&amp;b) {
	x = x * b.mul + b.plus;
}
inline void operator+=(Mark&amp;a, const Mark&amp;b) {
	a.mul *= b.mul;
	a.plus = a.plus * b.mul + b.plus;

}

inline void operator+=(Info&amp;a, const Mark&amp;b) {
	if (a.size == 0)
		return;
	a.minv += b, a.maxv += b;
	a.sum = a.sum * b.mul + a.size * b.plus;
}

inline void operator+=(Info&amp;a, const Info&amp;b) {
	if (a.size == 0) {
		a = b;
		return;
	}
	a.size += b.size, a.minv = min(a.minv, b.minv), a.maxv = max(a.maxv,
			b.maxv), a.sum += b.sum;
}

struct Node;

struct Node {
	Node*ch[4], *p;
	Mark chainMark, treeMark;
	Info chain, tree, all;

	bool inner, rev;
	int val;

	Node() :
			p(0), inner(true), rev(false), val(0) {
		memset(ch, 0, sizeof ch);
	}

	Node(int v) :
			p(0), inner(false), rev(false), val(v) {
		memset(ch, 0, sizeof ch);
		update();
	}

	void applyRev() {
		rev ^= 1;
	}

	void applyChain(const Mark&amp;a) {
		chainMark += a, chain += a, val += a;
		all = chain;
		all += tree;
	}

	void applyTree(const Mark&amp;a, bool kd = true) {
		treeMark += a, tree += a, all += a;
		if (kd)
			applyChain(a);
	}

	void relax() {
		if (rev) {
			swap(ch[0], ch[1]);
			for (int i = 0; i &lt; 2; ++i) {
				if (ch[i])
					ch[i]-&gt;applyRev();
			}
			rev = 0;
		}

		if (treeMark.ok()) {
			for (int i = 0; i &lt; 4; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyTree(treeMark, i &gt;= 2);
				}
			treeMark = Mark();
		}

		if (chainMark.ok()) {
			for (int i = 0; i &lt; 2; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyChain(chainMark);
				}
			chainMark = Mark();
		}
	}

	void update() {
		chain = tree = all = EMPTY;
		if (!inner)
			chain = all = Info(1, val, val, val);

		for (int i = 0; i &lt; 2; ++i) {
			if (ch[i]) {
				chain += ch[i]-&gt;chain;
				tree += ch[i]-&gt;tree;
			}
		}

		for (int i = 2; i &lt; 4; ++i) {
			if (ch[i]) {
				tree += ch[i]-&gt;all;
			}
		}

		all = chain, all += tree;
	}
	Node*get(int d) {
		if (ch[d]) {
			ch[d]-&gt;relax();
		}
		return ch[d];
	}
	bool dir(int t) {
		return p-&gt;ch[t + 1] == this;
	}
	int pos() {
		for (int i = 0; i &lt; 4; ++i) {
			if (p-&gt;ch[i] == this)
				return i;
		}
		return -1;
	}
	void setc(Node*c, int d) {
		ch[d] = c;
		if (c)
			c-&gt;p = this;
	}
	bool isRoot(int t) {
		if (t == 0) {
			return !p || (p-&gt;ch[0] != this &amp;&amp; p-&gt;ch[1] != this);
		} else {
			return !p || !p-&gt;inner || !inner;
		}
	}
};

void rot(Node*u, int t) {
	Node*p = u-&gt;p;
	int d = u-&gt;dir(t);
	if (p-&gt;p)
		p-&gt;p-&gt;setc(u, p-&gt;pos());
	else
		u-&gt;p = 0;
	p-&gt;setc(u-&gt;ch[!d + t], d + t);
	u-&gt;setc(p, !d + t);
	p-&gt;update();
}

void splay(Node*u, int t = 0) {
	while (!u-&gt;isRoot(t)) {
		if (u-&gt;p-&gt;isRoot(t))
			rot(u, t);
		else if (u-&gt;p-&gt;dir(t) == u-&gt;dir(t))
			rot(u-&gt;p, t), rot(u, t);
		else
			rot(u, t), rot(u, t);
	}
	u-&gt;update();
}

void add(Node*u, Node*v) {
	v-&gt;relax();
	for (int i = 2; i &lt; 4; ++i) {
		if (!v-&gt;ch[i]) {
			v-&gt;setc(u, i);
			return;
		}
	}
	Node*t = v, *x = new Node;
	for (; t-&gt;ch[2]-&gt;inner; t = t-&gt;get(2))
		;
	x-&gt;setc(t-&gt;ch[2], 2), x-&gt;setc(u, 3);
	t-&gt;setc(x, 2);
	splay(x, 2);
}

void del(Node*u) {
	if (u-&gt;p-&gt;inner) {
		u-&gt;p-&gt;p-&gt;setc(u-&gt;p-&gt;ch[5 - u-&gt;pos()], u-&gt;p-&gt;pos());
		Node*t = u-&gt;p;
		splay(u-&gt;p-&gt;p, 2);
		delete t;
	} else {
		u-&gt;p-&gt;setc(0, u-&gt;pos());
	}
	u-&gt;p = 0;
}

void pushTo(Node*u) {
	static Node*stack[MAX_N * 2];
	int top = 0;
	for (; u; u = u-&gt;p)
		stack[top++] = u;
	while (top)
		stack[--top]-&gt;relax();
}

void expose(Node*u) {
	Node*v = u, *t;
	pushTo(u);
	splay(u);
	if (u-&gt;ch[1]) {
		t = u-&gt;ch[1], u-&gt;ch[1] = 0, add(t, u), u-&gt;update();
	}
	while (u-&gt;p) {
		for (t = u-&gt;p; t-&gt;inner; t = t-&gt;p)
			;
		splay(t);
		if (t-&gt;ch[1])
			u-&gt;p-&gt;setc(t-&gt;ch[1], u-&gt;pos()), splay(u-&gt;p, 2), t-&gt;setc(u, 1);
		else
			del(u), t-&gt;setc(u, 1);
		u = t;
		u-&gt;update();
	}
	splay(v);
}

void makeRoot(Node* u) {
	expose(u);
	u-&gt;applyRev();
}

Node*getPar(Node*u) {
	expose(u);
	u = u-&gt;get(0);
	while (u &amp;&amp; u-&gt;ch[1])
		u = u-&gt;get(1);
	return u;
}

Node*getRoot(Node*u) {
	while (u-&gt;p)
		u = u-&gt;p;
	return u;
}

Node*cut(Node*u) {
	Node*v = getPar(u);
	if (v)
		expose(v), del(u), v-&gt;update();
	return v;
}

void link(Node*u, Node*v) {
	Node*p = cut(u);
	if (getRoot(u) != getRoot(v))
		p = v;
	if (p)
		expose(p), add(u, p), p-&gt;update();
}

int n, nQ;
Node*v[MAX_N];
vector&lt;int&gt; E[MAX_N];

#define BUFSIZE 10000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
int sign;
#define read() \
    do{ \
        if (pt &gt;= pend) \
        { \
            pt = buf; \
            fread(buf, 1, BUFSIZE, stdin); \
        } \
    } while(0)

#define scan(t) \
{ \
    t = 0;sign=1; \
    read(); \
    while ((*pt&lt;'0'||*pt&gt;'9')&amp;&amp;*pt!='-') {pt ++; read();} \
    if(*pt=='-')sign=-1,pt++;\
    while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
    t*=sign;\
}
#define scan_str(s) \
{ \
    int p = 0; \
    read(); \
    while ((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\r') {pt ++; read();}\
    while (!((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\n')) {s[p ++] = (*(pt ++)); read();} \
    s[p] = 0; \
}

int A[20], k;
char p[10000000];
char*opt = p;
inline void printInt(int x) {
	if (x &lt; 0)
		*opt++ = '-', x = -x;
	if (!x)
		*opt++ = '0';
	k = 0;
	while (x)
		A[k++] = x % 10, x /= 10;
	for (int i = k - 1; i &gt;= 0; i--)
		*opt++ = '0' + A[i];
	*opt++ = '\n';
}

void dfs(int u, int par) {
	for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (*e != par) {
			dfs(*e, u);
			add(v[*e], v[u]), v[u]-&gt;update();
		}
	}
}

int main() {
	scan(n);
	scan(nQ);
	for (int i = 0; i &lt; n - 1; ++i) {
		int a, b;
		scan(a);
		scan(b);
		--a, --b;
		E[a].push_back(b), E[b].push_back(a);
	}
	for (int i = 0; i &lt; n; ++i) {
		int val;
		scan(val);
		v[i] = new Node(val);
	}
	int rt;
	scan(rt);
	--rt;
	dfs(rt, -1);
	makeRoot(v[rt]);
	while (nQ--) {
		int k, x;
		scan(k);
		scan(x);
		--x;
		Node*u = v[x];
		if (k == 1) {
			makeRoot(u);
			rt = x;
		} else if (k == 9) {
			int y;
			scan(y);
			--y;
			link(u, v[y]);
		} else if (k == 0 || k == 3 || k == 11 || k == 5 || k == 4) {
			expose(u);
			if (k == 3 || k == 4 || k == 11) {
				int ans = u-&gt;val;
				for (int i = 2; i &lt; 4; ++i)
					if (u-&gt;ch[i]) {
						Info&amp;r = u-&gt;ch[i]-&gt;all;
						if (k == 3)
							ans = min(ans, r.minv);
						else if (k == 4)
							ans = max(ans, r.maxv);
						else if (k == 11)
							ans += r.sum;
					}

				printInt(ans);
			} else {
				int y;
				scan(y);
				Mark m(k == 5, y);
				u-&gt;val += m;
				for (int i = 2; i &lt; 4; ++i) {
					if (u-&gt;ch[i])
						u-&gt;ch[i]-&gt;applyTree(m);
				}
				u-&gt;update();
			}
		} else {
			int y;
			scan(y);
			--y;
			makeRoot(u), expose(v[y]), splay(u);
			if (k == 7 || k == 8 || k == 10) {
				Info&amp;ans = u-&gt;chain;
				if (k == 7)
					printInt(ans.minv);
				else if (k == 8)
					printInt(ans.maxv);
				else if (k == 10)
					printInt(ans.sum);
			} else {
				int z;
				scan(z);
				u-&gt;applyChain(Mark(k == 6, z));
			}
			makeRoot(v[rt]);
		}
	}
	*opt++ = '\0';
	puts(p);
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
using namespace std;

const int INF = ~0U &gt;&gt; 1, MAX_N = 100000 + 10;

struct Info {
	int size, minv, maxv, sum;
	Info(int size, int minv, int maxv, int sum) :
			size(size), minv(minv), maxv(maxv), sum(sum) {
	}
	Info() :
			size(0), minv(INF), maxv(-INF), sum(0) {
	}
};

const Info EMPTY;

struct Mark {
	int mul, plus;
	Mark(int mul, int plus) :
			mul(mul), plus(plus) {
	}
	Mark() :
			mul(1), plus(0) {
	}
	bool ok() {
		return mul != 1 || plus != 0;
	}
};

inline int apply(int x, const Mark&amp;b) {
	return b.mul * x + b.plus;
}

inline void operator+=(int&amp;x, const Mark&amp;b) {
	x = x * b.mul + b.plus;
}
inline void operator+=(Mark&amp;a, const Mark&amp;b) {
	a.mul *= b.mul;
	a.plus = a.plus * b.mul + b.plus;

}

inline void operator+=(Info&amp;a, const Mark&amp;b) {
	if (a.size == 0)
		return;
	a.minv += b, a.maxv += b;
	a.sum = a.sum * b.mul + a.size * b.plus;
}

inline void operator+=(Info&amp;a, const Info&amp;b) {
	a.size += b.size, a.minv = min(a.minv, b.minv), a.maxv = max(a.maxv,
			b.maxv), a.sum += b.sum;
}

struct Node;

struct Node {
	Node*ch[4], *p;
	Mark chainMark, treeMark;
	Info chain, tree, all;

	bool inner, rev;
	int val;

	Node() :
			p(0), inner(true), rev(false), val(0) {
		memset(ch, 0, sizeof ch);
	}

	Node(int v) :
			p(0), inner(false), rev(false), val(v) {
		memset(ch, 0, sizeof ch);
		update();
	}

	void applyRev() {
		rev ^= 1;
	}

	void applyChain(const Mark&amp;a) {
		chainMark += a, chain += a, val += a;
		all = chain;
		all += tree;
	}

	void applyTree(const Mark&amp;a, bool kd = true) {
		treeMark += a, tree += a, all += a;
		if (kd)
			applyChain(a);
	}

	void relax() {
		if (rev) {
			swap(ch[0], ch[1]);
			for (int i = 0; i &lt; 2; ++i) {
				if (ch[i])
					ch[i]-&gt;applyRev();
			}
			rev = 0;
		}

		if (treeMark.ok()) {
			for (int i = 0; i &lt; 4; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyTree(treeMark, i &gt;= 2);
				}
			treeMark = Mark();
		}

		if (chainMark.ok()) {
			for (int i = 0; i &lt; 2; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyChain(chainMark);
				}
			chainMark = Mark();
		}
	}

	void update() {
		chain = tree = all = EMPTY;
		if (!inner)
			chain = all = Info(1, val, val, val);

		for (int i = 0; i &lt; 2; ++i) {
			if (ch[i]) {
				chain += ch[i]-&gt;chain;
				tree += ch[i]-&gt;tree;
			}
		}

		for (int i = 2; i &lt; 4; ++i) {
			if (ch[i]) {
				tree += ch[i]-&gt;all;
			}
		}

		all = chain, all += tree;
	}
	Node*get(int d) {
		if (ch[d]) {
			ch[d]-&gt;relax();
		}
		return ch[d];
	}
	bool dir(int t) {
		return p-&gt;ch[t + 1] == this;
	}
	int pos() {
		for (int i = 0; i &lt; 4; ++i) {
			if (p-&gt;ch[i] == this)
				return i;
		}
		return -1;
	}
	void setc(Node*c, int d) {
		ch[d] = c;
		if (c)
			c-&gt;p = this;
	}
	bool isRoot(int t) {
		if (t == 0) {
			return !p || (p-&gt;ch[0] != this &amp;&amp; p-&gt;ch[1] != this);
		} else {
			return !p || !p-&gt;inner || !inner;
		}
	}
};

void rot(Node*u, int t) {
	Node*p = u-&gt;p;
	int d = u-&gt;dir(t);
	if (p-&gt;p)
		p-&gt;p-&gt;setc(u, p-&gt;pos());
	else
		u-&gt;p = 0;
	p-&gt;setc(u-&gt;ch[!d + t], d + t);
	u-&gt;setc(p, !d + t);
	p-&gt;update();
}

void splay(Node*u, int t = 0) {
	while (!u-&gt;isRoot(t)) {
		if (u-&gt;p-&gt;isRoot(t))
			rot(u, t);
		else if (u-&gt;p-&gt;dir(t) == u-&gt;dir(t))
			rot(u-&gt;p, t), rot(u, t);
		else
			rot(u, t), rot(u, t);
	}
	u-&gt;update();
}

void add(Node*u, Node*v) {
	v-&gt;relax();
	for (int i = 2; i &lt; 4; ++i) {
		if (!v-&gt;ch[i]) {
			v-&gt;setc(u, i);
			return;
		}
	}
	Node*t = v, *x = new Node;
	for (; t-&gt;ch[2]-&gt;inner; t = t-&gt;get(2))
		;
	x-&gt;setc(t-&gt;ch[2], 2), x-&gt;setc(u, 3);
	t-&gt;setc(x, 2);
	splay(x, 2);
}

void del(Node*u) {
	if (u-&gt;p-&gt;inner) {
		u-&gt;p-&gt;p-&gt;setc(u-&gt;p-&gt;ch[5 - u-&gt;pos()], u-&gt;p-&gt;pos());
		Node*t = u-&gt;p;
		splay(u-&gt;p-&gt;p, 2);
		delete t;
	} else {
		u-&gt;p-&gt;setc(0, u-&gt;pos());
	}
	u-&gt;p = 0;
}

void pushTo(Node*u) {
	static Node*stack[MAX_N * 2];
	int top = 0;
	for (; u; u = u-&gt;p)
		stack[top++] = u;
	while (top)
		stack[--top]-&gt;relax();
}

void expose(Node*u) {
	Node*v = u, *t;
	pushTo(u);
	splay(u);
	if (u-&gt;ch[1]) {
		t = u-&gt;ch[1], u-&gt;ch[1] = 0, add(t, u), u-&gt;update();
	}
	while (u-&gt;p) {
		for (t = u-&gt;p; t-&gt;inner; t = t-&gt;p)
			;
		splay(t);
		if (t-&gt;ch[1])
			u-&gt;p-&gt;setc(t-&gt;ch[1], u-&gt;pos()), splay(u-&gt;p, 2), t-&gt;setc(u, 1);
		else
			del(u), t-&gt;setc(u, 1);
		u = t;
		u-&gt;update();
	}
	splay(v);
}

void makeRoot(Node* u) {
	expose(u);
	u-&gt;applyRev();
}

Node*getPar(Node*u) {
	expose(u);
	u = u-&gt;get(0);
	while (u &amp;&amp; u-&gt;ch[1])
		u = u-&gt;get(1);
	return u;
}

Node*getRoot(Node*u) {
	while (u-&gt;p)
		u = u-&gt;p;
	return u;
}

Node*cut(Node*u) {
	Node*v = getPar(u);
	if (v)
		expose(v), del(u), v-&gt;update();
	return v;
}

void link(Node*u, Node*v) {
	Node*p = cut(u);
	if (getRoot(u) != getRoot(v))
		p = v;
	if (p)
		expose(p), add(u, p), p-&gt;update();
}

int n, nQ;
Node*v[MAX_N];
vector&lt;int&gt; E[MAX_N];

#define BUFSIZE 10000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
int sign;
#define read() \
    do{ \
        if (pt &gt;= pend) \
        { \
            pt = buf; \
            fread(buf, 1, BUFSIZE, stdin); \
        } \
    } while(0)

#define scan(t) \
{ \
    t = 0;sign=1; \
    read(); \
    while ((*pt&lt;'0'||*pt&gt;'9')&amp;&amp;*pt!='-') {pt ++; read();} \
    if(*pt=='-')sign=-1,pt++;\
    while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
    t*=sign;\
}
#define scan_str(s) \
{ \
    int p = 0; \
    read(); \
    while ((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\r') {pt ++; read();}\
    while (!((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\n')) {s[p ++] = (*(pt ++)); read();} \
    s[p] = 0; \
}

int A[20], k;
char p[10000000];
char*opt = p;
inline void printInt(int x) {
	if (x &lt; 0)
		*opt++ = '-', x = -x;
	if (!x)
		*opt++ = '0';
	k = 0;
	while (x)
		A[k++] = x % 10, x /= 10;
	for (int i = k - 1; i &gt;= 0; i--)
		*opt++ = '0' + A[i];
	*opt++ = '\n';
}

void dfs(int u, int par) {
	for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (*e != par) {
			dfs(*e, u);
			add(v[*e], v[u]), v[u]-&gt;update();
		}
	}
}

int main() {
	scan(n);
	scan(nQ);
	for (int i = 0; i &lt; n - 1; ++i) {
		int a, b;
		scan(a);
		scan(b);
		--a, --b;
		E[a].push_back(b), E[b].push_back(a);
	}
	for (int i = 0; i &lt; n; ++i) {
		int val;
		scan(val);
		v[i] = new Node(val);
	}
	int rt;
	scan(rt);
	--rt;
	dfs(rt, -1);
	makeRoot(v[rt]);
	while (nQ--) {
		int k, x;
		scan(k);
		scan(x);
		--x;
		Node*u = v[x];
		if (k == 1) {
			makeRoot(u);
			rt = x;
		} else if (k == 9) {
			int y;
			scan(y);
			--y;
			link(u, v[y]);
		} else if (k == 0 || k == 3 || k == 11 || k == 5 || k == 4) {
			expose(u);
			if (k == 3 || k == 4 || k == 11) {
				int ans = u-&gt;val;
				for (int i = 2; i &lt; 4; ++i)
					if (u-&gt;ch[i]) {
						Info&amp;r = u-&gt;ch[i]-&gt;all;
						if (k == 3)
							ans = min(ans, r.minv);
						else if (k == 4)
							ans = max(ans, r.maxv);
						else if (k == 11)
							ans += r.sum;
					}

				printInt(ans);
			} else {
				int y;
				scan(y);
				Mark m(k == 5, y);
				u-&gt;val += m;
				for (int i = 2; i &lt; 4; ++i) {
					if (u-&gt;ch[i])
						u-&gt;ch[i]-&gt;applyTree(m);
				}
				u-&gt;update();
			}
		} else {
			int y;
			scan(y);
			--y;
			makeRoot(u), expose(v[y]), splay(u);
			if (k == 7 || k == 8 || k == 10) {
				Info&amp;ans = u-&gt;chain;
				if (k == 7)
					printInt(ans.minv);
				else if (k == 8)
					printInt(ans.maxv);
				else if (k == 10)
					printInt(ans.sum);
			} else {
				int z;
				scan(z);
				u-&gt;applyChain(Mark(k == 6, z));
			}
			makeRoot(v[rt]);
		}
	}
	*opt++ = '\0';
	puts(p);
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
using namespace std;

const int INF = ~0U &gt;&gt; 1, MAX_N = 100000 + 10;

struct Info {
	int size, minv, maxv, sum;
	Info(int size, int minv, int maxv, int sum) :
			size(size), minv(minv), maxv(maxv), sum(sum) {
	}
	Info() :
			size(0), minv(INF), maxv(-INF), sum(0) {
	}
};

const Info EMPTY;

struct Mark {
	int mul, plus;
	Mark(int mul, int plus) :
			mul(mul), plus(plus) {
	}
	Mark() :
			mul(1), plus(0) {
	}
	bool ok() {
		return mul != 1 || plus != 0;
	}
};

inline int apply(int x, const Mark&amp;b) {
	return b.mul * x + b.plus;
}

inline void operator+=(int&amp;x, const Mark&amp;b) {
	x = x * b.mul + b.plus;
}
inline void operator+=(Mark&amp;a, const Mark&amp;b) {
	a.mul *= b.mul;
	a.plus = a.plus * b.mul + b.plus;

}

inline void operator+=(Info&amp;a, const Mark&amp;b) {
	if (a.size == 0)
		return;
	a.minv += b, a.maxv += b;
	a.sum = a.sum * b.mul + a.size * b.plus;
}

inline void operator+=(Info&amp;a, const Info&amp;b) {
	a.size += b.size, a.minv = min(a.minv, b.minv), a.maxv = max(a.maxv,
			b.maxv), a.sum += b.sum;
}

struct Node;

struct Node {
	Node*ch[4], *p;
	Mark chainMark, treeMark;
	Info chain, tree, all;

	bool inner, rev;
	int val;

	Node() :
			p(0), inner(true), rev(false), val(0) {
		memset(ch, 0, sizeof ch);
	}

	Node(int v) :
			p(0), inner(false), rev(false), val(v) {
		memset(ch, 0, sizeof ch);
		update();
	}

	void applyRev() {
		rev ^= 1;
	}

	void applyChain(const Mark&amp;a) {
		chainMark += a;
		if (inner)
			return;
		chain += a, val += a;
		all = chain;
		all += tree;
	}

	void applyTree(const Mark&amp;a, bool kd = true) {
		treeMark += a, tree += a, all += a;
		if (kd)
			applyChain(a);
	}

	void relax() {
		if (rev) {
			swap(ch[0], ch[1]);
			for (int i = 0; i &lt; 2; ++i) {
				if (ch[i])
					ch[i]-&gt;applyRev();
			}
			rev = 0;
		}

		if (treeMark.ok()) {
			for (int i = 0; i &lt; 4; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyTree(treeMark, i &gt;= 2);
				}
			treeMark = Mark();
		}

		if (chainMark.ok()) {
			for (int i = 0; i &lt; 2; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyChain(chainMark);
				}
			chainMark = Mark();
		}
	}

	void update() {
		chain = tree = all = EMPTY;
		if (!inner)
			chain = all = Info(1, val, val, val);

		for (int i = 0; i &lt; 2; ++i) {
			if (ch[i]) {
				chain += ch[i]-&gt;chain;
				tree += ch[i]-&gt;tree;
			}
		}

		for (int i = 2; i &lt; 4; ++i) {
			if (ch[i]) {
				tree += ch[i]-&gt;all;
			}
		}

		all = chain, all += tree;
	}
	Node*get(int d) {
		if (ch[d]) {
			ch[d]-&gt;relax();
		}
		return ch[d];
	}
	bool dir(int t) {
		return p-&gt;ch[t + 1] == this;
	}
	int pos() {
		for (int i = 0; i &lt; 4; ++i) {
			if (p-&gt;ch[i] == this)
				return i;
		}
		return -1;
	}
	void setc(Node*c, int d) {
		ch[d] = c;
		if (c)
			c-&gt;p = this;
	}
	bool isRoot(int t) {
		if (t == 0) {
			return !p || (p-&gt;ch[0] != this &amp;&amp; p-&gt;ch[1] != this);
		} else {
			return !p || !p-&gt;inner || !inner;
		}
	}
};

void rot(Node*u, int t) {
	Node*p = u-&gt;p;
	int d = u-&gt;dir(t);
	if (p-&gt;p)
		p-&gt;p-&gt;setc(u, p-&gt;pos());
	else
		u-&gt;p = 0;
	p-&gt;setc(u-&gt;ch[!d + t], d + t);
	u-&gt;setc(p, !d + t);
	p-&gt;update();
}

void splay(Node*u, int t = 0) {
	while (!u-&gt;isRoot(t)) {
		if (u-&gt;p-&gt;isRoot(t))
			rot(u, t);
		else if (u-&gt;p-&gt;dir(t) == u-&gt;dir(t))
			rot(u-&gt;p, t), rot(u, t);
		else
			rot(u, t), rot(u, t);
	}
	u-&gt;update();
}

void add(Node*u, Node*v) {
	v-&gt;relax();
	for (int i = 2; i &lt; 4; ++i) {
		if (!v-&gt;ch[i]) {
			v-&gt;setc(u, i);
			return;
		}
	}
	Node*t = v, *x = new Node;
	for (; t-&gt;ch[2]-&gt;inner; t = t-&gt;get(2))
		;
	x-&gt;setc(t-&gt;ch[2], 2), x-&gt;setc(u, 3);
	t-&gt;setc(x, 2);
	splay(x, 2);
}

void del(Node*u) {
	if (u-&gt;p-&gt;inner) {
		u-&gt;p-&gt;p-&gt;setc(u-&gt;p-&gt;ch[5 - u-&gt;pos()], u-&gt;p-&gt;pos());
		Node*t = u-&gt;p;
		splay(u-&gt;p-&gt;p, 2);
		delete t;
	} else {
		u-&gt;p-&gt;setc(0, u-&gt;pos());
	}
	u-&gt;p = 0;
}

void pushTo(Node*u) {
	static Node*stack[MAX_N * 2];
	int top = 0;
	for (; u; u = u-&gt;p)
		stack[top++] = u;
	while (top)
		stack[--top]-&gt;relax();
}

void expose(Node*u) {
	Node*v = u, *t;
	pushTo(u);
	splay(u);
	if (u-&gt;ch[1]) {
		t = u-&gt;ch[1], u-&gt;ch[1] = 0, add(t, u), u-&gt;update();
	}
	while (u-&gt;p) {
		for (t = u-&gt;p; t-&gt;inner; t = t-&gt;p)
			;
		splay(t);
		if (t-&gt;ch[1])
			u-&gt;p-&gt;setc(t-&gt;ch[1], u-&gt;pos()), splay(u-&gt;p, 2), t-&gt;setc(u, 1);
		else
			del(u), t-&gt;setc(u, 1);
		u = t;
		u-&gt;update();
	}
	splay(v);
}

void makeRoot(Node* u) {
	expose(u);
	u-&gt;applyRev();
}

Node*getPar(Node*u) {
	expose(u);
	u = u-&gt;get(0);
	while (u &amp;&amp; u-&gt;ch[1])
		u = u-&gt;get(1);
	return u;
}

Node*getRoot(Node*u) {
	while (u-&gt;p)
		u = u-&gt;p;
	return u;
}

Node*cut(Node*u) {
	Node*v = getPar(u);
	if (v)
		expose(v), del(u), v-&gt;update();
	return v;
}

void link(Node*u, Node*v) {
	Node*p = cut(u);
	if (getRoot(u) != getRoot(v))
		p = v;
	if (p)
		expose(p), add(u, p), p-&gt;update();
}

int n, nQ;
Node*v[MAX_N];
vector&lt;int&gt; E[MAX_N];

#define BUFSIZE 10000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
int sign;
#define read() \
    do{ \
        if (pt &gt;= pend) \
        { \
            pt = buf; \
            fread(buf, 1, BUFSIZE, stdin); \
        } \
    } while(0)

#define scan(t) \
{ \
    t = 0;sign=1; \
    read(); \
    while ((*pt&lt;'0'||*pt&gt;'9')&amp;&amp;*pt!='-') {pt ++; read();} \
    if(*pt=='-')sign=-1,pt++;\
    while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
    t*=sign;\
}
#define scan_str(s) \
{ \
    int p = 0; \
    read(); \
    while ((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\r') {pt ++; read();}\
    while (!((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\n')) {s[p ++] = (*(pt ++)); read();} \
    s[p] = 0; \
}

int A[20], k;
char p[10000000];
char*opt = p;
inline void printInt(int x) {
	if (x &lt; 0)
		*opt++ = '-', x = -x;
	if (!x)
		*opt++ = '0';
	k = 0;
	while (x)
		A[k++] = x % 10, x /= 10;
	for (int i = k - 1; i &gt;= 0; i--)
		*opt++ = '0' + A[i];
	*opt++ = '\n';
}

void dfs(int u, int par) {
	for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (*e != par) {
			dfs(*e, u);
			add(v[*e], v[u]), v[u]-&gt;update();
		}
	}
}

int main() {
//	freopen("in","r",stdin);
	scan(n);
	scan(nQ);
	for (int i = 0; i &lt; n - 1; ++i) {
		int a, b;
		scan(a);
		scan(b);
		--a, --b;
		E[a].push_back(b), E[b].push_back(a);
	}
	for (int i = 0; i &lt; n; ++i) {
		int val;
		scan(val);
		v[i] = new Node(val);
	}
	int rt;
	scan(rt);
	--rt;
	dfs(rt, -1);
	makeRoot(v[rt]);
	while (nQ--) {
		int k, x;
		scan(k);
		scan(x);
		--x;
		Node*u = v[x];
		if (k == 1) {
			makeRoot(u);
			rt = x;
		} else if (k == 9) {
			int y;
			scan(y);
			--y;
			link(u, v[y]);
		} else if (k == 0 || k == 3 || k == 11 || k == 5 || k == 4) {
			expose(u);
			if (k == 3 || k == 4 || k == 11) {
				int ans = u-&gt;val;
				for (int i = 2; i &lt; 4; ++i)
					if (u-&gt;ch[i]) {
						Info&amp;r = u-&gt;ch[i]-&gt;all;
						if (k == 3)
							ans = min(ans, r.minv);
						else if (k == 4)
							ans = max(ans, r.maxv);
						else if (k == 11)
							ans += r.sum;
					}

				printInt(ans);
			} else {
				int y;
				scan(y);
				Mark m(k == 5, y);
				u-&gt;val += m;
				for (int i = 2; i &lt; 4; ++i) {
					if (u-&gt;ch[i])
						u-&gt;ch[i]-&gt;applyTree(m);
				}
				u-&gt;update();
			}
		} else {
			int y;
			scan(y);
			--y;
			makeRoot(u), expose(v[y]), splay(u);
			if (k == 7 || k == 8 || k == 10) {
				Info&amp;ans = u-&gt;chain;
				if (k == 7)
					printInt(ans.minv);
				else if (k == 8)
					printInt(ans.maxv);
				else if (k == 10)
					printInt(ans.sum);
			} else {
				int z;
				scan(z);
				u-&gt;applyChain(Mark(k == 6, z));
			}
			makeRoot(v[rt]);
		}
	}
	*opt++ = '\0';
	puts(p);
}
</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
using namespace std;

const int INF = ~0U &gt;&gt; 1, MAX_N = 100000 + 10;

struct Info {
	int size, minv, maxv, sum;
	Info(int size, int minv, int maxv, int sum) :
			size(size), minv(minv), maxv(maxv), sum(sum) {
	}
	Info() :
			size(0), minv(INF), maxv(-INF), sum(0) {
	}
};

const Info EMPTY;

struct Mark {
	int mul, plus;
	Mark(int mul, int plus) :
			mul(mul), plus(plus) {
	}
	Mark() :
			mul(1), plus(0) {
	}
	bool ok() {
		return mul != 1 || plus != 0;
	}
};

inline int apply(int x, const Mark&amp;b) {
	return b.mul * x + b.plus;
}

inline void operator+=(int&amp;x, const Mark&amp;b) {
	x = x * b.mul + b.plus;
}
inline void operator+=(Mark&amp;a, const Mark&amp;b) {
	a.mul *= b.mul;
	a.plus = a.plus * b.mul + b.plus;

}

inline void operator+=(Info&amp;a, const Mark&amp;b) {
	if (a.size == 0)
		return;
	a.minv += b, a.maxv += b;
	a.sum = a.sum * b.mul + a.size * b.plus;
}

inline void operator+=(Info&amp;a, const Info&amp;b) {
	a.size += b.size, a.minv = min(a.minv, b.minv), a.maxv = max(a.maxv,
			b.maxv), a.sum += b.sum;
}

struct Node;

struct Node {
	Node*ch[4], *p;
	Mark chainMark, treeMark;
	Info chain, tree, all;

	bool inner, rev;
	int val;

	Node() :
			p(0), inner(true), rev(false), val(0) {
		memset(ch, 0, sizeof ch);
	}

	Node(int v) :
			p(0), inner(false), rev(false), val(v) {
		memset(ch, 0, sizeof ch);
		update();
	}

	void applyRev() {
		rev ^= 1;
	}

	void applyChain(const Mark&amp;a) {
		chainMark += a;
		chain += a, val += a;
		all = chain;
		all += tree;
	}

	void applyTree(const Mark&amp;a, bool kd = true) {
		treeMark += a, tree += a, all += a;
		if (kd)
			applyChain(a);
	}

	void relax() {
		if (rev) {
			swap(ch[0], ch[1]);
			for (int i = 0; i &lt; 2; ++i) {
				if (ch[i])
					ch[i]-&gt;applyRev();
			}
			rev = 0;
		}

		if (treeMark.ok()) {
			for (int i = 0; i &lt; 4; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyTree(treeMark, i &gt;= 2);
				}
			treeMark = Mark();
		}

		if (chainMark.ok()) {
			for (int i = 0; i &lt; 2; ++i)
				if (ch[i]) {
					ch[i]-&gt;applyChain(chainMark);
				}
			chainMark = Mark();
		}
	}

	void update() {
		if (!inner) {
			tree = EMPTY;
			chain = all = Info(1, val, val, val);

			for (int i = 0; i &lt; 2; ++i) {
				if (ch[i]) {
					chain += ch[i]-&gt;chain;
					tree += ch[i]-&gt;tree;
				}
			}

			for (int i = 2; i &lt; 4; ++i) {
				if (ch[i]) {
					tree += ch[i]-&gt;all;
				}
			}

			all = chain, all += tree;
		} else {
			chain = tree = EMPTY;

			for (int i = 2; i &lt; 4; ++i) {
				if (ch[i]) {
					tree += ch[i]-&gt;all;
				}
			}

			all = tree;
		}
	}
	Node*get(int d) {
		if (ch[d]) {
			ch[d]-&gt;relax();
		}
		return ch[d];
	}
	bool dir(int t) {
		return p-&gt;ch[t + 1] == this;
	}
	int pos() {
		for (int i = 0; i &lt; 4; ++i) {
			if (p-&gt;ch[i] == this)
				return i;
		}
		return -1;
	}
	void setc(Node*c, int d) {
		ch[d] = c;
		if (c)
			c-&gt;p = this;
	}
	bool isRoot(int t) {
		if (t == 0) {
			return !p || (p-&gt;ch[0] != this &amp;&amp; p-&gt;ch[1] != this);
		} else {
			return !p || !p-&gt;inner || !inner;
		}
	}
};

void rot(Node*u, int t) {
	Node*p = u-&gt;p;
	int d = u-&gt;dir(t);
	if (p-&gt;p)
		p-&gt;p-&gt;setc(u, p-&gt;pos());
	else
		u-&gt;p = 0;
	p-&gt;setc(u-&gt;ch[!d + t], d + t);
	u-&gt;setc(p, !d + t);
	p-&gt;update();
}

void splay(Node*u, int t = 0) {
	while (!u-&gt;isRoot(t)) {
		if (u-&gt;p-&gt;isRoot(t))
			rot(u, t);
		else if (u-&gt;p-&gt;dir(t) == u-&gt;dir(t))
			rot(u-&gt;p, t), rot(u, t);
		else
			rot(u, t), rot(u, t);
	}
	u-&gt;update();
}

void add(Node*u, Node*v) {
	v-&gt;relax();
	for (int i = 2; i &lt; 4; ++i) {
		if (!v-&gt;ch[i]) {
			v-&gt;setc(u, i);
			return;
		}
	}
	Node*t = v, *x = new Node;
	for (; t-&gt;ch[2]-&gt;inner; t = t-&gt;get(2))
		;
	x-&gt;setc(t-&gt;ch[2], 2), x-&gt;setc(u, 3);
	t-&gt;setc(x, 2);
	splay(x, 2);
}

void del(Node*u) {
	if (u-&gt;p-&gt;inner) {
		u-&gt;p-&gt;p-&gt;setc(u-&gt;p-&gt;ch[5 - u-&gt;pos()], u-&gt;p-&gt;pos());
		Node*t = u-&gt;p;
		splay(u-&gt;p-&gt;p, 2);
		delete t;
	} else {
		u-&gt;p-&gt;setc(0, u-&gt;pos());
	}
	u-&gt;p = 0;
}

void pushTo(Node*u) {
	static Node*stack[MAX_N * 2];
	int top = 0;
	for (; u; u = u-&gt;p)
		stack[top++] = u;
	while (top)
		stack[--top]-&gt;relax();
}

void expose(Node*u) {
	Node*v = u, *t;
	pushTo(u);
	splay(u);
	if (u-&gt;ch[1]) {
		t = u-&gt;ch[1], u-&gt;ch[1] = 0, add(t, u), u-&gt;update();
	}
	while (u-&gt;p) {
		for (t = u-&gt;p; t-&gt;inner; t = t-&gt;p)
			;
		splay(t);
		if (t-&gt;ch[1])
			u-&gt;p-&gt;setc(t-&gt;ch[1], u-&gt;pos()), splay(u-&gt;p, 2), t-&gt;setc(u, 1);
		else
			del(u), t-&gt;setc(u, 1);
		u = t;
		u-&gt;update();
	}
	splay(v);
}

void makeRoot(Node* u) {
	expose(u);
	u-&gt;applyRev();
}

Node*getPar(Node*u) {
	expose(u);
	u = u-&gt;get(0);
	while (u &amp;&amp; u-&gt;ch[1])
		u = u-&gt;get(1);
	return u;
}

Node*getRoot(Node*u) {
	while (u-&gt;p)
		u = u-&gt;p;
	return u;
}

Node*cut(Node*u) {
	Node*v = getPar(u);
	if (v)
		expose(v), del(u), v-&gt;update();
	return v;
}

void link(Node*u, Node*v) {
	Node*p = cut(u);
	if (getRoot(u) != getRoot(v))
		p = v;
	if (p)
		expose(p), add(u, p), p-&gt;update();
}

int n, nQ;
Node*v[MAX_N];
vector&lt;int&gt; E[MAX_N];

#define BUFSIZE 10000000
char buf[BUFSIZE], *pt = buf + BUFSIZE, *pend = buf + BUFSIZE;
int sign;
#define read() \
    do{ \
        if (pt &gt;= pend) \
        { \
            pt = buf; \
            fread(buf, 1, BUFSIZE, stdin); \
        } \
    } while(0)

#define scan(t) \
{ \
    t = 0;sign=1; \
    read(); \
    while ((*pt&lt;'0'||*pt&gt;'9')&amp;&amp;*pt!='-') {pt ++; read();} \
    if(*pt=='-')sign=-1,pt++;\
    while (((*pt) &gt;= '0' &amp;&amp; (*pt) &lt;= '9')) {t = t * 10 + (*(pt ++)) - '0'; read();}\
    t*=sign;\
}
#define scan_str(s) \
{ \
    int p = 0; \
    read(); \
    while ((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\r') {pt ++; read();}\
    while (!((*pt) == ' ' || (*pt) == '\n' || (*pt) == '\n')) {s[p ++] = (*(pt ++)); read();} \
    s[p] = 0; \
}

int A[20], k;
char p[10000000];
char*opt = p;
inline void printInt(int x) {
	if (x &lt; 0)
		*opt++ = '-', x = -x;
	if (!x)
		*opt++ = '0';
	k = 0;
	while (x)
		A[k++] = x % 10, x /= 10;
	for (int i = k - 1; i &gt;= 0; i--)
		*opt++ = '0' + A[i];
	*opt++ = '\n';
}

void dfs(int u, int par) {
	for (vector&lt;int&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (*e != par) {
			dfs(*e, u);
			add(v[*e], v[u]), v[u]-&gt;update();
		}
	}
}

int main() {
//	freopen("in", "r", stdin);
	scan(n);
	scan(nQ);
	for (int i = 0; i &lt; n - 1; ++i) {
		int a, b;
		scan(a);
		scan(b);
		--a, --b;
		E[a].push_back(b), E[b].push_back(a);
	}
	for (int i = 0; i &lt; n; ++i) {
		int val;
		scan(val);
		v[i] = new Node(val);
	}
	int rt;
	scan(rt);
	--rt;
	dfs(rt, -1);
	makeRoot(v[rt]);
	while (nQ--) {
		int k, x;
		scan(k);
		scan(x);
		--x;
		Node*u = v[x];
		if (k == 1) {
			makeRoot(u);
			rt = x;
		} else if (k == 9) {
			int y;
			scan(y);
			--y;
			link(u, v[y]);
		} else if (k == 0 || k == 3 || k == 11 || k == 5 || k == 4) {
			expose(u);
			if (k == 3 || k == 4 || k == 11) {
				int ans = u-&gt;val;
				for (int i = 2; i &lt; 4; ++i)
					if (u-&gt;ch[i]) {
						Info&amp;r = u-&gt;ch[i]-&gt;all;
						if (k == 3)
							ans = min(ans, r.minv);
						else if (k == 4)
							ans = max(ans, r.maxv);
						else if (k == 11)
							ans += r.sum;
					}

				printInt(ans);
			} else {
				int y;
				scan(y);
				Mark m(k == 5, y);
				u-&gt;val += m;
				for (int i = 2; i &lt; 4; ++i) {
					if (u-&gt;ch[i])
						u-&gt;ch[i]-&gt;applyTree(m);
				}
				u-&gt;update();
			}
		} else {
			int y;
			scan(y);
			--y;
			makeRoot(u), expose(v[y]), splay(u);
			if (k == 7 || k == 8 || k == 10) {
				Info&amp;ans = u-&gt;chain;
				if (k == 7)
					printInt(ans.minv);
				else if (k == 8)
					printInt(ans.maxv);
				else if (k == 10)
					printInt(ans.sum);
			} else {
				int z;
				scan(z);
				u-&gt;applyChain(Mark(k == 6, z));
			}
			makeRoot(v[rt]);
		}
	}
	*opt++ = '\0';
	puts(p);
}
</pre><pre></pre><h2>Problem3166</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include &lt;set&gt;
using namespace std;

const int MAX_BIT = 30;
const int MAX_N = 50000 + 10;

struct Tree;
Tree*alloc();

struct Tree {
	Tree*ch[2];
	int cnt;
	Tree*get(int w) {
		if (ch[w] == 0) {
			ch[w] = alloc();
		}
		return ch[w];
	}
};

Tree*alloc() {
	const int BUFFER_SIZE = 10000;
	static Tree*buffer = 0, *cur = 0;
	if (buffer == 0 || cur == buffer + BUFFER_SIZE) {
		buffer = new Tree[BUFFER_SIZE];
		cur = buffer;
	}
	cur-&gt;cnt = 0;
	memset(cur-&gt;ch, 0, sizeof cur-&gt;ch);
	return cur++;
}

Tree* add(Tree*u, int x, int bit) {
	Tree*nu = alloc();
	nu-&gt;cnt = u ? u-&gt;cnt + 1 : 1;
	if (u)
		memcpy(nu-&gt;ch, u-&gt;ch, sizeof u-&gt;ch);

	if (bit &gt;= 0) {
		int go = x &gt;&gt; bit &amp; 1;
		nu-&gt;ch[go] = add(u ? u-&gt;ch[go] : 0, x, bit - 1);
	}
	return nu;
}

Tree*before[MAX_N];
int n, a[MAX_N];

int get(Tree*a, int c) {
	if (a &amp;&amp; a-&gt;ch[c])
		return a-&gt;ch[c]-&gt;cnt;
	return 0;
}

int calc(int l, int r, int x) {
	//[l,r)
	Tree*a = before[l], *b = before[r];
	int ret = 0;

	for (int i = MAX_BIT; i &gt;= 0; --i) {
		int cur = x &gt;&gt; i &amp; 1;
		int cnt = get(b, !cur) - get(a, !cur);
		int go = cnt &gt; 0 ? !cur : cur;
		if (a)
			a = a-&gt;ch[go];
		if (b)
			b = b-&gt;ch[go];
		ret += (go ^ cur) &lt;&lt; i;
	}
	return ret;
}

bool cmp(int i, int j) {
	return a[i] &lt; a[j];
}
int ord[MAX_N];

int main() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		scanf("%d", a + i);
	}
	before[0] = 0;
	for (int i = 1; i &lt;= n; ++i) {
		before[i] = add(before[i - 1], a[i - 1], MAX_BIT);
	}
	for (int i = 0; i &lt; n; ++i) {
		ord[i] = i;
	}
	sort(ord, ord + n, cmp);
	set&lt;int&gt; have;
	have.insert(-1);
	have.insert(n);
	int ans = 0;

	for (int i = n - 1; i &gt;= 0; --i) {
		int me = ord[i];
		set&lt;int&gt;::iterator it = have.insert(me).first, L, R;
		if (i == n - 1)
			continue;
		L = it, R = it;
		--L;
		if (L != have.begin())
			--L;
		++R;
		if (*R != n)
			++R;
		//(*L,*R)
		ans = max(ans, calc(*L + 1, *R, a[me]));
	}

	cout &lt;&lt; ans &lt;&lt; endl;
}
</pre><pre></pre><h2>Problem3167</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt;
#include &lt;cstdlib&gt;
using namespace std;

const int MOD = int(1e9) + 7;
typedef long long int64;
struct Int {
	int x;
	Int() :
			x(0) {
	}
	Int(int64 _x) {
		x = _x % MOD;
		if (x &lt; 0)
			x += MOD;
	}
	static Int get(int x) {
		Int a;
		a.x = x;
		return a;
	}

	Int operator+(const Int&amp;o) const {
		int64 t = x + o.x;
		if (t &gt;= MOD)
			t -= MOD;
		return get(t);
	}
	Int operator*(const Int&amp;o) const {
		return get(1LL * x * o.x % MOD);
	}
	Int operator-(const Int&amp;o) const {
		int64 t = x - o.x;
		if (t &lt; 0)
			t += MOD;
		return get(t);
	}
	Int operator/(const Int&amp;o) const {
		return (*this) * o.inv();
	}
	Int&amp;operator+=(const Int&amp;o) {
		return (*this) = *this + o;
	}
	Int&amp;operator-=(const Int&amp;o) {
		return (*this) = *this - o;
	}
	Int&amp;operator*=(const Int&amp;o) {
		return (*this) = *this * o;
	}
	Int&amp;operator/=(const Int&amp;o) {
		return (*this) = *this / o;
	}

	Int power(int64 n) const {
		if (!n)
			return get(1);
		const Int&amp;a = *this;
		if (n &amp; 1)
			return power(n - 1) * a;
		else
			return (a * a).power(n &gt;&gt; 1);
	}

	Int inv() const {
		return power(MOD - 2);
	}
	bool operator==(const Int&amp;o) const {
		return x == o.x;
	}
	bool operator!=(const Int&amp;o) const {
		return x != o.x;
	}
};
const int MAX_N = 1000 + 10;

int n;

struct Edge {
	int t;
	char op;
	Edge(int t, char op) :
			t(t), op(op) {
	}
};

vector&lt;Edge&gt; E[MAX_N];

Int dp[MAX_N][MAX_N];

int size[MAX_N];

Int comb[MAX_N][MAX_N];

int total = 0;

void dfs(int u, int par) {
	size[u] = 1;

	for (vector&lt;Edge&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (e-&gt;t != par) {
			dfs(e-&gt;t, u);
			size[u] += size[e-&gt;t];
		}
	}

	//
	static Int dp2[MAX_N][MAX_N]; //i,cntsmall
	int tot = 0;
	dp2[0][0] = 1;
	int cur = 0;

	for (vector&lt;Edge&gt;::iterator e = E[u].begin(); e != E[u].end(); ++e) {
		if (e-&gt;t != par) {
			Int*am = dp2[cur];
			Int*nxt = dp2[++cur];

			Int*ch = dp[e-&gt;t];
			Int way[MAX_N];
			int cTot = size[e-&gt;t];
			if (e-&gt;op == '&lt;') {
				//u&lt;e-&gt;t
				way[cTot] = 0;
				for (int i = cTot - 1; i &gt;= 0; --i) {
					way[i] = way[i + 1] + ch[i];
				}
			} else {
				//u&gt;e-&gt;t
				way[0] = 0;
				for (int i = 1; i &lt;= cTot; ++i) {
					way[i] = way[i - 1] + ch[i - 1];
				}
			}

			for (int i = 0; i &lt;= tot + cTot; ++i) {
				nxt[i] = 0;
			}

			for (int i = 0; i &lt;= tot; ++i) {
				Int c = am[i];
				if (c.x == 0)
					continue;
				int j = tot - i;
				for (int a = 0; a &lt;= cTot; ++a) {
//					++total;
					int b = cTot - a;
					nxt[i + a] += c * comb[a + i][a] * comb[b + j][b] * way[a];
				}
			}

			tot += cTot;
		}
	}

	for (int i = 0; i &lt;= tot; ++i) {
		dp[u][i] = dp2[cur][i];
	}
}

void work() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		E[i].clear();
	}
	for (int i = 0; i &lt; n - 1; ++i) {
		int a, b;
		char op;
		scanf("%d", &amp;a);
		for (;;) {
			op = getchar();
			if (op == '&lt;' || op == '&gt;')
				break;
		}
		scanf("%d", &amp;b);
		if (op == '&gt;')
			swap(a, b);
		//a&lt;b
		E[a].push_back(Edge(b, '&lt;'));
		E[b].push_back(Edge(a, '&gt;'));
	}

	dfs(0, -1);
	Int ans = accumulate(dp[0], dp[0] + n, Int());
	cout &lt;&lt; ans.x &lt;&lt; endl;
}

void runLarge() {
	n = 1000;
	for (int i = 1; i &lt; n; ++i) {
		int a = i - 1, b = i;
		char op = rand() % 2 == 0 ? '&lt;' : '&gt;';
		if (op == '&gt;')
			swap(a, b);
		E[a].push_back(Edge(b, '&lt;'));
		E[b].push_back(Edge(a, '&gt;'));
	}
	total = 0;
	dfs(0, -1);
	Int ans = accumulate(dp[0], dp[0] + n, Int());
	cout &lt;&lt; ans.x &lt;&lt; endl;
	cerr &lt;&lt; total &lt;&lt; endl;
}

int main() {
	for (int i = 0; i &lt; MAX_N; ++i) {
		for (int j = 0; j &lt;= i; ++j) {
			comb[i][j] =
					(i == 0 || j == 0) ?
							1 : comb[i - 1][j] + comb[i - 1][j - 1];
		}
	}
//	runLarge();
	int T;
	cin &gt;&gt; T;
	while (T--) {
		work();
	}
}
</pre><pre></pre><h2>Problem3201</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
using namespace std;
const int MAX_N = 1000 + 10, MOD = 1000000007;
int n, a[MAX_N];
int comb[MAX_N][MAX_N];
typedef long long int64;

int64 getPow(int64 a, int e) {
	if (e == 0)
		return 1;
	return e % 2 == 0 ?
			getPow(1LL * a * a % MOD, e &gt;&gt; 1) : getPow(a, e - 1) * a % MOD;
}

void work() {
	cin &gt;&gt; n;
	for (int i = 1; i &lt;= n; ++i) {
		cin &gt;&gt; a[i];
	}
	sort(a + 1, a + n + 1);
	static int64 dp[MAX_N];
	dp[0] = 1;
	for (int i = 1; i &lt;= n; ++i) {
		dp[i] = getPow(a[i], i);
		for (int j = 1; j &lt; i; ++j) {
			dp[i] -= dp[j - 1] * getPow(a[i] - a[j], i - j + 1) % MOD
					* comb[i][j - 1] % MOD;
		}
		dp[i] %= MOD;
		if (dp[i] &lt; 0)
			dp[i] += MOD;
//		cout &lt;&lt; i &lt;&lt; ":" &lt;&lt; dp[i] &lt;&lt; endl;
	}
	cout &lt;&lt; dp[n] &lt;&lt; endl;
}

int main() {
	for (int i = 0; i &lt; MAX_N; ++i) {
		for (int j = 0; j &lt;= i; ++j) {
			comb[i][j] =
					(i == 0 || j == 0) ?
							1 : (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD;
		}
	}
	int T;
	cin &gt;&gt; T;
	while (T--)
		work();
}
</pre><pre>﻿








</pre><br><a href="http://www.lydsy.com/JudgeOnline/"></a><span class="red">HOME</span><a href="javascript:history.go(-1)"></a><span class="red">Back</span><hr><center>
	
</center><div class="footer">
			&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		
			
		
	</div><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=ko">한국어</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=cn">中文</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=fa">فارسی</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=en">English</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=th">ไทย</a><br><div>版权所有 ©2008-2012 大视野在线测评 | 
</div><script src="./BZOJ全代码_files/stat.php" language="JavaScript"></script><script src="./BZOJ全代码_files/cnzz_core.php" charset="utf-8" type="text/javascript"></script><a href="http://www.cnzz.com/stat/website.php?web_id=2982771" target="_blank" title="站长统计">站长统计</a><div>Based on opensource project .</div><a href="http://hustoj.googlecode.com/">hustoj</a></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></body></html>